#include "val/qrl/include/table.inc"
#include "val/qrl/include/TConfig.inc"
#include "val/qrl/include/TUseCase.inc"

  struct dataitems_struct
    {
      string dataitem;
      string datatype_class;
      string datatype;
    };


  struct actor_dataitems_struct
    {
      int actorid;
      string dataitem;
    };

  set USERDEFINED;

  boolean DATACONDITION;
  set DATACONDITIONSET;
  set ALLDATAITEMS;

  set DataItemsDataTypes;
  set FixedValueSet;
 
  set ActorDataItems;
  string PRODUCES;
  string FILETEXT = "";


void
main ()
{

  format ("ValidatorDocuments.rtf");

  node nodevar;

  string q = "node[UmlUseCase && node_refs] sort by name";

  list nodelist = list_select(q);

  int count = list_count(nodelist);

  int i;

  string TESTREADY = "";
  string NOTTESTREADY = "";

  list actorlist;

  int status=0;

  DataItemsDataTypes = set_create ("dataitems_struct");

  InitializeUserDefined();

  ActorDataItems = set_create("actor_dataitems_struct");
  ActorDataItems = Build_ActorDataItems();

  for (i=0;i<count;i++)
    {
      nodevar = list_get(nodelist,i);

      message ("Verifying Use Case: " + nodevar.name);

      FILETEXT = FILETEXT + "\nUseCase: " + (nodevar.name);

      actorlist = GetListOfActors(nodevar.id);

      if (list_count(actorlist) == 0)
        {
          FILETEXT = FILETEXT + "\n" + ("  ERROR: This Use Case has no Actor interactions.");
          status = 1;
        }
      else
        {
          status = CheckScenarios(nodevar.name, actorlist);
        }

      if (status == 0)
        {
          TESTREADY = TESTREADY + FILETEXT;
          FILETEXT = "";
        }
      else
        {
          NOTTESTREADY = NOTTESTREADY + FILETEXT;
          FILETEXT = "";
        }
    }

  PrintTitlePage();

  paragraph ("Heading 1");
  print ("Use Cases that are test-ready");
  paragraph ("Paragraph");
  print (TESTREADY);

  paragraph ("Heading 1");
  print ("Use Cases that are not test-ready");
  paragraph ("Paragraph");
  print (NOTTESTREADY);

}



int
CheckScenarios(string name, list actorlist)
{
  list scenariolist = GetScenarioList(name);
  int i;
  int count = list_count(scenariolist);
  node scenario;
  string scenario_name;
  int scenario_id;
  set DataTypes;
  string ActorIDs;
  list InputEvents;
  list OutputEvents;
  set EventDataItems;

  int status=0;
  int tmpstatus=0;

  ALLDATAITEMS = set_create ("string");

  FixedValueSet = set_create ("string");
  DATACONDITIONSET = set_create ("string");


  if (count == 0)
    {
      FILETEXT = FILETEXT + "\n" + ("  ERROR: This Use Case has no Scenarios.");
      return (1);
    }


  ActorIDs = GetActorIDList(name);

  EventDataItems = set_create("actor_dataitems_struct");

  set_clear(EventDataItems);

  InputEvents = list_create ("string", 0);
  OutputEvents = list_create ("string", 0);

  for (i=0;i<count;i++)
    {
      scenario = list_get(scenariolist,i);

      scenario_name = RemoveSpaces(scenario.name);
      scenario_id = scenario.id;

      FILETEXT = FILETEXT + "\n" + ("  Scenario: " + scenario_name);

      list_clear(InputEvents);
      list_clear(OutputEvents);


      InputEvents = GetInputEvents("Input", scenario_id, ActorIDs);
      OutputEvents = GetOutputEvents("Output", scenario_id, ActorIDs);

      if (list_count (InputEvents) == 0 || list_count(OutputEvents) == 0)
        {
          FILETEXT = FILETEXT + "\n" + ("    ERROR: Scenario " + scenario_name + " must have a minimum of one input event and one output event");
          status = status + 1;
        }
      else
        {
          PRODUCES = "";
          EventDataItems = GetUsesDataList (InputEvents);

          tmpstatus = CheckDataItems (ActorDataItems, EventDataItems);

//          print_produces_data (OutputEvents, PRODUCES);

          status = status + tmpstatus;
        }
    }

  return (status);
}







list
GetListOfActors(int id)
{
  string q1, q2;

  int i,count;
  list listvar;
  node nodevar;

  set actorset = set_create("string");

  q1 = "node [UmlActor && node_refs && " +
       "out_links [ link_refs && UmlUseCaseInteraction && " +
       "to_node_id == ${id} ] ]";


  q2 = "node [UmlActor && node_refs && " +
       "in_links [ link_refs && UmlUseCaseInteraction && " + 
       "from_node_id == ${id} ] ]";

  listvar = list_select (q1);

  count = list_count(listvar);

  for (i=0;i<count;i++)
    {
       nodevar = list_get(listvar,i);
       if (nodevar != NULL)
            set_add(actorset, nodevar.name);
    }

  listvar = list_select (q2);

  count = list_count(listvar);

  for (i=0;i<count;i++)
    {
       nodevar = list_get(listvar,i);
       if (nodevar != NULL)
            set_add(actorset, nodevar.name);
    }

  list actorlist = list_create("string",0);
  string stringvar;

  count = set_count(actorset);

  for (i=0;i<count;i++)
    {
       stringvar = set_get_element(actorset,i);
       list_append(actorlist, stringvar);
    }
  list_sort(actorlist);

  return (actorlist);
}



list
GetInputEvents(string type, int scenario_id, string actorids)
{
  string linkref_query, noderef_query;
  node_ref nr;

  if (actorids == "")
      actorids = "0";

  noderef_query = "node_ref [node_id == ${scenario_id} ] ";

  nr = find_by_query (noderef_query);

  linkref_query = "link_ref [ file_id == ${nr.file_id} && 
           link [ UmlSimpleMessage   &&
           from_node[${actorids}] ] ] sort by ycoord";

  return ( list_select (linkref_query) );

}


list
GetOutputEvents(string type, int scenario_id, string actorids)
{
 
  string linkref_query, noderef_query;
  node_ref nr;

  if (actorids == "")
      actorids = "0";

  noderef_query = "node_ref [node_id == ${scenario_id} ] ";

  nr = find_by_query (noderef_query);

  linkref_query = "link_ref [ file_id == ${nr.file_id} && 
           link [ UmlSimpleMessage   &&
           to_node[${actorids}] ] ] sort by ycoord";

  return ( list_select (linkref_query) );

}


set
Build_ActorDataItems()
{
  list dataitems;
  int i,count;
  note notevar, notevar0;
  item itemvar1, itemvar3, itemvar4, itemvar5, itemvar6;
  set tmpset;

  actor_dataitems_struct typename;
 
  string q1 = "note [TestDataItem && node[UmlActor && node_refs ]] sort by name";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";
 
  list notelist = list_select(q1);
 
  tmpset = set_create ("actor_dataitems_struct");
 
  count = list_count(notelist);
 
  for (i=0;i<count;i=i+1)
    {
      notevar = list_get(notelist,i);
 
      itemvar1 = find_by_query(q2);
 
      typename.actorid = notevar.obj_id;
      typename.dataitem = RemoveSpaces(itemvar1.value);
      set_add (tmpset, typename); 
    }

  return (tmpset);

}




set
GetUsesDataList ( list inputevents)
{

  int event_id, i,count;
  string eventname, fromclass, toclass, actionname;
  link_ref linkrefvar;
  string event;
  int actorid;

  set DataItems = set_create ("actor_dataitems_struct");

  count = list_count(inputevents);

  for (i=0; i<count; i=i+1)
    {
       linkrefvar = list_get(inputevents, i);

       event = GetEventName(linkrefvar.link_id);

       actorid = GetActorID(linkrefvar.from_node_ref_id, "out_link_refs");

       DataItems = GetUsesData(event, actorid, DataItems);
    }
  return (DataItems);
}


set
GetUsesData ( string event, int actorid, set tmpset)
{
  int i,count;
  note notevar;
  list TNote, notelist;
  item itemvar,itemvar2,itemvar4;
  string returndata;

  int l1,l2;

  l1 = string_find(event, 0, "(");

  if (l1 == string_length(event) )
     return;

  string data;
  list datalist;

  actor_dataitems_struct typename;
 

  l1 = string_find(event, 0, ":");

  if (l1 < string_length(event) )
     {
       if (PRODUCES == "")
          PRODUCES = string_extract( event, 0, l1 );
       else
          PRODUCES = PRODUCES + "," + string_extract( event, 0, l1 );
     }

  l2 = string_find(event, 0, "(");

  event = string_extract( event,l2+1,string_length(event)-(l2+1) );

  event = string_search_and_replace(event, ")", "");

  datalist = string_to_list(event, ",");

  count = list_count(datalist);

  for (i=0;i<count;i++)
    {
      data = list_get(datalist,i);
      if (!set_is_member ( FixedValueSet, RemoveSpaces(data)) )
         { 
           typename.actorid = actorid;
           typename.dataitem = RemoveSpaces(data);
           set_add ( tmpset, typename);
         }
    }
  return (tmpset);
}



void
print_produces_data ( list outputevents, string produces)
{

  list EventList;
  int event_id, i,count;
  string eventname, fromclass, toclass, actionname;
  link_ref linkrefvar;
  string event;

  count = list_count(outputevents);


  if (count >0)
     FILETEXT = FILETEXT + "\n" +  ("   produces dataitem\n");


  for (i=0; i<count; i=i+1)
    {
       linkrefvar = list_get(outputevents, i);
       event = GetEventName(linkrefvar.link_id);

       eventname = StripData(event);
       event_id = GetEventID(linkrefvar.link_id);

       set_add ( ALLDATAITEMS, eventname);
       set_add (DataItemsDataTypes, eventname + SEPARATOR + 
                     "FIXED" + SEPARATOR2 + "did_occur");

       if (i>0)
          FILETEXT = FILETEXT + "\n" + ",\n";

       FILETEXT = FILETEXT + "\n" + "     " + eventname;
       GetProducesData(event);
    }

   if (produces != "")
      GetProducesData("(" + produces + ")");

   if (count > 0) 
     FILETEXT = FILETEXT + "\n" + ";\n\n";
}


void
GetProducesData ( string event)
{
  int i,count;
  note notevar, notevar0;

  list TNote, notelist;
  item itemvar;
  int l1,l2;

  l1 = string_find(event, 0, "(");

  if (l1 == string_length(event) )
     return;

  string data;
  list datalist;

  event = string_extract( event,l1+1,string_length(event)-(l1+1) );

  event = string_search_and_replace(event, ")", "");


  datalist = string_to_list(event, ",");

  count = list_count(datalist);

  for (i=0;i<count;i++)
    {
      data = list_get(datalist,i);
      set_add ( ALLDATAITEMS, RemoveSpaces(data));

      FILETEXT = FILETEXT + "\n" +  (",\n         " + RemoveSpaces(data));
    }



}



string
GetEventName( int link_id)
{
  link linkvar;
  item itemvar;
  string name;

  string query2 = "link [ id == ${link_id} ]";

  linkvar = find_by_query (query2);


  if (linkvar == NULL)
     return (NULL);


  return (RemoveSpaces(linkvar.name));

}



int
GetEventID( int link_id)
{
  link linkvar;
  string query = "link [ id == ${link_id} ]";

  linkvar = find_by_query (query);

  if (linkvar == NULL)
    return (0);
  else 
    return (linkvar.id);


}



string
GetOneActorName( int id)
{

  string query2 = "node [${id}]";

  node nodevar = find_by_query (query2);

  return (RemoveSpaces(nodevar.name));

}



int
GetActorID( int link_id , string direction)
{
  string query = "node_ref [ ${link_id} ]";

  node_ref noderefvar = find_by_query (query);

  if (noderefvar == NULL)
    return (0);
  else 
    return (noderefvar.node_id);


}



int
CheckDataItems (set ActorDataItems, set EventDataItems)
{
  int i,count;
  int status=0;
  actor_dataitems_struct eventdataitem;

  count = set_count(EventDataItems);

  for (i=0;i<count;i++)
    {
      eventdataitem = set_get_element(EventDataItems,i);
      if (!set_is_member (ActorDataItems, eventdataitem ) )
        {
          FILETEXT = FILETEXT + "\n" + "    ERROR: DataItem '" + eventdataitem.dataitem + "' is not declared in Actor '" + GetOneActorName(eventdataitem.actorid) + "'";
          status = status + 1;
        }
      else
        {
           status = status + CheckDataType(eventdataitem);
        }

     }
  return (status);
}


int
CheckDataType(actor_dataitems_struct eventdataitem)
{
  string DataType = GetDataType(eventdataitem);
  int status=0;

  if (DataType == "UNDEFINED")
    {
       print ("  No DataType definition");
       status = status + 1;
    }
  else if (DataType != "FIXED" && DataType != "PREDEFINED")
    {
      if (!set_is_member(USERDEFINED, DataType) )
        {
          FILETEXT = FILETEXT + "\n" + "    WARNING: DataType '" + DataType + 
               "' of DataItem '" + eventdataitem.dataitem + "'\n" + "             " +
               "declared in Actor '" + GetOneActorName(eventdataitem.actorid) + 
               "' is not defined in a Data Type Table";
          status = status + 1;
        }
    }


  return (status);
}




string
GetDataType(actor_dataitems_struct data)
{
  list dataitems;
  int i,count;
  note notevar, notevar0;
  item itemvar1, itemvar3, itemvar4, itemvar5, itemvar6;

  dataitems_struct typename;
 
  string q1 = "note [TestDataItem && name == '${data.dataitem}' && obj_id == ${data.actorid}]";
  string q3 = "item [TFixedValue && note_id == ${notevar.id}]";
  string q4 = "item [TDataType && note_id == ${notevar.id}]";
  string q5 = "item [TDataTypeName && note_id == ${notevar.id}]";
 

  notevar = find_by_query(q1);
 
  if (notevar  == NULL)
     return ("UNDEFINED");

  itemvar3 = find_by_query(q3);
  itemvar4 = find_by_query(q4);
  itemvar5 = find_by_query(q5);
 
  if (itemvar3 != NULL)
    return ("FIXED");

  if (itemvar4 != NULL)
    return ("PREDEFINED");

  if (itemvar5 != NULL)
    return (itemvar5.value);
 
  return ("UNDEFINED");
}

void
InitializeUserDefined()
{

  string q = "node [TTestType && node_refs[file[ttypetable]]]";

  list listvar = list_select(q);
  node nodevar;

  USERDEFINED = set_create("string");

  int i;
  int count = list_count(listvar);

  for (i=0;i<count;i++)
    {
      nodevar = list_get (listvar,i);
      set_add (USERDEFINED, nodevar.name);
    }


}





void
PrintTitlePage()
{

  paragraph ("Title");
  print ("");

  paragraph ("BTitle");
  print ("Test Readiness Report");

  paragraph ("BSubTitle");
  print ("");

  paragraph ("BSubTitle");
  print ("for");

  paragraph ("BSubTitle");
  print ("");

  paragraph ("BTitle");
  print ( current_system() );

  paragraph ("BSubTitle");
  print ("");

  paragraph ("BSubTitle");
  print ( "on");

  paragraph ("BSubTitle");
  print ("");

  paragraph ("BSubTitle");
  print ( time_to_string (time_now(), NULL));

}


