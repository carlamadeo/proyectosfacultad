//
//      sccsid[] = %W% %Y% %D%
//      StP/Core
//      StP/Uml
//      Confidential property of Aonix
//      Copyright (c) 1992-1997
//      All rights reserved
//
//
//      sccsid[] = @(#)cte.qrl	1.3  94/10/10
//      StP/OMT
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1994
//      All rights reserved
//

// general qrl utility functions 
#include "rules/qrl/ct.inc"

// this comes from the core
#include "rules/qrl/gte_qrl_std.inc"
#include "rules/qrl/requirements_nav.inc"

// gte specific functions
#include "rules/qrl/gte.inc"

// UML specific functions
#include "rules/qrl/uml.inc"
#include "rules/qrl/oper_parse.inc"
#include "rules/qrl/uclasst_syntax.inc"
#include "rules/qrl/uml_class_semantics.inc"

// Reverse Engineering Stuff
#include "rules/qrl/pe_nav.inc"
#include "rules/qrl/re_pe_label_funcs.inc"
#include "rules/qrl/cte_sync.inc"

// cloned stuff from OO
#include "rules/qrl/cloned_cte.inc"
#include "rules/qrl/gte_uml_object_rename.inc"

// local definitions needed for generic navigation code
#include "rules/qrl/uml_ada_nav.inc"
// Begin Add ECR 4179
#include "rules/qrl/navtostp.inc"
#include "rules/qrl/navtosniff.inc"
// End Add ECR 4179

// ECR3484, new include
#include "rules/qrl/uclasst_pick.qrl"

// ECR 6880 Property sheets from table editors
struct gde_symbol {
    int cur_row;
    int cur_col;
    string label;
};

#include "rules/qrl/uclassd.ps.qrl"
// ECR 6880 end

string uclasst_canonical_args(int hsect, int vsect, int row, int col)
{
	int absRow, absCol;
	int selStartRow, selEndRow, selStartCol, selEndCol;

	absRow = gte_get_row(hsect,row);
	absCol = gte_get_col(vsect,col);

	selStartRow = gte_get_first_row_in_selected();
	selEndRow = gte_get_last_row_in_selected();
	selStartCol = gte_get_first_col_in_selected();
	selEndCol = gte_get_last_col_in_selected();

	string lbl = gte_get_cell_label(absRow,absCol);

	string lbl2 =  uml_args_to_format(lbl, Canonical);

	// this is to prevent FileSave from accidentally masking the table
	// dirty by setting the string when it hasn't changed
	if (lbl != lbl2 ) {
		CoordCellLabel(absRow, absCol,lbl2);

		// to force repaint without repainting whole table
		gte_set_selection_quietly(absRow,absCol,absRow,absCol);
		gte_refresh_selection();
		gte_set_selection(selStartRow, selStartCol, selEndRow, selEndCol);
	}

	return lbl2;
}

// JED
// Table-level semantics check
void
uclasst_check_semantics(string fname)
{
    string class_name = gte_get_cell_label(gte_get_last_row(gte_lookup_symbol("ClassHsect")), 1);
	string ref_rest = "[file[type=UmlClassTable && name='" + fname + "']]";
	string ops_rest = "&& node_refs[file[type=UmlClassTable && name='" + fname + "']]";
	list errs=NULL;
	string err_str;
	int i;

	boolean passed = 
		uml_check_class_semantics(class_name, ref_rest, ops_rest, errs);

	if(!passed) {
		for(i=0;i<list_count(errs);i++) {
			err_str = list_get(errs,i);
            print_error(err_str);
		}
		print_error("Class '" + class_name + "' failed semantics checks.");
	} else {
		print_warning("Class '" + class_name + "' passed semantics checks.");
	}
}


void
ClassTableInitializeFromPEViaCC()
{
    string          classname = UmlClassTableGetClassCellLabel();
    string          PE = getPE();
    string          cmdPrefix = "sh -c '";
    string          cmdPostfix = "' &";

    if (is_windows_platform())
    {
        cmdPrefix = "cmd /c start /b ";
        cmdPostfix="";
    }

    if (classname == NULL || classname == "")
    {
	gte_print_error("A class must be specified before you construct from it!");
	return;
    }
    if (PE == "Reverse Engineering")
    {
	FileSaveIfModified();
	print_message( "Please wait while table is updated..." );
 	system(cmdPrefix + "xxx2yyy -action smdb2uml -forward_messages "
            + editor_get_msgd_handle()
 	       + " -p " + current_projdir()
 	       + " -s " + current_system()
	       + " -nodiagram -from_cte "
	       + classname + cmdPostfix );
	// no longer needed gte_stpem("FileLoad " + classname);
    } else
    {
	gte_print_error("Class Capture from programming environment " + PE + " not supported.");
    }
    return;
}

string
uml_class_table_name(int hsect, int vsect, int row, int col)
{
    string result = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));
    string newres;

    if (result == "")
        return (NULL);

    if ((newres = uml_base_name(result)) != result)
    {
        gte_log_undo_start();
        print_error("Class name `" + result + "' has invalid characters. Fixing name ...");
        CoordCellLabel(1, 1, newres);
        gte_refresh_table();
        return strip_whitespace(newres);
    }
 
    return strip_whitespace(result);
}

string
UmlCxxCodeGenId(int hsect, int vsect, int row, int col)
{
    return UmlCodeGenId("UmlCxxCodeGenId", hsect, vsect, row, col);
}

// this gets set externally when the gendumpfiles program is running, in
// which case the following routine short-cuts into the C++ code in
// gendumpfiles/mapTable.C
int GENDUMPFILES = 0;

string
UmlCodeGenId(string idtype, int hsect, int vsect, int row, int col)
{
    if (GENDUMPFILES == 1)
        return GendumpFilesCodeGenId(idtype, hsect, vsect, row, col);

    node            object;
    list            objects;
    string          id, fid = "", rid = "";
    item            item;
 
    //
    // assumption:  if a code gen id exists in the repository, then we have
    // to assume it's already been assigned to some generated code and we
    // have to assume it's unique (what about a cloned/copied one?)
    //

    //
    // get the current code gen ids (file-based and repository-based) and the
    // associated object (if there is no mapped object, we obviously(?)
    // don't care about the id)
    //
    fid = gte_cell_getprop(hsect, vsect, row, col, idtype);
    if (fid == NULL)
	fid = "";
    objects = gte_cell_mapped_oms_nodes(hsect, vsect, row, col);
    if (objects == NULL || list_count(objects) == 0)
	return fid;
    object = list_get(objects, 0);
    item = find_by_query("item[obj_id=${object.id} & ${idtype}]");
    if (item != NULL)
	rid = item.value;

    // now, sync the fid and the rid

    // case rid is null:  if the fid is unique use it (repos regen), otherwise gen a new id
    if (rid == "")
    {
	if (fid == "" || find_by_query("item[${idtype} & value='${fid}']") != NULL)
	    id = to_string(generateProbablyUniqueId(idtype, idtype));
	else
	    id = fid;
    }

    // case fid is null:  simply use the rid (see initial assumption)
    else if (fid == "")
	id = rid;

    // case fid & rid are not null:  if they match, everything's ok
    else if (rid == fid)
	id = rid;

    // case fid & rid are not null:  if they don't match, simply use the rid (see initial assumption)
    else if (rid != fid)
	id = rid;

    // fid = rid
    gte_cell_setprop(hsect, vsect, row, col, idtype, id);
    return id;
}

list
uclasst_class_name_completion_func(string pattern, string label, string extent,
				 string apptype, int scopeid)
{
        node classScope;
        int i;

	list l = gte_default_name_completion_func(pattern,label,extent,apptype,scopeid);
        // fetch ObjectClassScope with node refs
        list theClassScopes =
               list_select("node[UmlObjectClassScope"+
                           " && name $ '${pattern}' && node_refs]");

        for(i=0;i<list_count(theClassScopes);i++) {
            classScope = list_get(theClassScopes,i);
            // ignore anon classes and append others
            if(classScope.name!="" && string_length(classScope.name)>=2
	        && string_extract(classScope.name,0,2) == "%%")
                continue;
            list_append(l,classScope.name);
        }


	return l;
}

list
uclasst_operation_name_completion_func(string pattern, string label,
		string extent, string apptype, int scopeid)
{
	list l = gte_default_name_completion_func(pattern,label,extent,apptype,scopeid);

	// JED - now add the Messages
	// find the parent class
	node class = find_by_query("node[${scopeid}]");

	if (NULL == class) {
		// JED - something wrong
		return l;
	}
	list_concatenate(l, uml_messages_for_class(pattern,class));
	 
	return l;
}


// uml im integration functions 
/////////////////////////////////////////////////////////
// IM Entity Chooser

// queries to load attributes into cte from im product definition
const string classname_attr_from_im_query = "node[Attribute && scope_node[name='${classname}'] && node_refs]";
const string classid_attr_from_im_query = "node[Attribute && scope_node_id==${sqlitem.obj_id} && node_refs]";
const string attr_im_type_query = "item[(SybaseDataType || OracleDataType || InformixDataType) && obj_id=${attr.id}]";
const string attr_im_default_value_query = "item[DefaultValue && obj_id=${attr.id}]";

void
UmlClassTableInitializeFromEntity()
{
  list            l;
  string          q, qa = "";
  const string    ALL_IM_ENTITIES = "node[Entity && node_refs${withattrs}]";
  string	    withattrs;
  
  withattrs = "&&scoped_nodes[Attribute&&node_refs]";
  qa = "with Attributes ";
  // qa = "";
  // withattrs = "";
  l = list_select(ALL_IM_ENTITIES);
  
  if (list_count(l) == 0)
    {
      print_error("No IM Entities " + qa + "defined in this System", NULL);
      return;
    }
  editor_item_selector(l, "DefineClassTableFromEntity();",
		       "Construct Class Table from Entity",
		       True);
}

void
DefineClassTableFromEntity()
{
  list            sel = editor_selector_selected_objects();
  int		    id;
  node	    e;
  string	    cn, tbl_fn;
  string          currfn;
  file	    ctbl;
  const	    string CLASS_TBL_WITH_CLASS = "file[UmlClassTable && node_refs[node[UmlClass && name ='${cn}']]]";
  
  if (list_count(sel) == 0)
    {
      print_message("No Entity selected");
      return;
    }
  id = list_get(sel, 0);
  e = node_from_oid(id);
  if (e == NULL)
    {
      print_message("Entity not found"); // why did we find it before then
      return;
    }
  
  cn = strip_whitespace(e.name);
  
  ctbl = find_by_query(CLASS_TBL_WITH_CLASS);
  if (ctbl != NULL)
    {
      cn = ctbl.name;
    }
  
  currfn = gte_substitute_string("${file}");
  
  if (gte_confirm_and_reset("defineConfirm") == False)
    {
      return;
    }
  
  if (currfn != cn)
    {
      gte_stpem("FileLoad " + cn);
    }
  UmlClassTableInitializeFromIMEntityName(e.name);
  gte_refresh_table();
}

void
UmlClassTableAddIMEAAsAttributes()
{
  list            l;
  string          q, qa = "";
  const string    ALL_IM_ENTITIES = "node[Entity && node_refs${withattrs}]";
  string	    withattrs;
  
  withattrs = "&&scoped_nodes[Attribute&&node_refs]";
  qa = "with Attributes ";
  // qa = "";
  // withattrs = "";
  l = list_select(ALL_IM_ENTITIES);
  
  if (list_count(l) == 0)
    {
      print_error("No IM Entities " + qa + "defined in this System", NULL);
      return;
    }
  editor_item_selector(l, "AddClassTableFromEntity();",
		       "Construct Class Table from Entity",
		       False);
}

void
AddClassTableFromEntity()
{
  list            sel = editor_selector_selected_objects(), attrs, vanattrs;
  int             id, i;
  node            e, a;
  string          ftstr, classname;
  const string    CLASS_TBL_WITH_CLASS = "file[UmlClassTable && node_refs[node[UmlClass && name ='${cn}']]]";
  item            sqlitem;
  string          sqlname;
  
  if (list_count(sel) == 0)
    {
      print_message("No Entity selected");
      return;
    }
  
  /* retrieve all the attrs of the selected im entits */
  vanattrs = list_create("node", 0);
  for (i = 0; i < list_count(sel); i = i + 1)
    {
      id = list_get(sel, i);
      e = node_from_oid(id);
      if (e == NULL)
	{
	  print_message("Entity not found (entity object id = " + id + ")");
	  continue;
	}
      classname = to_oms_string(e.name);
      if (classname == "")
	continue;
      attrs = list_select(classname_attr_from_im_query);
      /* if not found, try if the SqlName maps */
      if (list_count(attrs) == 0)
	{
	  sqlname = strip_whitespace(classname);
	  sqlitem = find_by_query(SQL_ITEM_NAME_QUERY);
	  if (sqlitem != NULL)
	    attrs = list_select(classid_attr_from_im_query);
	}
      list_concatenate(vanattrs, attrs);
    }
  
  /* filter out dupes and ones that already exist in the table */
  int             aths = gte_lookup_symbol("AttributeHsect");
  int             atnmcol = gte_lookup_symbol("AttributeNameCol");
  list            attr_names = list_create("string", 0);
  attrs = list_create("node", 0);
  for (i = 0; i < list_count(vanattrs); i = i + 1)
    {
      a = list_get(vanattrs, i);
      if (find_value_in_hsect(a.name, aths, atnmcol, atnmcol) == True)
	continue;
      if (list_find(attr_names, 0, a.name) < list_count(attr_names))
	continue;
      list_append(attr_names, a.name);
      list_append(attrs, a);
    }
  
  if (list_count(attrs) > 0)
    {
      /* save the current hideshows as ft expression */
      string savevis = gte_visibility_filltable_expression();
      
      gte_filltable_string("FillTable{" + UmlIMAttributesHsectExpression(attrs, True) + "}");
      
      /* restore the hideshows */
      gte_filltable_string(savevis);
      
      /* refresh */
      gte_refresh_table();
      
    }
  return;
}

string
UmlIMAttributesHsectExpression(list attrs, boolean append)
{
  // maps a list of IM entity attributes to a filltable hsect expression 

  string hsect_expression_main; 
  string rows_expression_main = ""; 
  node attr;
  int i;

    /* Don't append if whole section is empty */
    if (append && hsect_values_empty(gte_lookup_symbol("AttributeHsect"), 0, 0, gte_lookup_symbol("AttributeNameCol"), gte_lookup_symbol("AttributeNameCol") + 2) == True)
	append = False; 

  for (i = 0; i < list_count(attrs); i = i + 1)
    {
      attr = list_get(attrs, i);
      rows_expression_main = rows_expression_main + UmlAttributeRowExpressionMain(attr, attr_im_type_query, attr_im_default_value_query, append);
      append = False;  
    }

  hsect_expression_main = "{Hsect{Index AttributeHsect}{Vsect{Index MainDefinitionVsect}" + rows_expression_main + "}}";
  return(hsect_expression_main);
}

void
UmlClassTableInitializeFromIMEntityName(string entityname)
{
  /* initialize an Uml Class Table from an IM Entity and its attributes */

  string classname, sqlname;
  string savevis;
  list attrs;
  item	sqlitem;

  classname = to_oms_string(entityname);
  if (classname == "")
    return;

  /* save the current hideshows as ft expression */
  savevis = gte_visibility_filltable_expression();

  /* clear table */   
  gte_inittable_string("FillTable " + gte_get_table_type() + "{}");

  /* fill class name */
  gte_filltable_string
	("FillTable{{Hsect{Index ClassHsect}{Vsect {Index MainDefinitionVsect}{Row {Cell {Label \"" + filltable_string_escape(classname) + "\"}}}}}}");

  /* get IM attributes */
  attrs = list_select(classname_attr_from_im_query);
  // If not found, try if the SqlName maps ...
  if (list_count(attrs) == 0)
  {
    sqlname = strip_whitespace(classname);
    sqlitem = find_by_query(SQL_ITEM_NAME_QUERY);
    if (sqlitem != NULL)
    {
	attrs = list_select(classid_attr_from_im_query);
    }
  }

  /* fill table from attributes */
  gte_filltable_string("FillTable{" + UmlIMAttributesHsectExpression(attrs, False) + "}");

  /* restore the hideshows */
  gte_filltable_string(savevis);

  /* refresh */
  gte_refresh_table();
}

// Begin Add ECR3782
// check for existing super/sub classes
// if more than one exists, show a picklist with marks for classes
// with existing class tables
void LoadUMLClassTable( string type, int cte_id ) {
    
    int i, ccount;
    list classes, item_select_list = list_create( "string", 0 );
    node cte_class, class;
    file cte_file;
    string classname;

    // get id of class from cte file id
    cte_class = find_by_query("node[UMLClass && node_refs[file[UMLClassTable && id == " 
			  + cte_id + "]]]");
    if( cte_class == NULL ) {
		print_error( "Class table is not mapped correctly, exiting." );
    }

    if( type == "Sub" ) {
		classes = list_select("node[UMLClass && out_links[UMLGeneralization && link_refs && " +
		      "to_node_id == " + cte_class.id + "]]");
    } else if( type == "Super" ) {
		classes = list_select("node[UMLClass && in_links[UMLGeneralization && link_refs && " +
		      "from_node_id == " + cte_class.id + "]]");
    }

    if( classes != NULL ) {
		ccount = list_count( classes );
	
		if( ccount > 1 ) {
	
		    // we need to offer a pick list
		    for( i=0; i<ccount; i++ ) {
				class = list_get( classes, i );
		
				// mark classes with existing table files
				cte_file = find_by_query("file[UMLClassTable && node_refs[node[id == " + 
							 class.id + "]]]" );
				if( cte_file != NULL ) {
				    classname = "# " + class.name;
				} else {
				    classname = "  " + class.name;
				}
				list_append( item_select_list, classname );
		    }
	
		    editor_item_selector(item_select_list, "LoadCTEFromClassList( 0 );",
					 "Existing " + type + " Classes", True);
		} else if( ccount == 1 ) {
		    // load the table for the only existing class right away
		    class = list_get( classes, 0 );
		    LoadCTEFromClassList( class.id );
		} else {
		    print_error( "Class has no " + type + " class yet !" );
		}		
    } else {
		print_error( "Class has no " + type + " class yet !" );
    }

    return;
}

// Load class table from given class id or from classname selected in pick list
// create the CTE file if it does not exist yet
void LoadCTEFromClassList( int id ) {

    string classname;
    node class;
    file cte_file;

    if( id == 0 ) {
		list sel = editor_selector_selected_labels();
		if( list_count( sel ) != 1 ) {
		    gte_print_error( "Only one class can be selected !" );
		    return;
		}
		classname = list_get( sel, 0 );
		classname = string_strip( classname, "L", "#" );
		classname = string_strip( classname, "L", " " );
		class = find_by_query( "node[UMLClass && name == '" + classname + "']" );
		if( class != NULL ) {
		    id = class.id;
		}
    }

    cte_file = find_by_query( "file[UMLClassTable && node_refs[node[id == " + id + "]]]" );
    
    if( cte_file != NULL ) {
		gte_stpem( "FileLoad " + cte_file.name );
    } else {
		print_error( "Class table does not exist, creating new table ..." );
		UmlClassTableInitialize( id );
    }

}
// End Add ECR3782

// begin ECR 4476
////////////////////////////////////////////////////////////////////////////////////////////
// copy operation to subclasses
////////////////////////////////////////////////////////////////////////////////////////////

boolean is_copy_to_subclasses_currently_copying = False;
boolean is_popped_up_copy_to_subclasses = False;
node last_copy_to_subclasses_class = NULL;
int last_copy_to_subclasses_row = -1;
boolean is_copy_to_subclasses_active = True;
boolean is_ok_copy_to_subclasses_active = True;
list copy_to_subclasses_subClasses;

// Check if the menu-item should be active
int
gte_copy_to_subclasses_search_active_func()
{
    if (is_copy_to_subclasses_currently_copying == True)
	return(ACTIVE_FUNC_IS_INACTIVE);

    if (gte_get_current_cell_is_readonly())
	return(ACTIVE_FUNC_IS_INACTIVE);

    if (gte_get_hsect(gte_get_current_cell_row()) != 5)
	return(ACTIVE_FUNC_IS_INACTIVE);

    // should not copy without a class
    if(gte_get_cell_label(1, 1) == "")
	return(ACTIVE_FUNC_IS_INACTIVE);

    // should not copy an empty operation name
    if(gte_get_cell_label(gte_get_current_cell_row(), 1) == "")
	return(ACTIVE_FUNC_IS_INACTIVE);

    // should not copy constructor
    if(gte_get_cell_label(1, 1) == gte_get_cell_label(gte_get_current_cell_row(), 1))
	return(ACTIVE_FUNC_IS_INACTIVE);

    // should not copy destructor
    if(string_extract(gte_get_cell_label(gte_get_current_cell_row(), 1), 0, 1) == "~")
	return(ACTIVE_FUNC_IS_INACTIVE);

    return(ACTIVE_FUNC_IS_ACTIVE);
}

// pop up the property
void
gte_copy_to_subclasses()
{
    node theClass;
    list objects;

    // get the current class
    objects = gte_cell_mapped_oms_nodes(1, 1, 1, 1);
    if (objects == NULL || list_count(objects) == 0)
	return; // should never happen!
    theClass = list_get(objects, 0);

    // currently I could use a list of strings,
    // but hopefully somewhen there can be multiple classes with the same name but in different packages :-)
    copy_to_subclasses_subClasses = list_create("node", 0);
    // add the current class (to avoid recursions)
    list_append(copy_to_subclasses_subClasses, theClass);
    getSubClasses(theClass, copy_to_subclasses_subClasses);
    // now remove the current class
    list_delete(copy_to_subclasses_subClasses, 0);
    copy_to_subclasses_subClasses = list_sort_all(copy_to_subclasses_subClasses, "compareCopyToSubClasses");

    if(list_count(copy_to_subclasses_subClasses) == 0) {
	print_error("Class \"" + theClass.name + "\" has no subclasses!");
	return;
    }
    gte_stpem("PropertySheetShow GteCopyToSubclasses");
    is_popped_up_copy_to_subclasses = True;
}

void
gte_copy_to_subclasses_owneraction_cb()
{
    list objects;
    node theClass;
    int i;
    list classNames;
    ui_prop p;

    if (is_copy_to_subclasses_currently_copying == True || is_popped_up_copy_to_subclasses == False)
	return;

    // same row as before. Since opening a new table sets the curser to the class name, such a change is found
    if(gte_get_current_cell_row() == last_copy_to_subclasses_row)
	return;
    last_copy_to_subclasses_row = gte_get_current_cell_row();

    p = to_ui_prop("GteCopyToSubclasses", "SubclassesList");
    if (gte_copy_to_subclasses_search_active_func() != ACTIVE_FUNC_IS_ACTIVE)	{
	// turn off the lights ...
	if(is_copy_to_subclasses_active == True) {
	    is_copy_to_subclasses_active = False;
	    ui_activate(p, False);
	    if(is_ok_copy_to_subclasses_active == True) {
		is_ok_copy_to_subclasses_active = False;
		ui_activate(to_ui_prop("GteCopyToSubclasses", "OK"), False);
		ui_activate(to_ui_prop("GteCopyToSubclasses", "Apply"), False);
	    }
	}
	return;
    }

    // turn the lights on ...
    if(is_copy_to_subclasses_active == False) {
	is_copy_to_subclasses_active = True;
	ui_activate(p, True);
	// these are turned on or off later
//	ui_activate(to_ui_prop("GteCopyToSubclasses", "OK"), True);
//	ui_activate(to_ui_prop("GteCopyToSubclasses", "Apply"), True);
    }

    // get the current class
    objects = gte_cell_mapped_oms_nodes(1, 1, 1, 1);
    if (objects == NULL || list_count(objects) == 0)
	return; // should never happen!
    theClass = list_get(objects, 0);

    // same class as before ...
    if(last_copy_to_subclasses_class != NULL && last_copy_to_subclasses_class == theClass) {
	if(is_ok_copy_to_subclasses_active == False && list_count(ui_list_selected(p)) > 0) {
	    is_ok_copy_to_subclasses_active = True;
	    ui_activate(to_ui_prop("GteCopyToSubclasses", "OK"), True);
	    ui_activate(to_ui_prop("GteCopyToSubclasses", "Apply"), True);
	}
	return;
    }

    last_copy_to_subclasses_class = theClass;

    classNames = list_create("string", 0);
    for(i = 0; i < list_count(copy_to_subclasses_subClasses); ++ i) {
	theClass = list_get(copy_to_subclasses_subClasses, i);
	list_append(classNames, theClass.name);
    }

    ui_list_set_value(p, classNames);
    if(list_count(classNames) > 0) {
// currently there is a nifty bug,
// ui_list_select_all selects all items, but the first is not highlighted
// later, when you select some item then this *and* the first gets selected
// this is nasty, because the first one is still not highlighted.
//	ui_list_select_all(p);
	if(is_ok_copy_to_subclasses_active == False) {
	    is_ok_copy_to_subclasses_active = True;
	    ui_activate(to_ui_prop("GteCopyToSubclasses", "OK"), True);
	    ui_activate(to_ui_prop("GteCopyToSubclasses", "Apply"), True);
	}
    }
    else if(is_ok_copy_to_subclasses_active == True) {
	is_ok_copy_to_subclasses_active = False;
	ui_activate(to_ui_prop("GteCopyToSubclasses", "OK"), False);
	ui_activate(to_ui_prop("GteCopyToSubclasses", "Apply"), False);
    }
}

// get all subclasses,
// calls itself recursive,
// tries to avoid endless loops when there is a loop in the generalization hierarchy
void
getSubClasses(node theClass, list subClasses)
{
    list L;
    int i;

    L = list_select("node[out_links[UmlGeneralization && link_refs && to_node_id = ${theClass.id}]]");
    for(i = list_count(L) - 1; i >= 0; -- i) {
	theClass = list_get(L, i);
	if(list_find(subClasses, 0, theClass) == list_count(subClasses)) {
	    list_append(subClasses, theClass);
	    getSubClasses(theClass, subClasses);
	}
    }
}

int
compareCopyToSubClasses(list theList, int a, int b)
{
    node aNode = list_get(theList, a);
    node bNode = list_get(theList, b);

    if(aNode.name > bNode.name)
	return 1;
    if(aNode.name < bNode.name)
	return -1;
    return 0;
}

int
gte_copy_to_subclasses_list_select_cb(ui_event_tp event, 
				      ui_prop theprop, 
				      int id,
				      string value)
{
    // print_message("gte_copy_to_subclasses_list_select_cb");
    ui_prop p;

    p = to_ui_prop("GteCopyToSubclasses", "SubclassesList");
    if(list_count(ui_list_selected(p)) > 0) {
	if(is_ok_copy_to_subclasses_active == False) {
	    is_ok_copy_to_subclasses_active = True;
	    ui_activate(to_ui_prop("GteCopyToSubclasses", "OK"), True);
	    ui_activate(to_ui_prop("GteCopyToSubclasses", "Apply"), True);
	}
    }
    else if(is_ok_copy_to_subclasses_active == True) {
	is_ok_copy_to_subclasses_active = False;
	ui_activate(to_ui_prop("GteCopyToSubclasses", "OK"), False);
	ui_activate(to_ui_prop("GteCopyToSubclasses", "Apply"), False);
    }

    return 1;
}

// OK - pressed
int
gte_copy_to_subclasses_ok_select_cb(ui_event_tp event, 
				    ui_prop theprop, 
				    int id,
				    string value)
{
    // print_message("gte_copy_to_subclasses_ok_select_cb");
    do_the_copy();
    is_popped_up_copy_to_subclasses = False;
    return 1;
}

// Apply - pressed
int
gte_copy_to_subclasses_apply_select_cb(ui_event_tp event, 
				       ui_prop theprop, 
				       int id,
				       string value)
{
    // print_message("gte_copy_to_subclasses_apply_select_cb");
    do_the_copy();
    return 0;
}

void
do_the_copy()
{
    ui_prop p;
    list selected;
    list labels;
    int i, j, k;
    file f;
    node theClass;
    string theFile;
    int row, col;
    int hs, firstRow, lastRow;
    string op, sig, label;
    string savevis;

    row = gte_get_current_cell_row();
    col = gte_get_current_cell_col();

    is_copy_to_subclasses_currently_copying = True;
    p = to_ui_prop("GteCopyToSubclasses", "SubclassesList");
    selected = ui_list_selected(p);

    // save the row, the name and signature are saved into variables, the rest into a list
    labels = list_create("string", 0);
    op = gte_get_cell_label(row, 1);
    sig = gte_get_cell_label(row, 2);
    for(i = 3; i < 29; ++ i) {
	list_append(labels, gte_get_cell_label(row, i));
    }

    gte_disable_refresh();
    savevis = gte_visibility_filltable_expression();

    theFile = gte_substitute_string("${file}");
    hs = gte_lookup_symbol("OperationHsect");
    for(i = 0; i < list_count(selected); ++ i) {
	if (gte_is_modified() == True)
	    gte_stpem("FileSave");

	theClass = list_get(copy_to_subclasses_subClasses, list_get(selected, i));
	f = find_by_query("file[UmlClassTable && node_refs[node_id = ${theClass.id}]]");
	if(f == NULL) {
	    UmlClassTableInitialize(theClass.id);
	    // the refresh is done in the initialization of the table,
	    // but I think that the editor is much faster without refresh,
	    // so switch it off again.
	    // a cleaner thing would be to add a new parameter to
	    // the function above, but that could break something, so ..
	    gte_disable_refresh();
	    // set the hideshows to the same as in the superclass table
	    gte_filltable_string(savevis);
	}
	else
	    gte_stpem("FileLoad " + f.name);

	lastRow = gte_get_last_row(hs);

	// find the operation
	for (j = gte_get_first_row(hs); j <= lastRow; ++ j) {
	    if(gte_get_cell_label(j, 1) == op && gte_get_cell_label(j, 2) == sig) {
		break;
	    }
	}

	// not found, find an empty line
	if( j > lastRow ) {
	    for (j = gte_get_first_row(hs); j <= lastRow; ++ j) {
		if(gte_get_cell_label(j, 1) == "" && gte_get_cell_label(j, 2) == "") {
		    gte_set_selection_quietly(j, 1, j, 1);
		    gte_filltable_string("FillTable { { Hsect { Index Current }" +
					 "{ Vsect { Index Current } { Row { Index Current }" +
					 "{ Cell { Index Current } { Label \"" +
					 op + "\"}}}}}}");
		    if(sig != "") {
			gte_set_selection_quietly(j, 2, j, 2);
			gte_filltable_string("FillTable { { Hsect { Index Current }" +
					     "{ Vsect { Index Current } { Row { Index Current }" +
					     "{ Cell { Index Current } { Label \"" +
					     sig + "\"}}}}}}");
		    }
		    break;
		}
	    }
	}

	// still not found, insert a row
	if( j > lastRow ) {
	    gte_insert_row_after( lastRow, 1 );
	    gte_set_selection_quietly(j, 1, j, 1);
	    gte_filltable_string("FillTable { { Hsect { Index Current }" +
				 "{ Vsect { Index Current } { Row { Index Current }" +
				 "{ Cell { Index Current } { Label \"" +
				 op + "\"}}}}}}");
	    if(sig != "") {
		gte_set_selection_quietly(j, 2, j, 2);
		gte_filltable_string("FillTable { { Hsect { Index Current }" +
				     "{ Vsect { Index Current } { Row { Index Current }" +
				     "{ Cell { Index Current } { Label \"" +
				     sig + "\"}}}}}}");
	    }
	}

	// j is always the current row
	// now fill and/or update all the columns
	for(k = 3; k < 29; ++ k) {
	    label = list_get(labels, k - 3);
	    // 6 == abstract
	    if(k != 6 && label != gte_get_cell_label(j, k)) {
		gte_set_selection_quietly(j, k, j, k);
		gte_filltable_string("FillTable { { Hsect { Index Current }" +
				     "{ Vsect { Index Current } { Row { Index Current }" +
				     "{ Cell { Index Current } { Label \"" +
				     label + "\"}}}}}}");
	    }
	}
    }

    if (gte_is_modified() == True)
	gte_stpem("FileSave");

    // restore
    gte_stpem("FileLoad " + theFile);
    gte_set_selection_quietly(row, col, row, col);
    gte_goto(row, col);
    gte_enable_refresh();
    gte_refresh_table();
    is_copy_to_subclasses_currently_copying = False;
}
// end ECR 4476

//  Add any user customizations to the file included below:
#include_if_exists "user/uml/rules/qrl/user_uclasst.qrl"
