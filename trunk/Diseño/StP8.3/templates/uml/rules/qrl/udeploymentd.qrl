
//      StP/Uml
//      Confidential property of Aonix
//      Copyright (c) 1997
//      All rights reserved
//

// Master include -- includes everything else
// general qrl utility functions
#include "rules/qrl/ct.inc"

// some more stuff from ct
#include "rules/qrl/gde_qrl_std.inc"

// the UML stuff
#include "rules/qrl/uml.inc"
#include "rules/qrl/oper_parse.inc"
#include "rules/qrl/udeploymentd.ps.qrl"
#include "qrl/include/export_to_doors.inc"

// ECR4052 Model Management
#include "rules/qrl/model_management.inc"

// Begin ECR947, ECR 4494
#include "rules/qrl/note_link.inc"

// ECR 4731
#include "rules/qrl/navtostp.inc"

// ECR 5184 start
#include "rules/qrl/re_pe_label_funcs.inc"
#include "rules/qrl/navtosniff.inc"
#include "rules/qrl/pe_nav.inc"
#include "rules/qrl/uclassd_marks.inc"
#include "rules/qrl/uclassd.inc"
// ECR 5184 end

#include "rules/qrl/default_arc_type.inc" //ECR 6469

const    int    ACTIVE_FUNC_IS_UNDEFINED = -1; // SAME AS OMT

list    the_last_selection = NULL; // SAME AS OMT

int    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;

boolean
idehook_invalidate_all()
{
    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;
    return(True);
}

// SAME AS OMT
void
idehook_force_new_selection()
{
    the_last_selection = NULL;
    idehook_invalidate_all();
}

// SAME AS OMT
boolean
idehook_did_selection_change()
{
    list    symbols;

    symbols = gde_selected_symbols();

    if (the_last_selection == NULL)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (list_count(symbols) != list_count(the_last_selection))
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (lists_equal(symbols, the_last_selection) == False)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    return(False);
}

list
uml_note_link_symbols()
{
    string link_types = "Communicates deploys Dependency Interface isComponentOf";
    return string_to_list(link_types, " ");
}
// End ECR947, ECR 4494

////////////////////////////////////////////////////////////////////////////////
//
//   componentNavigation handles navigation between the deployment diagram 
//   and it's associated component diagram for No Object Selected Navigations.
//
////////////////////////////////////////////////////////////////////////////////
void componentNavigation()
{
    string diagramName;
    string currentQuery;
    list componentFileReferences;

    diagramName = gde_substitute_string("${file}");
    currentQuery = "file[UmlComponentDiagram && name = '" + diagramName + "']";
    componentFileReferences = list_select(currentQuery);
    if (list_count(componentFileReferences) != 0)
    {
    	editor_send_msg("ucomponentd", "FileLoad "+diagramName, CH_FIRST);
	editor_send_msg("ucomponentd", "EditorShowDeiconify", CH_FIRST);
	print_message("Navigated to Component Diagram '"+diagramName+"'");
    }
    else
    {
	print_error("No Component Diagram '"+diagramName+"'");
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//   this routine "deployAComponentDiagramFromDeploymentEditor" is called 
//   to query for an appropriate component diagram and the deploy said
//   diagram.
//
////////////////////////////////////////////////////////////////////////////////
void deployAComponentDiagramFromDeploymentEditor()
{
    string currentQuery;
    file currentFile;
    list componentFileReferences;
    int i;
    list currentComponentFiles;

    ///////////////////////////////////////////////////////////////////////////
    // Clear the buffer (If user cancels the next if statment succeeds) 
    // and deployment is canceled
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("BufferClear");
    gde_builtin("EditorSetFileName \"Noname\"");
    if (list_count(gde_all_symbols()) != 0)
    {
	return;
    }

    ///////////////////////////////////////////////////////////////////////////
    //  Query for all UmlComponentDiagrams
    ///////////////////////////////////////////////////////////////////////////
    currentQuery = "file[UmlComponentDiagram]";
    componentFileReferences = list_select(currentQuery);
    ///////////////////////////////////////////////////////////////////////////
    //  Make a list of strings representing the diagrams
    ///////////////////////////////////////////////////////////////////////////
    currentComponentFiles = list_create("string",0);
    for (i = 0; i < list_count(componentFileReferences); i++)
    {
	currentFile = list_get(componentFileReferences,i);
	list_append(currentComponentFiles,currentFile.name);
    }

    ///////////////////////////////////////////////////////////////////////////
    // Start the file selection property sheet
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("PropertySheetShow selectDiagram");
    FileSelectionNameInitialize(currentComponentFiles);
}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void clearAndDeployAComponentDiagram(string diagramName)
{
    ///////////////////////////////////////////////////////////////////////////
    // Clear the buffer (If user cancels the next if statment succeeds) 
    // and deployment is canceled
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("BufferClear");
    gde_builtin("EditorSetFileName \"Noname\"");
    if (list_count(gde_all_symbols()) != 0)
    {
	return;
    }
    deployAComponentDiagram(diagramName);
}

////////////////////////////////////////////////////////////////////////////////
//
//	this routine "deployAComponentDiagram" is called from the component
//	editor to cause a deployment of the current component diagram.
//
////////////////////////////////////////////////////////////////////////////////
void deployAComponentDiagram(string diagramName)
{
    int 	theTransaction;
    list 	componentNodeReferences;
    list	componentLinkReferences;
    list 	oldNodes;
    list 	newGdeNodes;
    string	currentQuery;
    int 	i,j;
    node_ref	currentNodeReference;
    node	currentNode;
    node	secondaryNode;
    link_ref	currentLinkReference;
    link_ref	secondaryLinkReference;
    link	currentLink;
    gde_node 	currentGdeNode;
    int		foundTo;
    int		foundFrom;

    ///////////////////////////////////////////////////////////////////////////
    // if name is null exit
    ///////////////////////////////////////////////////////////////////////////
    if (diagramName == "")
    {
	return;
    }
    ///////////////////////////////////////////////////////////////////////////
    // save current state for editor
    ///////////////////////////////////////////////////////////////////////////
    gde_save_state();
    theTransaction = gde_start_edit_transaction();

    ///////////////////////////////////////////////////////////////////////////
    // set this deployment diagram name to same as component diagram
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("EditorSetFileName \"" + diagramName  +"\"");

    ///////////////////////////////////////////////////////////////////////////
    // get all nodes && links  associated with this component diagram
    ///////////////////////////////////////////////////////////////////////////
    currentQuery = "node_ref[file[type==UmlComponentDiagram && name=='"+diagramName+"']]";
    componentNodeReferences = list_select(currentQuery);
    currentQuery = "link_ref[file[type==UmlComponentDiagram && name=='"+diagramName+"']]";
    componentLinkReferences = list_select(currentQuery);

    ///////////////////////////////////////////////////////////////////////////
    // Sort out the various node types into separte lists and draw them
    ///////////////////////////////////////////////////////////////////////////
    oldNodes 		= list_create("node",0);
    newGdeNodes 	= list_create("gde_node",0);
    for (i = 0; i < list_count(componentNodeReferences); i++)
    {
	currentNodeReference = list_get(componentNodeReferences,i);
	currentNode = find_by_query("node[id="+currentNodeReference.node_id+"]");
	if (currentNode != NULL)
	{
	    if (currentNode.type == "UmlComponentExecutable")
	    {
		currentGdeNode = gde_node_create
		    ("executableComponent",currentNodeReference.xcoord,currentNodeReference.ycoord);
		gde_node_set_label(currentGdeNode,currentNode.name);
		list_append(newGdeNodes,currentGdeNode);
    		list_append(oldNodes,currentNode);
	    }
	    else if (currentNode.type == "UmlComponentBinary")
	    {
		currentGdeNode = gde_node_create
		    ("binaryComponent",currentNodeReference.xcoord,currentNodeReference.ycoord);
		gde_node_set_label(currentGdeNode,currentNode.name);
		list_append(newGdeNodes,currentGdeNode);
    		list_append(oldNodes,currentNode);
	    }
	    else if (currentNode.type == "UmlComponentObject")
	    {
		currentGdeNode = gde_node_create
		    ("objectComponent",currentNodeReference.xcoord,currentNodeReference.ycoord);
		gde_node_set_label(currentGdeNode,currentNode.name);
		list_append(newGdeNodes,currentGdeNode);
    		list_append(oldNodes,currentNode);
	    }
	    /////////////////////////////////////////////////////////////////////////////
	    // Interface is a special case.  If it's hooked up to a source we skip it
	    /////////////////////////////////////////////////////////////////////////////
	    else if (currentNode.type == "UmlComponentInterface")
	    {
		currentLink = find_by_query("link[from_node_id=="+currentNodeReference.node_id+"]");
		if (currentLink!= NULL)
		{
		    secondaryNode = find_by_query("node[id="+currentLink.to_node_id+"]");
		    if (secondaryNode.type != "UmlComponentSource")
		    {
		   	currentGdeNode = gde_node_create
		  	    ("interfaceComponent",
			        currentNodeReference.xcoord,currentNodeReference.ycoord);
		   	gde_node_set_label(currentGdeNode,currentNode.name);
			list_append(newGdeNodes,currentGdeNode);
    			list_append(oldNodes,currentNode);
		    }
		}
	    }
	}
    }

    ///////////////////////////////////////////////////////////////////////////
    // Now draw the links that apply to the carried though nodes
    ///////////////////////////////////////////////////////////////////////////
    for (i = 0; i < list_count(componentLinkReferences); i++)
    {
	currentLinkReference = list_get(componentLinkReferences,i);
	currentLink = find_by_query("link[id="+currentLinkReference.link_id+"]");
	if (currentLink != NULL)
	{
	    foundTo = -1;
	    foundFrom = -1;
	    for (j = 0; ((j < list_count(oldNodes)) && ((foundTo == -1) || (foundFrom == -1))); j++)
	    {
		currentNode = list_get(oldNodes,j);
		if (currentNode.id == currentLink.to_node_id)
		{
		    foundTo = j;
		}
		if (currentNode.id == currentLink.from_node_id)
		{
		    foundFrom = j;
		}
	    }
	    if ((foundTo != -1) && (foundFrom != -1))
	    {	
		if (currentLink.type == "UmlComponentInterface")
		{
		    gde_arc_create("Interface",
			list_get(newGdeNodes,foundFrom), list_get(newGdeNodes,foundTo));
		}
		else if (currentLink.type == "UmlComponentDependency")
		{
		    gde_arc_create("Dependency",
			list_get(newGdeNodes,foundFrom), list_get(newGdeNodes,foundTo));
		}
		else if (currentLink.type == "UmlComponentComposit")
		{
		    gde_arc_create("isComponentOf",
			list_get(newGdeNodes,foundFrom), list_get(newGdeNodes,foundTo));
		}
	    }
	}
    }

    gde_builtin("BufferZoom FitDiagram");
    gde_builtin("EditorShowDeiconify");
    gde_end_edit_transaction(GDE_CMD_INSERT, theTransaction, False);
}

int udeploymentd_check_semantics()
{
    int err_count = 0;
    list allSymbols;
    list allInterfaceNodes;
    list allComponentNodes;
    list allDependencyArcs;
    list allComponentArcs;
    list allInterfaceArcs;
    list interfaceCountsList;
    gde_node tempNode;
    gde_arc tempArc;
    gde_symbol tempSymbol;
    int i;
    int count;
    int position;
    string tempType;

    // get all symbols on pallet
    allSymbols = gde_all_symbols();

    // initialize all lists
    allInterfaceNodes 	= list_create("gde_node",0);
    allComponentNodes 	= list_create("gde_node",0);
    allDependencyArcs 	= list_create("gde_arc",0);
    allComponentArcs 	= list_create("gde_arc",0);
    allInterfaceArcs 	= list_create("gde_arc",0);

    // separate out all 
    //   interface nodes, interface arcs, components, dependancy arcs, is Component of arcs
    for (i = 0; i < list_count(allSymbols); i++)
    {
	tempSymbol = list_get(allSymbols,i);
	if (gde_symbol_is_node(tempSymbol) == True)
	{
	    tempType = gde_get_symbol_type(tempSymbol);
	    if (tempType == "interfaceComponent")
	    {
		list_append(allInterfaceNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "binaryComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "sourceComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "executableComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "objectComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	}
	else if (gde_symbol_is_arc(tempSymbol) == True)
	{
	    tempType = gde_get_symbol_type(tempSymbol);
	    if (tempType == "Interface")
	    {
    		list_append(allInterfaceArcs,to_gde_arc(tempSymbol));
	    }
	    else if (tempType == "Dependenency")
	    {
    		list_append(allDependencyArcs,to_gde_arc(tempSymbol));
	    }
	    else if (tempType == "isComponentOf")
	    {
    		list_append(allComponentArcs,to_gde_arc(tempSymbol));
	    }
	}
    }

    // check that all interfaces have one interface link

    interfaceCountsList = list_create("int",0);
    for (i = 0; i < list_count(allInterfaceNodes); i++)
    {
	list_append(interfaceCountsList,0);
    }

    for (i = 0; i < list_count(allInterfaceArcs); i++)
    {
	position = list_find(allInterfaceNodes,0,gde_arc_fromnode(list_get(allInterfaceArcs,i)));
	if (position < list_count(allInterfaceNodes))
	{
	    count = list_get(interfaceCountsList,position);
	    count++;
	    list_set(interfaceCountsList,position,count);
	}
	else
	{
	    err_count++;
	    print_error("An interface arc exists with no interface node");
	}
    }

    for (i = 0; i < list_count(interfaceCountsList); i++)
    {
	count = list_get(interfaceCountsList,i);
	if (count == 0)
	{
	    print_error("Interface "+gde_node_label(list_get(allInterfaceNodes,i))+
		" is not attached to a component");
	    err_count++;
	}
	else if (count > 1)
	{
	    print_error("Interface "+gde_node_label(list_get(allInterfaceNodes,i))+
		" is attached to "+count+" components.");
	    err_count++;
	}
    }	

    return err_count;
}

//  Add any user customizations to the file included below:
#include_if_exists "user/uml/rules/qrl/user_udeploymentd.qrl"

