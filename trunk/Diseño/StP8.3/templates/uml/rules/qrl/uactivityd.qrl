
//      StP/UML
//      Confidential property of Aonix
//      Copyright (c) 1997
//      All rights reserved



#include "rules/qrl/ct.inc"

#include "rules/qrl/uml.inc"
#include "rules/qrl/object_instance.inc"
// rename
//#include "rules/qrl/oo_object_rename.inc"
#include "rules/qrl/state_diag_syms.inc"
#include "rules/qrl/gde_qrl_std.inc"

#include "rules/qrl/uactivityd.ps.qrl"
#include "qrl/include/export_to_doors.inc"

// ECR4052 Model Management
#include "rules/qrl/model_management.inc"

// Begin ECR947, ECR 4494
#include "rules/qrl/note_link.inc"

// ECR 4731
#include "rules/qrl/navtostp.inc"

#include "rules/qrl/default_arc_type.inc" //ECR 6469

// ECR 6285
#include "rules/qrl/uclassd_marks.inc"

const    int    ACTIVE_FUNC_IS_UNDEFINED = -1; // SAME AS OMT

list    the_last_selection = NULL; // SAME AS OMT

int    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;

list items;
list state_machines;
int nId;
boolean
FindOrCreateScenarioForUseCaseInActivityDiagram(int nodeId)
{
	node useCase = find_by_query("node[${nodeId}]");
    // check if there is a state machine with this name
    string qFindNamedStateMachine = "node_ref[file[UmlActivityDiagram] && node[UmlStateMachine && name='${useCase.name}']]";
    state_machines = list_select(qFindNamedStateMachine);
	if (0 == list_count(state_machines))
	{
		if(editor_confirm("Create new scenario for Use Case " + useCase.name + "?", "Yes", "No"))
			UmlStateDiagramInitFromUseCase(nodeId);
		list_clear(state_machines);
		return (True);
	}

	items = list_create("string", 0);
	list_append(items, "<<Create New Scenario for Use Case " + useCase.name + ">>");
	int i;
	node_ref entry;
	file f;
	for (i = 0; i < list_count(state_machines); i++)
	{
		entry = list_get(state_machines, i);
		f = find_by_query("file[${entry.file_id}]");
		list_append(items, "StateMachine " + useCase.name + " in diagram " + f.name);
	}

	nId = nodeId;
	editor_item_selector(items,
	    "umlCreateNamedScenarioInActivityDiagram();",
	    "Create Scenario for " + useCase.name,
	    True
	    );

	return (True);
}

int umlCreateNamedScenarioInActivityDiagram()
{
	list sel = editor_selector_selected_labels();
	
	if (sel == NULL || list_count(sel) == 0 || list_count(sel) > 1)
	{
		list_clear(items);
		list_clear(state_machines);
		return (0);
	}

	if (list_get(sel, 0) == list_get(items, 0))
		UmlStateDiagramInitFromUseCase(nId);
	else
	{
		int i;
		file f;
		node_ref entry;
		for (i = 1; i < list_count(items); i++)
			if (list_get(sel, 0) == list_get(items, i))
			{
				entry = list_get(state_machines, i-1);
				f = find_by_query("file[${entry.file_id}]");
				gde_builtin("FileLoad " + f.name);
				gde_builtin("BufferZoom FitDiagram");
			}
	}

	list_clear(sel);
	list_clear(items);
	list_clear(state_machines);
	return (1);
}

boolean
idehook_invalidate_all()
{
    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;
    return(True);
}

// SAME AS OMT
void
idehook_force_new_selection()
{
    the_last_selection = NULL;
    idehook_invalidate_all();
}

// SAME AS OMT
boolean
idehook_did_selection_change()
{
    list    symbols;

    symbols = gde_selected_symbols();

    if (the_last_selection == NULL)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (list_count(symbols) != list_count(the_last_selection))
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (lists_equal(symbols, the_last_selection) == False)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    return(False);
}

list
uml_note_link_symbols()
{
    string link_types = "StateTransitionLink SplitControlLink MergeControlLink InputLink OutputLink";
    return string_to_list(link_types, " ");
}
// End ECR947, ECR 4494

const string    UML_DECISION_SYMBOL_TYPE = "Decision";

int uactivityd_check_semantics()
{
    int err_count = 0;
    
//--- START ECR 3829   
//    Replace procedure
//    err_count = uml_check_state_machine_semantics() + err_count;
    err_count = uml_check_activity_state_machine_semantics() + err_count;
//--- END  ECR 3829   

    err_count = uml_check_transitions() + err_count;

    return err_count;
}

boolean
UActivityDCheckSyntax()
{
    boolean clean = gde_default_check_syntax();
    if(!uml_check_state_machine_syntax("Activity"))
	    clean = False;   

    if(!uml_check_transitions_syntax())
	clean = False;

    return clean;
}


list
uml_state_types_with_incoming_transitions()
{
    list	types;

    types = string_to_list(
		UML_STATE_SYMBOL_TYPE + " " +
		UML_FINAL_STATE_SYMBOL_TYPE + " " +
		UML_DECISION_SYMBOL_TYPE, " ");
    return(types);
}
boolean
uml_state_has_outgoing_transition(string symbol_type)
{
    if (symbol_type == UML_STATE_SYMBOL_TYPE ||
	symbol_type == UML_INITIAL_STATE_SYMBOL_TYPE ||
	symbol_type == UML_DECISION_SYMBOL_TYPE) 
	return True;
    return False;
}

list
uml_state_types_with_outgoing_transitions()
{    
    list	types;

    types = string_to_list(
		UML_STATE_SYMBOL_TYPE + " " +
		UML_INITIAL_STATE_SYMBOL_TYPE + " " +
		UML_DECISION_SYMBOL_TYPE, " ");
    return(types);
}

int
idehook_split_control_active_func()
{
    list	symbols, tr, tg, valid_targets;
    int		cnt;
    gde_arc	a;
    gde_node	n;
    list	endn;

    symbols = gde_selected_symbols();

    tr = gde_arcs_find_by_type(symbols, UML_STATE_TRANS_LINK_SYMBOL_TYPE);

    if (list_count(tr) != 1)
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }
    valid_targets = uml_state_types_with_incoming_transitions();
    cnt = list_count(gde_symbols_find_with_types(symbols, valid_targets));
    if ((cnt + 1) != list_count(symbols))
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }

    a = list_get(tr, 0);
    endn = list_create("gde_node", 0);
    n = gde_arc_get_real_tonode(a, False, endn, NULL);
    tg = gde_node_list_to_sym_list(endn);
    cnt = list_count(gde_symbols_find_with_types(tg, valid_targets));
    if (cnt != list_count(tg))
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }

    return ACTIVE_FUNC_IS_ACTIVE;
}

int
idehook_merge_control_active_func()
{
    list	symbols, tr, valid_targets, endn, tg;
    gde_node	n;
    gde_arc	a;
    int		i, cnt;

    symbols = gde_selected_symbols();

    tr = gde_arcs_find_by_type(symbols, UML_STATE_TRANS_LINK_SYMBOL_TYPE);

    if (list_count(tr) <= 0)
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }
    valid_targets = uml_state_types_with_incoming_transitions();
    for(i = 0; i < list_count(tr); i = i + 1)
    {
	a = list_get(tr, i);
	endn = list_create("gde_node", 0);
	n = gde_arc_get_real_tonode(a, False, endn, NULL);
	tg = gde_node_list_to_sym_list(endn);
	cnt = list_count(gde_symbols_find_with_types(tg, valid_targets));
	if (cnt != list_count(tg))
	{
	    return ACTIVE_FUNC_IS_INACTIVE;
	}
    }

    return ACTIVE_FUNC_IS_ACTIVE;
}

const string    SEL_STATE_TARGET_PROMPT = "Please select a state for target of transition";

void
UActivityDCreateControlSplit()
{
    list            symbols, tr, st;
    int             cnt, i;
    string          label;
    gde_arc         a, sa;
    gde_node        fn, sn, n, tn, lback, v;
    gde_symbol      s, sf;
    int             x, y, dodefer;

    symbols = gde_selected_symbols();

    tr = gde_arcs_find_by_type(symbols, UML_STATE_TRANS_LINK_SYMBOL_TYPE);

    if (list_count(tr) != 1)
    {
	// messages("if (list_count(tr) != 1)");
	return;
    }
    st = gde_symbols_find_with_types(symbols,
			       uml_state_types_with_incoming_transitions());
    cnt = list_count(st);

    if ((cnt + 1) != list_count(symbols))
    {
	return;
    }
    a = list_get(tr, 0);

    label = gde_arc_get_first_label(a);

    a = list_get(tr, 0);
    fn = gde_arc_get_real_fromnode(a, True, NULL, NULL);

    if (fn == NULL)
    {
	return;
    }
    tn = gde_arc_get_real_tonode(a, False, NULL, NULL);

    x = 0;
    y = 0;

    if (tn != NULL)
    {
	i = list_find(st, 0, to_gde_symbol(tn));
	if (i == list_count(st))
	{
	    list_append(st, to_gde_symbol(tn));
	}
    }
    i = list_find(st, 0, to_gde_symbol(fn));
    lback = NULL;
    if (i < list_count(st))
    {
	lback = fn;
	list_delete(st, i);
    }
    for (i = 0; i < list_count(st); i = i + 1)
    {
	n = to_gde_node(list_get(st, i));
	x = gde_node_x(n) + x;
	y = gde_node_y(n) + y;
    }

    if (i == 0)
    {
	x = gde_arc_fromx(a);
	y = gde_arc_fromy(a);
    } else
    {
	x = x / i;
	y = y / i;
    }
    x = (gde_arc_fromx(a) + x) / 2;
    y = (gde_arc_fromy(a) + y) / 2;

    dodefer = gde_start_edit_transaction();

    sn = gde_node_create(UML_SPLIT_CONTROL_SYMBOL_TYPE, x, y);
    sa = gde_arc_create(UML_STATE_TRANS_LINK_SYMBOL_TYPE, fn, sn);
    if (sa == NULL || sn == NULL)
    {
	gde_end_edit_transaction(0, dodefer, False);
	return;
    }
    if (label != NULL)
    {
	gde_arc_set_label(sa, label);
    }
    gde_arc_delete(a);

    if (cnt == 0)
    {
	if (tn != NULL)
	{
	    sa = gde_arc_create(UML_SPLIT_CONTROL_LINK_SYMBOL_TYPE, sn, tn);
	}
	gde_end_edit_transaction(GDE_CMD_INSERT, dodefer, False);
	start_an_arc_from(to_gde_symbol(sn), UML_SPLIT_CONTROL_LINK_SYMBOL_TYPE,
			  SEL_STATE_TARGET_PROMPT, False);
	return;
    }
    sf = to_gde_symbol(sn);
    if (lback != NULL)
    {
	x = gde_arc_fromx(sa);
	if (x == gde_arc_tox(sa))
	{
	    x = x - 30;
	    y = (gde_arc_fromy(sa) + gde_arc_toy(sa)) / 2;
	} else
	{
	    x = (x + gde_arc_tox(sa)) / 2;
	    y = gde_arc_tox(sa);
	}
	v = gde_node_create(UML_VERTEX_SYMBOL_TYPE, x, y);
	sa = gde_arc_create(UML_SPLIT_CONTROL_LINK_SYMBOL_TYPE, sn, v);
	sa = gde_arc_create(UML_SPLIT_CONTROL_LINK_SYMBOL_TYPE, v, fn);
    }
    for (i = 0; i < list_count(st); i = i + 1)
    {
	s = list_get(st, i);
	sa = gde_arc_create(UML_SPLIT_CONTROL_LINK_SYMBOL_TYPE, sf, s);
    }
    gde_end_edit_transaction(GDE_CMD_INSERT, dodefer, False);
}

boolean
arc_multiple_segs_selected(gde_arc a, list arcs)
{
    gde_arc	a1;
    gde_node	tn;
    list	st, segs;
    gde_symbol	s;
    int		i;

    st = list_create("gde_node", 0);
    segs = list_create("gde_symbol", 0);

    tn = gde_arc_get_real_tonode(a, False, st, segs);

    // don't want to find this arc again ...
    for(i = 1; i < list_count(segs); i = i + 1)
    {
	s = list_get(segs, i);
	if (gde_symbol_is_arc(s))
	{
	    a1 = to_gde_arc(s);
	    if (list_find(arcs, 0, a1) != list_count(arcs))
	    {
		// message("Found duplicate seg selected...");
		return(True);
	    }
	}
    }
    return(False);
}

void
UActivityDMergeControl()
{
    list            symbols, tr, st, al1, st2, sources, newtr;
    int             cnt, i, j, k, nc;
    string          label;
    gde_arc         a, a2, ma;
    gde_node        fn, sn, n, tn, lback, v;
    gde_symbol      s, sf;
    int             x, y, dodefer;

    symbols = gde_selected_symbols();


    tr = gde_arcs_find_by_type(symbols, UML_STATE_TRANS_LINK_SYMBOL_TYPE);
    newtr = list_create("gde_arc", 0);

    if (list_count(tr) < 1)
    {
	return;
    }


    // st contains all the to states
    st = list_create("gde_node", 0);
    for (i = 0; i < list_count(tr); i = i + 1)
    {
	a = list_get(tr, i);
	if (i < (list_count(tr) -1))
	{
	    if (list_find(tr, i+1, a) < list_count(tr))
	    {
		continue;
	    }
	}

	// get rid of arcs where more than one arc segement is
	// selected of the same arc

	if (arc_multiple_segs_selected(a, tr))
	{
	    // message("duplicate on path - ignore");
	    continue;
	}
	list_append(newtr, a);
	tn = gde_arc_get_real_tonode(a, False, st, NULL);
    }
    // the cleaned state transition link list ...
    tr = newtr;

    // for each transition find all the target nodes

    dodefer = gde_start_edit_transaction();


    // for all all targets find the links that end in this target
    for (k = 0; k < list_count(st); k = k + 1)
    {
	tn = list_get(st, k);
	al1 = list_create("gde_arc", 0);
	x = 0;
	y = 0;
	for (j = 0; j < list_count(tr); j = j + 1)
	{
	    // for all arcs find if they end in the target
	    a2 = list_get(tr, j);
	    st2 = list_create("gde_node", 0);
	    n = gde_arc_get_real_tonode(a2, False, st2, NULL);
	    if (list_find(st2, 0, tn) != list_count(st2))
	    {
		list_append(al1, a2);
		x = x + (gde_arc_fromx(a2) + gde_arc_tox(a2)) / 2;
		y = y + (gde_arc_fromy(a2) + gde_arc_toy(a2)) / 2;
	    }
	}

	// now al1 contains all arcs ending in tn
	cnt = list_count(al1);
	if (cnt == 0)
	{
	    continue;
	}
	x = x / cnt;
	y = y / cnt;
	sn = gde_node_create(UML_MERGE_CONTROL_SYMBOL_TYPE, x, y);
	if (sn == NULL)
	{
	    gde_end_edit_transaction(0, dodefer, False);
	    return;
	}
	// message("arcs ending in same node " + list_count(al1));

	ma = gde_arc_create(UML_MERGE_CONTROL_LINK_SYMBOL_TYPE, sn, tn);

	for (i = 0; i < list_count(al1); i = i + 1)
	{
	    a = list_get(al1, i);
	    label = gde_arc_get_first_label(a);

	    sources = list_create("gde_node", 0);
	    fn = gde_arc_get_real_fromnode(a, False, sources, NULL);

	    for (nc = 0; nc < list_count(sources); nc = nc + 1)
	    {
		fn = list_get(sources, nc);
		ma = gde_arc_create(UML_STATE_TRANS_LINK_SYMBOL_TYPE, fn, sn);
		if (ma == NULL)
		{
		    continue;
		}
		if (label != NULL)
		{
		    gde_arc_set_label(ma, label);
		}
	    }
	}
    }

    for (i = 0; i < list_count(tr); i = i + 1)
    {
	a = list_get(tr, i);
	gde_arc_delete(a);
    }

    gde_end_edit_transaction(GDE_CMD_INSERT, dodefer, False);
}

// ECR 7215 moved 'uml_decision_outgoing_transitions' and 'uml_decision_name' to 'state_diag_syms.inc'

list transition_symbolic_dependents(gde_mapsymbol ms)
{
    list dependents = list_create("gde_mapsymbol", 0);
    gde_link transition = to_gde_link(ms);
    gde_node target = gde_link_tonode(transition);
    gde_node source = gde_link_fromnode(transition);
    string target_nt_name = gde_nt_name(gde_node_nt(target));
    string source_nt_name = gde_nt_name(gde_node_nt(source));

    if(source_nt_name == UML_DECISION_SYMBOL_TYPE)
	list_append(dependents,to_gde_mapsymbol(source));
    if(target_nt_name == UML_SPLIT_CONTROL_SYMBOL_TYPE || 
       target_nt_name == UML_MERGE_CONTROL_SYMBOL_TYPE)
	list_append(dependents,to_gde_mapsymbol(target));
    
    return dependents;
}

boolean
uml_check_transitions_syntax()
{
    list transitions = gde_arcs_find_by_type(gde_all_symbols(),
					     UML_STATE_TRANS_LINK_SYMBOL_TYPE);
    int i;
    gde_arc transition;
    string label;
    boolean clean = True;
    UMLParsedTransition parsed_transition;

    if(list_count(transitions) == 0)
	return True;
    
    for (i = 0; i < list_count(transitions); i = i + 1)
	{
	    transition = list_get(transitions, i);
	    label = gde_arc_label(transition);
	    parsed_transition = uml_parse_transition_label(label);
	    if (parsed_transition.unmatched_parens_error)
		{
		    /* syntax error */
		    gde_print_error("Syntax error: unmatched parentheses.",
				    gde_arc_psymid(transition));
		    clean = False;
		    
		}
	    if (parsed_transition.unmatched_brackets_error)
		{
		    gde_print_error("Syntax error: unmatched guard brackets.",
				    gde_arc_psymid(transition));
		    clean = False;
		}
	    
	    if(parsed_transition.event != "" || 
	       parsed_transition.sendev != "")
		{
		    /* syntax error */
		    gde_print_error("Syntax error: transition may only be labeled with guard and action.",
				     gde_arc_psymid(transition));
		    clean = False;
		}
	}
    
    return clean;
}

list state_symbolic_dependents(gde_mapsymbol ms)
{
    int i;
    list dependents, arcs, links;
    gde_node gn = to_gde_node(ms);
    gde_arc arc;
    gde_node target;
    
    dependents = list_create("gde_mapsymbol",0);
    arcs = gde_node_outarcs(gn);
    for(i = 0; i < list_count(arcs);i++)
	{
	    arc = list_get(arcs, i);
	    if (gde_lt_name(gde_arc_lt(arc)) == UML_STATE_TRANS_LINK_SYMBOL_TYPE)
		{
		    links = gde_arc_links(arc);
		    if (list_count(links) > 0)
			{
			    target = gde_link_tonode(list_get(links, 0));
			    if(gde_nt_name(gde_node_nt(target)) == 
			       UML_SPLIT_CONTROL_SYMBOL_TYPE || 
			       gde_nt_name(gde_node_nt(target)) == 
			       UML_MERGE_CONTROL_SYMBOL_TYPE)
				list_append(dependents,to_gde_mapsymbol(target));
			    
			}
		}
	}
    return dependents;
}
 
// Begin Add ECR 5421
string clean_as_name( string as_name )
{
    string newres = string_translate(as_name, UML_BAD_CH, UML_GOOD_CH);
    newres = string_search_and_replace( newres, " ", "_" );
    return newres;
}
// End ECR 5421

// Begin Add ECR 3829
void
UmlStateDiagramInitFromActionState(int oid)
{
    node actionState = find_by_query("node[UmlActionState && id = ${oid}]");
    gde_node state_machine;
    int dodefer,id;
    string filename;

    EditorShowOnNavReceive();
    
    if(actionState == NULL)
    {
        print_error("No action state node with id " + oid + ".");
        return;
    }
    
    // ECR 5421
    string as_name = clean_as_name( actionState.name );
    
    filename = create_new_file_in_sequence(as_name, NULL);
    gde_builtin("FileLoad " + filename);

    gde_builtin("BufferFindOpt -center");    

    gde_save_state();
    dodefer = gde_start_edit_transaction();
    state_machine =  gde_node_create(UML_STATE_MACHINE_SYMBOL_TYPE,
                  0, 0);
    gde_node_set_label(state_machine, as_name);

    gde_end_edit_transaction(GDE_CMD_INSERT, dodefer, False);
    /* center the buffer */
    gde_builtin("BufferZoom FitDiagram");
    
    /* save all this work we did */

    gde_builtin("FileSaveas " + filename);
    id = gde_node_psymid(state_machine);
    gde_builtin("BufferFind " + id);
    
}

int uml_check_activity_state_machine_semantics()
{
    gde_node sm = uml_state_machine();
    string label;
    string class_name;
    string operation_name;
    list path_components;
    uml_operation parsed_operation;
    int pos;
    int err_count = 0;

    string corrNodes = "(UmlClass || UmlUseCase || UmlSystem || UmlPackage || UmlActionState) ";

    if(sm == NULL)
    return err_count;

    label = gde_node_label(sm);
    if(label == NULL || label == "")
    return err_count;
    
    print_message("Checking State Machine...");

    if(uml_state_machine_is_class(label))
    {
        if(find_by_query("node[" + corrNodes + " && name = '" + label + "']") == NULL)
        {
            gde_print_error("No Model Element " + label + " corresponding to State Machine",gde_node_psymid(sm));
            err_count++;
        }
    }
    else
    {   
        //It must correspond to an operation
        pos = string_find(label,0,UML_PATH_SEPARATOR);
        class_name = string_extract(label,0,pos);
        pos = pos + string_length(UML_PATH_SEPARATOR);
        if(pos >= string_length(label))
        return err_count;

        operation_name = 
        string_extract(label,pos,
                   string_length(label) - pos);
        
        parsed_operation = 
        uml_parse_operation(operation_name);
        
        if(parsed_operation.error)
        return err_count;

        if(find_by_query("node[UmlOperation && sig = '${parsed_operation.opArgs}' && name = '${parsed_operation.opName}' && scope_node[name = '${class_name}']]") == NULL)
        {   
            gde_print_error("No Operation " + label + " corresponding to State Machine",gde_node_psymid(sm));
            err_count++;
        }
    }
    return err_count;
}

/////////////////////////////////////////////////////////
// ActionState rename 
/////////////////////////////////////////////////////////

#include "rules/qrl/gde_uml_object_rename.inc"

const   string  ACTIONSTATE_RENAME_PROP_SHEET = "ActionStateRename";

void
uml_actionState_rename_init(gde_mapsymbol actionState)
{
    uml_rename_set_curr_label(ACTIONSTATE_RENAME_PROP_SHEET, actionState);
}

void
uml_actionState_rename(gde_mapsymbol actionState)
{
    gde_builtin("PropertySheetShow " + ACTIONSTATE_RENAME_PROP_SHEET);

    uml_actionState_rename_init(actionState);
}

void
uml_actionState_rename_action_done()
{
    gde_mapsymbol ms = gde_selected_mapsymbol();
    ui_prop p = to_ui_prop(ACTIONSTATE_RENAME_PROP_SHEET, "All");
    
    if (gde_rename_action_done_standard_checks(ms, p, "uml_actionState_rename") == False)
    return;
    
    uml_actionState_rename_init(ms);
}

list
getStateMachineContext( string sm_name )
{
    node my_as;
    int i;
    list smContextParents = list_select("node[(UmlSystem || UmlPackage || UmlClass || UmlUseCase) && name='${sm_name}' && node_refs]");

    // exception for action states (whitespaces and newlines allowed !)
    // get all ActionStates first
    list all_action_states = list_select( "node[UmlActionState && node_refs[file[name != '" + file_part(gde_file_name()) + "']]]" ); // ECR 6924
        
    // loop and "normalize"
    for( i=0; i<list_count( all_action_states ); i++ )
    {
        my_as = list_get( all_action_states, i );
        // ECR 5421
        if( clean_as_name( my_as.name ) == sm_name )
        {
            list_append( smContextParents, my_as );
        }
    }
    
    return( smContextParents );
}

boolean
stateMachineHasContext( string sm_name )
{
    if( list_count( getStateMachineContext( sm_name ) ) > 0 )
        return True;
    else
        return False;
}

// returns the context of the state machine for a display mark
string stateMachineContextDM( string sm_name )
{
    string smContext = "Context: ";
    list smContextParents = getStateMachineContext( sm_name );
        
    int parentNumber = list_count(smContextParents);

    // nothing found -> return empty string
    if (parentNumber == 0)  return "";
    
    if (parentNumber > 1)  return smContext + "more than one parent !";
    
    node smParent = list_get(smContextParents, 0);
    
    if (smParent.type == "UmlActionState")  return smContext + "refined Action State";
    if (smParent.type == "UmlUseCase")  return smContext + "Scenario for Use Case";
    if (smParent.type == "UmlSystem")  return smContext + "System";
    if (smParent.type == "UmlPackage")  return smContext + "Package";
    if (smParent.type == "UmlClass")  return smContext + "Class";
    
    list_clear(smContextParents);
    return "";
}


int
idehook_action_state_active_func()
{
    list    symbols;
    gde_symbol  gSymbol;
    gde_node    gNode;
    string      gNodeType;

    symbols = gde_selected_symbols();

    if (list_count(symbols) == 1)
    {
        gSymbol = list_get( symbols, 0 );
    
        if (gde_symbol_is_node(gSymbol)) {
            gNode     = to_gde_node(gSymbol);
            gNodeType = gde_nt_name(gde_node_nt(gNode));

            if (gNodeType == UML_STATE_SYMBOL_TYPE )  
           return ACTIVE_FUNC_IS_ACTIVE;
        }
        else print_warning("not Node");
    }

    return ACTIVE_FUNC_IS_INACTIVE;
}


void labelActionStateWithUseCaseName() 
{
    int     ucnt, ux;
    node    useCase;

    list    useCaseList  = list_create("node", 0);
    list    useCaseNames = list_create("string", 0);


    useCaseList = list_select("node[UmlUseCase && node_refs] sort by name");
    ucnt        = list_count(useCaseList);

    if (ucnt == 0) {
    print_error("No Use Cases defined !", NULL);
    return;
    }

    for (ux = 0; ux < ucnt; ux++)
    {
        useCase = list_get(useCaseList, ux);
        list_append(useCaseNames, useCase.name);
    }

    editor_item_selector(useCaseNames, "LabelActionStateFromList();",
             "Label Action State with Use Case Name", True);

    list_clear(useCaseList);
    list_clear(useCaseNames);

    return;
}

void LabelActionStateFromList() 
{ 
    gde_symbol  gSymbol;
    gde_node    gNode;
    string      gNodeType, newName;

    list        ucNames = editor_selector_selected_labels();
    list        symbols = gde_selected_symbols();

    // do nothing if no new name 
    if (list_count(ucNames) != 1) return;  // no selection

    newName = list_get(ucNames, 0);
    if (newName == NULL || newName == "")  return;  // no new name


    // check if the selected symbol is an action state, otherwise do nothing
    if (list_count(symbols) != 1) return;  // no more symbol selected

    gSymbol = list_get( symbols, 0 );

    if (gde_symbol_is_node(gSymbol)) 
    {
        gNode     = to_gde_node(gSymbol);
        gNodeType = gde_nt_name(gde_node_nt(gNode));

        if (gNodeType != UML_STATE_SYMBOL_TYPE ) return;  //wrong symbol selected

        // we have everything we need, set the label now
    gde_save_state();
    gde_node_set_label(gNode, newName);
    }

    return; // something went wrong, return anyway
}

list
find_parent_action_state( string file_id, string as_name )
{
    int i;
    node my_as;
    node_ref my_as_ref;
    list refs = list_create( "node_ref", 0 );
    
    // get all ActionStates first
    list all_action_states = list_select( "node[UmlActionState && " +
        "node_refs[file[UmlActivityDiagram && id != " + file_id + "]]]" );
        
    // loop and "normalize"
    for( i=0; i<list_count( all_action_states ); i++ )
    {
        my_as = list_get( all_action_states, i );
        // ECR 5421
        if( clean_as_name( my_as.name ) == as_name )
        {
            my_as_ref = find_by_query( "node_ref[node_id == " + my_as.id + "]" );
            list_append( refs, my_as_ref );
        }
    }
    return( refs );
}

// changed second parameter to node id for ECR 5421
list
find_refined_action_state( string as_id, string file_id  )
{
    node as = find_by_query( "node[id==${as_id}]" );
    if( as == NULL )
        return NULL;
    string refined_query = "node_ref[node[UmlStateMachine && name == '" +
        // ECR 5421
        clean_as_name( as.name ) + "'] && file[UmlActivityDiagram && id != " +
        file_id + "]]";
    return list_select( refined_query );
}

// changed parameter to node id for ECR 5421
boolean
action_state_is_refined( string as_id )
{
    node as = find_by_query( "node[id==${as_id}]" );
    if( as == NULL )
        return False;
    file my_file = find_by_query( "file[UmlActivityDiagram && node_refs[node[id==" + as_id + "]]]" );
    if( my_file == NULL )
        return False;
    
    if( list_count( find_refined_action_state( as_id, to_string( my_file.id ) ) ) > 0 )
        return True;
    else
        return False;
}

// End Add ECR 3829

//  Add any user customizations to the file included below:
#include_if_exists "user/uml/rules/qrl/user_uactivityd.qrl"
