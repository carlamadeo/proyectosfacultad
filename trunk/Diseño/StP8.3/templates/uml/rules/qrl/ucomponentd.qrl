//
//      StP/Uml
//      Confidential property of Aonix
//      Copyright (c) 1997
//      All rights reserved
//

// Master include -- includes everything else
// general qrl utility functions
#include "rules/qrl/ct.inc"

// some more stuff from ct
#include "rules/qrl/gde_qrl_std.inc"

// the UML stuff
#include "rules/qrl/uml.inc"
#include "rules/qrl/oper_parse.inc"
#include "rules/qrl/ucomponentd.ps.qrl"
#include "qrl/include/export_to_doors.inc"

// ECR4052 Model Management
#include "rules/qrl/model_management.inc"

// Begin ECR947, ECR 4494
#include "rules/qrl/note_link.inc"

// ECR 4731
#include "rules/qrl/navtostp.inc"

// ECR 5184 start
#include "rules/qrl/re_pe_label_funcs.inc"
#include "rules/qrl/navtosniff.inc"
#include "rules/qrl/pe_nav.inc"
#include "rules/qrl/uclassd_marks.inc"
#include "rules/qrl/uclassd.inc"
// ECR 5184 end

#include "rules/qrl/default_arc_type.inc" //ECR 6469

const    int    ACTIVE_FUNC_IS_UNDEFINED = -1; // SAME AS OMT

list    the_last_selection = NULL; // SAME AS OMT

int    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;

boolean
idehook_invalidate_all()
{
    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;
    return(True);
}

// SAME AS OMT
void
idehook_force_new_selection()
{
    the_last_selection = NULL;
    idehook_invalidate_all();
}

// SAME AS OMT
boolean
idehook_did_selection_change()
{
    list    symbols;

    symbols = gde_selected_symbols();

    if (the_last_selection == NULL)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (list_count(symbols) != list_count(the_last_selection))
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (lists_equal(symbols, the_last_selection) == False)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    return(False);
}

list
uml_note_link_symbols()
{
    string link_types = "Dependency Interface isComponentOf";
    return string_to_list(link_types, " ");
}
// End ECR947, ECR 4494

void deploymentNavigation()
{
    string diagramName;
    string currentQuery;
    list deploymentFileReferences;

    diagramName = gde_substitute_string("${file}");
    currentQuery = "file[UmlDeploymentDiagram && name = '" + diagramName + "']";
    deploymentFileReferences = list_select(currentQuery);
    if (list_count(deploymentFileReferences) != 0)
    {
	editor_send_msg("udeploymentd", "FileLoad "+diagramName, CH_FIRST);
	editor_send_msg("udeploymentd", "EditorShowDeiconify", CH_FIRST);
	print_message("Navigated to Deployment Diagram '"+diagramName+"'");
    }
    else
    {
	if (editor_confirm("Generate Deployment Diagram '"+diagramName+"'?", "OK", "Cancel"))
	{
	    print_message("Generating Deployment Diagram '"+diagramName+"'");
	    deployThisDiagram();
	}
    }
}

void deployThisDiagram()
{
    string diagramName;
    diagramName = gde_substitute_string("${file}");
    editor_send_msg("udeploymentd",
	"EditorQrlEvalNoSave clearAndDeployAComponentDiagram(\""+diagramName+"\");",
	CH_FIRST);
}

int ucomponentd_check_semantics()
{
    int err_count = 0;
    list allSymbols;
    list allInterfaceNodes;
    list allComponentNodes;
    list allDependencyArcs;
    list allComponentArcs;
    list allInterfaceArcs;
    list interfaceCountsList;
    gde_node tempNode;
    gde_arc tempArc;
    gde_symbol tempSymbol;
    int i;
    int count;
    int position;
    string tempType;

    // get all symbols on pallet
    allSymbols = gde_all_symbols();

    // initialize all lists
    allInterfaceNodes 	= list_create("gde_node",0);
    allComponentNodes 	= list_create("gde_node",0);
    allDependencyArcs 	= list_create("gde_arc",0);
    allComponentArcs 	= list_create("gde_arc",0);
    allInterfaceArcs 	= list_create("gde_arc",0);

    // separate out all 
    //   interface nodes, interface arcs, components, dependancy arcs, is Component of arcs
    for (i = 0; i < list_count(allSymbols); i++)
    {
	tempSymbol = list_get(allSymbols,i);
	if (gde_symbol_is_node(tempSymbol) == True)
	{
	    tempType = gde_get_symbol_type(tempSymbol);
	    if (tempType == "interfaceComponent")
	    {
		list_append(allInterfaceNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "binaryComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "sourceComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "executableComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	    else if (tempType == "objectComponent")
	    {
		list_append(allComponentNodes,to_gde_node(tempSymbol));
	    }
	}
	else if (gde_symbol_is_arc(tempSymbol) == True)
	{
	    tempType = gde_get_symbol_type(tempSymbol);
	    if (tempType == "Interface")
	    {
    		list_append(allInterfaceArcs,to_gde_arc(tempSymbol));
	    }
	    else if (tempType == "Dependenency")
	    {
    		list_append(allDependencyArcs,to_gde_arc(tempSymbol));
	    }
	    else if (tempType == "isComponentOf")
	    {
    		list_append(allComponentArcs,to_gde_arc(tempSymbol));
	    }
	}
    }

    // check that all interfaces have one interface link

    gde_node curr_int_node;
    gde_arc curr_arc;
    list out_arcs;
    list in_arcs;
    int x, y;
    string curr_arc_type;
    set link_set = set_create("gde_link");
    list in_links;
    list out_links;
    int int_link_count;

    for (i=0; i<list_count(allInterfaceNodes); i++)
    {
        set_clear(link_set);
        curr_int_node = list_get(allInterfaceNodes, i);

        out_arcs = gde_node_outarcs(curr_int_node);
        in_arcs = gde_node_inarcs(curr_int_node);

        for (x=0; x<list_count(out_arcs); x++)
        {
            curr_arc = list_get(out_arcs, x);
            curr_arc_type = gde_lt_name(gde_arc_lt(curr_arc));
            if (curr_arc_type == "Interface")
            {
                out_links = gde_arc_links(curr_arc);
                for (y=0; y<list_count(out_links); y++)
                {
                    set_add(link_set, list_get(out_links, y));
                }
            }
        }

        for (x=0; x<list_count(in_arcs); x++)
        {
            curr_arc = list_get(in_arcs, x);
            curr_arc_type = gde_lt_name(gde_arc_lt(curr_arc));
            if (curr_arc_type == "Interface")
            {
                in_links = gde_arc_links(curr_arc);
                for (y=0; y<list_count(in_links); y++)
                {
                    set_add(link_set, list_get(in_links, y));
                }
            }
        }

        int_link_count = set_count(link_set); 
	if (int_link_count == 0)
	{
	    gde_print_error("Interface " + gde_node_label(curr_int_node) +
                 " is not attached to a component.", gde_node_psymid(curr_int_node));
	    err_count++;
	}
	else if (int_link_count > 1)
	{
	    gde_print_error("Interface " + gde_node_label(curr_int_node) +
            " is attached to " + int_link_count + " components.", gde_node_psymid(curr_int_node));
	    err_count++;
	}

    }

    set_clear(link_set);

    list arc_links;
    gde_link curr_link;
    string from_node_type;
    string to_node_type;
    gde_link prev_link = NULL;

    for (i=0; i<list_count(allInterfaceArcs); i++)
    {
        curr_arc = list_get(allInterfaceArcs, i);
        arc_links = gde_arc_links(curr_arc);

        for (y=0; y<list_count(arc_links); y++)
        {
            set_add(link_set, list_get(out_links, y));
        }

        if (set_count(link_set) > 0)
        {
            curr_link = set_get_element(link_set, 0);
        }
        else
            continue;

        if (curr_link == prev_link)
            continue;

        prev_link = curr_link;

        from_node_type = gde_nt_name(gde_node_nt(gde_link_fromnode(curr_link)));
        to_node_type = gde_nt_name(gde_node_nt(gde_link_tonode(curr_link)));

        if (from_node_type != "interfaceComponent" && 
            to_node_type != "interfaceComponent")
        gde_print_error("An interface link exists without an interface node.", 
                         gde_arc_psymid(curr_arc));

    }

    return err_count;
}

//  Add any user customizations to the file included below:
#include_if_exists "user/uml/rules/qrl/user_ucomponentd.qrl"
