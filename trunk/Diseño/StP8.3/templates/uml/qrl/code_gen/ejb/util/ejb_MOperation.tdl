/**********************************************
 *
 * Helper-Routines for Operations
 * 
 * Author:  Frank Lippert
 * Company: Aonix GmbH
 * Date:    11/18/2000
 *********************************************/
 
// Generates the throws clause of an operation. 
// (the throws clause is then normally augmented 
// with predefined exceptions)
proc genOperationThrows(MOperation)
    local throws = "";
    loop(MOperation->Note->Item Where [Item.type] == "UmlOperationThrows")
        [throws] = [Item.value];
    end loop
    [MOperation:throws] = [throws];
end proc


proc genExceptions(exceptions)
    if ([exceptions] == "")
        return "";
    else
        return ", "[exceptions];
    end if
end proc



// Is Operation "final"?
proc isOperationFinal(MOperation)
    loop(MOperation->Note->Item Where [Item.type] == "UmlMemberJavaIsFinal")
        [MOperation:final] = "True";
    end loop
end proc


// Generates the modifiers (the rest of it, except the binding) 
// of an operation.
proc genOperationModifier(MOperation)
    local modifier = "";
    loop(MOperation->Note->Item Where [Item.type] == "UmlOperationIsAbstract" || [Item.type] == "UmlMemberJavaIsFinal" || [Item.type] == "UmlOperationIsSynchronized" || [Item.type] == "UmlOperationJavaIsNative"; setDelim(""); setDelim(" "))
        if ([Item.type] == "UmlOperationIsAbstract")
            [modifier] = [modifier] delim() "abstract";
        end if
        if ([Item.type] == "UmlMemberJavaIsFinal")
            [modifier] = [modifier] delim() "final";
        end if
        if ([Item.type] == "UmlOperationJavaIsNative")
            [modifier] = [modifier] delim() "native";
        end if
        if ([Item.type] == "UmlOperationJavaIsSynchronized")
            [modifier] = [modifier] delim() "synchronized";
        end if
    end loop
   [MOperation:modifier] = [modifier];
end proc



// Generates a value for the operation's visibility,
// if the user didn't define one.
proc genOperationVisibility(MOperation) 
    if ([MOperation.access] == "")
        [MOperation.access] = "public";
    end if
end proc



// Generates a default value of the operation's binding 
// Changes "normal" to "".
proc genOperationBinding(MOperation) 
    if ([MOperation.binding] == "normal")
        [MOperation.binding] = "";
    end if
end proc



// Generates a default value for the operations
// returntype. If  the user didn't define one
// we change it to "void".
proc genOperationReturnType(MOperation)
    if ([MOperation.returnType] == "")
        [MOperation.returnType] = "void";
    end if
end proc



// Generates a type-name list out of the operation's parameters.
proc genOpParaList(MOperation)
    local paras = "";
    loop(MOperation->OpPara; setDelim(""); setDelim(", "))
        importType([OpPara.type]);
        [paras] = [paras] delim() [OpPara.type] " " [OpPara.name];
    end loop
    return [paras];
end proc

// Generates a type list out of the operation's parameters.
proc genOpParaTypes(MOperation)
    local types = "";
    loop(MOperation->OpPara; setDelim(""); setDelim(", "))
        [types] = [types] delim() [OpPara.type];
    end loop
    return [types];
end proc



// Generates an operation declaration header without whitespace.
// (often the modifiers are emtpy)
proc genOperationHeader(MOperation)
    local header = "";
    
    [header] = [MOperation.access] " " [MOperation.binding] " " [MOperation:modifier] " " [MOperation.returnType];
    [header] = replace([header], " +", " ");
    return [header];
end proc



// Saves the number of arguments of a
// operation as an metaelement property
proc opCount(MOperation) 
    local op_count = "0";
    
    loop(MOperation->OpPara)
        add([op_count], "1");
    end loop
    [MOperation:op_count] = [op_count];
end proc


// Returns the proper default value
// for a particular datatype
proc getDefaultReturn(MOperation)
    switch([MOperation.returnType])
        case "void" :
            return "";
        case "boolean" :
            return " false";
        case "byte" :
        case "short" :
        case "int" :
            return " 0";
        case "long" :
            return " 0L";
        case "float" :
            return " 0.0F";
        case "double" :
            return " 0.0D";
        case "char" :
            return " \u0000";
        case "String" :
            return " \"\"";
        default :
            return " null";
    end switch
end proc