//*****************************************************************************
// $RCSfile: com_genClassHeader.tdl,v $
// $Revision: 1.4 $
// $Date: 2001/12/04 12:59:55 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates a header file for each metamodel type MClass with <<COMObject>>.
*/

/*
import other template files
*/
USES com_std;
USES ../tdl/std;

proc genClassHeader(MClass)
	/* local variables */
	local packageList;
	local fileName;

	/* The variable [packageList] holds an id list of all packages that is build
	   up of two parts: the id of the domain package (if one exists) and the 
	   id of the enclosing package (relativ to MClass, if one exists) 
	   This id list is needed as a condition for the next loop statement 
	   getIdListRec is a predefined function */
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	
	/* Determine the first part of the file name to be generated.
	   If an instance of metamodel type MClass is part of an enclosing package
	   this packagename will be the name for the subdirectory the source
	   files are generated in */
	loop(Instances->MPackage([packageList]))
		[fileName] = [fileName] [MPackage.name] "/";
	end loop

	if ([MClass.stereotype]=="COMObject")	
		/* Build the final filename for MClass */
		[fileName] = [srcdir] "/" [fileName] [MClass.name] ".h";
		/* Redirect output to standard output */
		info = "generate " [fileName] "\n";
		/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
		   in std.tdl) */
		mkdir(lsdir( [fileName]));
		
		/* Set the output redirection to [fileName]. output is a predefined
		   function */
		output( [fileName] );
		/* insert package id that is used inside the templates by the procedure
		   provided as the second parameter to the mark function */
		insert("package",[Class_[MClass.name]]);
	
		/* Call the appropriate template for generation of header file */
		out = [MClass].genClassHeader();
	end if 
end proc

template MClass.genClassHeader()
[loop (MClass->MPackage)]
#include "[MPackage.name].h"	// Header generated by com.exe
[end loop]

[/*	actual instance of MClass inherits from interfaces.
	The interfaces are deliverd by proc. genImplementClass, in com_std.tdl
*/]
class [MClass.name] : [genImplementClass([MClass])]
{
[/* attribute is used for actual methods imlementation of IUnknown */]
	private:
	ULONG localRefCounter;
	public:
	[MClass.name]() {localRefCounter=0;}
	
	public:
	[/* generates the root interface methods, in com_std.tdl */]
	// Root interface methods	
[getRootInterfaceMethodsForClassHeader([MClass])]	
	
	// Interface [getInterfaceClass([MClass])]
	private:
	[/* generate methods of the interfaces, s. below */]
	[genInterfaceMethodsForClassHeader([MClass])]
};
end template

/* generate methods of the interfaces */
template genInterfaceMethodsForClassHeader(MClass)
[setLanguage("CPP")]
[loop(MClass->Implement)]
[/* The second loop statement is to differentiate the methods of the interfaces*/]
// Interface [Implement.name]
[loop(Implement->MOperation)]
STDMETHODIMP [MOperation.name]([getOpTypeList([MOperation])]);
[end loop]
[end loop]
end template




















