//*****************************************************************************
// $RCSfile: com_genClass.tdl,v $
// $Revision: 1.4 $
// $Date: 2001/12/04 12:59:55 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates a cpp file for each metamodel type MClass with <<COMObject>>.
   Calls the starting procedure for generation of header, factory and idl file.
*/

/*
import other template files
*/
USES com_genFactory;
USES com_genInterface;
USES com_genClassHeader;
USES com_std;
USES ../tdl/std;


proc MNormalClass.startGen(MClass)
	/* local variables */
	local packageList;
	local fileName;

	/* The variable [packageList] holds an id list of all packages that is build
	   up of two parts: the id of the domain package (if one exists) and the 
	   id of the enclosing package (relativ to MClass, if one exists) 
	   This id list is needed as a condition for the next loop statement.
	   getIdListRec is a predefined function */
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	
	/* Determine the first part of the file name to be generated.
	   If an instance of metamodel type MClass is part of an enclosing package
	   this packagename will be the name for the subdirectory the source
	   files are generated in */
	loop(Instances->MPackage([packageList]))
		[fileName] = [fileName] [MPackage.name] "/";
	end loop

	if ([MClass.stereotype]=="COMObject")	
		/* Build the final filename for MClass */
		[fileName] = [srcdir] "/" [fileName] [MClass.name] ".cpp";
		/* Redirect output to standard output */
		info = "generate " [fileName] "\n";
		/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
		   in std.tdl) */
		mkdir(lsdir( [fileName]));
		
		/* Set the output redirection to [fileName]. output is a predefined
		   function */
		output( [fileName] );
		/* insert package id that is used inside the templates by the procedure
		   provided as the second parameter to the mark function */
		insert("package",[Class_[MClass.name]]);
	
		/* Call the appropriate template (either MInterface.genClass or 
		   MClass.genClass) depending on the actual subtype of MClass
		   and redirect output to the channel set by setOutput (s. above) */
		out = [MClass].genClass();	/* redirect output to cxx impl. file for coclass */
		[MClass].genFactoryClass([MClass]); /* generates factory, in com_genFactory.tdl */
		genClassHeader([MClass]);	/* generates header for coclass in com_genClassHeader.tdl */
		startGenInterfaces([MClass]);	/* generates idl file in com_genInterface.tdl*/
	end if 
end proc

/* generate implementation file for coclass
*/
template MClass.genClass()
#include "[MClass.name].h"	

[MClass.name]::~[MClass.name]() {;}

[/* generate methods of the basic interface, 
	 either IUnknown or IDispatch, in com_std.tdl */]
[getRootInterfaceMethodsForClass([MClass])]
[/* generate methods of the interfaces, s. below */]
[genInterfaceMethodsForClass([MClass])]
end template

template genInterfaceMethodsForClass(MClass)
[setLanguage("CPP")]
[loop(MClass->Implement)]
[/* The second loop statement is to differentiate the methods of the interfaces*/]
// Interface [Implement.name]
[loop(Implement->MOperation)]
STDMETHODIMP [MClass.name]::[MOperation.name]([getOpTypeList([MOperation])]) 
{ 
	;
}
[end loop]
[end loop]
end template


proc getInterfaceClass(MClass)
	local ret;
    loop(MClass->Implement)
        [ret] = [Implement.name];
    end loop
	return [ret];
end proc
























