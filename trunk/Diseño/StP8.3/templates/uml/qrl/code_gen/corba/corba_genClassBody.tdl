//*****************************************************************************
// $RCSfile: corba_genClassBody.tdl,v $
// $Revision: 1.3 $
// $Date: 2001/12/04 12:59:55 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates a implementation file for each metamodel type MClass that
   represents implementation class for appropriate interface.
*/

/*
import other template files
*/
USES ../tdl/std;
USES corbaidl_std;
USES corbaidl_genFactory;
USES corbaidl_genFactoryHeader;

proc genClassBody(MInterface)
	/* local variables */
	local packageName;
	local fileName;
	local implementationFilename;

	loop(MInterface->Implementation)
		loop(MInterface->MPackage)
			[packageName] = [MPackage.name];
		end loop
		[implementationFilename] = [Implementation.name];

		/* Build the final filename for MClass */
		[fileName] = [srcdir] "/" [packageName] "/" [implementationFilename] ".cpp";
		/* Redirect output to standard output */
		info = "generate " [fileName] "\n";
		/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
		   in std.tdl) */
		mkdir(lsdir( [fileName]));
		
		/* Set the output redirection to [fileName]. output is a predefined
		   function */
		output( [fileName] );
		/* insert package id that is used inside the templates by the procedure
		   provided as the second parameter to the mark function */
//		insert("package",[Class_[MInterface.name]]);
	
		/* Call the appropriate template for generation of header file */
		out = [Implementation].genClassBody([MInterface]);
		genFactoryHeader([MInterface]);	// call proc. for generating header of class factory
		genFactoryBody([MInterface]);	// call proc. for generation impl. file of class factory

	end loop
end proc

/*	start template
*/
template MClass.genClassBody(MInterface)
[loop (MClass->MPackage)]
#include <corba.h>
#include "[MPackage.name]_S.hpp"	[// include file generated by corba compiler]

#include "[MClass.name].hpp"
[end loop]
[mergeOut("UDIF","user includes")]

[genConstructor([MClass])]						[// gen. constructor]

[genDestructor([MClass])]						[// gen. destructor]

[genLifeCycleOperationsBody([MInterface])]		[// gen. lifecycle operations depending on factory]

[genAccessorForIDLAttribsBody([MClass])]		[// nomen est omen]

[genIDLOperationsBody([MClass])]				[// dito]

end template

/*	generate constructor
*/ 
template genConstructor(MClass)
[MClass.name]::[MClass.name]()
{
	[mergeOut("UDCC","user defined constructor code")]
}
end template

/*	generate lifecycle operations, depending on request to generate 
	class factory
*/ 
template genLifeCycleOperationsBody(MInterface)
[// first check, whether Factory should be generated]
[if (getFactoryNameFromInterface([MInterface], "FALSE") != "")]
// IDL Lifecycle operations
[loop (MInterface->Implementation)]
void [Implementation.name]::remove()
{
	delete this;	
}
[end loop]
[end if]	
end template

/*	generate destructor
*/
template genDestructor(MClass)
[MClass.name]::~[MClass.name]()
{
[loop (MClass->Implement)]
[// first check, whether Factory should be generated]
[if (getFactoryNameFromInterface([Implement], "TRUE") != "")]
    // free my TIE object
    myTie = 0;

[end if]	
[end loop]
	[mergeOut("UDDC","user defined destructor code")]
}
end template

/*	generate bodies of IDL operations
*/
template genIDLOperationsBody(MClass)
[setLanguage("CPP")]
[loop(MClass->Implement)]
[/* extract operations only, that are not static.That have a different semantic */]

// IDL operations
[loop(Implement->MOperation WHERE [MOperation.binding] != "static")]
[getDataType([MOperation.returnType])] [MClass.name]::[MOperation.name]([getOpTypeList([MOperation])])
{
	[mergeOut("UDOI::" getUniqueId([MOperation]),"operation implementation")]
}
[end loop]
[end loop]
end template

/*	generate accessor operations for IDL attributes
*/
template genAccessorForIDLAttribsBody(MClass)
[setLanguage("CPP")]
[loop(MClass->Implement)]
[if (hasLoop(Implement->MAttribute))]
// IDL Attribute setters and getters
[end if]
[loop(Implement->MAttribute)]
[getDataType([MAttribute.type])] [MClass.name]::[MAttribute.name]()
{
	[getDataType([MAttribute.type])] retVal;
	
	[mergeOut("UDAG::" getUniqueId([MAttribute]),"attribute getter")]
	
	return retVal;	
}

void [MClass.name]::[MAttribute.name](const [getDataType([MAttribute.type])] _[MAttribute.name])
{
	[mergeOut("UDAS::" getUniqueId([MAttribute]),"attribute setter")]
	
}
[end loop]
[end loop]
end template

