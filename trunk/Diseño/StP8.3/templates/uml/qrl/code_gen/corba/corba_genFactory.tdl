//*****************************************************************************
// $RCSfile: corba_genFactory.tdl,v $
// $Revision: 1.3 $
// $Date: 2001/12/04 12:59:55 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates a cpp file for each factory. Factories are fully generated for 
   intefaces with tagged value 'HasFactory=<factory class name>'.
*/

/*
import other template files
*/
USES corbaidl_std;
USES corbaidl_genFactoryHeader;
USES ../tdl/std;


proc genFactoryBody(MInterface)
	/* local variables */
	local packageName;
	local fileName;
	local implementationFilename;

	loop(MInterface->Implementation)
		loop(MInterface->MPackage)
			[packageName] = [MPackage.name];
		end loop
		[implementationFilename] = getTaggedValueValue([MInterface], "HasFactory");
		if ([implementationFilename] == "")
			return;
		end if
		
		/* Build the final filename for MClass */
		[fileName] = [srcdir] "/" [packageName] "/" [implementationFilename] "_i.cpp";
		/* Redirect output to standard output */
		info = "generate " [fileName] "\n";
		/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
		   in std.tdl) */
		mkdir(lsdir( [fileName]));
		
		/* Set the output redirection to [fileName]. output is a predefined
		   function */
		output( [fileName] );
		/* insert package id that is used inside the templates by the procedure
		   provided as the second parameter to the mark function */
//		insert("package",[Class_[MInterface.name]]);
	
		/* Call the appropriate template for generation of header file */
		out = [Implementation].genFactoryBody([MInterface]);
	end loop
end proc

/*	start template
*/
template MClass.genFactoryBody(MInterface)
#include <corba.h>
[loop (MClass->MPackage)]
#include "[MPackage.name]_S.hpp"	[// header generated by corba compiler]

[end loop]
#include "[getFactoryNameFromInterface([MInterface], "FALSE")]_i.hpp"
#include "[MClass.name].hpp"
[mergeOut("UDIF","user includes")]

[getFactoryNameFromInterface([MInterface], "FALSE")]_i* [getFactoryNameFromInterface([MInterface], "FALSE")]_i::mInstance = 0;

extern CORBA::BOA_ptr boa;

[genConstructorBody([MInterface])]			[// gen. constructor ]

[genDestructorBody([MInterface])]			[// gen. destructor ]

[instanciateFactoryBody([MInterface])]		[// gen. the instance method]

[factoryDoYourJobBody([MInterface])]		[// method that instantiates the server class]

[genStaticOperationsOfInterfaceBody([MInterface])]	[// use the static ops from interface]

end template

// Generate operation bodies for factory class.
// These op's are stored as static operations in the appropriate interface by convention
// For further information s. Whitepaper "Modeling CORBA components"

template genStaticOperationsOfInterfaceBody(MInterface)
[//loop over all static operations in interface belonging to that factory class]
[loop (MInterface->MOperation WHERE [MOperation.binding] == "static")]
[MInterface.name]* [getFactoryNameFromInterface([MInterface], "FALSE")]_i::[genStaticInterfaceOpBody([MOperation])]
{
    [MInterface.name]* _[MInterface.name]Impl = create[MInterface.name]();
	[mergeOut("UDOI::" getUniqueId([MOperation]),"operation implementation")]
    
    return _[MInterface.name]Impl;
}
[end loop]
end template

/*	get the op. name of static operation with correct type of ret. val and signature
*/
proc genStaticInterfaceOpBody(MOperation)
	local retVal;
	setLanguage("CPP");	/* sets the tag for typemapping. See TDL documentation for further information */
		[retVal] = getDataType([MOperation.returnType]) " ";
		[retVal] = [retVal] [MOperation.name]"("getOpTypeList([MOperation])")";
	return [retVal];
end proc

/*	method that instantiated the server class
*/
template factoryDoYourJobBody(MInterface)
[MInterface.name]* [getFactoryNameFromInterface([MInterface], "FALSE")]_i::create[MInterface.name]()
{
    // Create implemementation object
    [loop (MInterface->Implementation)]
    [Implementation.name]*  _[MInterface.name]Impl = new [Implementation.name];
    [end loop]
    
    // Create TIE object
    [loop (MInterface->MPackage)]
    [loop (MInterface->Implementation)]
    [MPackage.name]_tie_[MInterface.name]<[Implementation.name]>* tie[MInterface.name] = \
    new [MPackage.name]_tie_[MInterface.name]<[Implementation.name]>(*_[MInterface.name]Impl,"");

    // Store pointer to TIE in the Time_i object
    _[MInterface.name]Impl->myTie = tie[MInterface.name];
    
    // Register object at CORBA runtime system
    boa->obj_is_ready(tie[MInterface.name]);
    
    // Return TIE object (typed as interface object = superclass of the tie object)
    return [MPackage.name]::[MInterface.name]::_duplicate(tie[MInterface.name]);
    [end loop]
    [end loop]
}
end template

/*	destructor
*/
template genDestructorBody(MInterface)
[getFactoryNameFromInterface([MInterface], "FALSE")]_i::~[getFactoryNameFromInterface([MInterface], "FALSE")]_i()
{
    // Destroy my propagator.
    if (myTie)
    {
        delete myTie;
        myTie = 0;
    }
}
end template

/*	constructor
*/
template genConstructorBody(MInterface)
[getFactoryNameFromInterface([MInterface], "FALSE")]_i::[getFactoryNameFromInterface([MInterface], "FALSE")]_i()
{
    // Create propagator for me
[loop (MInterface->MPackage)]
    myTie = new [MPackage.name]_tie_[getFactoryNameFromInterface([MInterface], "FALSE")]<[getFactoryNameFromInterface([MInterface], "FALSE")]_i> (*this, "");
[end loop]

    // I am ready
    boa->obj_is_ready(myTie);
}
end template

/*	method to instantiate the factory according to the singleton pattern
*/
template instanciateFactoryBody(MInterface)
[getFactoryNameFromInterface([MInterface], "FALSE")]_i* [getFactoryNameFromInterface([MInterface], "FALSE")]_i::instance()
{
    if (!mInstance)
    {
        mInstance = new [getFactoryNameFromInterface([MInterface], "FALSE")]_i();        
    }
    
    return mInstance;
}
end template





















