//*****************************************************************************
// $RCSfile: corbaidl_genInterface.tdl,v $
// $Revision: 1.4 $
// $Date: 2001/12/04 12:59:56 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates an idl file for all separate interfaces or 
   idl files depending on packages, if code is generated for the whole model.
   Generated are interfaces for model element class with <<interface>>
   or interface symbol
*/

/*
import other template files
*/
USES corbaidl_std;
//USES corbaidl_genClassHeader;

proc gen_dir_file(MClass)
	/* local variables */
	local packageList;
	local fileName;
	local dirName;	// Directory part of file name, driven by package containment

	/* The variable [packageList] holds an id list of all packages that is build
	   up of two parts: the id of the domain package (if one exists) and the 
	   id of the enclosing package (relativ to MClass, if one exists) 
	   This id list is needed as a condition for the next loop statement 
	   getIdListRec is a predefined function */
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	
	
	/* Determine the first part of the file name to be generated.
	   If an instance of metamodel type MClass is part of an enclosing package
	   this packagename will be the name for the subdirectory the source
	   files are generated in */
	loop(Instances->MPackage([packageList]))
		[dirName] = [dirName] [MPackage.name] "/";
	end loop

	/* Build the final filename for MClass */
	[fileName] = [srcdir] "/" [dirName] [MClass.name][interface_extension];
	mkdir(lsdir( [fileName]));
	output( [fileName] );
	
//	info = "generate " [fileNameForAllClasses] "\n";
	
	insert("package",[Class_[MClass.name]]);

	/*	call the starting point for generation of idl files
	*/
	out = genPreface([MClass]);
end proc

/*	called when the whole model is to be generated
	in this case idl files for top level packages are generated
*/
proc MPackage.startGenInterfaceFile()
	/* local variables */
	local fileName;

		[fileName] = [fileName] [MPackage.name] "/";
		/* Build the final filename for idl file on basis of package name */
		[fileName] = [srcdir] "/" [fileName] [MPackage.name] ".idl";
		/* Redirect output to standard output */
//		info = "generate " [fileName] "\n";
		/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
		   in std.tdl) */
		mkdir(lsdir( [fileName]));
		
		/* Set the output redirection to [fileName]. setOutput is a predefined
		   function */
		output( [fileName] );

		/* Call the appropriate template and redirect output to the 
		channel set by setOutput (s. above) */
		out = genTemplate([MPackage]);
end proc

/*	called from proc gen_dir_file
	needed for marking the include section inside the 
	generated idl file.
*/
template genPreface(MClass)
[mark("include", "inc_proc")]
[mergeOut("UDIN","includes")]


[genModuleForSingleInterface([MClass])]
[genInterface([MClass])]
[CLOSEMODULE]
end template

/*	if single interface is part of module
	prepare the generation of module with 
	open and close {}
*/
proc genModuleForSingleInterface(MClass)
	[OPENMODULE] = "";
	[CLOSEMODULE] = "";
	if (hasLoop(MClass->MPackage))
	loop(MClass->MPackage)
		[OPENMODULE] = "module "[MPackage.name]" {";
		[CLOSEMODULE] = "};";
	end loop
	end if
	return [OPENMODULE];
end proc

/*	preparational template
*/
template genTemplate(MPackage)

#ifndef __[MPackage.name]__
#define __[MPackage.name]__

[irgendeineProc([MPackage])]

#endif
end template

/*	separeted  procedure used for  recursive call
*/
proc irgendeineProc(MPackage)
	return genIDLfile([MPackage]);
end proc

/*	Start template
*/
template genIDLfile(MPackage)
module [MPackage.name] {	
[if (hasLoop (MPackage->SubPackage))]
[loop (MPackage->SubPackage AS sub)]
[irgendeineProc([sub])]		[// Recursion, gen. subpacks, before gen. classes of outer packs]
[end loop]
[end if]
[loop (MPackage->MClass)]	[// loop over all classes, enclosed by package symbol	]
[genInterface([MClass])]	[// start generating interfaces]
[end loop]
};
end template

proc genInterface(MClass)
//info = "genInterface with: " [MClass.name]"\n";
	return [MClass].genInterfaces();
end proc

proc helper69(schtring)
info = "---> "[schtring] "\n";
end proc

/*	template for generating the interfaces
*/
template MInterface.genInterfaces()
[//helper69([MInterface.name])]
[if ([comment_classes]=="True")]
[loop(MInterface->Note Where [Note.type] == "GenericObject")]
[commentedOutDesc([Note.description])]
[end loop]  
[end if]

	interface [MInterface.name] [genBaseInterface([MInterface])] {
		
	[genRelationship([MInterface])]
	
	
	[mergeOut("UDREL","relations")]
	
	
	[genAttribute([MInterface])]
	
	[mergeOut("UDVAR","variables")]

	[genMethod([MInterface])]

	[mergeOut("UDOP","operations")]

	};
end template

/*	generate base interface
*/
proc genBaseInterface(MInterface)
	local retVal = "";
	loop(MInterface->SuperClass AS super; setDelim(": "); setDelim(", "))
//		info = "Super Ingo: "[super.name]"\n";
		[retVal] = [retVal] delim() [super.name];
	end loop
	return [retVal];
end proc

template genRelationship(MInterface)
[/* each relation (MAssociation) has two end points (MAssociationEnd). 
	We look for pairs of end points where one end point is attached to 
	the source class and the other end point is attached to the 
	destination class. We use the alias name 'FromRole' for the end point
	of the source class, 'ToRole' for the end point of the destination 
	class, and 'Partner' for the destination class itself. The condition
	'Where [FromRole.id] != [ToRole.id]' assures that both end points are
	different. */]
[loop(MInterface->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id])]
[// decide whether the relation is generated, depending on navigability]
[checkNavigability([FromRole], [ToRole])]
[if ([generateTheAssociation] == "True")]
[insert("include",[Partner.id])] 
[//insert("include",[Partner.id])] 
[helper2([MInterface],[Partner])]
[/*genRelationStatement([MInterface], [FromRole], [Partner], [ToRole])*/]
[[Partner].genRelationStatement([MInterface], [FromRole], [ToRole])]
[end if]
[end loop]	
end template

proc helper2(MInterface, MClass)
	// ECR 4816 info = [MInterface.name]" "[MClass.name]"\n";
end proc

proc helper1(schtring, MInterface)
	info = [schtring][MInterface.name]"\n";;
end proc

/*	generate include statements, called from mark procedure
*/
template MClass.inc_proc()
[// do nothing]
end template

template MInterface.inc_proc()
#include "[MInterface.name].idl"
end template


/* maps the multiplicity of the end point MAssociationEnd. We distinguish the 
   following cases:
   "One"  : a single instance
   "Fix"  : a fix no. of instances
   "Range": a range of instances, the upper value is less the *
   "Many" : a Vector
   Procedure getCorbaMultiplicity (defined in std.tdl) provides the multiplicity of 
   the end point 
   At this point only the variable to store the association is delivered,
   i.e. the instance variable, array or vector (depending on the multiplicity)
   The instanciation (depending on the type of the association) is done in the
   constructor.
   
   MInterface is the partner of that association, but can't be aliased
*/
// proc genRelationStatement(MInterface, MAssociationEnd AS FromRole, MClass As Partner, MAssociationEnd AS ToRole)

proc MInterface.genRelationStatement(MInterface AS srcInterf, MAssociationEnd AS FromRole, MAssociationEnd AS ToRole)

	[PackageHierarchy] = getEnclosingPackages([MInterface]);
info = "---> "[MInterface.name] " ---> "[PackageHierarchy]"\n";
	if ([ToRole.name]==[MInterface.name] || [ToRole.name] == "")
		[ToRole.name] = "ref_"[MInterface.name];
	end if

	local multiplicity = getCorbaMultiplicity([srcInterf], [FromRole], [ToRole], [MInterface]);
	switch([multiplicity])

	case "One"	: 
		return  "attribute " [PackageHierarchy][MInterface.name] " " [ToRole.name] ";";

	case "Fix"	:
		local fix = "\t"[ToRole:Instantiation]"\n";
		[fix] = [fix] "\tattribute " [ToRole.name]"_def " [ToRole.name] ";";
		return [fix];

	case "Range"	:
		local range = "\t"[ToRole:Instantiation]"\n";
		[range] = [range] "\tattribute " [ToRole.name]"_def " [ToRole.name] ";";
		return [range];

	case "Many" : 
		local many = "\t"[ToRole:Instantiation]"\n";
		[many] = [many] "\tattribute " [ToRole.name]"_def " [ToRole.name] ";";
		return [many];

	default 	: 
		return "attribute " [PackageHierarchy][MInterface.name] " " [ToRole.name] "[] = new " [MInterface.name] "[" [multiplicity] "];";
	end switch
end proc

proc getEnclosingPackages(MInterface)
	local packageList="";
	local packHier = "";
	
	loop(MInterface->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	
	loop(Instances->MPackage([packageList]))
		[packHier] = [packHier][MPackage.name]"::";
	end loop
	
	return [packHier];

end proc

proc MNormalClass.genRelationStatement(MInterface AS srcInterf, MAssociationEnd AS FromRole, MAssociationEnd AS ToRole)
// dummy, do nothing.
end proc

/*	sets the global variable generateTheAssociation, depending on 
	the navigability, found on both association roles.
	Bidirectional assocs are generated (with(out) arrows on both ends)
	Unidirectional assocs are generated only if the arrow is on the opposite
	end of the association
*/
proc checkNavigability(MAssociationEnd AS FromRole, MAssociationEnd AS ToRole)
	[generateTheAssociation] = "False";
//	info = "From: " [FromRole.isNavigable] "\n";
//	info = "To: " [ToRole.isNavigable] "\n";
	// the following is interpreted as bidirectional association
	// generate it!
	if ([FromRole.isNavigable] == [ToRole.isNavigable])
		[generateTheAssociation] = "True";
	end if
	// now only the opposite end is of interest
	// it it's true, it's an unidirectional association
	// generate it!
	if ([ToRole.isNavigable] == "TRUE")
		[generateTheAssociation] = "True";
	end if
end proc

/*	generate the attributes
*/
template genAttribute(MInterface)
[setLanguage("CORBAIDL")]	[/* sets the tag for typemapping. See TDL documentation for further information */]
[loop(MInterface->MAttribute)]
	[if ([comment_attributes]=="True")]
	[loop(MAttribute->Note Where [Note.type] == "GenericObject")]
	[commentedOutDesc([Note.description])]
	[end loop]  
	[end if]
	[attributeIsReadonly([MAttribute])] attribute [MAttribute.type] [MAttribute.name];
[end loop]
end template

/*	is attribute readonly?
*/
proc attributeIsReadonly(MAttribute)
	if (itemValueForType([MAttribute],"UmlAttributeIDLIsReadOnly", "")=="True")
		return "readonly";
	end if	
end proc

/*	is operation oneway?
*/
proc operationIsOneWay(MOperation)
	local result = itemValueForType([MOperation], "UmlOperationIDLAttribute", "");

	if ([result] == "True")
		return "oneway ";
	end if 
	
	if ([result] == "oneway")
		return "oneway ";
	else
		return "";
	end if 
end proc

/* generate methods of interface MInterface
 */
template genMethod(MInterface)
[setLanguage("CORBAIDL")]	[/* sets the tag for typemapping. See TDL documentation for further information */]
[/* extract all operations from interface, that != static */]
[loop(MInterface->MOperation WHERE [MOperation.binding] != "static")]
	[if ([comment_operations]=="True")]
	[loop(MOperation->Note Where [Note.type] == "GenericObject")]
	[commentedOutDesc([Note.description])]
	[end loop]
	[end if]
	[getContext([MOperation])]
	[operationIsOneWay([MOperation])][getDataType([MOperation.returnType])] [MOperation.name]([getOpTypeList([MOperation])])[MOperation:Semicolon]
	[if ([MOperation:Context] != "")]
	[MOperation:Context];
	[end if]
[end loop]

end template

/*	generate context to operation if set in class table
*/
proc getContext(MOperation)
	local cont = itemValueForType([MOperation], "UmlOperationIDLContext", "");
	[MOperation:Context] = "";
	[MOperation:Semicolon] = ";";
	
	if ([cont] != "")
		[MOperation:Context] = "context(\""[cont]"\")";
		[MOperation:Semicolon] = "";
	end if
end proc

/* check if class is marked as external, return TRUE if class is external
	normaly there is no code generation for external classes
*/ 
proc classIsExternal(MClass)
	loop(MClass->Note->Item)
		if ([Item.type] == "UmlClassIsImported" && [Item.value] == "True")
			return "True";
		end if
	end loop
	return "False";
end proc



proc help1(str, MClass)
	info = [str]": " [MClass.name]"\n";
end proc

proc help2(str, MPackage)
	info = [str]": "[MPackage.name]"\n";
end proc
proc helper(MPackage)
	info = "helper: "[MPackage.name]"\n";
end proc

/*	dummy template to avoid warnings if 
	generator passes normal class to this
	template without stereotype interface
*/
template MNormalClass.genInterfaces()
[// dummy template to avoid warnings]
end template















