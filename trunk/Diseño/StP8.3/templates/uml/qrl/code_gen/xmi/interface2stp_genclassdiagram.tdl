/////////////////////////////////////////////////////////////////////////////
// StP Symbol types
/////////////////////////////////////////////////////////////////////////////

proc MPackage.getSymbolType()
    return "Package";
end proc

proc MClass.getSymbolType()
    return "Class";
end proc

proc MTemplateClass.getSymbolType()
    return "ParameterizedClass";
end proc

proc MInstantiatedClass.getSymbolType()
    return "InstantiatedClass";
end proc

proc MAttribute.getSymbolType()
    return "Attribute";
end proc

proc MOperation.getSymbolType()
    return "Operation";
end proc

proc MObject.getSymbolType()
    return "Object";
end proc

/////////////////////////////////////////////////////////////////////////////
// StP Symbol mappings
/////////////////////////////////////////////////////////////////////////////

proc MPackage.getMappingName()
    return "ClassMapping";
end proc

proc MClass.getMappingName()
    return "ClassMapping";
end proc

proc MTemplateClass.getMappingName()
    return "ParameterizedClassMapping";
end proc

proc MInstantiatedClass.getMappingName()
    return "InstantiatedClassMapping";
end proc

proc MAttribute.getMappingName()
    return "ClassMapping";
end proc

proc MOperation.getMappingName()
    return "ClassMapping";
end proc

proc MObject.getMappingName()
    return "ObjectMapping";
end proc

/////////////////////////////////////////////////////////////////////////////
// Helper functions
/////////////////////////////////////////////////////////////////////////////

proc MSemElement.getName()
    return replaceQuotes([MSemElement.name]);
end proc

proc MOperation.getName()
    return replaceQuotes([MOperation.name] "( " generateOperationParameters([MOperation]) " )");
end proc

proc makeRef(MElement)
    [REF_[MElement.id]] = getNextID();
    return [REF_[MElement.id]];
end proc

proc getRef(MElement)
    if ([REF_[MElement.id]] == "")
        return [UIDMAP_[MElement.id]];
    else
        return [REF_[MElement.id]];
    end if
end proc

proc clearRef(MElement)
    local res;

    [res] = [REF_[MElement.id]];
    [REF_[MElement.id]] = "";

    return [res];
end proc

/////////////////////////////////////////////////////////////////////////////
// StP files generation
/////////////////////////////////////////////////////////////////////////////

proc generatePackageClassDiagrams()
    [SYS_DIAGRAM] = "StPCommon";

    [CLASS_WIDTH] = 300;
    [CLASS_HEIGHT] = 80;
    // ECR 6927 begin
    [PACKAGE_WIDTH] = 400;
    [PACKAGE_HEIGHT] = 150;
    // ECR 6927 end
    [nClass1X] = 0;
    [nClass1Y] = 0;
    [nClass1W] = [CLASS_WIDTH];
    [nClass1H] = [CLASS_HEIGHT];
    [nClass2X] = 0;
    [nClass2Y] = 0;
    [nClass2W] = [CLASS_WIDTH];
    [nClass2H] = [CLASS_HEIGHT];

    [X_SPACING] = 200;
    [Y_SPACING] = 100;
    [X_ROLE_OFFSET] = 30;
    [Y_ROLE_OFFSET] = 50;

    loop(Instances->MPackage)
        loop(Instances->MClass)
            [CLASS_X [MClass.id]] = 0;
            [CLASS_Y [MClass.id]] = 0;
        end loop
    end loop

    loop(Instances->MPackage)
        [nClass] = 1;
        [nClassCount] = loopCount(MPackage->MClass);
        [nCategoriesCount] = loopCount(MPackage->SubPackage);
        [nTotalCount] = add([nClassCount],[nCategoriesCount]);
        if ([nTotalCount] != 0)
            [nWidth] = ceil(sqrt([nTotalCount]));
            [nHeight] = div(sub(add([nTotalCount], [nWidth]), 1), [nWidth]);
            dumpPackageDiagram([MPackage]);
        end if
    end loop

    // Generate system diagram
    [nClass] = 1;
    [nClassCount] = loopCount(Instances->MClass Where !hasLoop(MClass->MPackage));
    [nCategoriesCount] = loopCount(Instances->MPackage Where !hasLoop(MPackage->SubPackage));
    [nTotalCount] = add([nClassCount],[nCategoriesCount]);
    [nWidth] = add(floor(sqrt([nTotalCount])),1);
    [nHeight] = add(div([nTotalCount],[nWidth]),1);
    dumpFreeClassesDiagram();

    // generate relations
    generateGeneralizationRelations();
    generateDependencyRelations();
    generateBindingRelations();
    generateImplementsRelations();
    generateAssociationRelations();
end proc

proc dumpPackageDiagram(MPackage)
    local packageName = [MPackage].getName();
    [packageName] = replace([packageName]," ","_");
    output( [ProjectDir] "uclassd_files/" getFileName([packageName],"") ".uclassd");
    generateClassDiagramInfo([packageName]);
    generatePackageInfo([MPackage], TRUE);
    loop(MPackage->SubPackage)
        generatePackageInfo([SubPackage], FALSE);
    end loop
    loop(MPackage->MClass)
        generateClassInfo([MClass]);
    end loop
end proc

proc dumpFreeClassesDiagram()
    local diagramName = [SYS_DIAGRAM];
    [diagramName] = replace([diagramName]," ","_");
    output( [ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
    generateClassDiagramInfo([diagramName]);
    loop(Instances->MPackage Where !hasLoop(MPackage->Domain))
        generatePackageInfo([MPackage], FALSE);
    end loop
    loop(Instances->MClass Where !hasLoop(MClass->MPackage))
        generateClassInfo([MClass]);
    end loop
end proc

proc generatePackageInfo(MPackage, MainPackage)
    if ([MainPackage])
        [nPackW] = max(mul(mul([nWidth],[X_SPACING]),3),1282);
        [nPackH] = add(mul(mul([nHeight],[Y_SPACING]),3),256);
        [nPackX] = div(sub(div([nPackW],2),div([nPackW],7)),3);
        [nPackY] = add(mul(sub(sub([nHeight],1),div([nHeight],2)),[Y_SPACING]),35);
    else
        [nPackX] = mul(mod(sub([nClass],1),[nWidth]),[X_SPACING]);
        [nPackY] = mul(div(sub([nClass],1),[nWidth]),[Y_SPACING]);
        [nPackW] = [CLASS_WIDTH];
        [nPackH] = [CLASS_HEIGHT];
    end if
    >>
    Node [getRef([MPackage])]
    {
        { Type Package }
        { Loc [nPackX] [nPackY] }
        { Scale [nPackW].00 [nPackH].00 }
        { Label
            { Text "[[MPackage].getName()]" }
        }
    >> out
    if (![MainPackage])
        loop(MPackage->Domain)
            >>
                { IsIncluded True }
                { Parent [getRef([Domain])] }
            >> out
        end loop
    end if
    >>
        { ViewPoint UmlAllMembers }
        { Object
            { PDMType Node }
            { MappingName [[MPackage].getMappingName()] }
            { ID 0 }
            { GUID "[[MPackage].getGuid()]" }
        }
    }
    >> out

    if (![MainPackage])
        loop(MPackage->Domain)
            local ARC_ID = getNextID();
            local LINK_ID = getNextID();
            >>
            Arc [[ARC_ID]]
            {
                { Type Contains }
                { IsInclusion True }
                { From
                    { ID [getRef([Domain])] }
                }
                { To
                    { ID [getRef([MPackage])] }
                }
            }
            Link [[LINK_ID]]
            {
                { FirstArc [[ARC_ID]] }
                { LastArc [[ARC_ID]] }
                { Object
                    { PDMType Link }
                    { MappingName ContainsMapping }
                    { ID 0 }
                }
            }
            >> out
        end loop

        [nClass] = add([nClass],1);
    end if
end proc

proc generateClassInfo(MClass)
    local ARC_ID;
    local LINK_ID;
    local classposX = mul(mod(sub([nClass],1),[nWidth]),[X_SPACING]);
    local classposY = mul(div(sub([nClass],1),[nWidth]),[Y_SPACING]);
    [CLASS_NODE_ID] = getRef([MClass]);
    [CLASS_X [MClass.id]] = [classposX];
    [CLASS_Y [MClass.id]] = [classposY];

    >>
    Node [CLASS_NODE_ID]
    {
        { Type [[MClass].getSymbolType()] }
        { Loc [classposX] [classposY] }
        { Scale [CLASS_WIDTH].00 [CLASS_HEIGHT].00 }
        { Label
            { Text "[[MClass].getName()]" }
        }
    >> out
    loop(MClass->MPackage)
        >>
            { IsIncluded True }
            { Parent [getRef([MPackage])] }
        >> out
    end loop
    >>
        { ViewPoint UmlAllGeneralization }
        { Object
            { PDMType Node }
            { MappingName [[MClass].getMappingName()] }
            { ID 0 }
            { GUID "[[MClass].getGuid()]" }
        }
    }
    >> out
    loop(MClass->MPackage)
        [ARC_ID] = getNextID();
        [LINK_ID] = getNextID();
        >>
        Arc [[ARC_ID]]
        {
            { Type Contains }
            { IsInclusion True }
            { From
                { ID [getRef([MPackage])] }
            }
            { To
                { ID [getRef([MClass])] }
            }
        }
        Link [[LINK_ID]]
        {
            { FirstArc [[ARC_ID]] }
            { LastArc [[ARC_ID]] }
            { Object
                { PDMType Link }
                { MappingName ContainsMapping }
                { ID 0 }
            }
        }
        >> out
    end loop
//  generateClassAttributesInfo([MClass]);
//  generateClassOperationsInfo([MClass]);
    [nClass] = add([nClass],1);
end proc

proc generateAssociationRelations()
    local nCurrentX;
    local nCurrentY;
    local nClassCount;
    local diagramName;

    loop(Instances->MClass As FromClass)
        [nClassCount] = loopCount(FromClass->Role->MAssociation Where !isNaryAssociation([MAssociation]));
        if ([nClassCount] >= 1)
            [diagramName] = [FromClass.name] "_REL_ASS";
            [diagramName] = replace([diagramName]," ","_");
            output([ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
            generateClassDiagramInfo([diagramName]);

            // dump normal (binary) associations
            [nClassCount] = loopCount(FromClass->Role->MAssociation Where isBinaryAssociation([MAssociation]));
            if (mod([nClassCount], 2) == 1)
                [nCurrentX] = 0;
            else
                [nCurrentX] = div([X_SPACING], 2);
            end if
            [nCurrentY] = sub(0, [Y_SPACING]);
            loop(FromClass->Role As FromRole->MAssociation Where isBinaryAssociation([MAssociation]))
                loop(MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id])
                    makeRef([FromClass]);
                    generateNode([FromClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);
                    [nCurrentY] = sub(0, [nCurrentY]);
                    makeRef([ToClass]);
                    generateNode([ToClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);
                    [nCurrentY] = sub(0, [nCurrentY]);
                    dumpBinaryClassAssociation([FromRole], [ToRole], [nCurrentX], [nCurrentY], [nCurrentX], sub(0, [nCurrentY]));
                    clearRef([FromClass]);
                    clearRef([ToClass]);

                    [nCurrentX] = sub(0, [nCurrentX]);
                    if ([nCurrentX] >= 0)
                        [nCurrentX] = add([nCurrentX], [X_SPACING]);
                    end if
                end loop
            end loop

            // dump reflexive associations
            [nClassCount] = loopCount(Instances->MAssociation Where
                                isReflexiveAssociation([MAssociation]) &&
                                hasLoop(MAssociation->MAssociationEnd->MClass Where [MClass.id] == [FromClass.id]));
            if (mod([nClassCount], 2) == 1)
                [nCurrentX] = 0;
            else
                [nCurrentX] = div([X_SPACING], 2);
            end if
            [nCurrentY] = mul(2, "-" [Y_SPACING]);
            loop(FromClass->Role->MAssociation Where isReflexiveAssociation([MAssociation]))
                // dump reflexive associations only once, but not for every role
                if (!["ASSOC_"[FromClass.id]"_"[MAssociation.id]])
                    ["ASSOC_"[FromClass.id]"_"[MAssociation.id]] = TRUE;
                    makeRef([FromClass]);
                    generateNode([FromClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);
                    dumpReflexiveClassAssociation([Role], [nCurrentX], [nCurrentY]);
                    clearRef([FromClass]);

                    [nCurrentX] = sub(0, [nCurrentX]);
                    if ([nCurrentX] >= 0)
                        [nCurrentX] = add([nCurrentX], [X_SPACING]);
                    end if
                end if
            end loop
        end if
    end loop

    // dump n-ary associations
    generateNaryAssociations();
end proc

proc generateNaryAssociations()
    local nCurrentX;
    local nCurrentY;
    local nClassCount;
    local nAssNodeID;
    local nVertexID;
    local nArc1ID;
    local nArc2ID;
    local diagramName;

    loop(Instances->MAssociation Where isNaryAssociation([MAssociation]))
        [diagramName] = [MAssociation.name] "_REL_N_ASS";
        [diagramName] = replace([diagramName]," ","_");
        output([ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
        generateClassDiagramInfo([diagramName]);

        [nCurrentX]  = 0;
        [nCurrentY]  = sub(0, [Y_SPACING]);
        [nAssNodeID] = getNextID();
        >>
        Node [nAssNodeID]
        {
            { Type NaryAssociationHub }
            { Loc [nCurrentX] [nCurrentY] }
            { Scale 128.00 128.00 }
            { Label
                { Text "[[MAssociation].getName()]" }
            }
            { Object
                { PDMType Node }
                { MappingName AssociationNodeMapping }
                { ID 0 }
                { GUID "[[MAssociation].getGuid()]" }
            }
        }
        >> out

        [nClassCount] = loopCount(MAssociation->MAssociationEnd);
        if (mod([nClassCount], 2) == 1)
            [nCurrentX] = 0;
        else
            [nCurrentX] = div([X_SPACING], 2);
        end if
        [nCurrentY] = sub(0, [nCurrentY]);
        loop(MAssociation->MAssociationEnd->MClass)
            makeRef([MClass]);
            generateNode([MClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);

            [nVertexID] = getNextID();
            [nArc1ID]   = getNextID();
            [nArc2ID]   = getNextID();
            >>
            Node [nVertexID]
            {
                { Type Vertex }
                { Loc [nCurrentX] 0 }
                { Scale 128.00 128.00 }
            }
            Arc [nArc1ID]
            {
                { Type NaryAssociationRole }
                { From
                    { ID [nAssNodeID] }
                }
                { To
                    { ID [nVertexID] }
                }
            }
            Arc [nArc2ID]
            {
                { Type NaryAssociationRole }
                { From
                    { ID [nVertexID] }
                }
                { To
                    { ID [getRef([MClass])] }
                }
            }
            Link [getNextID()]
            {
                { FirstArc [nArc1ID] }
                { LastArc [nArc2ID] }
                { Object
                    { PDMType Link }
                    { MappingName ToMapping }
                    { ID 0 }
                    { GUID "[[MAssociationEnd].getGuid()]" }
                }
            }
            >> out

            // create association roles
            if ([MAssociationEnd].getName() != "")
                >>
                Cntx [getNextID()]
                {
                    { Type RelLabelFrom }
                    { Loc [add([nCurrentX], 50)] [sub([nCurrentY], 30)] }
                    { Label
                        { Text "[[MAssociationEnd].getName()]" }
                    }
                    { Parent [nArc2ID] }
                }
                >> out
            end if

            clearRef([MClass]);
            [nCurrentX] = sub(0, [nCurrentX]);
            if ([nCurrentX] >= 0)
                [nCurrentX] = add([nCurrentX], [X_SPACING]);
            end if
        end loop

        // association class
        loop (MAssociation->AssociationClass)
            local XA = 0;
            local YA = mul(2, "-" [Y_SPACING]);
            local nLinkClassStpID = makeRef([AssociationClass]);
            local nClassLinkArcStpID = getNextID();
            local nClassLinkLinkStpID = getNextID();

            generateNode([AssociationClass], [XA], [YA], [CLASS_WIDTH], [CLASS_HEIGHT]);
            clearRef([AssociationClass]);
            >>
            Arc [nClassLinkArcStpID]
            {
                { Type AssociationClassLink }
                { From
                    { ID [nAssNodeID] }
                }
                { To
                    { ID [nLinkClassStpID] }
                }
            }
            Link [nClassLinkLinkStpID]
            {
                { FirstArc [nClassLinkArcStpID] }
                { LastArc [nClassLinkArcStpID] }
                { Object
                    { PDMType Link }
                    { MappingName AttributedAssociationMapping }
                    { ID 0 }
                }
            }
            >> out
        end loop
    end loop
end proc

proc generateGeneralizationRelations()
    local nCurrentX;
    local nCurrentY;
    local nClassCount;
    local nVertexID;
    local nVertexID1;
    local nArcID;
    local n1;
    local n2;
    local diagramName;

    loop(Instances->MClass)
        if (hasLoop(MClass->SubClass))
            [diagramName] = [MClass.name] "_REL_GEN" ;
            [diagramName] = replace([diagramName]," ","_");
            output([ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
            generateClassDiagramInfo([diagramName]);

            [nCurrentX] = 0;
            [nCurrentY] = sub(0, [Y_SPACING]);
            [nVertexID] = getNextID();
            [nArcID]    = getNextID();

            generateNode([MClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);
            >>
            Node [nVertexID]
            {
                { Type Vertex }
                { Loc [nCurrentX] 0 }
                { Scale 128.00 128.00 }
            }
            Arc [nArcID]
            {
                { Type Generalization }
                { From
                    { ID [nVertexID] }
                }
                { To
                    { ID [getRef([MClass])] }
                }
            }
            >> out

            [nVertexID1] = [nVertexID];
            [nCurrentY] = sub(0, [nCurrentY]);
            [nClassCount] = loopCount(MClass->SubClass);
            if (mod([nClassCount], 2) == 1)
                [nCurrentX] = 0;
            else
                [nCurrentX] = div([X_SPACING], 2);
            end if
            loop(MClass->SubClass->MInheritance)
                generateNode([SubClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);

                if ([nCurrentX] != 0)
                    [n1] = getNextID();
                    >>
                    Node [n1]
                    {
                        { Type Vertex }
                        { Loc [nCurrentX] 0 }
                        { Scale 128.00 128.00 }
                    }
                    Arc [getNextID()]
                    {
                        { Type Generalization }
                        { From
                            { ID [n1] }
                        }
                        { To
                            { ID [nVertexID1] }
                        }
                    }
                    >> out
                else
                    [n1] = [nVertexID];
                end if
                [nVertexID1] = [nVertexID];
                [nVertexID]  = [n1];

                [n2] = getNextID();
                >>
                Arc [n2]
                {
                    { Type Generalization }
                    { From
                        { ID [getRef([SubClass])] }
                    }
                    { To
                        { ID [n1] }
                    }
                    { Label
                        { Text "[[MInheritance].getName()]" }
                    }
                }
                Link [getNextID()]
                {
                    { FirstArc [n2] }
                    { LastArc [nArcID] }
                    { Object
                        { PDMType Link }
                        { MappingName GeneralizationMapping }
                        { ID 0 }
                        { GUID "[[MInheritance].getGuid()]" }
                    }
                }
                >> out

                [nCurrentX] = sub(0, [nCurrentX]);
                if ([nCurrentX] >= 0)
                    [nCurrentX] = add([nCurrentX], [X_SPACING]);
                end if
            end loop
        end if
    end loop

    // ECR 6927 begin
    loop(Instances->MPackage)
        if (hasLoop(MPackage->ChildPackage))
            [diagramName] = [MPackage.name] "_REL_GEN" ;
            [diagramName] = replace([diagramName]," ","_");
            output([ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
            generateClassDiagramInfo([diagramName]);

            [nCurrentX] = 0;
            [nCurrentY] = sub(0, [Y_SPACING]);
            [nVertexID] = getNextID();
            [nArcID]    = getNextID();

            generateNode([MPackage], [nCurrentX], [nCurrentY], [PACKAGE_WIDTH], [PACKAGE_HEIGHT]);
            >>
            Node [nVertexID]
            {
                { Type Vertex }
                { Loc [nCurrentX] 0 }
                { Scale 128.00 128.00 }
            }
            Arc [nArcID]
            {
                { Type Generalization }
                { From
                    { ID [nVertexID] }
                }
                { To
                    { ID [getRef([MPackage])] }
                }
            }
            >> out

            [nVertexID1] = [nVertexID];
            [nCurrentY] = sub(0, [nCurrentY]);
            [nClassCount] = loopCount(MPackage->ChildPackage);
            if (mod([nClassCount], 2) == 1)
                [nCurrentX] = 0;
            else
                [nCurrentX] = div([X_SPACING], 2);
            end if
            loop(MPackage->ChildPackage->MPackageInheritance)
                generateNode([ChildPackage], [nCurrentX], [nCurrentY], [PACKAGE_WIDTH], [PACKAGE_HEIGHT]);

                if ([nCurrentX] != 0)
                    [n1] = getNextID();
                    >>
                    Node [n1]
                    {
                        { Type Vertex }
                        { Loc [nCurrentX] 0 }
                        { Scale 128.00 128.00 }
                    }
                    Arc [getNextID()]
                    {
                        { Type Generalization }
                        { From
                            { ID [n1] }
                        }
                        { To
                            { ID [nVertexID1] }
                        }
                    }
                    >> out
                else
                    [n1] = [nVertexID];
                end if
                [nVertexID1] = [nVertexID];
                [nVertexID]  = [n1];

                [n2] = getNextID();
                >>
                Arc [n2]
                {
                    { Type Generalization }
                    { From
                        { ID [getRef([ChildPackage])] }
                    }
                    { To
                        { ID [n1] }
                    }
                    { Label
                        { Text "[[MPackageInheritance].getName()]" }
                    }
                }
                Link [getNextID()]
                {
                    { FirstArc [n2] }
                    { LastArc [nArcID] }
                    { Object
                        { PDMType Link }
                        { MappingName GeneralizationMapping }
                        { ID 0 }
                        { GUID "[[MPackageInheritance].getGuid()]" }
                    }
                }
                >> out

                [nCurrentX] = sub(0, [nCurrentX]);
                if ([nCurrentX] >= 0)
                    [nCurrentX] = add([nCurrentX], [X_SPACING]);
                end if
            end loop
        end if
    end loop
    // ECR 6927 end

end proc

proc generateDependencyRelations()
    local nCurrentX;
    local nCurrentY;
    local nClassCount;
    local nVertexID;
    local nVertexID1;
    local nArcID;
    local n1;
    local n2;
    local diagramName;

    loop(Instances->MDependentElement)
        if (hasLoop(MDependentElement->Client))
            [diagramName] = [MDependentElement.name] "_REL_DEP" ;
            [diagramName] = replace([diagramName]," ","_");
            output([ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
            generateClassDiagramInfo([diagramName]);

            [nCurrentX] = 0;
            [nCurrentY] = sub(0, [Y_SPACING]);
            [nVertexID] = getNextID();
            [nArcID]    = getNextID();

            generateNode([MDependentElement], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);
            >>
            Node [nVertexID]
            {
                { Type Vertex }
                { Loc [nCurrentX] 0 }
                { Scale 128.00 128.00 }
            }
            Arc [nArcID]
            {
                { Type Dependency }
                { From
                    { ID [nVertexID] }
                }
                { To
                    { ID [getRef([MDependentElement])] }
                }
            }
            >> out

            [nVertexID1] = [nVertexID];
            [nCurrentY] = sub(0, [nCurrentY]);
            [nClassCount] = loopCount(MDependentElement->Client);
            if (mod([nClassCount], 2) == 1)
                [nCurrentX] = 0;
            else
                [nCurrentX] = div([X_SPACING], 2);
            end if
            loop(MDependentElement->Client->MDependency)
                generateNode([Client], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);

                if ([nCurrentX] != 0)
                    [n1] = getNextID();
                    >>
                    Node [n1]
                    {
                        { Type Vertex }
                        { Loc [nCurrentX] 0 }
                        { Scale 128.00 128.00 }
                    }
                    Arc [getNextID()]
                    {
                        { Type Dependency }
                        { From
                            { ID [n1] }
                        }
                        { To
                            { ID [nVertexID1] }
                        }
                    }
                    >> out
                else
                    [n1] = [nVertexID];
                end if
                [nVertexID1] = [nVertexID];
                [nVertexID]  = [n1];

                [n2] = getNextID();
                >>
                Arc [n2]
                {
                    { Type Dependency }
                    { From
                        { ID [getRef([Client])] }
                    }
                    { To
                        { ID [n1] }
                    }
                    { Label
                        { Text "[[MDependency].getName()]" }
                    }
                }
                Link [getNextID()]
                {
                    { FirstArc [n2] }
                    { LastArc [nArcID] }
                    { Object
                        { PDMType Link }
                        { MappingName DependencyMapping }
                        { ID 0 }
                        { GUID "[[MDependency].getGuid()]" }
                    }
                }
                >> out

                [nCurrentX] = sub(0, [nCurrentX]);
                if ([nCurrentX] >= 0)
                    [nCurrentX] = add([nCurrentX], [X_SPACING]);
                end if
            end loop
        end if
    end loop
end proc

proc generateBindingRelations()
    local nCurrentX;
    local nCurrentY;
    local nClassCount;
    local nVertexID;
    local nVertexID1;
    local nArcID;
    local n1;
    local n2;
    local diagramName;

    loop(Instances->MTemplateClass)
        if (hasLoop(MTemplateClass->MInstantiatedClass))
            [diagramName] = [MTemplateClass.name] "_REL_BIND" ;
            [diagramName] = replace([diagramName]," ","_");
            output([ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
            generateClassDiagramInfo([diagramName]);

            [nCurrentX] = 0;
            [nCurrentY] = sub(0, [Y_SPACING]);
            [nVertexID] = getNextID();
            [nArcID]    = getNextID();

            generateNode([MTemplateClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);
            >>
            Node [nVertexID]
            {
                { Type Vertex }
                { Loc [nCurrentX] 0 }
                { Scale 128.00 128.00 }
            }
            Arc [nArcID]
            {
                { Type Refines }
                { From
                    { ID [nVertexID] }
                }
                { To
                    { ID [getRef([MTemplateClass])] }
                }
            }
            >> out

            [nVertexID1] = [nVertexID];
            [nCurrentY] = sub(0, [nCurrentY]);
            [nClassCount] = loopCount(MTemplateClass->MInstantiatedClass);
            if (mod([nClassCount], 2) == 1)
                [nCurrentX] = 0;
            else
                [nCurrentX] = div([X_SPACING], 2);
            end if
            loop(MTemplateClass->MInstantiatedClass->MTemplateBinding)
                generateNode([MInstantiatedClass], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);

                if ([nCurrentX] != 0)
                    [n1] = getNextID();
                    >>
                    Node [n1]
                    {
                        { Type Vertex }
                        { Loc [nCurrentX] 0 }
                        { Scale 128.00 128.00 }
                    }
                    Arc [getNextID()]
                    {
                        { Type Refines }
                        { From
                            { ID [n1] }
                        }
                        { To
                            { ID [nVertexID1] }
                        }
                    }
                    >> out
                else
                    [n1] = [nVertexID];
                end if
                [nVertexID1] = [nVertexID];
                [nVertexID]  = [n1];

                [n2] = getNextID();
                >>
                Arc [n2]
                {
                    { Type Refines }
                    { From
                        { ID [getRef([MInstantiatedClass])] }
                    }
                    { To
                        { ID [n1] }
                    }
                    { Label
                        { Text "[[MTemplateBinding].getName()]" }
                    }
                }
                Link [getNextID()]
                {
                    { FirstArc [n2] }
                    { LastArc [nArcID] }
                    { Object
                        { PDMType Link }
                        { MappingName RefinesMapping }
                        { ID 0 }
                        { GUID "[[MTemplateBinding].getGuid()]" }
                    }
                }
                >> out

                [nCurrentX] = sub(0, [nCurrentX]);
                if ([nCurrentX] >= 0)
                    [nCurrentX] = add([nCurrentX], [X_SPACING]);
                end if
            end loop
        end if
    end loop
end proc

proc generateImplementsRelations()
    local nCurrentX;
    local nCurrentY;
    local nClassCount;
    local nVertexID;
    local nVertexID1;
    local nArcID;
    local n1;
    local n2;
    local diagramName;

    loop(Instances->MInterface)
        if (hasLoop(MInterface->Implementation))
            [diagramName] = [MInterface.name] "_REL_IMPL" ;
            [diagramName] = replace([diagramName]," ","_");
            output([ProjectDir] "uclassd_files/" getFileName([diagramName],"") ".uclassd");
            generateClassDiagramInfo([diagramName]);

            [nCurrentX] = 0;
            [nCurrentY] = sub(0, [Y_SPACING]);
            [nVertexID] = getNextID();
            [nArcID]    = getNextID();

            >>
            Node [getRef([MInterface])]
            {
                { Type Interface }
                { Loc [nCurrentX] [nCurrentY] }
                { Scale 256.00 256.00 }
                { Label
                    { Text "[[MInterface].getName()]" }
                }
                { Object
                    { PDMType Node }
                    { MappingName [[MInterface].getMappingName()] }
                    { ID 0 }
                    { GUID "[[MInterface].getGuid()]" }
                }
            }
            Node [nVertexID]
            {
                { Type Vertex }
                { Loc [nCurrentX] 0 }
                { Scale 128.00 128.00 }
            }
            Arc [nArcID]
            {
                { Type Implements }
                { From
                    { ID [nVertexID] }
                }
                { To
                    { ID [getRef([MInterface])] }
                }
            }
            >> out

            [nVertexID1] = [nVertexID];
            [nCurrentY] = sub(0, [nCurrentY]);
            [nClassCount] = loopCount(MInterface->Implementation);
            if (mod([nClassCount], 2) == 1)
                [nCurrentX] = 0;
            else
                [nCurrentX] = div([X_SPACING], 2);
            end if
            loop(MInterface->Implementation)
                generateNode([Implementation], [nCurrentX], [nCurrentY], [CLASS_WIDTH], [CLASS_HEIGHT]);

                if ([nCurrentX] != 0)
                    [n1] = getNextID();
                    >>
                    Node [n1]
                    {
                        { Type Vertex }
                        { Loc [nCurrentX] 0 }
                        { Scale 128.00 128.00 }
                    }
                    Arc [getNextID()]
                    {
                        { Type Implements }
                        { From
                            { ID [n1] }
                        }
                        { To
                            { ID [nVertexID1] }
                        }
                    }
                    >> out
                else
                    [n1] = [nVertexID];
                end if
                [nVertexID1] = [nVertexID];
                [nVertexID]  = [n1];

                [n2] = getNextID();
                >>
                Arc [n2]
                {
                    { Type Implements }
                    { From
                        { ID [getRef([Implementation])] }
                    }
                    { To
                        { ID [n1] }
                    }
                }
                Link [getNextID()]
                {
                    { FirstArc [n2] }
                    { LastArc [nArcID] }
                }
                >> out

                [nCurrentX] = sub(0, [nCurrentX]);
                if ([nCurrentX] >= 0)
                    [nCurrentX] = add([nCurrentX], [X_SPACING]);
                end if
            end loop
        end if
    end loop
end proc

proc generateNode(MDependentElement, X, Y, W, H)
    local nParentId;
    local nArcId;

    [nParentId] = 0;
    loop (MDependentElement->MPara->MParaItem->MAttribute->MClass)
        [nParentId] = getRef([MClass]);
        out = generateNode([MClass], [X], [Y], [W], [H]) "\n";
    end loop
    loop (MDependentElement->MOperation->MClass)
        [nParentId] = getRef([MClass]);
        out = generateNode([MClass], [X], [Y], [W], [H]) "\n";
    end loop

    >>
    Node [getRef([MDependentElement])]
    {
        { Type [[MDependentElement].getSymbolType()] }
        { Loc [X] [Y] }
        { Scale [W].00 [H].00 }
        { Label
            { Text "[[MDependentElement].getName()]" }
        }
    >> out
    if ([nParentId] != 0)
    >>
        { IsIncluded True }
        { Parent [nParentId] }
        { ViewPoint UmlAllGeneralization }
    >> out
    end if
    >>
        { Object
            { PDMType Node }
            { MappingName [[MDependentElement].getMappingName()] }
            { ID 0 }
            { GUID "[[MDependentElement].getGuid()]" }
        }
    }
    >> out

    if ([nParentId] != 0)
        [nArcId] = getNextID();
        >>
        Arc [nArcId]
        {
            { Type Contains }
            { From
                { ID [nParentId] }
            }
            { To
                { ID [getRef([MDependentElement])] }
            }
            { IsInclusion True }
        }
        Link [getNextID()]
        {
            { FirstArc [nArcId] }
            { LastArc [nArcId] }
            { Object
                { PDMType Link }
                { MappingName ContainsMapping }
                { ID 0 }
            }
        }
        >> out
    end if
end proc

proc generateClassDiagramInfo(strDiagramName)
    >>
    Diagram UmlClassDiagram
    {
        { Name "[[strDiagramName]]" }
        { Format "1.6" }
        { Scale 0.00 }
        { PanX 0 }
        { PanY 0 }
        { Alignment 0 }
        { Summary
            { Nodes 0 }
            { Arcs 0 }
        }
    }
    >> out
end proc

proc generateClassOperationsInfo(MClass)
    loop(MClass->MOperation)
        [LINK_ID] = getNextID();
        [OP_NODE_ID] = getNextID();
        [ARC_NODE_ID] = getNextID();
        [LINK_NODE_ID] = getNextID();

        >>
        Node [OP_NODE_ID]
        {
            { Type Operation }
            { Label
                { Text "[[MOperation].getName()]" }
            }
            { Parent [getRef([MClass])] }
            { IsIncluded True }
            { Object
                { PDMType Node }
                { MappingName [[MOperation].getMappingName()] }
                { ID 0 }
                { GUID "[[MOperation].getGuid()]" }
            }
        }
        Arc [ARC_NODE_ID]
        {
            { Type Contains }
            { From
                { ID [getRef([MClass])] }
            }
            { To
                { ID [OP_NODE_ID] }
            }
            { IsInclusion True }
        }
        Link [LINK_NODE_ID]
        {
            { FirstArc [ARC_NODE_ID] }
            { LastArc [ARC_NODE_ID] }
            { Object
                { PDMType Link }
                { MappingName ContainsMapping }
                { ID 0 }
            }
        }
        >> out
    end loop
end proc

proc generateClassAttributesInfo(MClass)
    loop(MClass->MAttribute)
        [LINK_ID] = getNextID();
        [ATT_NODE_ID] = getNextID();
        [ARC_NODE_ID] = getNextID();
        [LINK_NODE_ID] = getNextID();
        >>
        Node [ATT_NODE_ID]
        {
            { Type Attribute }
            { Label
                { Text "[[MAttribute].getName()]" }
            }
            { IsIncluded True }
            { Parent [getRef([MClass])] }
            { Object
                { PDMType Node }
                { MappingName [[MAttribute].getMappingName()] }
                { ID 0 }
                { GUID "[[MAttribute].getGuid()]" }
            }
        }
        Arc [ARC_NODE_ID]
        {
            { Type Contains }
            { From
                { ID [ATT_NODE_ID] }
            }
            { To
                { ID [ATT_NODE_ID] }
            }
            { IsInclusion True }
        }
        Link [LINK_NODE_ID]
        {
            { FirstArc [ARC_NODE_ID] }
            { LastArc [ARC_NODE_ID] }
            { Object
                { PDMType Link }
                { MappingName ContainsMapping }
                { ID 0 }
            }
        }
        >> out
    end loop
end proc

proc dumpBinaryClassAssociation(MAssociationEnd As FromRole, MAssociationEnd As ToRole, X1, Y1, X2, Y2)
    local ARC_ID = getNextID();
    local FromClassID;
    local ToClassID;
    local dxs;
    local dys;
    local rx;
    local ry;
    local dx = sub([X2],[X1]);
    local dy = sub([Y2],[Y1]);
    local d = dist([dx], [dy]);

    if ([dx] == 0)
        [dxs] = 0;
    else
        [dxs] = div([dx], abs([dx]));
    end if

    if ([dy] == 0)
        [dys] = 0;
    else
        [dys] = div([dy], abs([dy]));
    end if

    loop(FromRole->MClass As FromClass)
        [FromClassID] = getRef([FromClass]);
    end loop
    loop(ToRole->MClass As ToClass)
        [ToClassID] = getRef([ToClass]);
    end loop

    loop(FromRole->MAssociation)
        >>
        Arc [ARC_ID]
        {
            { Type Association }
            { From
                { ID [FromClassID] }
            }
            { To
                { ID [ToClassID] }
            }
            { Label
                { Text "[[MAssociation].getName()]" }
            }
        }
        Link [getNextID()]
        {
            { FirstArc [ARC_ID] }
            { LastArc [ARC_ID] }
            { Object
                { PDMType Node }
                { MappingName AssociationNodeMapping }
                { ID 0 }
                { GUID "[[MAssociation].getGuid()]" }
            }
            { Object
                { PDMType Link }
                { MappingName FromMapping }
                { ID 0 }
                { GUID "[[FromRole].getGuid()]" }
            }
            { Object
                { PDMType Link }
                { MappingName ToMapping }
                { ID 0 }
                { GUID "[[ToRole].getGuid()]" }
            }
        }
        >> out

        [rx] = sub([X1], mul([dxs], [X_ROLE_OFFSET]));
        [rx] = add([rx], div(mul([dy], [X_ROLE_OFFSET]), [d]));
        [ry] = add([Y1], mul([dys], [Y_ROLE_OFFSET]));
        [ry] = add([ry], div(mul([dx], [Y_ROLE_OFFSET]), [d]));

        if ([FromRole].getName() != "")
        >>
        Cntx [getNextID()]
        {
            { Type RelLabelFrom }
            { Loc [rx] [ry] }
            { Label
                { Text "[[FromRole].getName()]" }
            }
            { Parent [ARC_ID] }
        }
        >> out
        end if

        [rx] = add([X2], mul([dxs], [X_ROLE_OFFSET]));
        [rx] = sub([rx], div(mul([dy], [X_ROLE_OFFSET]), [d]));
        [ry] = sub([Y2], mul([dys], [Y_ROLE_OFFSET]));
        [ry] = sub([ry], div(mul([dx], [Y_ROLE_OFFSET]), [d]));

        if ([ToRole].getName() != "")
        >>
        Cntx [getNextID()]
        {
            { Type RelLabelTo }
            { Loc [rx] [ry] }
            { Label
                { Text "[[ToRole].getName()]" }
            }
            { Parent [ARC_ID] }
        }
        >> out
        end if

        // association class
        loop (MAssociation->AssociationClass)
            local XC = add([X1],div([dx],2));
            local YC = add([Y1],div([dy],2));
            local XA = add([XC],div([X_SPACING],2));
            local YA = add([YC],mul([Y_SPACING],2));
            local nLinkClassStpID = makeRef([AssociationClass]);
            local nClassLinkArc1StpID = getNextID();
            local nClassLinkArc2StpID = getNextID();
            local nClassLinkLinkStpID = getNextID();
            local nClassLinkCntxStpID = getNextID();
            local nVertexStpID = getNextID();

            generateNode([AssociationClass], [XA], [YA], [CLASS_WIDTH], [CLASS_HEIGHT]);
            clearRef([AssociationClass]);
            >>
            Cntx [nClassLinkCntxStpID]
            {
                { Type AssociationAnchor }
                { Loc [XC] [YC] }
                { Scale 12.00 12.00 }
                { Parent [ARC_ID] }
            }
            Node [nVertexStpID]
            {
                { Type Vertex }
                { Loc [XA] [YC] }
                { Scale 128.0 128.0}
            }
            Arc [nClassLinkArc1StpID]
            {
                { Type AssociationClassLink }
                { From
                    { ID [nClassLinkCntxStpID] }
                }
                { To
                    { ID [nVertexStpID] }
                }
            }
            Arc [nClassLinkArc2StpID]
            {
                { Type AssociationClassLink }
                { From
                    { ID [nVertexStpID] }
                }
                { To
                    { ID [nLinkClassStpID] }
                }
            }
            Link [nClassLinkLinkStpID]
            {
                { FirstArc [nClassLinkArc1StpID] }
                { LastArc [nClassLinkArc2StpID] }
                { Object
                    { PDMType Link }
                    { MappingName AttributedAssociationMapping }
                    { ID 0 }
                }
            }
            >> out
        end loop
    end loop
end proc

proc dumpReflexiveClassAssociation(MAssociationEnd As FromRole, X, Y)
    local Vertex1ID = getNextID();
    local Vertex2ID = getNextID();
    local nArc1ID = getNextID();
    local nArc2ID = getNextID();
    local nArc3ID = getNextID();
    local ClassID;

    loop (FromRole->MClass)
        [ClassID] = getRef([MClass]);
    end loop

    loop(FromRole->MAssociation->MAssociationEnd As ToRole Where [FromRole.id] != [ToRole.id])
        >>
        Node [Vertex1ID]
        {
            { Type Vertex }
            { Loc [sub([X],60)] [sub([Y],60)] }
            { Scale 128.0 128.0}
        }
        Node [Vertex2ID]
        {
            { Type Vertex }
            { Loc [add([X],60)] [sub([Y],60)] }
            { Scale 128.0 128.0}
        }
        Arc [nArc1ID]
        {
            { Type Association }
            { From
                { ID [ClassID] }
            }
            { To
                { ID [Vertex1ID] }
            }
        }
        Arc [nArc2ID]
        {
            { Type Association }
            { From
                { ID [Vertex1ID]}
            }
            { To
                { ID [Vertex2ID] }
            }
            { Label
                { Text "[[MAssociation].getName()]" }
            }
        }
        Arc [nArc3ID]
        {
            { Type Association }
            { From
                { ID [Vertex2ID] }
            }
            { To
                { ID [ClassID] }
            }
        }
        Link [getNextID()]
        {
            { FirstArc [nArc1ID] }
            { LastArc [nArc3ID] }
            { Object
                { PDMType Node }
                { MappingName AssociationNodeMapping }
                { ID 0 }
                { GUID "[[MAssociation].getGuid()]" }
            }
            { Object
                { PDMType Link }
                { MappingName FromMapping }
                { ID 0 }
                { GUID "[[FromRole].getGuid()]" }
            }
            { Object
                { PDMType Link }
                { MappingName ToMapping }
                { ID 0 }
                { GUID "[[ToRole].getGuid()]" }
            }
        }
        >> out

        // Association Role Labels
        if ([FromRole].getName() != "")
            >>
            Cntx [getNextID()]
            {
                { Type RelLabelFrom }
                { Loc [sub([X], 50)] [sub([Y], 30)] }
                { Label
                    { Text "[[FromRole].getName()]" }
                }
                { Parent [nArc1ID] }
            }
            >> out
        end if
        if ([ToRole].getName() != "")
            >>
            Cntx [getNextID()]
            {
                { Type RelLabelTo }
                { Loc [add([X], 10)] [sub([Y], 30)] }
                { Label
                    { Text "[[ToRole].getName()]" }
                }
                { Parent [nArc3ID] }
            }
            >> out
        end if

        // association class
        loop (MAssociation->AssociationClass)
            local nLinkClassStpID = makeRef([AssociationClass]);
            local nClassLinkCntxStpID = getNextID();
            local nClassLinkLinkStpID = getNextID();
            local nClassLinkArcStpID = getNextID();
            local Y1 = sub([Y], 60);

            generateNode([AssociationClass], [X], sub([Y1], [Y_SPACING]), [CLASS_WIDTH], [CLASS_HEIGHT]);
            clearRef([AssociationClass]);
            >>
            Cntx [nClassLinkCntxStpID]
            {
                { Type AssociationAnchor }
                { Loc [X] [Y1] }
                { Scale 12.00 12.00 }
                { Parent [nArc2ID] }
            }
            Arc [nClassLinkArcStpID]
            {
                { Type AssociationClassLink }
                { From
                    { ID [nClassLinkCntxStpID] }
                }
                { To
                    { ID [nLinkClassStpID] }
                }
            }
            Link [nClassLinkLinkStpID]
            {
                { FirstArc [nClassLinkArcStpID] }
                { LastArc [nClassLinkArcStpID] }
                { Object
                    { PDMType Link }
                    { MappingName AttributedAssociationMapping }
                    { ID 0 }
                }
            }
            >> out
        end loop
    end loop
end proc

