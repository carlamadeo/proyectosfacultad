//*****************************************************************************
// $RCSfile: ada_genrel.tdl,v $
// $Revision: 1.3 $
// $Date: 2002/03/08 16:03:54 $
// Author: Peter Kleiner
//*****************************************************************************

//wdh: insert 'aliased' for array elements
/*
Support templates and procedures dealing with relations.
called by genSpec (defined in ada_genspec.tdl) and genBody (defined in ada_genbody.tdl).

templates/procs called in genSpec. The order follows the occurence in genSpec

9.3.4.2. genRelationshipComponents
	Generate a single component for a navigable relation to another class
9.3.4.2.1. genRelationPointerDeclaration
	Generate relation based on pointer
9.3.4.2.2. genRelationObjectDeclaration
	Generate relation based on object
15a. genRelationOperationSpecs
	generate a get/set method for each relation depending on relation visibility
	specified in the model and the place of generation indicated by the second
	parameter:
	public:
		generate get for relation vis. public, public-read-only, public-operation
		generate set for relation vis. public,  public-operation
	public-child
		generate get for relation vis. public-child, public-child-read-only, public-child-operation
		generate set for relation vis. public-child,  public-child-operation
	private
		generate get for relation vis. private, private-read-only,
			private-operation
		generate set for relation vis. private, private-operation
	private-child
		generate get for relation vis. private-child, private-child-read-only,
			private-child-operation
		generate set for relation vis. private-child, private-child-operation
	implementation:
		generate get for relation vis. implementation
		generate set for relation vis. implementation
15b. genRelationOperationSpecsPT
		generate get function for relation vis. != implementation
		generate set procedure for relation vis. != implementation
15c: genRelationOperationSpecsTask
		generate get entry for relation vis. != implementation
		generate set entry for relation vis. != implementation
15.1. genAssocIndex

templates/procs called in genBody. The order follows the occurence in genBody

22a. genRelationOperationBodies
	generate a get/set method body for each relation depending on relation visibility
	specified in the model and the place of generation indicated by the second
	parameter:
	implementation:
		generate get/set for relation vis. other than *-child*
	public-child
		generate get/set for relation vis. public-child, public-child-read-only, public-child-operation
	private-child
		generate get/set for relation vis. private-child, private-child-read-only, private-child-operation
22b. genRelationOperationBodiesPT
22c. genRelationOperationBodiesTask
22.1. genAssocIndex

*/

/* 9.3.4.2. generate a component for each navigable relation.
   Each relation (MAssociation) has two end points (MAssociationEnd).
   We look for pairs of end points where one end point is attached to
   the source class and the other end point is attached to the
   destination class. We use the alias name 'FromRole' for the end point
   of the source class, 'ToRole' for the end point of the destination
   class, and 'Partner' for the destination class itself. The condition
   'Where [FromRole.id] != [ToRole.id]' assures that both end points are
   different. */
template genRelationshipComponents(MClass)
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="";setText(genSectionComment("Relations")))]
[getText()]
[   if([ToRole:isPointer])]
[genRelationPointerDeclaration([MClass],[ToClass],[ToRole])]
[   else]
[genRelationObjectDeclaration([MClass],[ToClass],[ToRole])]
[   end if]
[end loop]
end template


template genContextType(MClass,place)
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [ToRole:isPointer] == TRUE && [ToRole:mechanism] == "AddStartMoreNext")]
[   switch([ToRole].visibility())]
[   case "public" :]
[      if([place] == "public")]
type [ToRole:ctxTypeName] is
	record
		Offset : Integer := 0;
	end record;		
[      end if]
[      return]
[   default :]
[      if([place] == "public")]
type [ToRole:ctxTypeName] is private;
[      else if([place] == "private")]
type [ToRole:ctxTypeName] is
	record
		Offset : Integer := 0;
	end record;		
[      end if end if]
[   end switch]
[end loop]
end template

/* 9.3.4.2.1 generate relation based on pointer. Maps the multiplicity of the end point
   MAssociationEnd. We distinguish the following cases:
   "One"  : a single pointer
   "Many" : a pointer to an unconstrained array of pointers
   "n"    : an array of n pointers
   Procedure getMultiplicity (defined in std.tdl) provides the multiplicity of
   the end point. Type declarations required for the realization of the relation are
   output at the insertion point marked "passoctypes_"[MClass.name], which has to be
   outside the class record type. getClassTypeForAssociation determines the subtype indication
   to use in order to refer to the partner class. (defined in ada_std.tdl) */
proc genRelationPointerDeclaration(MClass, MClass As Partner, MAssociationEnd)
	local multiplicity = getMultiplicity([MAssociationEnd.multiplicity]);

	switch([multiplicity])
	case "Many" :
		if([MAssociationEnd:typesDone] == "")
        		insert("passoctypes_"[MClass.name], genRelationManyPointerTypes([MClass],[Partner],[MAssociationEnd]));
			[MAssociationEnd:typesDone] = "*";
		end if
		return [MAssociationEnd:adaName] " : " [MAssociationEnd:ptrTypeName] ";";
	case "One"	:
		return  [MAssociationEnd:adaName] " : " getClassTypeForAssociation([Partner],[MClass.name]) ";";
	default 	:
		if([MAssociationEnd:typesDone] == "")
        		insert("passoctypes_"[MClass.name],genRelationNPointerTypes([MClass],[Partner],[MAssociationEnd],[multiplicity]));
			[MAssociationEnd:typesDone] = "*";
		end if
 		return [MAssociationEnd:adaName] " : " [MAssociationEnd:arrayTypeName] ";";
	end switch
end proc

template genRelationManyPointerTypes(MClass, MClass As Partner, MAssociationEnd)
type [MAssociationEnd:arrayTypeName] is array (integer range <>) of aliased [getClassTypeForAssociation([Partner],[MClass.name])];
type [MAssociationEnd:ptrTypeName] is access all [MAssociationEnd:arrayTypeName];
end template

template genRelationNPointerTypes(MClass, MClass As Partner, MAssociationEnd, N)
type [MAssociationEnd:arrayTypeName] is array (1 .. [N]) of aliased [getClassTypeForAssociation([Partner],[MClass.name])];
end template

/* 9.3.4.2.2 generate relation based on component declaration */
proc genRelationObjectDeclaration(MClass, MClass As Partner, MAssociationEnd)
	local multiplicity = getMultiplicity([MAssociationEnd.multiplicity]);
	
	switch([multiplicity])
	case "Many" :
		if([MAssociationEnd:typesDone] == "")
	        	insert("passoctypes_"[MClass.name],genRelationManyObjectTypes([MClass],[Partner],[MAssociationEnd]));
			[MAssociationEnd:typesDone] = "*";
		end if
		return [MAssociationEnd:adaName] " : aliased " [MAssociationEnd:ptrTypeName] ";";
	case "One"	:
		return  [MAssociationEnd:adaName] " : aliased " importClass([Partner]) ";" ;
	default 	:
		if([MAssociationEnd:typesDone] == "")
	        	insert("passoctypes_"[MClass.name],genRelationNObjectTypes([MClass],[Partner],[MAssociationEnd],[multiplicity]));
			[MAssociationEnd:typesDone] = "*";
		end if
		return [MAssociationEnd:adaName] " : aliased " [MAssociationEnd:arrayTypeName] ";";
	end switch
end proc

template genRelationManyObjectTypes(MClass, MClass As Partner, MAssociationEnd)
type [MAssociationEnd:arrayTypeName] is array (integer range <>) of aliased [importClass([Partner])];
type [MAssociationEnd:ptrTypeName] is access all [MAssociationEnd:arrayTypeName];
end template

template genRelationNObjectTypes(MClass, MClass As Partner, MAssociationEnd, N)
type [MAssociationEnd:arrayTypeName] is array (1 .. [N]) of aliased [importClass([Partner])];
end template

/* 15a. generate set/get operation for relations with [place] visibility 
   this is always called in the package specification or body, even for MClass being
   a task or protected type */
template genRelationOperationSpecs(MClass,place)
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [ToRole:isPointer] == TRUE && visibilityMatch([ToRole].visibility(), [place]);setText(""genSectionComment("Relation operations")))]
[getText()]
[   if([ToRole:mechanism] == "GetSet" || [ToRole:mechanism] == "GetSetWithAlloc")]
function get[ToRole:adaName](this : [getClassParamForRead([MClass])][setDelim("; ")][genAssocIndex([ToRole])]) return [getClassTypeForAssociation([Partner],[MClass.name])][genRename([MClass],"get"[ToRole:adaName])];
	[genInlinePragma("get"[ToRole:adaName])]
[      if(regexp([ToRole].visibility(),"read-only") == "")]
procedure set[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])][setDelim("; ")][genAssocIndex([ToRole])]; item : [getClassTypeForAssociation([Partner],[MClass.name])])[genRename([MClass],"set"[ToRole:adaName])];
	[genInlinePragma("set"[ToRole:adaName])]
[      end if]
[/* wdh extensions to manage 1:N Associations: */]
[genAssocManagementSpec([MClass],[ToRole],[Partner])]
[   else]
procedure startRead[ToRole:adaName](this : [getClassParamForRead([MClass])]; Ctx : in out [ToRole:ctxTypeName])[genRename([MClass],"startRead"[ToRole:adaName])];
	[genInlinePragma("startRead"[ToRole:adaName])]
function more[ToRole:adaName](this : [getClassParamForRead([MClass])]; Ctx : [ToRole:ctxTypeName]) return Boolean[genRename([MClass],"more"[ToRole:adaName])];
	[genInlinePragma("more"[ToRole:adaName])]
function next[ToRole:adaName](this : [getClassParamForRead([MClass])]; Ctx : access [ToRole:ctxTypeName]) return [getClassTypeForAssociation([Partner],[MClass.name])][genRename([MClass],"next"[ToRole:adaName])];
	[genInlinePragma("next"[ToRole:adaName])]
[      if(regexp([ToRole].visibility(),"read-only") == "")]
procedure add[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])]; item : [getClassTypeForAssociation([Partner],[MClass.name])])[genRename([MClass],"add"[ToRole:adaName])];
	[genInlinePragma("add"[ToRole:adaName])]
[      end if]
[   end if]
[end loop]

end template

/* 15b. generate set/get operations for relations in the protected type declaration.*/
template genRelationOperationSpecsPT(MClass)
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [ToRole:isPointer] == TRUE && visibilityMatchBody([ToRole].visibility(), "implementation");setText(""genSectionComment("Relation operations")))]
[// above, use visibilityMatchBody(,"implementation") because we want the definition if we generate the calling subprogramms]
[getText()]
[   if([ToRole:mechanism] == "GetSet" || [ToRole:mechanism] == "GetSetWithAlloc")]
function get[ToRole:adaName][openList()][genAssocIndex([ToRole])][closeList()] return [getClassTypeForAssociation([Partner],[MClass.name])];
[      if(regexp([ToRole].visibility(),"read-only") == "")]
procedure set[ToRole:adaName][openList()][genAssocIndex([ToRole])][delim()]item : [getClassTypeForAssociation([Partner],[MClass.name])]);
[      end if]
[/* wdh extensions to manage 1:N Associations: */]
[genAssocManagementSpecPT([MClass],[ToRole],[Partner])]
[   else]
[setDelim("; ")]
[getText()]
function more[ToRole:adaName] (Ctx : [ToRole:ctxTypeName]) return Boolean;
function next[ToRole:adaName] (Ctx : access [ToRole:ctxTypeName]) return [getClassTypeForAssociation([Partner],[MClass.name])];
[      if(regexp([ToRole].visibility(),"read-only") == "")]
[setDelim("; ")]
procedure add[ToRole:adaName](item : [getClassTypeForAssociation([Partner],[MClass.name])]);
[      end if]
[   end if]
[end loop]
end template

/* 15c. generate set/get operations for relations in the protected type declaration.*/
template genRelationOperationSpecsTask(MClass)
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && visibilityMatchBody([ToRole].visibility(),"implementation");setText(""genSectionComment("Relation operations")))]
[// above, use visibilityMatchBody(,"implementation") because we want the definition if we generate the calling subprogramms]
[   if([ToRole:mechanism] == "GetSet" || [ToRole:mechanism] == "GetSetWithAlloc")]
[setDelim("; ")]
[getText()]
entry get[ToRole:adaName](item : out [getClassTypeForAssociation([Partner],[MClass.name])][genAssocIndex([ToRole])]);
[      if(regexp([ToRole].visibility(),"read-only") == "")]
[openList()]
entry set[ToRole:adaName][genAssocIndex([ToRole])][delim()]item : [getClassTypeForAssociation([Partner],[MClass.name])]);
[      end if]
[/* wdh extensions to manage 1:N Associations: */]
[genAssocManagementSpecTask([MClass],[ToRole],[Partner])]
[   else]
entry more[ToRole:adaName](haveMore : out Boolean; Ctx : [ToRole:ctxTypeName]);
entry next[ToRole:adaName](item : out [getClassTypeForAssociation([Partner],[MClass.name])]; Ctx : in out [ToRole:ctxTypeName]);
[      if(regexp([ToRole].visibility(),"read-only") == "")]
entry add[ToRole:adaName](item : [getClassTypeForAssociation([Partner],[MClass.name])]);
[      end if]
[   end if]
[end loop]
end template

/* 15.1. add an index for the association */
proc genAssocIndex(MAssociationEnd)

	local multiplicity = getMultiplicity([MAssociationEnd.multiplicity]);
	local result;

	if([multiplicity]=="One")
		return "";
	else
 		[result] = delim() "I : Integer";
 		setDelim("; ");
 		return [result];
	end if

end proc

/* 22a. generate body for the set/get operation generated for the relations of MClass
        this is called in the package body, even for a task or PT */
template genRelationOperationBodies(MClass,place)
[/* relation accessor and set operation body. useAssocIndex (22.1)
    appends the index parameter to the class record component, if any */]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [ToRole:isPointer] == TRUE && visibilityMatchBody([ToRole].visibility(), [place]);setText(""genSectionComment("Relation operations")))]
[getText()]
[   if([ToRole:mechanism] == "GetSet" || [ToRole:mechanism] == "GetSetWithAlloc")]
function get[ToRole:adaName](this : [getClassParamForRead([MClass])][setDelim("; ")][genAssocIndex([ToRole])]) return [getClassTypeForAssociation([Partner],[MClass.name])] is
[      if(isTask([MClass])  && !isTagged([MClass]))]
	Result : [getClassTypeForAssociation([Partner],[MClass.name])];
begin
	[thisToTaskPt([MClass])]get[ToRole:adaName](Result[setDelim(", ")][useAssocIndex([ToRole])][closeList()];
	return Result;
[      else if(isPT([MClass]))]
begin
	return [thisToTaskPt([MClass])]get[ToRole:adaName][openList()][useAssocIndex([ToRole])][closeList()][ToRole:makePointer];
[      else]
begin
	return this.[ToRole:adaName][openList()][useAssocIndex([ToRole])][closeList()][ToRole:makePointer];
[      end if end if]
end get[ToRole:adaName];
\
[      if(regexp([ToRole].visibility(),"read-only") == "")]

procedure set[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])][setDelim("; ")][genAssocIndex([ToRole])]; item : [getClassTypeForAssociation([Partner],[MClass.name])]) is
[         if((isTask([MClass]) == TRUE && isTagged([MClass]) == FALSE) || isPT([MClass]) == TRUE)]
begin
	[accThisToTaskPt([MClass])]set[ToRole:adaName][openList()][useAssocIndex([ToRole])][delim()] Item);
[         else if([ToRole:mechanism] == "GetSetWithAlloc")]
[genSetWithAlloc([ToRole:ptrTypeName],[ToRole:arrayTypeName],"acc_this."[ToRole:adaName])]
[         else]
begin
	acc_this.[ToRole:adaName][openList()][useAssocIndex([ToRole])][closeList()] := Item;
[         end if end if]
end set[ToRole:adaName];
\
[      end if]
[/* wdh extensions to manage 1:N Associations: */]
[genAssocManagementBodies([MClass],[ToRole],[Partner])]
[   else]
procedure startRead[ToRole:adaName](this : [getClassParamForRead([MClass])]; Ctx : in out [ToRole:ctxTypeName]) is
begin
   Ctx.Offset := 0;
end startRead[ToRole:adaName];

function more[ToRole:adaName](this : [getClassParamForRead([MClass])]; Ctx : [ToRole:ctxTypeName]) return Boolean is
[      if(isTask([MClass])  && !isTagged([MClass]))]
	Result : Boolean;
begin
	[thisToTaskPt([MClass])]more[ToRole:adaName](Result, Ctx);
	return Result;
[      else if(isPT([MClass]))]
begin
	return [thisToTaskPt([MClass])]more[ToRole:adaName] (Ctx);
[      else]
begin
	if this.[ToRole:adaName] = NULL then
		return False;
	elsif Ctx.Offset > this.[ToRole:adaName]'length then
		return False;
	else
		return True;
	end if;
[      end if end if]
end more[ToRole:adaName];

function next[ToRole:adaName](this : [getClassParamForRead([MClass])]; Ctx : access [ToRole:ctxTypeName]) return [getClassTypeForAssociation([Partner],[MClass.name])] is
[      if(isTask([MClass])  && !isTagged([MClass]))]
	Result : [getClassTypeForAssociation([Partner],[MClass.name])];
begin
	[thisToTaskPt([MClass])]next[ToRole:adaName](Result, Ctx.all);
	return Result;
[      else if(isPT([MClass]))]
begin
	return [thisToTaskPt([MClass])]next[ToRole:adaName](Ctx)[ToRole:makePointer];
[      else]
	Result : [getClassTypeForAssociation([Partner],[MClass.name])];
begin
	Result := this.[ToRole:adaName](this.[ToRole:adaName]'first + Ctx.Offset)[ToRole:makePointer];
	Ctx.Offset := Ctx.Offset + 1;
	return Result;
[      end if end if]
end next[ToRole:adaName];
\
[      if(regexp([ToRole].visibility(),"read-only") == "")]

procedure add[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])]; item : [getClassTypeForAssociation([Partner],[MClass.name])]) is
[         if((isTask([MClass]) == TRUE && isTagged([MClass]) == FALSE) || isPT([MClass]) == TRUE)]
begin
	[accThisToTaskPt([MClass])]add[ToRole:adaName](item);
[         else]
[genAdd([ToRole:ptrTypeName],[ToRole:arrayTypeName],"acc_this."[ToRole:adaName])]
[         end if]
end add[ToRole:adaName];
\
[      end if]
[   end if]
[end loop]
end template

template genSetWithAlloc(ptrTypeName,arrayTypeName,ptrExpr)
	ptr : [ptrTypeName] renames [ptrExpr];
	new_ptr : [ptrTypeName];
[insert("include","Unchecked_Deallocation")]
	procedure Free is new Unchecked_Deallocation ([arrayTypeName], [ptrTypeName]);
begin
	if ptr = NULL then
		ptr := new [arrayTypeName] (1 .. 10*(I + 9)/10);
	elsif I > ptr.all'last then
		new_ptr := new [arrayTypeName] (1 .. 10*(I + 9)/10);
		new_ptr.all (1 .. ptr.all'length) := ptr.all;
		Free (ptr); ptr := new_ptr;
	end if;
	ptr.all (I) := Item;
end template

template genAdd(ptrTypeName,arrayTypeName,ptrExpr)
	ptr : [ptrTypeName] renames [ptrExpr];
	new_ptr : [ptrTypeName];
[insert("include","Unchecked_Deallocation")]
	procedure Free is new Unchecked_Deallocation ([arrayTypeName], [ptrTypeName]);
begin
	if ptr = NULL then
		ptr := new [arrayTypeName] (1 .. 10);
		ptr.all (1) := item;
	else
		for I in ptr.all'range loop
			if ptr.all (I) = NULL then
				ptr.all (I) := item;
				return;
			end if;
		end loop;
		new_ptr := new [arrayTypeName] (1 .. ptr.all'length + 10);
		new_ptr.all (1 .. ptr.all'length) := ptr.all;
		new_ptr.all (ptr.all'length + 1) := item;
		Free (ptr); ptr := new_ptr;
	end if;
end template

/* 22b. generate body for the set/get operation generated for the relations of MClass
        this is called in the protected type body */
template genRelationOperationBodiesPT(MClass)
[/* relation accessor and set operation body. useAssocIndex (22.1)
    appends the index parameter to the class record component, if any */]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && visibilityMatchBody([ToRole].visibility(),"implementation");setText(""genSectionComment("Relation operations")))]
[// above, use visibilityMatchBody(,"implementation") because we want the definition if we generate the calling subprogramms]
[getText()]
[   if([ToRole:mechanism] == "GetSet" || [ToRole:mechanism] == "GetSetWithAlloc")]
function get[ToRole:adaName][openList()][genAssocIndex([ToRole])][closeList()] return [getClassTypeForAssociation([Partner],[MClass.name])] is
begin
	return [accThisToAttr([MClass])].[ToRole:adaName][openList()][useAssocIndex([ToRole])][closeList()];
end get[ToRole:adaName];
[      if(regexp([ToRole].visibility(),"read-only") == "")]

procedure set[ToRole:adaName][openList()][genAssocIndex([ToRole])][delim()]item : [getClassTypeForAssociation([Partner],[MClass.name])]) is
[         if([ToRole:mechanism] == "GetSetWithAlloc")]
[genSetWithAlloc([ToRole:ptrTypeName],[ToRole:arrayTypeName],accThisToAttr([MClass])"."[ToRole:adaName])]
[         else]
begin
	[accThisToAttr([MClass])].[ToRole:adaName][openList()][useAssocIndex([ToRole])][closeList()] := item;
[         end if]
end set[ToRole:adaName];
[      end if]
[/* wdh extensions to manage 1:N Associations: */]
[genAssocManagementBodiesPT([MClass],[ToRole],[Partner])]
[   else]
function more[ToRole:adaName](Ctx : [ToRole:ctxTypeName]) return Boolean is
begin
	if [accThisToAttr([MClass])].[ToRole:adaName] = NULL then
		return False;
	elsif Ctx.Offset > [accThisToAttr([MClass])].[ToRole:adaName]'length then
		return False;
	else
		return True;
	end if;
end more[ToRole:adaName];

function next[ToRole:adaName](Ctx : access [ToRole:ctxTypeName]) return [getClassTypeForAssociation([Partner],[MClass.name])] is
	Result : [getClassTypeForAssociation([Partner],[MClass.name])];
begin
	Result := [accThisToAttr([MClass])].[ToRole:adaName]([accThisToAttr([MClass])].[ToRole:adaName]'first + Ctx.Offset)[ToRole:makePointer];
	Ctx.Offset := Ctx.Offset + 1;
	return Result;
end next[ToRole:adaName];

[      if(regexp([ToRole].visibility(),"read-only") == "")]
procedure add[ToRole:adaName](item : [getClassTypeForAssociation([Partner],[MClass.name])]) is
[genAdd([ToRole:ptrTypeName],[ToRole:arrayTypeName],accThisToAttr([MClass])"."[ToRole:adaName])]
end add[ToRole:adaName];

[      end if]
[   end if]
[end loop]
end template


/* 22c. generate body for the set/get operation generated for the relations of MClass
        this is called in the protected type body */
template genRelationOperationBodiesTask(MClass)
[/* relation accessor and set operation body. useAssocIndex (22.1)
    appends the index parameter to the class record component, if any */]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && visibilityMatchBody([ToRole].visibility(),"implementation");setText(""genSectionComment("Relation operations")))]
[// above, use visibilityMatchBody(,"implementation") because we want the definition if we generate the calling subprogramms]
[   if([ToRole:mechanism] == "GetSet" || [ToRole:mechanism] == "GetSetWithAlloc")]
[selectAlternative(
	genRelationGetBodyTask([ToRole],[MClass],[Partner]))]
[      if(regexp([ToRole].visibility(),"read-only") == "")]
[         if([ToRole:mechanism] == "GetSetWithAlloc")]
[selectAlternative(
	genRelationSetWithAllocBodyTask([ToRole],[MClass],[Partner]))]
[         else]
[selectAlternative(
	genRelationSetBodyTask([ToRole],[MClass],[Partner]))]
[         end if]
[      end if]
[/* wdh extensions to manage 1:N Associations: */]
[genAssocManagementBodiesTask([MClass],[ToRole],[Partner])]
[   else]
[selectAlternative(
	genRelationMoreBodyTask([ToRole],[MClass],[Partner]))]
[selectAlternative(
	genRelationNextBodyTask([ToRole],[MClass],[Partner]))]
[      if(regexp([ToRole].visibility(),"read-only") == "")]
[selectAlternative(
	genRelationAddBodyTask([ToRole],[MClass],[Partner]))]
[      end if]
[   end if]
[end loop]
end template

template genRelationGetBodyTask(MAssociationEnd As ToRole,MClass,MClass As Partner)
accept get[ToRole:adaName](item : out [getClassTypeForAssociation([Partner],[MClass.name])][setDelim("; ")][genAssocIndex([ToRole])]) do
	item := [accThisToAttr([MClass])].[ToRole:adaName][openList()][useAssocIndex([ToRole])][closeList()];
end get[ToRole:adaName];
end template

template genRelationSetBodyTask(MAssociationEnd As ToRole,MClass,MClass As Partner)
accept set[ToRole:adaName][openList()][genAssocIndex([ToRole])][delim()]item : [getClassTypeForAssociation([Partner],[MClass.name])]) do
	[accThisToAttr([MClass])].[ToRole:adaName][openList()][useAssocIndex([ToRole])][closeList()] := item;
end set[ToRole:adaName];
end template

template genRelationSetWithAllocBodyTask(MAssociationEnd As ToRole,MClass,MClass As Partner)
accept set[ToRole:adaName][openList()][genAssocIndex([ToRole])][delim()]item : [getClassTypeForAssociation([Partner],[MClass.name])]) do
	declare
	[genSetWithAlloc([ToRole:ptrTypeName],[ToRole:arrayTypeName],accThisToAttr([MClass])"."[ToRole:adaName])]
	end;
end set[ToRole:adaName];
end template

template genRelationMoreBodyTask(MAssociationEnd As ToRole,MClass,MClass As Partner)
accept more[ToRole:adaName](haveMore : out Boolean; Ctx : [ToRole:ctxTypeName]) do
	if [accThisToAttr([MClass])].[ToRole:adaName] = NULL then
		haveMore := False;
	elsif Ctx.Offset > [ToRole:adaName]'length then
		haveMore := False;
	else
		haveMore := True;
	end if;
end more[ToRole:adaName];
end template

template genRelationNextBodyTask(MAssociationEnd As ToRole,MClass,MClass As Partner)
accept next[ToRole:adaName](item : out [getClassTypeForAssociation([Partner],[MClass.name])]; Ctx : in out [ToRole:ctxTypeName]) do
	item := [accThisToAttr([MClass])].[ToRole:adaName]([accThisToAttr([MClass])].[ToRole:adaName]'first + Ctx.Offset)[ToRole:makePointer];
	Ctx.Offset := Ctx.Offset + 1;
end next[ToRole:adaName];
end template

template genRelationAddBodyTask(MAssociationEnd As ToRole,MClass,MClass As Partner)
accept add[ToRole:adaName](item : [getClassTypeForAssociation([Partner],[MClass.name])]) do
	declare
	[genAdd([ToRole:ptrTypeName],[ToRole:arrayTypeName],accThisToAttr([MClass])"."[ToRole:adaName])]
	end;
end add[ToRole:adaName];
end template

/* 22.1. put a reference to the integer parameter generated by genAssocIndex (15.1)
   if the given association end requires an indes subscript */
proc useAssocIndex(MAssociationEnd)

	local multiplicity = getMultiplicity([MAssociationEnd.multiplicity]);
	local result;

	if([multiplicity]=="One")
		return "";
	else
 		[result] = delim()"I";
 		setDelim(","); 
 		return [result];
	end if

end proc


// extensions:


template pragma_inline(Name)
--pragma Inline ([Name]);
end template


/* wdh extensions to manage 1:N Associations: */

template genAssocManagementSpec(MClass,MAssociationEnd As ToRole,MClass As Partner)
function Get_[ToRole:adaName](this : [getClassParamForRead([MClass])][setDelim("; ")][genAssocIndex([ToRole])]) return [getClassTypeForAssociation([Partner],[MClass.name])]
	renames get[ToRole:adaName];
[if (genAssocIndex([ToRole])!="") ]
function  Count_[ToRole:adaName](this : [getClassParamForRead([MClass])]) return natural;
[pragma_inline("Count_"[ToRole:adaName])]
[end if]
[   if(regexp([ToRole].visibility(),"read-only") == "")]
procedure Set_[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])][setDelim("; ")][genAssocIndex([ToRole])]; item : [getClassTypeForAssociation([Partner],[MClass.name])])
	renames set[ToRole:adaName];
[if (genAssocIndex([ToRole])!="") ]
procedure Alloc_[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])]; Count : Natural);
procedure Add_[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])]; item : [getClassTypeForAssociation([Partner],[MClass.name])])[genRename([MClass],"set"[ToRole:adaName])];
procedure Remove_[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])][setDelim("; ")][genAssocIndex([ToRole])])[genRename([MClass],"set"[ToRole:adaName])];
[pragma_inline("Set_"[ToRole:adaName]",Alloc_"[ToRole:adaName]",Add_"[ToRole:adaName]",Remove_"[ToRole:adaName])]
[   end if]
[end if]
end template

template genAssocManagementSpecPT(MClass,MAssociationEnd As ToRole,MClass As Partner)
[if (genAssocIndex([ToRole])!="") ]
function  Count_[ToRole:adaName] return natural;
[   if(regexp([ToRole].visibility(),"read-only") == "")]
procedure Alloc_[ToRole:adaName] (Count : Natural);
procedure Add_[ToRole:adaName](item : [getClassTypeForAssociation([Partner],[MClass.name])]);
procedure Remove_[ToRole:adaName][openList()][genAssocIndex([ToRole])][closeList()];
[   end if]
[end if]
end template

template genAssocManagementSpecTask(MClass,MAssociationEnd As ToRole,MClass As Partner)
[if (genAssocIndex([ToRole])!="") ]
entry Count_[ToRole:adaName] (result : out natural);
[   if(regexp([ToRole].visibility(),"read-only") == "")]
entry Alloc_[ToRole:adaName] (Count : Natural);
entry Add_[ToRole:adaName](item : [getClassTypeForAssociation([Partner],[MClass.name])]);
entry Remove_[ToRole:adaName][openList()][genAssocIndex([ToRole])][closeList()];
[   end if]
[end if]
end template


template genAssocManagementBodiesPT(MClass,MAssociationEnd As ToRole,MClass As Partner)
[if (genAssocIndex([ToRole])!="") ]

function  Count_[ToRole:adaName]  return natural is
[genAssocManagementImplementCount([MClass],[ToRole],[Partner],"acc_this.")]
end Count_[ToRole:adaName];

[   if(regexp([ToRole].visibility(),"read-only") == "")]
procedure Alloc_[ToRole:adaName] (Count : Natural) is
[genAssocManagementImplementAlloc([MClass],[ToRole],[Partner],"acc_this.")]
end Alloc_[ToRole:adaName];

procedure Add_[ToRole:adaName] (Item : [getClassTypeForAssociation([Partner],[MClass.name])])[genRename([MClass],"set"[ToRole:adaName])] is
[genAssocManagementImplementAdd([MClass],[ToRole],[Partner],"acc_this.","")]
end Add_[ToRole:adaName];

procedure Remove_[ToRole:adaName] [setDelim("(")][genAssocIndex([ToRole])]) is
[genAssocManagementImplementRemove([MClass],[ToRole],[Partner],"acc_this.")]
end Remove_[ToRole:adaName];

[   end if]
[end if]
end template


template genAssocManagementBodiesTask(MClass,MAssociationEnd As ToRole,MClass As Partner)
[if (genAssocIndex([ToRole])!="") ]
[selectAlternative(
genAssocManagementAcceptCount([MClass],[ToRole],[Partner]))]
[   if(regexp([ToRole].visibility(),"read-only") == "")]
[selectAlternative(
genAssocManagementAcceptAlloc([MClass],[ToRole],[Partner]))]
[selectAlternative(
genAssocManagementAcceptAdd([MClass],[ToRole],[Partner]))]
[selectAlternative(
genAssocManagementAcceptRemove([MClass],[ToRole],[Partner]))]
[   end if]
[end if]
end template

template genAssocManagementAcceptCount(MClass,MAssociationEnd As ToRole,MClass As Partner)
accept Count_[ToRole:adaName] (Result : out Natural) do
	declare
		function Count return natural is
		[genAssocManagementImplementCount([MClass],[ToRole],[Partner],"")]
		end Count;
	begin
		Result := Count;
	end;
end Count_[ToRole:adaName];
end template

template genAssocManagementAcceptAlloc(MClass,MAssociationEnd As ToRole,MClass As Partner)
accept Alloc_[ToRole:adaName] (Count : Natural) do
	declare 
	[genAssocManagementImplementAlloc([MClass],[ToRole],[Partner],"")]
	end;
end Alloc_[ToRole:adaName];
end template

template genAssocManagementAcceptAdd(MClass,MAssociationEnd As ToRole,MClass As Partner)
accept Add_[ToRole:adaName](item : [getClassTypeForAssociation([Partner],[MClass.name])]) do
	declare
		function Count return natural is
		[genAssocManagementImplementCount([MClass],[ToRole],[Partner],"")]
		end Count;
		procedure Alloc (Count : Natural) is
		[genAssocManagementImplementAlloc([MClass],[ToRole],[Partner],"")]
		end Alloc;
		Index : Natural := Count + 1;
	begin
[// must avoid recursive call from:   genAssocManagementImplementAdd([MClass],[ToRole],[Partner],"","")]
		Alloc (Index);
		[accThisToAttr([MClass])].[ToRole:adaName](Index) := Item;
	end;
end Add_[ToRole:adaName];
end template

template genAssocManagementAcceptRemove(MClass,MAssociationEnd As ToRole,MClass As Partner)
accept Remove_[ToRole:adaName][openList()][genAssocIndex([ToRole])][closeList()] do
	declare 
	[genAssocManagementImplementRemove([MClass],[ToRole],[Partner],"")]
	end;
end Remove_[ToRole:adaName];
end template

template genAssocManagementBodies(MClass,MAssociationEnd As ToRole,MClass As Partner)
[if (genAssocIndex([ToRole])!="") ]

function  Count_[ToRole:adaName] (this : [getClassParamForRead([MClass])]) return natural is
[      if(isTask([MClass])  && !isTagged([MClass]))]
	Result : Natural;
begin
	[thisToTaskPt([MClass])]Count_[ToRole:adaName](Result);
	return Result;
[      else if(isPT([MClass]))]
begin
	return [thisToTaskPt([MClass])]Count_[ToRole:adaName];
[      else]
[genAssocManagementImplementCount([MClass],[ToRole],[Partner],"this.")]
[      end if end if]
end Count_[ToRole:adaName];

[   if(regexp([ToRole].visibility(),"read-only") == "")]
procedure Alloc_[ToRole:adaName] (acc_this : [getClassParamForUpdate([MClass])]; Count : Natural) is
[      if(isTask([MClass])  && !isTagged([MClass]))]
begin
	[accThisToTaskPt([MClass])]Alloc_[ToRole:adaName](Count);
[      else if(isPT([MClass]))]
begin
	[accThisToTaskPt([MClass])]Alloc_[ToRole:adaName](Count);
[      else]
[genAssocManagementImplementAlloc([MClass],[ToRole],[Partner],"acc_this.")]
[      end if end if]
end Alloc_[ToRole:adaName];

procedure Add_[ToRole:adaName](acc_this : [getClassParamForUpdate([MClass])]; item : [getClassTypeForAssociation([Partner],[MClass.name])])[genRename([MClass],"set"[ToRole:adaName])] is
[      if(isTask([MClass])  && !isTagged([MClass]))]
begin
	[accThisToTaskPt([MClass])]Add_[ToRole:adaName](Item);
[      else if(isPT([MClass]))]
begin
	[accThisToTaskPt([MClass])]Add_[ToRole:adaName](Item);
[      else]
[genAssocManagementImplementAdd([MClass],[ToRole],[Partner],"acc_this.","acc_this")]
[      end if end if]
end Add_[ToRole:adaName];

procedure Remove_[ToRole:adaName] (acc_this : [getClassParamForUpdate([MClass])][genAssocIndex([ToRole])]) is
[      if(isTask([MClass])  && !isTagged([MClass]))]
begin
	[accThisToTaskPt([MClass])]Remove_[ToRole:adaName](I);
[      else if(isPT([MClass]))]
begin
	[accThisToTaskPt([MClass])]Remove_[ToRole:adaName](I);
[      else]
[genAssocManagementImplementRemove([MClass],[ToRole],[Partner],"acc_this.")]
[      end if end if]
end Remove_[ToRole:adaName];

[   end if]
[end if]
end template


template genAssocManagementImplementCount(MClass,MAssociationEnd As ToRole,MClass As Partner,thisPrefix)
	use type [ToRole:ptrTypeName], [getClassTypeForAssociation([Partner],[MClass.name])];
	Result : Natural := 0;
begin
	if [thisPrefix][ToRole:adaName] /= null then
		for I in reverse [thisPrefix][ToRole:adaName].all'range loop
			if [thisPrefix][ToRole:adaName](I) /= null then
				result := I; -- 'first is always 1
				exit;
			end if;
		end loop;
	end if;
	return Result;
end template

template genAssocManagementImplementAlloc(MClass,MAssociationEnd As ToRole,MClass As Partner,thisPrefix)
	Old : [ToRole:ptrTypeName];
[insert("include","Unchecked_Deallocation")]
	procedure Free is new Unchecked_Deallocation ([ToRole:arrayTypeName], [ToRole:ptrTypeName]);
begin
	if [thisPrefix][ToRole:adaName] /= null and then [thisPrefix][ToRole:adaName].all'Length < Count then
		Old := [thisPrefix][ToRole:adaName];
		[thisPrefix][ToRole:adaName] := new [ToRole:arrayTypeName](1..Count);
		[thisPrefix][ToRole:adaName] (1..Old.all'Length) := Old.all;
		Free (Old);
	else
		[thisPrefix][ToRole:adaName] := new [ToRole:arrayTypeName](1..Count);
	end if;
end template

template genAssocManagementImplementAdd(MClass,MAssociationEnd As ToRole,MClass As Partner,thisPrefix,thisParam)
	Index : Natural;
begin
[   if ([thisParam]== "")]
	Index := Count_[ToRole:adaName] + 1;
	Alloc_[ToRole:adaName] (Index);
[   else]
	Index := Count_[ToRole:adaName] ([thisParam].all) + 1;
	Alloc_[ToRole:adaName] ([thisParam], Index);
[   end if]
	[thisPrefix][ToRole:adaName](Index) := Item;
end template

template genAssocManagementImplementRemove(MClass,MAssociationEnd As ToRole,MClass As Partner,thisPrefix)
	use type [ToRole:ptrTypeName];
	List : [ToRole:ptrTypeName];
[insert("include","Unchecked_Deallocation")]
	procedure Free is new Unchecked_Deallocation ([ToRole:arrayTypeName], [ToRole:ptrTypeName]);
begin
	if [thisPrefix][ToRole:adaName] /= null and then 
		I in [thisPrefix][ToRole:adaName].all'range 
	then	
		if [thisPrefix][ToRole:adaName].all'Length > 1 then
			List := new [ToRole:arrayTypeName] ([thisPrefix][ToRole:adaName].all'First..[thisPrefix][ToRole:adaName].all'Last-1);
			[thisPrefix][ToRole:adaName] (1.. I-1) := [thisPrefix][ToRole:adaName] (1 .. I-1);
			[thisPrefix][ToRole:adaName] (I .. [thisPrefix][ToRole:adaName].all'Last-1)
				:= [thisPrefix][ToRole:adaName] (I+1 .. [thisPrefix][ToRole:adaName].all'Last);
		end if;
		Free ([thisPrefix][ToRole:adaName]);
		[thisPrefix][ToRole:adaName] := List;
	else
		raise Constraint_Error;
	end if;
end template


/* end wdh extensions to manage 1:N Associations */


// 3.2 GenSmartCptrSpec generates the smart pointer definition
// This template is defined in file wdh_extensions
template GenSmartCptrSpec(MClass)
[insert("include","ACD_Runtime.Smart_Pointer_Pkg")]
package [MClass.name]_Smart_Cptr is new ACD_Runtime.Smart_Pointer_Pkg ([getClassResultType([MClass],TRUE)], null, Free);
subtype [MClass.name]_Scptr is [MClass.name]_Smart_Cptr.Smart_Pointer;
end template
