//*****************************************************************************
// Autor : Chafik Aouanet, P.Kleiner
// Date  : 24.6.1999
//*****************************************************************************

// wdh: 00/10/10
// As a side effect of MPackage.getSubsystemPath,
// we compute and assign [MPackage:fileNamePrefix] by catenating the
// TaggedValue "FileNamePrefix" of all enclosing subsystems
// The idea is that even in the non-directory-structured view of ObjectAda, the package structure is visualized.
// As long as TaggedValue "FileNamePrefix" is not defined, this modification
// has no effect to the generated code or file names.

// wdh: 00/10/17
// correct pattern matching for classname*.
// use " *\*" instead of " *".

// wdh:00/11/08
// support Counted_Ref stereotypes for aggregations

// wdh 00/11/09, genResultObjectType: same logic for "class_name*" as in genResultType 

// wdh 00/11/10 use selectAda in .visibility procedures

// wdh 00/11/13 MAttribute.visibility:  tagged value Attribute_Operations=FALSE --> implementation
USES ../tdl/std;
/* Generates a marked section in the output. The content of this section can 
be changed by the user in the generated file. These changes will not be 
overwritten, in the following cycles of code generation */
template mergeOut(uniqueId,desc,defaultText)
--#ACD# M([uniqueId]) [desc]
[defaultText]   -- user defined code to be added here ...
--#end ACD#
end template

/* this procedure is called once by main (defined in ada_main.tdl) before
   any other procedure or template. It sets up the merge mechanism for 
   incremental code generation (delMergeFile and appendMergeFile).
   The current language for type mapping is defined (setLanguage) */
proc init()
	if ([language] == "")
	   [language] = "Ada95";
	end if
	
	if ([language] == "Ada95")
	   info = "Generating Ada 95 code\n";
	else if ([language] == "Ada83")
	   info = "Generating Ada 83 code\n";
        else
           info = "language " [language] " not supported by this template. Choose Ada83 or Ada95\n";
           return;
	end if end if
	
	delMergeFile();
	setMapFile([srcdir] "/srcmap");
	appendMergeFile("merge_config_ADA95.txt");
	setLanguage([language]); 
	
	initWantCode();
end proc	

proc openList()
   setDelim("(");
end proc

proc closeList()
   if (delim() != "(")
      return ")";
   else
      return "";
   end if
end proc

//^
// code stored in repository
//

proc getCodeFromRep(MOperation)

loop(MOperation->Note Where [Note.type] == "UmlOperationAda95Code")
   return outDesc([Note.description]);
end loop
return "";

end proc
	
template outDesc(Description)
[loop(Instances->TokenSet([Description]))]
[TokenSet.line]
[end loop]
end template

template outDescAsComment(Description)
[loop(Instances->TokenSet([Description]))]
-- [TokenSet.line]
[end loop]
end template

// This procedure should return a useful name  for diagnostics.
// It is NOT intended to be used in the generated code.
proc MSemElement.getFullName()
   return "MSemElement" [MSemElement.id];
end proc


//*****************************************************************************
// Selective code generation support
//*****************************************************************************
// Note:
//   [class_id_list] is the list of classes for which we should generate code.
//   An empty list means: generate codefor all classes.

proc initWantCode ()
   // We compute the property for all classes in one run for better efficiency
//T info = "initWantCode : class_id_list -> " [class_id_list]"\n";   

   if ([class_id_list] == "")
      loop(Instances -> MClass as x)
         [x:wantCode] = TRUE;
      end loop
   else
      loop(Instances -> MClass as x)
         [x:wantCode] = FALSE;
      end loop
      loop(Instances -> MClass([class_id_list]) as x)
         [x:wantCode] = TRUE;
      end loop
   end if
end proc

proc wantCodeForRuntime() 
   if ([class_id_list] == "")
//T info = "wantCodeForRuntime : TRUE\n";  
      return TRUE;
   else
//T info = "wantCodeForRuntime : FALSE\n";  
      return FALSE;
   end if
end proc

proc MClass.wantCode()
//T info = "MClass.wantCode : "[MClass.name]" -> "[MClass:wantCode]"\n";  
   return [MClass:wantCode]; // The property is set for all Classes in initWantCode
end proc

proc wantCodeForGroup(group)
// For a group, we generate code if there is a least one Class in the group for which we want code

   local x = "wantCodeForGroup_Cache_For_" [group];
//T info = "wantCodeForGroup :" [x]"\n";   
   
   if ([[x]] == "")
       [[x]] = hasLoop(Instances -> MClass(MClass_by_group([group])) where [MClass].wantCode());
   end if

//T info = "wantCodeForGroup :" [x]" -> "[[x]]"\n";   
   return [[x]];

end proc



//*****************************************************************************
// 3. Properties of packages
//*****************************************************************************

proc MPackage.getFullName()
   return [MPackage.name];
end proc

proc MPackage.getStereoType()

//T   info = "stereo " [MPackage.name] " -> ";

   loop(MPackage->Note where [Note.type] == "UmlExtensibilityDefinition") 
      loop(Note->Item where [Item.type] == "UmlStereotype")
//T        info = [Item.value] "\n";
        return toLower([Item.value]);
       end loop
   end loop

//T   info = "\n";
   return "";
end proc

proc MPackage.getTaggedValue(tag,defaultValue)

   loop(MPackage->TaggedValue Where [TaggedValue.tag] == [tag])
      return [TaggedValue.value];
   end loop
   return [defaultValue];

end proc

proc MPackage.getTaggedValueBool(tag,defaultValue)

//T info = "Package " [MPackage.name] " tag " [tag] " default " [defaultValue] " -> ";

   loop(MPackage->TaggedValue Where [TaggedValue.tag] == [tag])
//T info = "match:" [TaggedValue.value] "\n";
      switch (toUpper([TaggedValue.value]))
      case TRUE:
         return TRUE;
      case FALSE:
         return FALSE;
      default:
 info = "Package " [MPackage.name] " tag " [tag] " has illegal value " [TaggedValue.value] ". Using default " [defaultValue] "\n";
         return [defaultValue];
      end switch
    end loop
//T info = "not match: use default\n";
   return [defaultValue];

end proc

proc MPackage.isExternal()


   loop(MPackage->Note where [Note.type] == "UmlPackageDefinition") 
      loop(Note->Item where [Item.type] == "UmlPackageIsImported")
         if([Item.value] || [Item.value] == "True")
            return TRUE;
         else
            return FALSE;
         end if
       end loop
   end loop
   
   return FALSE;   
   
end proc

proc MPackage.isGeneric()

   if([MPackage].getStereoType() == "generic")
	return TRUE;
   else
   	return FALSE;
   end if
   
end proc

proc MPackage.isInstance()

//T   loop(MPackage->Supplier->MDependency)
//T     loop(Supplier->MPackage As SupplierPackage)
//T       info = "isInstance: Package " [MPackage.name] " sup " [SupplierPackage.name] " dep " [MDependency.name] "\n";
//T     end loop
//T   end loop

//T   info = "isInstance " [MPackage.name];

   loop(MPackage->Supplier->MDependency)
     loop(Supplier->MPackage As SupplierPackage where [SupplierPackage].isGeneric())
      info = " supplier " [SupplierPackage.name] " dep " [MDependency.name];
//not yet available in ACD      if([MDependency.name] == "generic instantiation")
      if(TRUE)
//T         info = " -> TRUE\n";
	 return TRUE;
      end if
   end loop
   end loop
  
//T   info = " -> FALSE\n";
   return FALSE;
   
end proc

proc isSubsystemPackage(MPackage)

   if([MPackage].getStereoType() == "segment")
	return TRUE;
   else if([MPackage].getStereoType() == "subsystem")
	return TRUE;
   else
   	return FALSE;
   end if end if
   
end proc

//*****************************************************************************
// 4. Properties of classes
//*****************************************************************************

proc MClass.getFullName()
   loop(MClass->MPackage)
      return [MPackage].getFullName() "." [MClass.name];
   end loop
   return [MClass.name];
end proc

proc MClass.getStereoType()

   loop(MClass->Note where [Note.type] == "UmlExtensibilityDefinition") 
      loop(Note->Item where [Item.type] == "UmlStereotype")
         return toLower([Item.value]);
       end loop
   end loop

   return toLower([MClass.stereotype]);
   
end proc


proc MClass.getTaggedValue(tag,defaultValue)

//T info = "MClass " [MClass.name] " tag " [tag] " default " [defaultValue] " -> "; 

   loop(MClass->TaggedValue Where [TaggedValue.tag] == [tag])
//T info = "match:" [TaggedValue.value] "\n"; 
      return [TaggedValue.value];
   end loop
//T info = "not match: use default\n"; 
   return [defaultValue];

end proc

proc MClass.getConstraint()

   loop(MClass->Note where [Note.type] == "UmlExtensibilityDefinition") 
      loop(Note->Item where [Item.type] == "UmlConstraintItem")
         return [Item.value];
       end loop
   end loop
   
   return "";

end proc

proc MClass.getTaggedValueBool(tag,defaultValue)

//T info = [MClass].getFullName() " tag " [tag] " default " [defaultValue] " -> ";

   loop(MClass->TaggedValue Where [TaggedValue.tag] == [tag])
//T info = "match:" [TaggedValue.value] "\n";
      switch (toUpper([TaggedValue.value]))
      case TRUE:
         return TRUE;
      case FALSE:
         return FALSE;
      default:
 info = "Class " [MClass].getFullName() " tag " [tag] " has illegal value " [TaggedValue.value] ". Using default " [defaultValue] "\n";
         return [defaultValue];
      end switch
    end loop
//T info = "not match: use default\n";
   return [defaultValue];

end proc

proc MClass.isAbstract()

   if(getClassPrivacy([MClass]) != "private")
      loop(MClass->Note->Item where [Item.type] == "UmlClassIsAbstract")
         if([Item.value] || [Item.value] == "True")
            return TRUE;
         else
            return FALSE;
         end if
      end loop
   end if
   
   return [MClass].getTaggedValueBool("Abstract", FALSE);
   
end proc

proc isArray(MClass)

   if([MClass].getStereoType() == "array")
      return TRUE;
   else
      return FALSE;
   end if
   
end proc


proc makeChildPackage(MClass)

//   return [MClass].getTaggedValue("Child_Package", FALSE);
   return [MClass].getTaggedValueBool("Child_Package", hasLoop(MClass->SuperClass));

end proc

proc isDatatype(MClass)

   loop(MClass->MDataType where [MClass].getConstraint() != "")
      return TRUE;
   end loop
   return FALSE;
   
end proc

proc isSingleton(MClass)

   if(toLower([MClass].getTaggedValue("pattern","")) == "singleton")
      return TRUE;
   else
      return FALSE;
   end if

end proc

proc isTypemapping(MClass)


   loop(MClass->MDataType where [MClass].getConstraint() == "")
      return TRUE;
   end loop
  return FALSE;
   
end proc

proc isEnumeration(MClass)

   if([MClass].getStereoType() == "enumeration")
      return TRUE;
   else
      return FALSE;
   end if
   
end proc

proc MClass.isExternal()

   if(isTypemapping([MClass]))
      return TRUE;
   end if
   
   loop(MClass->Note where [Note.type] == "UmlClassDefinition") 
      loop(Note->Item where [Item.type] == "UmlClassIsImported")
         if([Item.value] || [Item.value] == "True")
            return TRUE;
         else
            return FALSE;
         end if
       end loop
   end loop
   
   loop(MClass->MPackage where [MPackage].isExternal())
      return TRUE;
   end loop

   return FALSE;   
   
end proc

proc MClass.isGeneric()

   loop(MClass->MTemplateClass)
      return TRUE;
   end loop
   return FALSE;
   
end proc

proc doGenClassPtr(MClass)

//	if(stateMachineImplementation([MClass]) == "Table")
//testInfo("wdh","doGenClassPtr for "[MClass.name]" true for Table\n");
//		return TRUE;
//		// prevent bug in OA 7.1.2: use of access <class> in profile of 
//		// subprogram parameter (here: action proc) fails
//	end if

	if([MClass:isComposite])
		return FALSE;
	end if
	if([MClass].isExternal())
		return FALSE;
	end if
	if(getClassPrivacy([MClass]) == "implementation")
		return FALSE;
	end if
	if(!isTagged([MClass]))
		return FALSE;
	end if
//	if(isLimited([MClass]))
//		return FALSE;
//testInfo("wdh","doGenClassPtr for "[MClass.name]" false for limited\n");
//	end if
	
	loop(MClass->Note where [Note.type] == "UmlClassAda95Definition")
 		loop(Note->Item where [Item.type] == "UmlClassAda95GenWideAccessType")
         		if([Item.value] || [Item.value] == "True")
				return TRUE;
			else
				return FALSE;
			end if
		end loop
	end loop
//testInfo("wdh","doGenClassPtr for "[MClass.name]" check tagged value Class_Pointer\n");

	return [MClass].getTaggedValueBool("Class_Pointer", "TRUE");
end proc

proc doGenPtr(MClass)

	if([MClass:isComposite])
		return FALSE;
	end if
	if([MClass].isExternal())
		return FALSE;
	end if
	if(getClassPrivacy([MClass]) == "implementation")
		return FALSE;
	end if
	 
	loop(MClass->Note where [Note.type] == "UmlClassAda95Definition")
 		loop(Note->Item where [Item.type] == "UmlClassAda95GenAccessType")
			if([Item.value] || [Item.value] == "True")
				return TRUE;
			else
				return FALSE;
			end if
		end loop
	end loop

	return [MClass].getTaggedValueBool("Pointer", "TRUE");
end proc

proc doGenStreamOps(MClass)

	return [MClass].getTaggedValueBool("Stream_Operations", "FALSE");

end proc

proc hasDiscriminant(MClass)


   loop(MClass->MAttribute where isDiscriminant([MAttribute]))
      return TRUE;
   end loop
   return FALSE;
   
end proc


proc MClass.isInstance()

   if(hasLoop(MClass->MInstantiatedClass))
      return TRUE;
   else
      return FALSE;
   end if
   
end proc

proc isInterface(MClass)
	local interface = "";
    loop(MClass->MInterface where [MInterface.name] != "")
    	return TRUE;
    end loop
	return FALSE;
end proc

proc isLimited(MClass)

//T info = "isLimited " [MClass.name];

   if(getClassPrivacy([MClass]) != "private extension")
   
      loop(MClass->Note where [Note.type] == "UmlClassAda95Definition")
         loop(Note->Item where [Item.type] == "UmlClassAda95IsLimited")
//T info = "-> (1) " [Item.value] "\n";
            if([Item.value] || [Item.value] == "True")
               return TRUE;
            else
               return FALSE;
            end if
         end loop
      end loop
   end if
   
   if (isTask([MClass]) )
//T info = "-> (2) TRUE\n";
      return TRUE;
   else if (isPT([MClass]) )
//T info = "-> (3) TRUE\n";
      return TRUE;
   else if (isStoragePool([MClass]) )
//T info = "-> (4) TRUE\n";
      return TRUE;
   end if end if end if

   loop(MClass->SuperClass)
//T info = "-> (5);
      if(isLimited([SuperClass]))
         return TRUE;
      end if
   end loop
   
//T info = "-> (6) " [MClass].getTaggedValueBool("Limited", FALSE) "\n";
   return [MClass].getTaggedValueBool("Limited", FALSE);

end proc

proc getClassPrivacy(MClass)

   local defautlPrivacy;
   local privacy = "";

   if([MClass:privacy] != "")
      return [MClass:privacy];
   end if

   if(isExplicitlyNonTagged([MClass]))
      [defaultPrivacy] = "private";
   else
      [defaultPrivacy] = "private extension"; // defaultValue value   
   end if
      
   loop(MClass->Note where [Note.type] == "UmlClassAda95Definition") 
      loop(Note->Item where [Item.type] == "UmlClassAda95TypePrivacy")
         [privacy] = [Item.value];
     end loop
   end loop

   if([privacy] == "")
      [privacy] = toLower([MClass].getTaggedValue("Class_Visibility", [defaultPrivacy]));
   end if

   switch([privacy])
   case "public":
   case "private":
   case "implementation":
      [MClass:privacy] = [privacy];
      return [privacy];
   case "tagged private":
   case "private extension":
      if(isExplicitlyNonTagged([MClass]) && (isTask([MClass]) || isPT([MClass])))
         info = "Class " [MClass.name] ": privacy " [privacy] " changed to private due to task/protected type\n";
         [privacy] = "private";
      end if
      [MClass:privacy] = [privacy];
      return [privacy];
   default :
      info = "Class " [MClass.name] ": privacy " [privacy] " unsupported\n";
      [MClass:privacy] = [defaultPrivacy];
      return [defaultPrivacy];
   end switch  
   
end proc

proc isAdaControlledRoot(MClass)
   
   if(toLower([MClass:packageName]) == "ada.finalization")
      if(toLower([MClass.name]) == "controlled")
         return TRUE;
      end if
      if(toLower([MClass.name]) == "limited_controlled")
         return TRUE;
      end if
   end if 
   
   return FALSE;
   
end proc

proc isFinalized(MClass)

   // implicit ?

   //Note: ada.finalization seems not to work with raven

   if([doCallStp] == TRUE && [doRaven] == FALSE && isActiveClassInstance([MClass]))
      return TRUE;
   end if

   // explicit ?
   
   if(isAdaControlledRoot([MClass]))
      return TRUE;
   end if
    
   // derived ?

   loop(MClass->SuperClass)
      return isFinalized([SuperClass]);
   end loop

   return FALSE;
   
end proc

proc isPT(MClass)

   switch([MClass].getStereoType())
   case "tagged protected type" :
   case "tagged_protected_type" :
   case "tagged-protected-type" :
      [MClass:ptName] = [MClass.name] "_pt";
      return TRUE;
   case "protected type" :
   case "protected_type" :
   case "protected-type" :
      [MClass:ptName] = [MClass.name];
      return TRUE;
   default :
      return FALSE;
   end switch

end proc

proc requiresChild(MClass,place)

//T   info = "requiresChild " [MClass.name] " at " [place] "\n";

   loop(MClass->MAttribute where visibilityMatch([MAttribute].visibility(), [place]"-child"))
//T      info = "   -> YES (1)\n";
      return TRUE;
   end loop   

   loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [ToRole:isPointer] == TRUE && visibilityMatch([ToRole].visibility(), [place]"-child"))
//T      info = "   -> YES (2)\n";
      return TRUE;
   end loop   

//T   info = "   -> NO\n";
   return FALSE;

end proc

proc getStoragePool(MClass)

   local result = [MClass].getTaggedValue("Storage_Pool", "");
   if([doRaven] == TRUE)
      [result] = [MClass].getTaggedValue("Raven_Storage_Pool", [result]);
   end if
   return [result];
   
end proc

proc isStoragePool(MClass)

   if([MClass].getStereoType() == "storage pool")
      return TRUE;
   else if([MClass].getStereoType() == "storage-pool")
      return TRUE;
   else if([MClass].getStereoType() == "storage_pool")
      return TRUE;
   else
      return FALSE;
   end if end if end if   
end proc

proc MClass.isSubunit()

   return [MClass].getTaggedValueBool("Subunit", FALSE);
   
end proc

proc isTagged(MClass)

   local privacy;

   switch([MClass].getStereoType())
   case "tagged task" :
   case "tagged_task" :
   case "tagged-task" :
      return TRUE;

   case "task" :
   case "active" :
   case "thread" :
      return FALSE;

   case "tagged protected type" :
   case "tagged_protected_type" :
   case "tagged-protected-type" :
      return TRUE;

   case "protected type" :
   case "protected_type" :
   case "protected-type" :
      return FALSE;

   case "enumeration" :
   case "array" :
      return FALSE;

   default :
      [privacy] = getClassPrivacy([MClass]);
   
      if ([privacy] == "public" || [privacy] == "private extension" || [privacy] == "tagged private")
         return TRUE;
      else
         return FALSE;
      end if
   end switch

end proc

proc isExplicitlyNonTagged(MClass)

   local privacy;

   switch([MClass].getStereoType())
   case "task" :
   case "thread" :
   case "active" :
      return TRUE;

   case "protected type" :
   case "protected_type" :
   case "protected-type" :
      return TRUE;

   case "enumeration" :
   case "array" :
      return TRUE;

   default :
      return FALSE;
   end switch

end proc

proc isTask(MClass)

   switch([MClass].getStereoType())
   case "tagged task" :
   case "tagged_task" :
   case "tagged-task" :
      [MClass:taskName] = [MClass.name] "_task";
      return TRUE;
   case "task" :
   case "thread" :
   case "active" :
      [MClass:taskName] = [MClass.name];
      return TRUE;
   default :
      return StateMachineRequiresTask([MClass]); 
   end switch

end proc

proc getNestingLevel (MClass)
   loop(MClass->SuperClass)
      return add(getNestingLevel([SuperClass]),1);
   end loop
   return "0";
end proc

proc getNestingSuffix (MClass)
   if ([MClass:NestingSuffix] == "")
      [MClass:NestingSuffix] = getNestingLevel([MClass]);
   end if
   
   if ([MClass:NestingSuffix] == "0")
      return ""; // so the most common case should look nice
   else
      return [MClass:NestingSuffix];
   end if
end proc

/********************************************
The procedure condGetUniqueId returns the empty string unless the class is nested in a package (other than a subsystem). If it is nested in a package, it returns "::"getUniqueId(MClass).
The whole point of this procedure is compatibility with existing merge sections.
Calls of condGetUniqueId should be replaced with "::"getUniqueId before a new project is started.
**********************************************/

proc condGetUniqueId (MClass)
	
   loop(MClass->MPackage where !isSubsystemPackage([MPackage]))
      return "::" getUniqueId([MClass]);
   end loop
   
   return "";
end proc

//*****************************************************************************
// 5. Properties of attributes
//*****************************************************************************

proc MAttribute.getFullName()
   return [MAttribute.name];
end proc

proc MAttribute.getStereoType()

   loop(MAttribute->Note where [Note.type] == "UmlExtensibilityDefinition") 
      loop(Note->Item where [Item.type] == "UmlStereotype")
         return toLower([Item.value]);
       end loop
   end loop

   return "";
end proc

proc MAttribute.getTaggedValue(tag,defaultValue)

   loop(MAttribute->TaggedValue Where [TaggedValue.tag] == [tag])
      return [TaggedValue.value];
   end loop
   return [defaultValue];

end proc

proc MAttribute.getTaggedValueBool(tag,defaultValue)

//T info = [MAttribute].getFullName() " tag " [tag] " default " [defaultValue] " -> ";

   loop(MAttribute->TaggedValue Where [TaggedValue.tag] == [tag])
//T info = "match:" [TaggedValue.value] "\n";
      switch (toUpper([TaggedValue.value]))
      case TRUE:
         return TRUE;
      case FALSE:
         return FALSE;
      default:
 info = "Attribute " [MAttribute].getFullName() " tag " [tag] " has illegal value " [TaggedValue.value] ". Using default " [defaultValue] "\n";
         return [defaultValue];
      end switch
    end loop
//T info = "not match: use default\n";
   return [defaultValue];

end proc

proc isAliased(MAttribute)

   loop(MAttribute->Note where [Note.type] == "UmlAttributeAda95Definition") 
      loop(Note->Item where [Item.type] == "UmlAttributeAda95IsAliased")
         return [Item.value];
       end loop
   end loop

   return FALSE;
end proc

proc isDiscriminant(MAttribute)

//T   info = "isDiscr" [MAttribute.name] "=" [MAttribute.id];
   
    if ([MAttribute].getStereoType() == "discriminant")
//T       info = " -> True (1)\n";
     return TRUE;
   end if
   
//ANNOT   loop(MAttribute->Note where [Note.type] == "UmlAttributeAda95Definition") 
//ANNOT      loop(Note->Item where [Item.type] == "UmlAttributeAda95IsDiscriminant")
//T         info = " -> " [Item.value] "(2)\n";
//ANNOT         return [Item.value];
//ANNOT      end loop
//ANNOT   end loop

//T   info = " -> False(3)\n";
   return FALSE;

end proc

proc MAttribute.isStatic()

   if([MAttribute.binding] == "static")
      return TRUE;
   else
      return FALSE;
   end if

end proc

proc MAttribute.visibility()


   local defaultVisibility = "public"; // the access operation !
   local visibility;
   local access; 

   if([MAttribute:privacy] != "")
      return [MAttribute:privacy];
   end if

   loop(MAttribute->MClass)
      if(![MClass].getTaggedValueBool("Attribute_Operations","TRUE"))
         [MAttribute:privacy] = "implementation";
         return "implementation";
      end if
      if([MClass:isComposite])
         [defaultVisibility] = "private";
      end if
   end loop

   if([MAttribute.access] != "")
   
      [access] = selectAda([MAttribute.access]);
//T info = " -> access=" [MAttribute:access]" resulting in "[access]"\n";
      switch([access])
      case "public" :
      case "private" :
      case "implementation" :
         [defaultVisibility] = [access];
         break;
      case "protected" :
         // not supported by Ada
         [defaultVisibility] = "private-operation";
         loop(MAttribute->MClass->SubClass where !makeChildPackage([MClass]))
            // needs to be public
            [defaultVisibility] = "public-operation";
            break;
         end loop
         break;
      default :
         loop(MAttribute->MClass)
            info = "Attribute " [MClass.name] "::" [MAttribute.name] ": access " [MAttribute.access] " unexpected\n";
         end loop
      end switch
   end if

   loop(MAttribute->MClass)
      if(getClassPrivacy([MClass]) == "implementation" && [defaultVisibility] != "implementation" )
         [defaultVisibility] = [defaultVisibility]"-child";
      end if
   end loop
   
   [visibility] = toLower([MAttribute].getTaggedValue("Visibility",[defaultVisibility]));
   
   if([visibility] == "read-only")
      [visibility] = "public-read-only";
   end if
   
   if([visibility] == "read-only-child")
      [visibility] = "public-child-read-only";
   end if
   
   switch([visibility])
   case "public":
   case "private":
   case "implementation":
   case "public-read-only":
   case "public-operation":
   case "private-read-only":
   case "private-operation":
   case "public-child":
   case "private-child":
   case "public-child-read-only":
   case "public-child-operation":
   case "private-child-read-only":
   case "private-child-operation":
//T info = " -> tag=" [visibility] "\n";
      [MAttribute:privacy] = [visibility];
      return [visibility];
   default :
      loop(MAttribute->MClass)
         info = "Attribute " [MClass.name] "::" [MAttribute.name] ": visibility " [visibility] " unsupported\n";
      end loop
      [MAttribute:privacy] = [defaultVisibility];
      return [defaultVisibility];
   end switch

end proc

//*****************************************************************************
// 6. Properties of operations
//*****************************************************************************

proc MOperation.getFullName()
   return [MOperation.name];
end proc

proc MOperation.getStereoType()

   loop(MOperation->Note where [Note.type] == "UmlExtensibilityDefinition") 
      loop(Note->Item where [Item.type] == "UmlStereotype")
         return toLower([Item.value]);
       end loop
   end loop

   return "";
end proc

proc MOperation.getTaggedValue(tag,defaultValue)

   loop(MOperation->TaggedValue Where [TaggedValue.tag] == [tag])
      return [TaggedValue.value];
   end loop
   return [defaultValue];

end proc

proc MOperation.getTaggedValueBool(tag,defaultValue)

//T info = [MOperation].getFullName() " tag " [tag] " default " [defaultValue] " -> ";

   loop(MOperation->TaggedValue Where [TaggedValue.tag] == [tag])
//T info = "match:" [TaggedValue.value] "\n";
      switch (toUpper([TaggedValue.value]))
      case TRUE:
         return TRUE;
      case FALSE:
         return FALSE;
      default:
 info = "Operation " [MOperation].getFullName() " tag " [tag] " has illegal value " [TaggedValue.value] ". Using default " [defaultValue] "\n";
         return [defaultValue];
      end switch
    end loop
//T info = "not match: use default\n";
   return [defaultValue];

end proc

proc MOperation.isAbstract()

   loop(MOperation->Note->Item where [Item.type] == "UmlOperationIsAbstract")
      if([Item.value] || [Item.value] == "True")
         return TRUE;
      else
         return FALSE;
      end if
   end loop
      
end proc


proc isEntry(MOperation)

   if ([MOperation].getStereoType() == "entry")
      return TRUE;
   end if

   return FALSE;
   
end proc

proc isTimedEntry(MOperation,MClass)

   return [MOperation].getTaggedValueBool("Timed_Call_Supported",FALSE);
   // We might try to filter out illegal use of the tagged value
   // But this is much easier done by the compiler.
   
end proc

proc isFunction(MOperation)

   if([MOperation.returnType] == "")
      return FALSE;
   end if
   
   if([MOperation.returnType] == "void")
      return FALSE;
   end if
   
   return TRUE;
   
end proc

proc isInlined(MOperation)


   if([MOperation].getTaggedValueBool("Inline",FALSE))
      return TRUE;
   end if

   loop(MOperation->Note where [Note.type] == "UmlOperationAda95Definition") 
      loop(Note->Item where [Item.type] == "UmlOperationAda95IsInline")
         if([Item.value] == "True")
            return TRUE;
         else
            return FALSE;
         end if
      end loop
   end loop

   loop(MOperation->Note where [Note.type] == "UmlOperationCxxDefinition") 
      loop(Note->Item where [Item.type] == "UmlOperationCxxIsInline")
         if([Item.value] == "True")
            return TRUE;
         else
            return FALSE;
         end if
      end loop
   end loop
   
   return FALSE;
   
end proc

proc MOperation.isStatic()

   switch([MOperation.binding])
   case "normal" : // Thus, all non-static operations are considered virtual
   case "virtual" :
      return FALSE;
   case "static" :
      return TRUE;
   default :
      return "undefined";
   end switch
end proc

proc MOperation.isSubunit()

   loop(MOperation->Note where [Note.type] == "UmlOperationAda95Definition") 
      loop(Note->Item where [Item.type] == "UmlOperationAda95IsSubunit")
         return [Item.value];
      end loop
   end loop

   return [MOperation].getTaggedValueBool("Subunit", FALSE);
   
end proc

proc MOperation.visibility()

   local access = selectAda([MOperation.access]);

   switch([access])
   case "public" :
   case "private" :
   case "implementation" :
      return [access];
   case "" :
//       loop(MOperation->MClass)
//          info = "Operation " [MClass.name] "::" [MOperation.name] ": empty access set to public\n";
//       end loop
      return "public";
   case "protected" :
      // not supported by Ada
      loop(MOperation->MClass->SubClass where !makeChildPackage([MClass]))
         // needs to be public
         return "public";
      end loop
      return "private";
   default :
      loop(MOperation->MClass)
         info = "Operation " [MClass.name] "::" [MOperation.name] ": access " [MOperation.access] " unexpected\n";
      end loop
   end switch

end proc

//*****************************************************************************
// 7. Properties of relations
//*****************************************************************************

proc MAssociationEnd.getFullName()
   loop (MAssociationEnd -> MClass)
       return [MClass].getFullName() "." [MAssociationEnd.name];
   end loop
end proc

proc MAssociationEnd.getTaggedValue(tag,defaultValue)

   loop(MAssociationEnd->TaggedValue Where [TaggedValue.tag] == [tag])
      return [TaggedValue.value];
   end loop
   return [defaultValue];

end proc

proc MAssociationEnd.getTaggedValueBool(tag,defaultValue)

//T info = [MAssociationEnd].getFullName() " tag " [tag] " default " [defaultValue] " -> ";

   loop(MAssociationEnd->TaggedValue Where [TaggedValue.tag] == [tag])
//T info = "match:" [TaggedValue.value] "\n";
      switch (toUpper([TaggedValue.value]))
      case TRUE:
         return TRUE;
      case FALSE:
         return FALSE;
      default:
 info = "AssociationEnd " [MAssociationEnd].getFullName() " tag " [tag] " has illegal value " [TaggedValue.value] ". Using default " [defaultValue] "\n";
         return [defaultValue];
      end switch
    end loop
//T info = "not match: use default\n";
   return [defaultValue];

end proc

proc MAssociationEnd.visibility()

   local defaultVisibility = "public"; // the access operation !
   local visibility;

   if([MAssociationEnd:visibility] != "")
      return [MAssociationEnd:visibility];
   end if

   loop(MAssociationEnd->MAssociation->MAssociationEnd As FromRole->MClass As Partner Where [FromRole.id] != [MAssociationEnd.id])
      if(![Partner].getTaggedValueBool("Relation_Operations","TRUE"))
         [MAssociationEnd:visibility] = "never";
         return "never";
      end if
      if([Partner:isComposite])
         [defaultVisibility] = "private";
      end if
//T      info = "Rel " [Partner.name] "::" [MAssociationEnd:adaName] ": defaultVisib " [defaultVisibility] "\n";
   end loop
   
//NY  if([MAssociationEnd.access] != "")
//NY      [defaultVisibility] = [MAssociationEnd.access];
//NY   end if

   loop(MAssociationEnd->MAssociation->MAssociationEnd As FromRole->MClass As Partner Where [FromRole.id] != [MAssociationEnd.id])
      if(getClassPrivacy([Partner]) == "implementation")
         [defaultVisibility] = [defaultVisibility]"-child";
      end if
   end loop   
   [visibility] = toLower([MAssociationEnd].getTaggedValue("Visibility",[defaultVisibility]));

   if([visibility] == "read-only")
      [visibility] = "public-read-only";
   end if
   
   if([visibility] == "read-only-child")
      [visibility] = "public-child-read-only";
   end if
      
   switch([visibility])
   case "public":
   case "private":
   case "implementation":
   case "public-read-only":
   case "public-operation":
   case "private-read-only":
   case "private-operation":
   case "public-child":
   case "private-child":
   case "public-child-read-only":
   case "public-child-operation":
   case "private-child-read-only":
   case "private-child-operation":
      [MAssociationEnd:visibility] = [visibility];
      return [visibility];
   default :
      loop(MAssociationEnd->MAssociation->MAssociationEnd As FromRole->MClass As Partner Where [FromRole.id] != [MAssociationEnd.id])
         info = "Association " [Partner.name] "::" [MAssociationEnd.name] ": visibility " [visibility] " unsupported\n";
      end loop
      [MAssociationEnd:visibility] = [defaultVisibility];
      return [defaultVisibility];
   end switch

end proc

proc MAssociationEnd.isNavigable()

   loop(MAssociationEnd->MClass)
      if(isArray([MClass]))
         return FALSE;
      end if
   end loop
   loop(MAssociationEnd->MAssociation->MAssociationEnd As OtherEnd->MClass)
      if(isArray([MClass]))
         return FALSE;
      end if
   end loop
   
   return [MAssociationEnd.isNavigable];

end proc

proc MAssociation.getStereoType()

   loop(MAssociation->Note where [Note.type] == "UmlExtensibilityDefinition") 
      loop(Note->Item where [Item.type] == "UmlStereotype")
         return toLower([Item.value]);
       end loop
   end loop

   return "";
end proc


//*****************************************************************************
// 7.1  Properties of any element
//*****************************************************************************

// Why the hell did we introduce specific getTaggedValue procs ?

proc MElement.getTaggedValue(tag,defaultValue)

   loop(MElement->TaggedValue Where [TaggedValue.tag] == [tag])
      return [TaggedValue.value];
   end loop
   return [defaultValue];

end proc


//*****************************************************************************
// 8. Output file handling
//*****************************************************************************
      
proc genPrepare(fileName)

	mkdir(lsdir( [fileName]));
	output( [fileName] );
	info = "generate " getOutput() "\n";

end proc

/* returns TRUE when the given attribute instance has a virtual binding, FALSE else */
proc isVirtual(MClass)

loop(MClass->MAttribute)
   if([MAttribute.binding] == "virtual")
      return TRUE;
   else
      return FALSE;
   end if
end loop
end proc

//*****************************************************************************
// 9. collect packages
//*****************************************************************************
/* Each class is mapped in Ada onto a record type, which in terms is embedded into a
   package specification. Relations between classes cause components of the designated
   class type to be added to the class record type. The package defining the other class
   has to be imported then. For a bidirectional association this would cause two class
   packages to import each other, which is prohibited by the Ada language.
   
   In order to prevent this case, a simple form of graph partitioning is implemented here.
   
   Each set of classes which are coupled by bidirectional associations form a group. The
   classes in each group are althogether generated into one package. The package name is
   constructed by appending all class names in the group, separated by a '_'.
   
   The procedure collectPackages traverses all instances of MClass and constructs 
   the sets. An attribute 'group' is computed for each class which holds the number of
   the group the class belongs to. Classes in no group get the value '0' assigned to the
   attribute. All groups are collected in a global variable 'groupList' for later
   traversal.
   
   The attribute 'packageName' is then computed and added to each class based on the 
   group information. For a group the package name is stored in a global associative variable
   PackageName_<group>. */
proc collectPackages()

   local group;
   local glDelim;

   loop(Instances->MClass)
      [MClass:group] = 0;
   end loop
   
   // template classes and instance classes are never added to a group.
   // they are surrounded by a package with nothing else in but the template class or
   // its instance

   loop(Instances->MPackage where [MPackage].isGeneric())
      [MPackage:group] = "--";
      loop(MPackage->MClass where ![MClass].isGeneric())
         testInfo("Collect", [MClass.name] " in <<generic>> package " [MPackage.name] " suppressed\n");
         [MClass:group] = "--";
      end loop
   end loop

   loop(Instances->MPackage where [MPackage].isInstance())
      [MPackage:group] = "--";
      loop(MPackage->MClass where ![MClass].isInstance())
         testInfo("Collect", [MClass.name] " in instance package " [MPackage.name] " suppressed\n");
         [MClass:group] = "--";
      end loop
   end loop

   loop(Instances->MPackage where isSubsystemPackage([MPackage]) || [MPackage].isExternal())
      [MPackage:group] = "--";
   end loop
   
   [groupList] = ""; [glDelim] = "";
   setCount(0);
    
   /* real packages in Model take precedence over package collection upon dependency */

   loop(Instances->MPackage where [MPackage:group] != "--")

      addCount(1);
      [groupList] = [groupList] [glDelim] getCount();
      setGMC(getCount(),2); // a model package always has to be generated, even when empty
      clearUsed(getCount());
      [glDelim] = "\n";
//T      info = "Package " [MPackage.name] " creates group " getCount() "\n";
      [MPackage:group] = getCount();
      /* mark the members */
      loop(MPackage->MClass)
//T         info = "Add " [MClass.name] " to group " getCount() "\n";
         [MClass:group] = getCount();
         addToGMC(getCount(),1);
      end loop
      loop(MPackage->MClass)
         addUsed(getCount(),[MClass]);
      end loop
      namePackage([MPackage]);
      setGN(getCount(), [MPackage:packageName]);
      setGK(getCount(), [MPackage].getStereoType());
      testInfo("Collect2", "Used:" getUsed(getCount()) "\n");
   end loop

   loop(Instances->MNormalClass where [MNormalClass:group] == 0 && ![MNormalClass].isExternal())
      addCount(1);
      [groupList] = [groupList] [glDelim] getCount();
      [glDelim] = "\n";
      setGMC(getCount(),1);
//T      info = "Class " [MNormalClass.name] " creates group " getCount() "\n";
      [MNormalClass:group] = getCount();
      setGN(getCount(), [MNormalClass.name]);
      setGK(getCount(), [MNormalClass].getStereoType());
      clearUsed(getCount());
      addUsed(getCount(),[MNormalClass]);
      testInfo("Collect2", "Used:" getUsed(getCount()) "\n");
   end loop

   // now handle the dependencies
   
   updateDependencies();

   loop(Instances->TokenSet([groupList]))
      testInfo("Collect", "Group " [TokenSet.line] " -> member count " getGMC([TokenSet.line]) "\n"); 
   end loop

   loop(Instances->TokenSet([groupList]) where getGMC([TokenSet.line]) == 1)
//T      info = "Group " [TokenSet.line] " eliminated\n";
      loop(Instances->MClass where [MClass:group] == [TokenSet.line])
//T         info = "   Class " [MClass.name] " removed from group\n";
         [MClass:group] = 0;
      end loop
      setGMC([TokenSet.line],0);
   end loop
   
   loop(Instances->MClass)
      testInfo("Collect", "Class " [MClass.name] " -> " [MClass:group] "\n"); 
   end loop

end proc

// group member count

proc setGMC(Group,value)

   local s = "GMC_" [Group];
   [[s]] = [value];

end proc

proc getGMC(Group)

   local s = "GMC_" [Group];
   return [[s]];

end proc

proc addToGMC(Group,value)

   local s = "GMC_" [Group];
   [[s]] = add([[s]],[value]);

end proc

proc setGN(Group,value)

   local s = "GN_" [Group];
   [[s]] = [value];

end proc

proc getGN(Group)


   local s = "GN_" [Group];
   return [[s]];

end proc

proc addToGN(Group,value)

   local s = "GN_" [Group];
   [[s]] = [value] ":" [[s]];

end proc

proc setGK(Group,value)

   local s = "GK_" [Group];
   [[s]] = [value];

end proc

proc getGK(Group)


   local s = "GK_" [Group];
   return [[s]];

end proc

proc updateDependencies()

   local changed = FALSE;
   local s;

   testInfo("Collect2", ">Update Dependencies\n"); 
   
   loop(Instances->TokenSet([groupList]) where getGMC([TokenSet.line]) > 0)
   
      local Group = [TokenSet.line];
      testInfo("Collect2", "-Group " [Group] "\n"); 
   
      // reset all "visited" marks
         
      loop(Instances->TokenSet([groupList]) As GL)
         clearVisited([GL.line]);
      end loop
   
      local result = followNavigableRelations([Group],[Group]," ");
      switch([result])
      case "cycle":
         /* this group reaches itself, merge in all groups on the "visited" path */

         /* need to do it again */
         [changed] = TRUE;
         break;
      case "dead":
         /* dead end */
         break;
      default:
         info = "ERROR\n";
      end switch
   end loop
   
   if([changed])
      updateDependencies();
   end if

   testInfo("Collect2", "<Update Dependencies\n"); 
         
end proc

proc clearUsed(Group)

   local s = "Used_" [Group];
   [[s]] = "";
   
end proc

proc addUsed(Group,MClass)

   local s = "Used_" [Group];

   /* follow navigable relations, if classPrivacy is not implementation */
   if (getClassPrivacy([MClass]) != "implementation")
      loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [Partner:group] != [Group] && inUsed([Partner],[Group]) == FALSE)
         if([ToRole].isNavigable())
            testInfo("Collect2", "   relation " [ToRole.id]"("[ToRole].isNavigable()") to " [Partner.name] ":" [Partner:group] "\n"); 
            [[s]] = [[s]] " " [Partner.id];
         end if
      end loop         
   end if
   
   /* follow superclass */
   loop(MClass->SuperClass As Partner where [Partner:group] != [Group] && inUsed([Partner],[Group]) == FALSE)
      testInfo("Collect2", "   superclass " [Partner.name] ":" [Partner:group] "\n"); 
      [[s]] = [[s]] " " [Partner.id];
   end loop         

end proc 

proc inUsed(MClass,Group)

   local s = "Used_" [Group];

   if(regexp([[s]]," "[MClass.id]" ") != "")
      return TRUE;
   else
      return FALSE;
   end if
   
end proc

proc getUsed(Group)

   local s = "Used_" [Group];
   return [[s]];

end proc

proc clearVisited(Group)

   local s = "V_" [Group];
   [[s]] = FALSE;

end proc

proc isVisited(Group)

   local s = "V_" [Group];
   return [[s]];

end proc

proc setVisited(Group)

   local s = "V_" [Group];
   [[s]] = TRUE;

end proc

proc mergeIn(Dest,Src)

   if([Dest] == [Src])
      return;
   end if
   
   testInfo("Collect2", "Merge groups " [Dest] "(" getGN([Dest]) ") and " [Src] "(" getGN([Src]) ")\n");

   addToGMC([Dest],getGMC([Src]));
   setGMC([Src],0);
   addToGN([Dest],getGN([Src]));
   setGK([Dest],"--");
      
   loop(Instances->MClass where [MClass:group] == [Src])
      [MClass:group] = [Dest];
   end loop
   clearUsed([Dest]);
   loop(Instances->MClass where [MClass:group] == [Dest])
      addUsed([Dest],[MClass]);
   end loop
   testInfo("Collect2", "Used:" getUsed([Dest]) "\n");

end proc 
 
proc followNavigableRelations(StartGroup,ThisGroup,Tab)

   local result = 0;
   local targetList = getUsed([ThisGroup]);
   local Tag = "FNR(" [StartGroup] "(" getGN([StartGroup]) ")/" [ThisGroup] "(" getGN([ThisGroup]) "))";
   local group; 

   testInfo("Collect2", [Tab] ">" [Tag] "\n"); 
   setVisited([ThisGroup]);

   loop(Instances->MClass([targetList]) As Partner)
      [group] = [Partner:group];    
      testInfo("Collect2",  [Tab] "-" [Tag] " Partner " [Partner.name] "." [group] "\n");
      if([group] == [StartGroup])
         testInfo("Collect2", [Tab] "<" [Tag] " reached startpoint by target -> cycle\n"); 
         // this is a cycle
         return "cycle";
      else if(isVisited([group]))
         testInfo("Collect2", [Tab] "-" [Tag] " already visited group\n"); 
         // we handled this before, skip
      else
         [result] = followNavigableRelations([StartGroup],[group],[Tab]" ");
         testInfo("Collect2",  [Tab] "-" [Tag] " back from " [Partner.name]  "." [group] " -> " [result] "\n"); 
         if([result] == "cycle")
            mergeIn([StartGroup],[group]);
            testInfo("Collect2", [Tab] "<" [Tag] " -> cycle\n"); 
            return "cycle";
         end if
      end if end if
   end loop
   testInfo("Collect2", [Tab] "<" [Tag] " -> dead\n"); 
   return "dead";
   
end proc

proc deriveNames()

   /* 1. create a package name for the classes according to their group and model package */

   /* by construction, classes in group 0 are not enclosed by a package in the model
      except for a <<generic>> package enclosing a single template class or an instantiation
      package enclosing a single instance class */
   testInfo("Names", "Name Classes in Group 0\n");
//??   loop(Instances->MClass(MClass_by_group(0))  && isTypemapping([MClass]) == FALSE)
   loop(Instances->MClass where [MClass:group] == 0 && isTypemapping([MClass]) == FALSE)
      nameClassPackage([MClass]);
   end loop

   testInfo("Names",  "Name groups\n");
   loop(Instances->TokenSet([groupList]))
      namePackageGroup([TokenSet.line]);
   end loop  

   loop(Instances->MClass where [MClass:group] != "--")
      testInfo("Names",  "Class " [MClass.name] " name " [MClass:subSystemPath]"/"[MClass:packageName] " in cu " [MClass:cuName] " group " [MClass:group] "\n");
   end loop

   loop(Instances->MClass)
      [MClass:fileName] = [MClass:fileNamePrefix][MClass:packageName];
   end loop


   /* 2. create a component name for each association end which is navigable.
      By this an a.e. without name is not navigable, i.e. no code will be generated */

   loop(Instances->MClass)
      [MClass:isComposite] = FALSE;
   end loop
      
   loop(Instances->MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole].isNavigable())
      testInfo("Names",  "NAV " [FromRole.id]"/"[ToRole.id] " " [MClass.name] " -> " [Partner.name] "\n");

      if([FromRole.aggregation] == "Aggregation")
         [ToRole:adaName] = genRoleName([ToRole])"_part";
         [ToRole:isPointer] = TRUE;
         [ToRole:makePointer] = "";
      else if([FromRole.aggregation] == "Composition")
         [ToRole:adaName] = genRoleName([ToRole])"_part";
         [ToRole:isPointer] = FALSE;
         [ToRole:makePointer] = "'access";
         [Partner:isComposite] = TRUE;
      else if([ToRole.aggregation] != "None")
         [ToRole:adaName] = genRoleName([ToRole])"_whole";
         [ToRole:isPointer] = TRUE;
         [ToRole:makePointer] = "";
      else
         [ToRole:adaName] = genRoleName([ToRole])"_asc";
         [ToRole:isPointer] = TRUE;
         [ToRole:makePointer] = "";
      end if end if end if
     
      local multiplicity = getMultiplicity([ToRole.multiplicity]);

      switch([multiplicity]) 
      case "Many" :
// wdh: you can activate an alternate mechanism e.g. via   
//       if ([ToRole.ordering])
         if (TRUE)
            [ToRole:mechanism] = "GetSetWithAlloc";
         else
            [ToRole:mechanism] = "AddStartMoreNext";
	    [ToRole:ctxTypeName] = [MClass.name] "_" [ToRole:adaName] "_context";
         end if
	 [ToRole:ptrTypeName] = [MClass.name] "_" [ToRole:adaName] "_ptr";
	 [ToRole:arrayTypeName] = [MClass.name] "_" [ToRole:adaName] "_array";
         break;
      case "One" :
         [ToRole:mechanism] = "GetSet";
         break;
      default :
         [ToRole:mechanism] = "GetSet";
	 [ToRole:arrayTypeName] = [MClass.name] "_" [ToRole:adaName] "_array";
         break;
      end switch

   end loop

end proc

proc nameClassPackage(MClass)

   testInfo("Names",  "Name " [MClass.name]);

   if([MClass:group] != 0 && getPackageNameOfGroup([MClass:group]) == "")
      namePackageGroup([MClass:group]);
   end if

   loop(MClass->MPackage where isSubsystemPackage([MPackage]) == FALSE)
      namePackage([MPackage]);
   end loop

   if([MClass].isGeneric())
      testInfo("Names",  " generic ");
      loop(MClass->MPackage where [MPackage].isGeneric())
         // the template package is named as found in the model, but as a local package
         
	 [MClass:packageName] = [MPackage.name];
         testInfo("Names",  " -> " [MClass:packageName] "\n");
	 [MClass:cuName] = [MPackage:cuName];
	 [MClass:referenceName] = [MPackage:packageName];

         return;
      end loop
      
      // no <<generic>> package in the model around this class

      [MClass:packageName] = [MClass.name] "_template";
      testInfo("Names",  " -> " [MClass:packageName] "\n");

      if([MClass:group] != 0)
         // make template package a local package of the group package
         [MClass:cuName] = getCuNameOfGroup([MClass:group]);
         [MClass:referenceName] = [MClass:cuName] "." [MClass:packageName];
         return;
      end if

      loop(MClass->MPackage where [MPackage].isExternal() == FALSE && isSubsystemPackage([MPackage]) == FALSE )
         // make template package a local package of the surrounding model package
         [MClass:cuName] = [MPackage:cuName];
         [MClass:referenceName] = [MClass:cuName] "." [MClass:packageName];
         return;
      end loop
      
      // no model package arround, make the template package a compilation unit
      [MClass:cuName] = [MClass:packageName];
      [MClass:referenceName] = [MClass:cuName];
      return;
   end if

   if([MClass].isInstance())
      testInfo("Names",  " instance ");
      loop(MClass->MPackage where [MPackage].isInstance())
         // the instance package is named as found in the model, but as a local package

	 [MClass:packageName] = [MPackage:packageName];
         testInfo("Names",  " -> " [MClass:packageName] "\n");
	 [MClass:cuName] = [MPackage:cuName];
	 loop(MClass->MInstantiatedClass->MTemplateClass)
	    [MClass:referenceName] = [MClass:packageName] "." [MTemplateClass.name];
         end loop
         
         return;
      end loop
      
      testInfo("Names",  " -> " [MClass.name] "_inst...\n");
      local name = [MClass.name] "_inst";
      /*** appending parameters is not necessary and might cause syntaz errors (e.g. for real or string literals)
      loop(MClass->MInstantiatedClass->InstPara)
         if([InstPara.type] != "")
            [name] = [name] "_" [InstPara.type];
         else
            [name] = [name] "_" [InstPara.name];
         end if
      end loop
      ***/
      [MClass:packageName] = [name];
      testInfo("Names",  " -> " [MClass:packageName] "\n");

      if([MClass:group] != 0)
         // make instance package a local package of the group package
         [MClass:cuName] = getCuNameOfGroup([MClass:group]);
         // references must name the template class name in Ada, the instance is a
         // package only
         loop(MClass->MInstantiatedClass->MTemplateClass)
	    [MClass:referenceName] = [MClass:cuName] "." [MClass:packageName] "." [MTemplateClass.name];
         end loop
         return;
      end if
      
      loop(MClass->MPackage where [MPackage].isExternal() == FALSE && isSubsystemPackage([MPackage]) == FALSE)
         // make instance package a local package of the surrounding model package
        [MClass:cuName] = [MPackage:cuName];
         // references must name the template class name in Ada, the instance is a
         // package only
         loop(MClass->MInstantiatedClass->MTemplateClass)
	    [MClass:referenceName] = [MClass:cuName] "." [MClass:packageName] "." [MTemplateClass.name];
         end loop
         return;
      end loop
      
      // no model package arround, make the instance package a compilation unit
      [MClass:cuName] = [MClass:packageName];
      loop(MClass->MInstantiatedClass->MTemplateClass)
	 [MClass:referenceName] = [MClass:packageName] "." [MTemplateClass.name];
      end loop
      return;
   end if

   // this is neither a template nor an instance
   // determine a package for the class 

   if([MClass:group] != 0)
      [MClass:packageName] = getPackageNameOfGroup([MClass:group]);
      testInfo("Names",  " -> " [MClass:packageName] "\n");
      if(isCOMClass([MClass]))
         [MClass:cuName] = [MClass:packageName] "." [MClass.name];
      else
         [MClass:cuName] = [MClass:packageName];
      end if
      [MClass:referenceName] = [MClass:cuName] "." [MClass.name];
      if(getLength([MClass:packageName]) > 30)
         [MClass:cuNickName] = "P"[MClass:group];
         [MClass:referenceNickName] = "P"[MClass:group] "." [MClass.name];
      end if
      return;
   end if
 
   loop(MClass->MPackage where isSubsystemPackage([MPackage]) == FALSE)
      [MClass:packageName] = [MPackage:packageName];
      tryChildOfSuperclass([MClass]);
      testInfo("Names",  " -> " [MClass:packageName] "\n");
      [MClass:cuName] = [MPackage:cuName];
      [MClass:referenceName] = [MClass:packageName] "." [MClass.name];
      return;
   end loop

   if([MClass].getStereoType() == "main")
      [MClass:packageName] = [MClass.name];
   else
      [MClass:packageName] = [MClass.name] "_pkg";
   end if
   tryChildOfSuperclass([MClass]);
   testInfo("Names",  " -> " [MClass:packageName] "\n");
   [MClass:cuName] = [MClass:packageName];
   [MClass:referenceName] = [MClass:packageName] "." [MClass.name];
   return;
   
end proc

proc tryChildOfSuperclass(MClass)


   if(makeChildPackage([MClass]))
      loop(MClass->SuperClass)
         testInfo("Names",  "   Make " [MClass.name] " child of " [SuperClass.name] "\n");
         if([SuperClass:group] != 0) 
            namePackageGroup([SuperClass:group]);
         else
            nameClassPackage([SuperClass]);
         end if
         [MClass:packageName] = [SuperClass:packageName] "." [MClass:packageName];
         [MClass:cuName] = [SuperClass:cuName] "." [MClass:cuName];
         [MClass:referenceName] = [SuperClass:packageName] "." [MClass:referenceName];
      end loop
   end if
   
end proc

/* construct the package name for the instance of MPackage, i.e. concat all enclosing packages */
proc namePackage(MPackage)

   // we assume currently that package nesting in the model implies child packages
   // therefore cuName = packageName holds here

   local packageList = getIdListRec(MPackage->Domain) [MPackage.id];
   local packageName = "";

   testInfo("Names", "   NP packageList " [MPackage.name] ": " [packageList] "\n");
   setDelim("");
   loop(Instances->MPackage([packageList]) As allPackage where !isSubsystemPackage([allPackage]))
         [packageName] = [packageName] delim() [allPackage.name];
         setDelim(".");
   end loop
   testInfo("Names",  "-> " [packageName] "\n");
   [MPackage:cuName] = [packageName];
   [MPackage:packageName] = [packageName];
   testInfo("Names",  "Package " [MPackage.name] " group " [MPackage:group]" -> package " [MPackage:packageName] " in cu " [MPackage:cuName] "\n");

end proc

/* construct the package name for the given group, i.e. concat all class names in the group */
proc namePackageGroup(Group)

   local name = "";

   testInfo("Names", "NPG " [Group] "\n");

   /* is there a model package other than subsystem, instance, <<generic>> ? */
   loop(Instances->MPackage where [MPackage:group] == [Group])
      if([MPackage:packageName] == "")
         namePackage([MPackage]);
      end if
      [name] = [MPackage:packageName];
      testInfo("Names", "NPG pkg " [MPackage.name] " name = " [name] "\n");
   
      [PackageName_[Group]] = [name];
      [CuName_[Group]] = [name];
      [FileName_[Group]] = [MPackage:fileNamePrefix] [name];
      testInfo("Names",  "   Group " [Group] " -> package " [name] " File " [FileName_[Group]]"\n");
      loop(Instances->MClass(MClass_by_group([Group])))
         nameClassPackage([MClass]);
      end loop
      return;
   end loop
   
   /* no model package around * /
   loop(Instances->MClass(MClass_by_group([Group]));setDelim("");setDelim("_"))
      testInfo("Names", "NPG add " [MClass.name] "\n");
      [name] = [name] delim() [MClass.name];
   end loop
   
   use name derived during collection of group */
   
   [name] = getAdaGroupName(getGN([Group]));
   
   [name] = [name] "_pkg";
   
   [PackageName_[Group]] = [name];
   [CuName_[Group]] = [name];
   [FileName_[Group]] = [name];
   testInfo("Names",  "   Group " [Group] " -> package " [name] "\n");
   loop(Instances->MClass(MClass_by_group([Group])))
      nameClassPackage([MClass]);
   end loop

end proc

tcl_proc getAdaGroupName(str)

	set result "";
	set lc "_";
	set li [split $str ":"];
	set sli [lsort $li];
	foreach {elem} $sli {
		if {$result == ""} {
			set result $elem
		} else {
			set result [concat $result$lc$elem]
		}
	}
	return $result	

end proc


/* evaluate subsystem stereotypes for packages */
proc determineSubsystems()

	loop(Instances->MPackage->MClass)
		[MPackage:subSystemPath] = [MPackage].getSubsystemPath();
		[MClass:subSystemPath] = [MPackage:subSystemPath];
		[MClass:fileNamePrefix] = [MPackage:fileNamePrefix];
		[SubsystemPath_[MClass:group]] = [MPackage:subSystemPath];
	end loop
	loop(Instances->MClass where [MClass:subSystemPath] == "")
		[MClass:subSystemPath] = [MClass].getSubsystemPath();
                [SubsystemPath_[MClass:group]] = [MClass:subSystemPath];
                [MClass:fileNamePrefix] = "";
	end loop

   loop(Instances->MClass)
      testInfo("Names",  "Class " [MClass.name] " -> subsysPath " [MClass:subSystemPath] [MClass:fileNamePrefix]"\n"); 
   end loop

   // init name - id mappings

   loop(Instances->MPackage->MClass where !isSubsystemPackage([MPackage]))
	[PackageOfClass_[MClass.name]] = [MPackage.id];
	testInfo("Names",  "Package of class " [MClass.name] ": " [PackageOfClass_[MClass.name]]"\n");
   end loop

   loop(Instances->MClass where [PackageOfClass_[MClass.name]] == "")
	[PackageOfClass_[MClass.name]] = [MClass.id];
	testInfo("Names",  "Package of class " [MClass.name] ": " [PackageOfClass_[MClass.name]]"\n");
   end loop

end proc

//^
// Construct the file path based on the nesting of packages in the model which are subsystems
// as marked by a stereotype
// wdh: As a side effect, we compute and assign [MPackage:fileNamePrefix] by catenating the
// TaggedValue "FileNamePrefix" of all enclosing subsystems.
//
proc MPackage.getSubsystemPath()

	local packageList = getIdListRec(MPackage->Domain) [MPackage.id];
	local path = "";
	local fileNamePrefix = "";
	
	testInfo("Names","getSubsystemPath " [MPackage.name] ":" [packageList]);
	loop(Instances->MPackage([packageList]) As allPackage where isSubsystemPackage([allPackage]))
		[path] = [path] "/" [allPackage.name];
		[fileNamePrefix] = [fileNamePrefix][allPackage].getTaggedValue("FileNamePrefix","");
	end loop
	[MPackage:fileNamePrefix] = [fileNamePrefix];

	testInfo("Names"," -> " [path] [MPackage:fileNamePrefix]"\n");
	return [path];

end proc

proc MClass.getSubsystemPath()

	local result = "";

	testInfo("Names","getSubsystemPath " [MClass.name]);
	loop(Instances->MPackage->MClass As C where isSubsystemPackage([MPackage]) && [C.id] == [MClass.id])
		testInfo("Names"," package " [MPackage.name] " -> ");
		return [MPackage].getSubsystemPath();
	end loop

	testInfo("Names"," -> \n");
	return "";

end proc

/* determine the name of a role */
proc genRoleName(MAssociationEnd)

   if([MAssociationEnd:genRoleNameResult] != "")
      return [MAssociationEnd:genRoleNameResult];
   end if

   local result = [MAssociationEnd.name];
   local className = "";
   if([result] != "")
      [MAssociationEnd:genRoleNameResult] = [result];
      return [MAssociationEnd:genRoleNameResult];
   end if
// the default does not work for unnamed MAssociationEnd

// if desired, the name of the association can be used for the component being generated
// in this case, decomment the following if statement
//
   loop(MAssociationEnd->MClass)
      [className] = [MClass.name];
      [result]    = [className];
   end loop

   if([result] == [className])
      // try to take name of association
      loop(MAssociationEnd->MAssociation where [MAssociation.name] != "")
         [MAssociationEnd:genRoleNameResult] = [MAssociation.name];
         return [MAssociationEnd:genRoleNameResult];
      end loop
   end if
   if([result] == "")
      info = "genRoleName cannot generate a useful name. returning SomeRole\n";
      [MAssociationEnd:genRoleNameResult] = "SomeRole";
      return [MAssociationEnd:genRoleNameResult];

   end if
 
   [MAssociationEnd:genRoleNameResult] = [result];
   return [MAssociationEnd:genRoleNameResult];

end proc

/* deliver the package name of group 'Group' */
proc getPackageNameOfGroup(Group)

   return [PackageName_[Group]];
   
end proc

/* deliver the package name of group 'Group' */
proc getCuNameOfGroup(Group)

   return [CuName_[Group]];
   
end proc

/* deliver the file name of group 'Group' */
proc getFileNameOfGroup(Group)

   return [FileName_[Group]];
   
end proc

/* deliver the package name of group 'Group' */
proc getSubsystemPathOfGroup(Group)

   return [SubsystemPath_[Group]];
   
end proc

//*****************************************************************************
// 13. How to handle classes at parameter/result type position and in associations
//*****************************************************************************

//^
// Generate the parameter type to access a class read only
//
proc getClassParamForRead(MClass)

   local selection = importClass([MClass]);

   testInfo("TypeMapping", "ClassParamForRead " [MClass.name]);

   if (isTagged([MClass]))
       testInfo("TypeMapping", " -> " [selection] "'class\n");
      return [selection] "'class";
   else if (getClassPrivacy([MClass]) == "implementation")
       testInfo("TypeMapping", " -> " [selection] "_ptr\n");
       return [selection] "_ptr";
   else     
       testInfo("TypeMapping", " -> " [selection] "\n");
       return [selection];
   end if end if

end proc

//^
// Generate the parameter type to access a class for read and write
//
proc getClassParamForUpdateOld(MClass)

   //Bug in OA 7.1.2 lets this version fail

   local selection = importClass([MClass]);

   testInfo("TypeMapping", "ClassParamForUpdate " [MClass.name]);
   
   if(isTagged([MClass]))
      testInfo("TypeMapping", "-> access " [selection] "'class\n");
      return "access " [selection] "'class";
//      if(doGenClassPtr([MClass]))
//         return [selection] "_cptr";
//      else if(!isVirtual([MClass]))
//         return "access " [selection] "'class";
//      end if end if
   else if(getClassPrivacy([MClass]) == "implementation")
      testInfo("TypeMapping", "-> " [selection] "_ptr\n");
      return [selection] "_ptr";
   else
      testInfo("TypeMapping", " access " [selection] "\n");
      return "access " [selection];
//      if(doGenPtr([MClass]))
//         return [selection] "_ptr";
//      else
//         return "access " [selection];
//      end if
   end if end if

end proc

proc getClassParamForUpdate(MClass)

   local selection = importClass([MClass]);
   local result = "";

   testInfo("TypeMapping", "ClassParamForUpdate " [MClass.name]);
   
   if(isTagged([MClass]))
      if(doGenClassPtr([MClass]))
         [result] = [selection] "_cptr";
      else if(!isVirtual([MClass]))
         [result] = "access " [selection] "'class";
      else
         [result] = "access " [selection];
      end if end if
   else if(getClassPrivacy([MClass]) == "implementation")
      [result] = [selection] "_ptr";
   else
      if(doGenPtr([MClass]))
         [result] = [selection] "_ptr";
      else
         [result] = "access " [selection];
      end if
   end if end if

   testInfo("TypeMapping", " -> " [result] "\n");
   return [result];

end proc

//^
// Generate the parameter type to access a class for read and write
//

proc getPrefixIfCountedRefAssoc(MClass,tag,selection)
// check whether there is an association with sterotype that indicates the use of counted references
// if so, return the name of the counted ref type.
// return "" otherwise

   local result = "";
   
   loop(MClass->Role As ToRole->MAssociation->MAssociationEnd As FromRole->MClass As FromClass  
        Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [FromClass.name] == [tag] 
              && [ToRole:isPointer] && [MAssociation].getStereoType() == "counted_ref")
	    
      [result] = [selection] "_Smart_Cptr";
//      testInfo("wdh","getPrefixIfCountedRefAssoc from " [tag] " to "[MClass.name] " -> ""FromClass=" [FromClass.name] " Sterotype "[MAssociation].getStereoType() " result " [result] "\n");
          
      testInfo("TypeMapping","getPrefixIfCountedRefAssoc from " [MClass.name] " to "[tag] " -> " [result] "\n");
   end loop
   
   return [result];

end proc

proc genCvtToClassTypeForAssociation(MClass,tag)

   local selection = importClass([MClass]);
   local result = "";
   
   [result] = getPrefixIfCountedRefAssoc([MClass],[tag],[selection]);
   if([result] != "")
      // just use the result from getClassTypeForCountedRefAssoc
      [result] = [result]".Create";
   else 
      // this means a simple type conversion, use just the type name
      [result] = getClassTypeForAssociation([MClass],[tag]);
   end if
   return [result];
end proc

proc getClassTypeForAssociation(MClass,tag)

   testInfo("TypeMapping", "ClassTypeForAssociation " [MClass.name]);

   local selection = importClass([MClass]);
   local result = "";
   
   [result] = getPrefixIfCountedRefAssoc([MClass],[tag],[selection]);
   if([result] != "")
      [result] = [result]".Smart_Pointer";
   else if(isTagged([MClass]))
      if(doGenClassPtr([MClass]))
         [result] = [selection]"_cptr";
      else
         insert("publicsupptypes_"[tag],"type " [tag] "_" [MClass.name] "_cptr is access all " [selection] "'class;\n");
         [result] = [tag] "_"[MClass.name] "_cptr";
      end if
   else if (getClassPrivacy([MClass]) == "implementation")
      [result] = [selection]"_ptr";
   else
      if(doGenPtr([MClass]))
         [result] = [selection]"_ptr";
      else
         insert("publicsupptypes_"[tag],"type " [tag] "_" [MClass.name] "_ptr is access all " [selection] ";\n");
         [result] = [tag] "_" [MClass.name] "_ptr";
      end if
   end if end if end if
   

   testInfo("TypeMapping", " -> " [result] "\n");
   return [result];

end proc

//^
// Generate the result type for a function returning the class
//
proc getClassResultType(MClass,Pointer)

   testInfo("TypeMapping", "ClassResultType " [MClass.name] " " [Pointer]);

   local selection = importClass([MClass]);
   local result = "";
   
   if(isTagged([MClass]))
      if(![Pointer])
         [result] = [selection];
      else if(doGenClassPtr([MClass]))
         [result] = [selection] "_cptr";
      else
         [result] = [selection] "'class";
      end if end if
   else if (getClassPrivacy([MClass]) == "implementation")
      [result] = [selection] "_ptr";
   else
      if(![Pointer])
         [result] = [selection];
      else if(doGenPtr([MClass]))
         [result] = [selection] "_ptr";
      else
         [result] = [selection];
      end if end if
   end if end if

   testInfo("TypeMapping", " -> " [result] "\n");
   return [result];

end proc

//^
// Generate the id list for the class(es) with specified group.
// Note that we often expect a single MClass in the list.
// This was introduced to improve the code generator performance.
//
proc MClass_by_group (group)

   local x = "MClass_by_group_Cache_For_" [group];
   
   if ([[x]] == "")
      loop(Instances -> MClass where [MClass:group] == [group])
         [[x]] = [[x]] " " [MClass.id];
//T info = "MClass_by_group #" [x]" -> "[[x]]"\n";  
      end loop
   end if

//T info = "MClass_by_group :" [x]" -> "[[x]]"\n";   
   return [[x]];
end proc

//^
// Generate the Ada type for a type name in the model
//
proc genParameterType(typeString)

   local result;

   testInfo("TypeMapping", "GetParameterType " [typeString]);
  
   [result] = replace([typeString]," *\*","");
   if([result] != [typeString])
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         testInfo("TypeMapping", "access Class " [MClass.name] "\n");
         return getClassParamForUpdate([MClass]);
      end loop
      // not a class, use 'access
      return typeReference([result],"access ");
   else
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         testInfo("TypeMapping", "Class " [MClass.name] "; ");
         return getClassParamForRead([MClass]);
      end loop
   end if
  
   // last resort
   return typeReference([result],"");

end proc

//^
// Generate the Ada type for a type name in the model
//
proc genActualParameterType(typeString)

   local result;
   
   testInfo("TypeMapping", "GetActualParameterType " [typeString]);
  
   [result] = replace([typeString]," *","");
   if([result] != [typeString])
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         return getClassParamForUpdate([MClass]);
      end loop
      // not a class, use 'access
      info = "Restriction: type other than class used in instance class must not include *\n";
      testInfo("TypeMapping", " -> " [typeString] "\n");
      return [typeString];
   else
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         return getClassParamForRead([MClass]);
      end loop
   end if
  
   // last resort
   return typeReference([result],"");

end proc

//^
// Generate the Ada type for a type name in the model
//
proc genComponentType(typeString)

   local result;

   testInfo("TypeMapping", "GetParameterType " [typeString]);
  
   [result] = replace([typeString]," *\*","");
   if([result] != [typeString])
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         testInfo("TypeMapping", "access Class " [MClass.name] "\n");
         return getClassParamForUpdate([MClass]);
      end loop
      // not a class, use access (won't compile, TBD: introduce pointer type)
      return typeReference([result],"access ");
   else
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         testInfo("TypeMapping", "Class " [MClass.name] "; ");
         local selection = importClass([MClass]);

         if (getClassPrivacy([MClass]) == "implementation")
            testInfo("TypeMapping", " -> " [selection] "_ptr\n");
            return [selection] "_ptr";
         else     
            testInfo("TypeMapping", " -> " [selection] "\n");
            return [selection];
         end if
      end loop
   end if
  
   // last resort
   return typeReference([result],"");

end proc

//^
// Generate the Ada type for a type name in the model
//
proc genResultType(typeString)

   local result;

   testInfo("TypeMapping", "genResultType " [typeString]);
  
//wdh 00/10/17   [result] = replace([typeString]," *","");
   [result] = replace([typeString]," *\*","");
   if([result] != [typeString])
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         return getClassResultType([MClass],TRUE);
      end loop
      // not a class, use 'access
      info = "Restriction: result type "[typeString]" other than class must not include *.  "[result]"\n";
      return [typeString];
   else
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         return getClassResultType([MClass],FALSE);
      end loop
   end if
  
   // last resort
   return typeReference([result],"");

end proc

proc genResultObjectType(typeString)

   local result;

   testInfo("TypeMapping", "GetResultObjectType " [typeString] " ");

//wdh 00/11/09, same logic for "class_name*" as in genResultType  
   [result] = replace([typeString]," *\*","");
   if([result] != [typeString])
      loop(Instances->MClass(MClass_ids_by_name ([result])) where !isTypemapping([MClass]))
         return getClassResultType([MClass],TRUE);
      end loop
      // not a class
      info = "Restriction: result type "[typeString]" other than class must not include *.  "[result]"\n";
   end if
      
   [result] = replace(toLower([typeString]),"'class","");
   return typeReference ([result],"");

end proc

proc typeReference(typeString,prefix)

   local Pkg;
   local result;

   testInfo("TypeMapping", " -> typeRef P:" [prefix] " T:" [typeString] " -> ");
   
   /* several cases possible here:
      - a variation of a class or data type class, i.e. followed by _ptr or _cptr
      - a type completely outside the model
      - a qualified name

      try to figure out the package for class case only here
      leave name as it is
      
      */  
   
   loop(Instances->MClass(MClass_ids_by_name ([typeString]))->MDataType->TaggedValue
	Where [TaggedValue.tag] == [language])
      testInfo("TypeMapping", "MDataType " [MDataType.name] " -> ");
      [Pkg] = [MDataType:packageName];
      if([Pkg] != "")
         insert("include",[MDataType.id]);
         testInfo("TypeMapping", [prefix] [Pkg] "." [TaggedValue.value] "\n");
         return [prefix] [Pkg] "." [TaggedValue.value];
      else
         testInfo("TypeMapping", [prefix] [TaggedValue.value] "\n");
         [Pkg] = getPrefix([TaggedValue.value],".");
         if([Pkg] != "")
            testInfo("TypeMapping", "(found import " [Pkg] ") ");
            insert("include",[Pkg]);
         end if
         return [prefix] [TaggedValue.value];
      end if
   end loop

   local typeSpec = lastWord([typeString]," "); // get rid of passing mode keywords
   local frontString = getPrefix([typeString]," "); // get rid of passing mode keywords
   local subString = [typeSpec];

   testInfo("TypeMapping", "   front " [frontString] " tail " [subString] "\n");
	
   // is it already a class name ?
   // This check can be omitted, if not appropriate
	
   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      testInfo("TypeMapping", "class " [MClass.id] " -> ");
      testInfo("TypeMapping", [prefix] [frontString] [MClass:packageName] "." [typeSpec] "\n");
      insert("include",[MClass.id]);
      return [prefix] [frontString] [MClass:packageName] "." [typeSpec];
   end loop

   // strip constraint, if any
	
   [subString] = stripConstraint([subString]);

   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      testInfo("TypeMapping", "class " [MClass.id] " -> ");
      testInfo("TypeMapping", [prefix] [frontString] [MClass:packageName] "." [typeSpec] "\n");
      insert("include",[MClass.id]);
      return [prefix] [frontString] [MClass:packageName] "." [typeSpec];
   end loop
	
   // strip _ptr or _cptr, if any

   [subString] = stripPointer([subString]);

   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      testInfo("TypeMapping", "class " [MClass.id] " -> ");
      testInfo("TypeMapping", [prefix] [frontString] [MClass:packageName] "." [typeSpec] "\n");
      insert("include",[MClass.id]);
      return [prefix] [frontString] [MClass:packageName] "." [typeSpec];
   end loop

   [frontString] = getPrefix([subString],".");
   if([frontString] != "")
      testInfo("TypeMapping", "(found import " [frontString] ") ");
      insert("include",[frontString]);
   end if
   testInfo("TypeMapping", [prefix] [typeString] "\n");
   return [prefix] [typeString];

end proc

proc genExpression(expr)

   testInfo("TypeMapping", "genExpression " [expr] "\n");
   local path = regexp([expr],"[A-Za-z][A-Za-z0-9_\.]*\.");

   if([path] != "")
      testInfo("TypeMapping", "   found " [path] "\n");
      insert("include",replace([path],"\.$",""));
   end if
   
   return [expr];

end proc

proc getClass(typeString)

   testInfo("getClass", " -> " [typeString] " -> ");
   
   /* several cases possible here:
      - a variation of a class or data type class, i.e. followed by _ptr or _cptr
      - a type completely outside the model
      - a qualified name

      try to figure out the package for class case only here
      leave name as it is
      
      */  
   
   loop(Instances->MClass(MClass_ids_by_name ([typeString]))->MDataType->TaggedValue
	Where [TaggedValue.tag] == [language])
      testInfo("TypeMapping", "MDataType " [MDataType.name] " -> 0\n");
      return 0;
   end loop

   local typeSpec = lastWord([typeString]," "); // get rid of passing mode keywords
   local frontString = getPrefix([typeString]," "); // get rid of passing mode keywords
   local subString = [typeSpec];
   local result;

   testInfo("TypeMapping", "   front " [frontString] " tail " [subString] "\n");
	
   // is it already a class name ?
   // This check can be omitted, if not appropriate
	
   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      testInfo("TypeMapping", "class " [MClass.name] " -> " [MClass.name] "\n");
      return [MClass.id];
   end loop

   // strip constraint, if any
	
   [subString] = stripConstraint([subString]);

   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      testInfo("TypeMapping", "class " [MClass.name] " -> " [MClass.name] "\n");
      return [MClass.id];
   end loop
	
   // strip _ptr or _cptr, if any

   [subString] = stripPointer([subString]);

   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      testInfo("TypeMapping", "class " [MClass.name] " -> " [MClass.name] "\n");
      return [MClass.id];
   end loop

   testInfo("TypeMapping", "no class -> 0\n");
   return 0;

end proc

proc stripConstraint(typeString)

	if (regexp([typeString],"(.*)") != "")
		return split([typeString],"(","L");
	else
		return [typeString];
	end if

end proc

tcl_proc lastWord(typeString,delim)

	set li [split $typeString $delim]
	
	return [lindex $li end]
	
end proc

tcl_proc getPrefix(name,delim)

	set li [split $name $delim]
	set n [llength $li]
	set nm1 [expr $n - 1]
	
	if {$n != 1} {
		set prefix [lindex $li 0]
		set li [lreplace $li $nm1 $nm1]
		set li [lreplace $li 0 0]
		foreach {elem} $li {
			set prefix [concat $prefix$delim$elem]
		}
		return $prefix	
	}

	set result ""	
	return $result
end proc

proc stripPointer(typeString)

	local result;

//T	info = "stripPtr " [typeString];

	[result] = replace([typeString],"_ptr$","");
	if([result] != [typeString])
//T		info = " (1)-> " [result] "\n";
		return [result];
	end if
	
	[result] = replace([typeString],"_cptr$","");
	if([result] != [typeString])
//T		info = " (2)-> " [result] "\n";
		return [result];
	end if
//wdh 00/10/17, just for consistency	[result] = replace([typeString],"[ ]*\*","");
	[result] = replace([typeString]," *\*","");
	if([result] != [typeString])
//T		info = " (2)-> " [result] "\n";
		return [result];
	end if
	
//T	info = " -> same\n";
	return [typeString];
	
end proc


proc visibilityMatch(visibility,place)

//T   info = "visibility match " [visibility] " at " [place] "\n";

   if([visibility] == "never")
      return FALSE;
   end if
   if([visibility] == "implementation")
      return FALSE;
   end if

   if([visibility]== [place])
      return TRUE;
   end if
   
   if([visibility] == [place]"-read-only")
//T      info = "visibility match ro at " [place] "\n";
      return TRUE;
   end if
   
   if([visibility] == [place]"-operation")
//T      info = "visibility match operation at " [place] "\n";
      return TRUE;
   end if
   
   return FALSE;

end proc

proc visibilityMatchBody(visibility,place)

//T   info = "visibility match body" [visibility] " at " [place] "\n";
   if([visibility] == "never")
      return FALSE;
   end if
   if([visibility] == "implementation")
      return FALSE;
   end if
   switch([place])
   case "implementation":
      if(regexp([visibility],".*child.*") == "")
          return TRUE;
      end if
      return FALSE;
   case "public-child":
      if(regexp([visibility],".*public-child.*") != "")
          return TRUE;
      end if
      return FALSE;
   case "private-child":
      if(regexp([visibility],".*private-child.*") != "")
          return TRUE;
      end if
      return FALSE;
   end switch 
   
   return FALSE;
     
end proc

proc classPrivacyMatch(privacy,place)

//T   info = "class privacy match " [privacy] " at " [place] "\n";

   if([privacy] == [place])
//T      info = "TRUE\n";
      return TRUE;
   end if
   
   if([place] == "private" && [privacy] == "tagged private")
//T      info = "visibility match tagged private at " [place] "\n";
      return TRUE;
   end if

   if([place] == "private" && [privacy] == "private extension")
//T      info = "visibility match private extension at " [place] "\n";
      return TRUE;
   end if
   
   return FALSE;

end proc

// from a string like   "java:java_val,ada:ada_val,default"
// select the ada_val if present, else the default
proc selectAda(access)

    local result = regexp([access],"ada:[^,]*");
    if ([result] != "")
       [result] = regexp([result],"[^:]*$");
    else
       [result] = regexp([access],"[^,]*$");
    end if

//    testInfo("wdh","selectAda maps "[access]" to "[result]"\n");
    
    return [result];
end proc

proc setTextBlind(t)

   setText([t]);
   
end proc

proc inherited(MAttribute,MClass)

   loop(MClass->SuperClass)
      loop(SuperClass->MAttribute As A where [A.name] == [MAttribute.name])
         return TRUE;
      end loop
      if(inherited([MAttribute],[SuperClass]))
         return TRUE;
      end if
   end loop

   return FALSE;

end proc

template accThis(MClass)
[if(isTagged([MClass]))]
this : [MClass.name]'class renames acc_this.all;
[else]
this : [MClass.name] renames acc_this.all;
[end if]
end template



proc genSectionComment(tag)

   local result = createString("-",80);

   return "--" [tag] createString("-", sub(78,getLength([tag])));

end proc

template genInlinePragma(name)
[if([doInlinePragmas])]
pragma inline([name]);
[else]
-- pragma inline([name]);
[end if]
end template

//------------------------------------------------------------------------------
tcl_proc delFile(fileName)
	catch {file delete $fileName}
end proc

//------------------------------------------------------------------------------
tcl_proc appendFile(fileName,line)
	set file [open $fileName "a"]
	puts $file $line
	close $file
end proc

//------------------------------------------------------------------------------
tcl_proc readFile(fileName)
	catch {
		set ic [ open $fileName ]
		set res [ read $ic ]
		close $ic
		return $res
	}
end proc

//------------------------------------------------------------------------------

proc setMapFile(fileName)
	[acdMapFileName] = [fileName];
	if ([class_id_list] != "")
		[acdMapFile_old_contents] = readFile([fileName]);
	end if
	delFile([fileName]);
end proc

//------------------------------------------------------------------------------
proc appendMapFile(classname,fileName)
	appendFile([acdMapFileName],[classname]"="[fileName]);
end proc

//------------------------------------------------------------------------------
proc closeMapFile()
	if ([class_id_list] != "")
	// append the previous contents to the file in case we only partial code generation
		loop (Instances->TokenSet([acdMapFile_old_contents]) As old_contents)
			appendFile([acdMapFileName],[old_contents.line]);
		end loop
	end if
end proc
