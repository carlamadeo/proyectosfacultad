//*****************************************************************************
// $RCSfile: ada_genconsdes.tdl,v $
// $Revision: 1.4 $
// $Date: 2002/03/15 16:19:33 $
// Author: Peter Kleiner
//*****************************************************************************

//wdh genIsAbstract added to spec of function Create.

//wdh: make Finalize a dispatching operation even if the type is not a controlled one
// This should make the operation more useful even if they are called 'manually'.
// Allthough we are tempted to make Initialize a dispatching operation too, we avoid it
// due to conflicts with the additional parameters which MUST not be present for controlled ones.

//wdh: change genFinalizeCallComposite so that it also works for Aggregations
// put the code into a procedure that can also be called for aggregations
/*
Support templates and procedures dealing with constructors and destructors.
called by genSpec (defined in ada_genspec.tdl) and genBody (defined in ada_genbody.tdl).

templates/procs called in genSpec. The order follows the occurence in genSpec

10. genConstructorSpec
	generate Initialize and Create method. Initialize to elaborate class type; Create
	to allocate an initialized class type instance on the heap.
10.1. genConstructorParameterList
	generate a parameter for each attribute of MClass which is a discriminant
11. genDestructorSpec
	generate Finalize and Free methods. Finalize to clean up a class type instance; Free
	to clean up and destroy a class type instance on the heap.

templates/procs called in genBody. The order follows the occurence in genBody

23. genConstructorBody
	generate the body of the default constructors Create and Initialize
23.1. genInitializeCallList
	generate an association with a component for each Attribute of MClass which
	is a discriminant
23.2. genInitializeDefaultCode
	generate the default code for the constructor Initialize
23.2.1. genInitCallComposite
23.3. genCreateDefaultCode
	generate the default code for the constructor Create
24. genDestructorBody
	generate the body of the default destructors Finalize and Free
24.1. genFinalizeDefaultCode
24.1.1. genFinalizeCallComposite
24.2. genDestructorDefaultCode

*/

/* 10. constructor */
template genConstructorSpec(MClass)

[genSectionComment("Constructor Operations")]
[if(isFinalized([MClass]) == TRUE && isInterface([MClass]) == FALSE)]
procedure Initialize (This : in out [MClass.name]);
	[genInlinePragma("Initialize")]
[   if(!isLimited([MClass]))]
procedure Adjust (This : in out [MClass.name]);
	[genInlinePragma("Adjust")]
[   end if]
[return]
[//wdh: do not generate other subprograms]
[end if]
[if (getClassPrivacy([MClass]) != "implementation" && isArray([MClass]) == FALSE)]
procedure Initialize (acc_this : [getClassParamForUpdate([MClass])][setDelim("; ")][genCompositeParameter([MClass])][genConstructorParameterList([MClass])][genRename([MClass],"Initialize")];
	[genInlinePragma("Initialize")]
[end if]

[if([MClass:isComposite] == FALSE  && isArray([MClass]) == FALSE)]
[   if(getStoragePool([MClass]) != "" || [doRaven] != TRUE || isSingleton([MClass]) == TRUE)]
function Create[openList()][genConstructorParameterList([MClass])] return [MClass.name]_ptr[[MClass].genIsAbstract()][genRename([MClass],"Create")];
	[genInlinePragma("Create")]
[   end if]
[end if]
end template

/* 10.1. generate a parameter for each attribute of MClass which is a discriminant */
proc genConstructorParameterList(MClass)

   local result = "";

   if(doInitializeStateMachine([MClass]))
      [result] = [result] delim() genEventArgDecl([MClass]);
      setDelim("; ");
   end if
   loop(MClass->MAttribute where isDiscriminant([MAttribute]))
      [result] = [result] delim() [MAttribute.name] " : " genParameterType([MAttribute.type])[MAttribute].genDefault();
      setDelim("; ");
   end loop
   
   [result] = [result] closeList();
   	
   return [result];

end proc

proc genEventArgDecl(MClass)

   if(isActiveClass([MClass]))
      return "Event : " importClass([MClass]) "_Event_Type";
   end if
   loop(MClass->SuperClass)
      return genEventArgDecl([SuperClass]);
   end loop
   return "";
   
end proc

/* 10.2. */
proc genCompositeParameter(MClass)

   loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName] != "" && [ToRole.aggregation] == "Composition")
      local result = delim() "Whole : " getClassTypeForAssociation([Partner],[MClass.name]);
      setDelim("; ");
      return [result];
   end loop
   return "";
   
end proc

/* 11. destructor */
template genDestructorSpec(MClass)

[genSectionComment("Destructor Operations")]

[if (getClassPrivacy([MClass]) != "implementation" && isArray([MClass]) == FALSE)]
procedure Finalize (Acc_This : in out [MClass.name])[genRename([MClass],"Finalize")];
	[genInlinePragma("Finalize")]
[end if]

[if([MClass:isComposite] == FALSE && [doRaven] == FALSE) /* Raven has a bug: rts_tagged_finalize... not there*/]
procedure Free (acc_this : in out [getClassResultType([MClass],TRUE)])[genRename([MClass],"Free")];
	[genInlinePragma("Free")]

[end if]
[if(doGenSmartCptr([MClass]))]
[GenSmartCptrSpec([MClass])]

[end if]
end template

/* 23. constructor */
template genConstructorBody(MClass)

[genSectionComment("Constructor Operations")]
[if([MClass.active])]
[genInitializeSM([MClass])]

[end if]
[if(isFinalized([MClass]) == TRUE && isInterface([MClass]) == FALSE)]
[genAdaFinalizationInitialize([MClass])]

[   if(!isLimited([MClass]))]
[genAdaFinalizationAdjust([MClass])]
[   end if]
[   return]
[//wdh: do not generate other subprograms]
[end if]
[if (getClassPrivacy([MClass]) != "implementation" && isArray([MClass]) == FALSE)]
[genConstructorInitialize([MClass])]

[end if]
[if([MClass:isComposite] == FALSE  && isArray([MClass]) == FALSE)]
[   if(getStoragePool([MClass]) != "" || [doRaven] != TRUE || isSingleton([MClass]) == TRUE)]
[genConstructorCreate([MClass])]

[   end if]
[end if]
end template

template genInitializeSM(MClass)
procedure InitializeSM (acc_this : [getClassParamForUpdate([MClass])][setDelim(";")][genConstructorParameterList([MClass])] is
begin
	[genStateMachineInitialize([MClass],[MClass])]
end InitializeSM;
end template

template genAdaFinalizationInitialize(MClass)
procedure Initialize (This : in out [MClass.name]) is
[mergeOut("UDAFID::" getUniqueId([MClass]),"Ada.Finalization.Initialize Declarations","")]
begin
[if([doCallStp] == TRUE && [doRaven] == FALSE && isActiveClassInstance([MClass]))]
	Managed_Base_Classes.Enter(This'unchecked_access);
[end if]
[mergeOut("UDAFIB::" getUniqueId([MClass]),"Ada.Finalization.Initialize Body",
	genAdaFinInitializeDefaultCode([MClass]))]
end Initialize;
end template

template genAdaFinInitializeDefaultCode(MClass)
null;
[loop(MClass->SuperClass)]
[importClassOp([SuperClass],"Initialize")]([importClass([SuperClass])](This));
[end loop]
end template

template genAdaFinalizationAdjust(MClass)
procedure Adjust (This : in out [MClass.name]) is
[mergeOut("UDAFAD::" getUniqueId([MClass]),"Ada.Finalization.Adjust Declarations","")]
begin
[if([doCallStp] == TRUE && [doRaven] == FALSE && isActiveClassInstance([MClass]))]
	Managed_Base_Classes.Reenter(This'unchecked_access);
[end if]
[mergeOut("UDAFAB::" getUniqueId([MClass]),"Ada.Finalization.Adjust Body",
	genAdaFinAdjustDefaultCode([MClass]))]
end Adjust;
end template

template genAdaFinAdjustDefaultCode(MClass)
null;
[loop(MClass->SuperClass)]
[importClassOp([SuperClass],"Adjust")]([importClass([SuperClass])](This));
[end loop]
end template

template genConstructorInitialize(MClass)
procedure Initialize (acc_this : [getClassParamForUpdate([MClass])][setDelim("; ")][genCompositeParameter([MClass])][genConstructorParameterList([MClass])] is
	[mergeOut("UDID::" getUniqueId([MClass]),"Initialization Declarations","")]
begin
[if(hasLoop(MClass->SuperClass))]
[   loop(MClass->SuperClass)]
[       if(![MClass].isAbstract())]
	[importClassOp([SuperClass],"Initialize")]([importClass([SuperClass])](acc_This.all)'access[setDelim(", ")][genInitializeCallList([SuperClass])];
[       end if]
[   end loop]
[else if([doCallStp] == TRUE && [doRaven] == TRUE && isActiveClassInstance([MClass]))]
	Managed_Base_Classes.Enter(acc_This.all'access);
[end if end if]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && ![ToRole:isPointer])]
[   if([FromRole:adaName] != "")]
	[genInitCallComposite([ToClass],[ToRole],accThisToAttr([MClass]),", acc_this")]
[   else]
	[genInitCallComposite([ToClass],[ToRole],accThisToAttr([MClass]),"")]
[   end if]
[end loop]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && isAutogenPartner([ToClass]) == TRUE)]
	[genCreateCallAutogenPartner([ToClass],[ToRole],accThisToAttr([MClass]),[MClass.name])]
[end loop]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [ToRole.aggregation] == "Composition")]
	[accThisToAttr([MClass])].[ToRole:adaName] := [genCvtToClassTypeForAssociation([ToClass],[MClass.name])] (Whole);
[end loop]
	[mergeOut("UDIB::" getUniqueId([MClass]),"Initialization Body", "null;")]
[if([MClass.active])]
	InitializeSM(acc_This[setDelim(", ")][genEventArg([MClass])][closeList()];
[end if]
end Initialize;
end template

/* 23.2.1. genInitCallComposite */
template genInitCallComposite(MClass As Partner,MAssociationEnd,OwnAttr,WholeArg)
[switch(getMultiplicity([MAssociationEnd.multiplicity]))]
[case "Many" :]
for I in acc_This.[MAssociationEnd:adaName]'range loop
[importClassOp([Partner],"Initialize")] ([OwnAttr].[MAssociationEnd:adaName](I)'access[WholeArg][setDelim(", ")][genEventArg([Partner])]);
end loop;
[	return]
[case "One"	:]
[importClassOp([Partner],"Initialize")] ([OwnAttr].[MAssociationEnd:adaName]'access[WholeArg][setDelim(", ")][genEventArg([Partner])]);
[	return]
[default 	:]
for I in acc_This.[MAssociationEnd:adaName]'range loop
	[importClassOp([Partner],"Initialize")] ([OwnAttr].[MAssociationEnd:adaName](I)'access[WholeArg][setDelim(", ")][genEventArg([Partner])]);
end loop;
[end switch]
end template

/* 23.2.1. genCreateCallAutogenPartner */
template genCreateCallAutogenPartner(MClass As Partner,MAssociationEnd,OwnAttr,tag)
[switch(getMultiplicity([MAssociationEnd.multiplicity]))]
[case "One"	:]
[OwnAttr].[MAssociationEnd:adaName] := [genCvtToClassTypeForAssociation([Partner],[tag])] ([importClassOp([Partner],"Create")] [openList()][genEventArg([Partner])][closeList()]);
[	return]
[default 	:]
for I in This.[MAssociationEnd:adaName]'range loop
	[OwnAttr].[MAssociationEnd:adaName](I) := [genCvtToClassTypeForAssociation([Partner],[tag])] ([importClassOp([Partner],"Create")] [openList()][genEventArg([Partner])][closeList()]);
end loop;
[end switch]
end template

template genConstructorCreate(MClass)
[if(isSingleton([MClass]))]
The_[MClass.name] : aliased [MClass.name];
The_[MClass.name]_Ref : aliased [MClass.name]_ptr;
[end if]
[if([MClass].isAbstract())]
[//  No constructor for abstract class ]
[else]
function Create[openList()][genConstructorParameterList([MClass])] return [MClass.name]_ptr is
	acc_this : [MClass.name]_ptr;
	[mergeOut("UDCD::" getUniqueId([MClass]),"Create Declarations", "")]
begin
[   if(isSingleton([MClass]))]
	if The_[MClass.name]_Ref /= NULL then
		return The_[MClass.name]_Ref;
	else			
		The_[MClass.name]_Ref := The_[MClass.name]'access;
		acc_this := The_[MClass.name]_Ref;
[   else]
	acc_this := new [MClass.name][openList()][genAllocatorCallList([MClass])];
[   end if]
[   if (getClassPrivacy([MClass]) != "implementation")]
[      if (isTagged([MClass]))]
		Initialize ([getClassParamForUpdate([MClass])] (acc_this)[setDelim(", ")][genInitializeCallList([MClass])];
[      else]
		Initialize (acc_this[setDelim(", ")][genInitializeCallList([MClass])];
[      end if]
[   end if]
		[mergeOut("UDCB::" getUniqueId([MClass]),"Create Body", "")]
[   if(isSingleton([MClass]))]
	end if;
[   end if]
	return acc_this;
end Create;
[end if]
end template

/* 23.1. generate an association with a component for each Attribute of MClass which is
   a discriminant */
proc genInitializeCallList(MClass)

   local result = "";

   if(doInitializeStateMachine([MClass]))
      [result] = [result] genEventArg([MClass]);
      setDelim(", ");
   end if
   loop(MClass->MAttribute where isDiscriminant([MAttribute]))
      [result] = [result] delim() [MAttribute.name];
      setDelim(", ");
   end loop

   return [result] closeList();

end proc

proc genAllocatorCallList(MClass)

   local result = "";

   loop(MClass->MAttribute where isDiscriminant([MAttribute]))
      [result] = [result] delim() [MAttribute.name];
      setDelim(", ");
   end loop
   	
   return [result] closeList();

end proc


proc genEventArg(MClass)

//T info = "genEventArg " [MClass.name];

   local result;

   if(isActiveClass([MClass]))
//T info = " -> active";
      loop(MClass->MStatemachine->MState->MCreationState->ToState->MTransition->TriggerEvent where genEventName([TriggerEvent]) != "__delay")
         [result] = delim() importClassOp([MClass],genEventName([TriggerEvent]));
         setDelim(", ");
         return [result];
      end loop
//T info = " -> no creation ev\n";
      return "";
   end if
   loop(MClass->SuperClass)
//T info = " -> ";
      return genEventArg([SuperClass]);
   end loop
//T info = " -> not active\n";
   return "";
   
end proc

/* 24. destructor */
template genDestructorBody(MClass)

[genSectionComment("Destructor Operations")]

[if (getClassPrivacy([MClass]) != "implementation" && isArray([MClass]) == FALSE)]
[genDestructorFinalize([MClass])]

[end if]
[if([MClass:isComposite] == FALSE && [doRaven] == FALSE) /* Raven has a bug: rts_tagged_finalize... not there*/]
[genDestructorFree([MClass])]

[end if]
end template

/*********************  wdh: obsolete **************************
template genAdaFinalizationFinalize(MClass)
procedure Finalize (This : in out [MClass.name]) is
[mergeOut("UDAFFD::" getUniqueId([MClass]),"Ada.Finalization.Finalize Declarations","")]
begin
[if([doCallStp] == TRUE && [doRaven] == FALSE && isActiveClassInstance([MClass]))]
	Managed_Base_Classes.Remove(This'unchecked_access);
[end if]
[mergeOut("UDAFFB::" getUniqueId([MClass]),"Ada.Finalization.Finalize Body",
	genAdaFinFinalizeDefaultCode([MClass]))]
end Finalize;
end template

template genAdaFinFinalizeDefaultCode(MClass)
null;
[loop(MClass->SuperClass)]
[importClassOp([SuperClass],"Finalize")]([importClass([SuperClass])](This));
[end loop]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && ![ToRole:isPointer])]
[   if(!isFinalized([MClass]))]
	[genFinalizeCallComposite("This","",[ToClass],[ToRole])]
[   end if]
[end loop]
end template
*************************** wdh obsolete ******************/

template genDestructorFinalize(MClass)
procedure Finalize (acc_this : in out [MClass.name]) is
-- acc_this is NOT an access, but we keep the name for backward compatibility
	[mergeOut("UDFID::" getUniqueId([MClass]),"Finalize Declarations", "")]
begin
	[mergeOut("UDFIB::" getUniqueId([MClass]),"Finalize Body", "null;")]
[if(hasLoop(MClass->SuperClass))]
[   loop(MClass->SuperClass)]
[       if(![MClass].isAbstract())]
	[importClassOp([SuperClass],"Finalize")]([importClass([SuperClass])](Acc_This));
[       end if]
[   end loop]
[else if([doCallStp] == TRUE && [doRaven] == TRUE && isActiveClassInstance([MClass]))]
	Managed_Base_Classes.Remove(Acc_This'access);
[end if end if]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="")]
[   if (![ToRole:isPointer])]
	[genFinalizeCallComposite(accThisToAttr([MClass]),"","Finalize",[ToClass],[ToRole])]
[   else if ([MAssociation].getStereoType() == "owner")]
	-- implicit deallocation code generated because association has stereotype "owner":
	[genFinalizeCallComposite(accThisToAttr([MClass]),"","Free",[ToClass],[ToRole])]
[        end if]
[switch(getMultiplicity([ToRole.multiplicity]))]
[case "Many" :]
	declare
[insert("include","Unchecked_Deallocation")]
		procedure Free is new Unchecked_Deallocation
			([ToRole:arrayTypeName], [ToRole:ptrTypeName]);
	begin
		Free ([accThisToAttr([MClass])].[ToRole:adaName]);
	end;
[default     :]
[end switch]
[   end if]
[end loop]
end Finalize;
end template

/* 24.1.1. genFreeCallComposite */
template genFinalizeCallComposite(thisExpr,callAttr,opName,MClass As Partner,MAssociationEnd)
[switch(getMultiplicity([MAssociationEnd.multiplicity]))]
[case "Many" :]
if [thisExpr].[MAssociationEnd:adaName] /= NULL then
	for I in [thisExpr].[MAssociationEnd:adaName]'range loop
		[importClassOp([Partner],[opName])] ([thisExpr].[MAssociationEnd:adaName] (I)[callAttr]);
	end loop;
end if;
[	return]
[case "One"	:]
[importClassOp([Partner],[opName])] ([thisExpr].[MAssociationEnd:adaName][callAttr]);
[	return]
[default 	:]
for I in acc_This.[MAssociationEnd:adaName]'range loop
	[importClassOp([Partner],[opName])] ([thisExpr].[MAssociationEnd:adaName] (I)[callAttr]);
end loop;
[end switch]
end template

template genDestructorFree(MClass)
procedure Free (acc_this : in out [getClassResultType([MClass],TRUE)]) is
[insert("include","Unchecked_Deallocation")]
[if(isTagged([MClass]))]
	procedure Deallocate is new Unchecked_Deallocation ([MClass.name]'class, [getClassResultType([MClass],TRUE)]);
[else]
	procedure Deallocate is new Unchecked_Deallocation ([MClass.name], [getClassResultType([MClass],TRUE)]);
[end if]
	[mergeOut("UDFRD::" getUniqueId([MClass]),"Free Declarations", "")]
begin
	[mergeOut("UDFRB::" getUniqueId([MClass]),"Free Body", "")]
	if acc_this = NULL then return; end if;
[if(!isArray([MClass]))]
[   if (getClassPrivacy([MClass]) != "implementation")]
	Finalize (acc_this.all);
[   end if]
[end if]
	Deallocate (acc_this);
end Free;
end template

proc isAutogenPartner(MClass)

//T info = [MClass.name] ": isAutogenPartner ";

//T info = [MClass.name] "-> NO because automatic creation of partners was disabled\n";
// The concept is quite confusing because it is not easy to find out when and how objects are created.
// Without it, we have to write some more code explicily. But it's easier to understand.
   return FALSE;

   if(isSingleton([MClass]))
//T info = [MClass.name] "-> YES (isSingleton)\n";
      return TRUE;
   end if
   
   setCount(0);
   loop(MClass->Role As ToRole->MAssociation->MAssociationEnd As FromRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole.isNavigable] == TRUE && [ToRole.aggregation] != "Composition")
	if(getMultiplicity([ToRole.multiplicity]) == "Many")
//T info = [MClass.name] "-> NO (multiplicity)\n";
		return FALSE;
	end if
	addCount(1);
   end loop
   if (getCount() == "1")
//T info = [MClass.name] "-> YES (1 assoc)\n";
   	return TRUE;
   else
//T info = [MClass.name] "-> NO (" getCount() " assocs)\n";
   	return FALSE;
   end if

end proc
