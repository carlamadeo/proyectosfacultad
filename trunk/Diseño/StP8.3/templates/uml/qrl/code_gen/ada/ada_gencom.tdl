template genCOMLibSpec(MPackage)
[startPackage()]
[mark("include","include_proc")]
[mergeOut("UDIF","includes", "")]

[/* getCuNameOfGroup determines the compilation unit name of [Group] */]
package [MPackage:cuName] is
[insert("include","AdaWin")]
[insert("include","AdaCom")]
[insert("include","CreateCOM.COMInterface")]
\
	[mergeOut("UDUFPD","package first public declarations","")]

	-- Type library ID for our COM Object
	LIBID_[MPackage.name] : aliased AdaWin.GUID :=
		AdaCom.To_GUID("{[uuidOfPackage([MPackage])]}");

	[/* loop over each instance of MNormalClass which belongs to [MPackage] */]
\
	[loop(MPackage->MClass->MNormalClass)]

	-- Class ID of COM object to be created
	CLSID_[MNormalClass.name] : aliased AdaWin.GUID :=
		AdaCom.To_GUID("{[uuidOfClass([MNormalClass])]}");

	[/* loop over each instance of MInterface which is implemented by MNormalClass */]
\
	[   loop(MNormalClass->Implement where isCOMInterface([Implement]))]

	-- IID for [Implement.name]
	IID_[Implement.name] : aliased AdaWin.GUID :=
		AdaCom.To_GUID("{[uuidOfClass([Implement])]}");

	[   end loop]
\
	[/* loop over each instance of MInterface which is implemented by MNormalClass */]
\
	[   loop(MNormalClass->Implement where isCOMInterface([Implement]))]

	-- Access function types for [Implement.name]
\
	[      loop(Implement->MOperation)]

	type Af_[Implement.name]_[MOperation.name] is access function (
		[genCOMProfile([Implement],[MOperation])];
		pragma Convention(Stdcall, Af_[Implement.name]_[MOperation.name]);

	[      end loop]
	
	[   end loop]
	[end loop]

	[mergeOut("UDULPD","package last public declarations","")]

end [MPackage:cuName];
end template


template genCOMClassSpec(MNormalClass,MPackage)
[startPackage()]
[mark("include","include_proc")]
[mergeOut("UDIF","includes", "")]

[/* getCuNameOfGroup determines the compilation unit name of [Group] */]
package [MPackage:cuName].[MNormalClass.name] is
[insert("include","CreateCOM.COMInterface")]
\
	[mergeOut("UDUFPD","package first public declarations","")]
\
	[/* loop over each instance of MInterface which is implemented by MNormalClass */]
\
	[loop(MNormalClass->Implement where isCOMInterface([Implement]))]

	-- Function specs for [Implement.name]
	[   loop(Implement->MOperation)]
	function [Implement.name]_[MOperation.name] (
		[genCOMProfile([Implement],[MOperation])];
		pragma Convention(Stdcall, [Implement.name]_[MOperation.name]);
	[outDescAsComment([MOperation.description])]

	[   end loop]
	[end loop]

	-- Interface definitions
\
	[/* loop over each instance of MInterface which is implemented by MNormalClass */]
\
	[loop(MNormalClass->Implement where isCOMInterface([Implement]))]

	type [Implement.name]_Vtbl_Record is
		record
			IUnknown : CreateCOM.COMInterface.IUnknown_Vtbl_Record;
	[   loop(Implement->MOperation)]
			[MOperation.name] : Af_[Implement.name]_[MOperation.name] := [Implement.name]_[MOperation.name]'access;
	[   end loop]
		end record;
	pragma Convention(C, [Implement.name]_Vtbl_Record);
	type [Implement.name]_Vtbl_Pointer is access all [Implement.name]_Vtbl_Record;

	[end loop]
\
	[/* loop over each instance of MInterface which is implemented by MNormalClass */]

	[loop(MNormalClass->Implement where isCOMInterface([Implement]))]
	[Implement.name]_Vtbl : aliased [Implement.name]_Vtbl_Record;
	[end loop]

	Guid_Map : aliased CreateCOM.COMInterface.GUID_Record_Array := (
	[loop(MNormalClass->Implement where isCOMInterface([Implement]);setDelim("");setDelim(","))]
[delim()]
		(IID_[Implement.name], [Implement.name]_Vtbl'Address)
	[end loop]);

	function Create return CreateCOM.COMInterface.COMInterface_Pointer;
	-- Creates a new COM Object and returns a pointer to IUnknown

	[genPublicSpecTForward([MNormalClass],FALSE)]

	[mergeOut("UDUSPD","package second public declarations","")]
\
	[genPublicSpec([MNormalClass])]
\
	[mergeOut("UDULPD","package last public declarations","")]
\
private

	[mergeOut("UDPFPD","package first private declarations","")]
\
	[genPrivateSpec([MNormalClass])]

	[mergeOut("UDPLPD","package last private declarations","")]

end [MPackage:cuName].[MNormalClass.name];
end template


template genCOMClassBody(MNormalClass,MPackage)
[startPackage()]
[mark("include","include_proc")]
[mergeOut("UDIF","includes", "")]

[/* getCuNameOfGroup determines the compilation unit name of [Group] */]
package body [MPackage:cuName].[MNormalClass.name] is

	[mergeOut("UDBFD","package body first declarations","")]

	--=============================================================================
	-- fixed part
	--=============================================================================
\
	[genClassBodyFixed([MNormalClass])]
\
\
	[/* loop over each instance of MInterface which is implemented by MNormalClass */]
\
	[loop(MNormalClass->Implement where isCOMInterface([Implement]))]
\
	[   loop(Implement->MOperation)]
	function [Implement.name]_[MOperation.name] (
		[genCOMProfile([Implement],[MOperation])] is
		acc_This : [MNormalClass.name]_Ptr := [MNormalClass.name]_ptr(This.CoClass);
	[      if(getCodeFromRep([MOperation]) == "")]
	[mergeOut("UDOI::"getUniqueId([MOperation]),"code","begin")]
	[      else]
	[getCodeFromRep([MOperation])]
	[      end if]
[insert("include","AdaWin.ErrorConstant")]
		return AdaWin.ErrorConstant.S_OK;
	end [Implement.name]_[MOperation.name];
	[   end loop]

	[end loop]

	function Create return CreateCOM.COMInterface.COMInterface_Pointer is
		Object : CreateCOM.COMInterface.COMInterface_Pointer;
		[MNormalClass.name]_Instance : CreateCOM.COMInterface.CoClass_Pointer := new [MNormalClass.name];
	begin
		-- Create an interface for the object
		Object := new CreateCOM.COMInterface.COMInterface_Type;

		-- Init the Instance
		[mergeOut("UDCB2::" getUniqueId([MNormalClass]),"Create Body 2", "Initialize("[MNormalClass.name]"_cptr("[MNormalClass.name]"_Instance));")]

		-- Create the object and assign in to the interface
		Object.CoClass := [MNormalClass.name]_Instance;

		return Object;
	end Create;

	[/* all subprograms with user inserted code are generated last by genClassBodyUser
	    (defined below) */]

	--=============================================================================
	-- user extensible part
	--=============================================================================
	[genClassBodyUser([MNormalClass])]

	[mergeOut("UDBLD","package body last declarations","")]

[mergeOut("UDBSP","package body statement part","begin\n\tnull;")]	
	[elaborateActiveClass([MNormalClass])]
end [MPackage:cuName].[MNormalClass.name];
end template

template genCOMmainLocalServer(MClass)
[mark("include","include_proc")]
[mergeOut("UDIF","includes", "")]
procedure [MClass:cuName] is
[insert("include","Ada.Strings.Unbounded")]
[insert("include","CreateCOM.Local_Server")]

	pragma Linker_Options ("oleaut32.lib");
	pragma Linker_Options ("user32.lib");
	--? pragma Linker_Options ("beepRC.coff");

	Object_Map : aliased CreateCOM.Local_Server.Factory_Record_Array := (
[loop(MClass->Supplier->MDependency where [MDependency.name] == "uses")]
[  loop(Supplier->MClass As SupplierClass where isCOMClass([SupplierClass]))]
[   loop(SupplierClass->MPackage)]
[insert("include",[MPackage.id])]
		([MPackage:cuName].CLSID_[SupplierClass.name],
[   end loop]
		[importClassOp([SupplierClass],"Create")]'Access,
		Ada.Strings.Unbounded.To_Unbounded_String
			("[SupplierClass:referenceName]"),
		Ada.Strings.Unbounded.To_Unbounded_String ("1"),
		Ada.Strings.Unbounded.To_Unbounded_String ("[SupplierClass.name]"),
		null,
		0),
[end loop]      
[end loop]      
		CreateCOM.Local_Server.Null_Factory_Record
		);
begin
	CreateCOM.Local_Server.Factory_Map := Object_Map'Unchecked_Access;
[loop(MClass->Supplier->MDependency where [MDependency.name] == "uses")]
[  loop(Supplier->MClass As SupplierClass where isCOMClass([SupplierClass]))]
[   loop(SupplierClass->MPackage)]
	CreateCOM.Local_Server.Init_Object([MPackage:cuName].LIBID_[MPackage.name]);
[   end loop]
[end loop]      
[end loop]
end [MClass:cuName];
end template

template genCOMmainInProc(MClass)
[mark("include","include_proc")]
[mergeOut("UDIF","includes", "")]
package [MClass:cuName]_Globals is
[insert("include","Ada.Strings.Unbounded")]
[insert("include","CreateCOM.Inproc")]

	pragma Linker_Options ("oleaut32.lib");
	pragma Linker_Options ("user32.lib");
	--? pragma Linker_Options ("beepRC.coff");

	Object_Map : aliased CreateCOM.Inproc.Factory_Record_Array := (
[loop(MClass->Supplier->MDependency where [MDependency.name] == "uses")]
[  loop(Supplier->MClass As SupplierClass where isCOMClass([SupplierClass]))]
[   loop(SupplierClass->MPackage)]
[insert("include",[MPackage.id])]
		([MPackage:cuName].CLSID_[SupplierClass.name],
[   end loop]
		[importClassOp([SupplierClass],"Create")]'Access,
		Ada.Strings.Unbounded.To_Unbounded_String
			("[SupplierClass:referenceName]"),
		Ada.Strings.Unbounded.To_Unbounded_String ("1"),
		Ada.Strings.Unbounded.To_Unbounded_String ("[SupplierClass.name]")),
[end loop]      
[end loop]      
		CreateCOM.Inproc.Null_Factory_Record
		);
		
   procedure Main;
		
end [MClass:cuName]_Globals;

package body [MClass:cuName]_Globals is

	procedure Main is
	begin
		CreateCOM.Inproc.Factory_Map := Object_Map'Unchecked_Access;
[loop(MClass->Supplier->MDependency where [MDependency.name] == "uses")]
[  loop(Supplier->MClass As SupplierClass where isCOMClass([SupplierClass]))]
[   loop(SupplierClass->MPackage)]
		CreateCOM.Inproc.Init_Object([MPackage:cuName].LIBID_[MPackage.name]);
[   end loop]
[end loop]   
[end loop]   
	end Main;
	   
end [MClass:cuName]_Globals;

with [MClass:cuName]_Globals;
procedure [MClass:cuName]_DLL is
begin
	[MClass:cuName]_Globals.Main;
end [MClass:cuName]_DLL;
end template


proc genCOMmain(MClass)

   local t = toLower([MClass].getTaggedValue("COM_Server_Type","local_server"));

   switch([t])
   case "local_server":
      return genCOMmainLocalServer([MClass]);
   case "inproc":
      return genCOMmainInProc([MClass]);
   default:
      info = [MClass.name] ": COM_Server_Type " [t] " unsupported\n";
      return [MClass.name] ": COM_Server_Type " [t] " unsupported";
   end switch
   
end proc

//=======================================================================

proc isCOMmain(MClass)

   if([MClass].getStereoType() == "main")
      loop(MClass->Supplier->MDependency where [MDependency.name] == "uses")
        loop(Supplier->MClass As SupplierClass where isCOMClass([SupplierClass]))
         return TRUE;
      end loop
      end loop
      return FALSE;
   else
      return FALSE;
   end if

end proc

proc getCOMserverType(MClass)

   if([MClass].getStereoType() == "main")
      loop(MClass->Supplier->MDependency where [MDependency.name] == "uses")
        loop(Supplier->MClass As SupplierClass where isCOMClass([SupplierClass]))
         return [MClass].getTaggedValue("COM_Server_Type","local_server");
      end loop
      end loop
      return "";
   else
      return "";
   end if

end proc


proc isCOMClass(MClass)

   if(uuidOfClass([MClass]) != "")
      return TRUE;
   else
      return FALSE;
   end if

end proc

proc isCOMInterface(MClass)

//T   info = "isCOMInterface " [MClass.name];

   if(uuidOfClass([MClass]) == "")
//T      info = " -> FALSE (no UUID) \n";
      return FALSE;
   end if
   
   loop(MClass->SuperClass)
      if([SuperClass.name] == "IUnknown")
//T         info = " -> TRUE\n";
         return TRUE;
      end if
      return isCOMInterface([SuperClass]);
   end loop
   
//T   info = " -> FALSE\n";
   return FALSE;

end proc


proc uuidOfClass(MClass)

   return [MClass].getTaggedValue("uuid","");
   
end proc

proc uuidOfPackage(MPackage)

   return [MPackage].getTaggedValue("uuid","");
   
end proc

template genCOMProfile(MInterface,MOperation)
	This : access CreateCOM.COMInterface.COMInterface_Type
[loop(MOperation->OpPara)]
;
	[OpPara.name] : [genParameterType([OpPara.type])] [[OpPara].genDefault()]
[end loop]
)
		return AdaWin.HRESULT
end template
