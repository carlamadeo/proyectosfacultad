//*****************************************************************************
// $RCSfile: ada_genbody.tdl,v $
// $Revision: 1.3 $
// $Date: 2002/03/08 16:03:54 $
// Author: Peter Kleiner
//*****************************************************************************

/*
genBody: 		generates the package body for an instance of meta type MClass.
genGroupBody:		generates the package body for a group of instances of meta type
              		MClass.
genTaskBodySubunit:	generates the subunit for an instance of meta type MClass
			which is a task to be realized as a subunit
genPTBodySubunit:	generates the subunit for an instance of meta type MClass
			which is a protected type to be realized as a subunit
genOperationSubunit:	generates the subunit for an instance of meta type MOperation
			which is to be realized as a subunit
all these are called by main (defined in ada_main.tdl).
*/

template genBody(MClass)
[/* mark This place is an insertion point (named "include") for include 
    statements. Include statements are inserted here during generation of the 
    class content by using the insert procedure. */]
[mark("include","include_proc")]
[mergeOut("UDIF","includes", "")]

package body [MClass:cuName] is

	[genElabDummyBody()]
	[mergeOut("UDBFD","package body first declarations","")]
\
	[/* all subprograms generated completely by the template are generated first by
	    genClassBodyFixed (defined below) */]

	--=============================================================================
	-- fixed part
	--=============================================================================
\
	[genClassBodyFixed([MClass])]
\
	[/* all subprograms with user inserted code are generated last by genClassBodyUser
	    (defined below) */]
\
	--=============================================================================
	-- user extensible part
	--=============================================================================
	[genClassBodyUser([MClass])]

	[mergeOut("UDBLD","package body last declarations","")]

[mergeOut("UDBSP","package body statement part","begin\n\tnull;")]	
	[elaborateActiveClass([MClass])]
end [MClass:cuName];
end template




/* like genBody for a single class, we generate in genGroupBody a package body for 
   a whole group of classes. Note that these classes are grouped together due to cyclic 
   dependencies onto each other, thus the class types all have to be declared before
   operations, relations, and attributes can refer to one of the other classes in the
   group */
template genGroupBody(Group)
[/* mark This place is an insertion point (named "include") for include 
    statements. Include statements are inserted here during generation of the 
    class content by using the insert procedure. */]
[mark("include","include_proc")]
[mergeOut("UDIF","includes", "")]

[/* getCuNameOfGroup determines the package name of [Group] */]
package body [getCuNameOfGroup([Group])] is
\
	[genElabDummyBody()]
	[mergeOut("UDBFD","package body first declarations","")]
\
	[/* loop over each instance of MTemplateClass which belongs to the group
	    to create the fixed part of the package body for this class */]
\
	[loop(Instances->MTemplateClass where [MTemplateClass:group] == [Group])]

	--=============================================================================
	--Class [MTemplateClass.name] (fixed part)
	--=============================================================================
	[genLocalTemplateBody([MTemplateClass])]
\
	[end loop]
\
	[/* loop over each instance of MClass which belongs to the group
	    to create the fixed part of the package body for this class */]
\
	[loop(Instances->MClass(MClass_by_group([Group]))->MNormalClass)]

	--=============================================================================
	--Class [MNormalClass.name] (fixed part)
	--=============================================================================
	[genClassBodyFixed([MNormalClass])]
\
	[end loop]
\
	[/* loop again over each instance of MClass which belongs to the group
	    to create the user modifyable part of the package body for this class */]
\
	[loop(Instances->MClass(MClass_by_group([Group]))->MNormalClass)]

	--=============================================================================
	--Class [MNormalClass.name] (user extensible part)
	--=============================================================================
	[genClassBodyUser([MNormalClass])]
\
	[end loop]

	[mergeOut("UDBLD","package body last declarations","")]	

[mergeOut("UDBSP","package body statement part","begin\n\tnull;")]	
[loop(Instances->MClass(MClass_by_group([Group]))->MNormalClass)]
	[elaborateActiveClass([MNormalClass])]
[end loop]
end [getCuNameOfGroup([Group])];
end template


template genLocalTemplateBody(MTemplateClass)
package body [MTemplateClass:packageName] is

	[genElabDummyBody()]
	[mergeOut("UDBFD::"  getUniqueId([MTemplateClass]),"package body first declarations","")]
\
	[/* all subprograms generated completely by the template are generated first by
	    genClassBodyFixed (defined below) */]

	--=============================================================================
	-- fixed part
	--=============================================================================
	[genClassBodyFixed([MTemplateClass])]

	[/* all subprograms with user inserted code are generated last by genClassBodyUser
	    (defined below) */]

	--=============================================================================
	-- user extensible part
	--=============================================================================
	[genClassBodyUser([MTemplateClass])]

	[mergeOut("UDBLD","package body last declarations","")]

[mergeOut("UDBSP::" getUniqueId([MTemplateClass]),"package body statement part","begin\n\tnull;")]	
end [MTemplateClass:packageName];
end template

template genPublicAccessBody(MClass)
[mark("include","include_proc")]
[mergeOut("UDIF","includes","")]
package body [MClass:packageName].AccessOps is
\
	[genAttributeOperationBodies([MClass],"public-child")]
	[genRelationOperationBodies([MClass],"public-child")]
\
end [MClass:packageName].AccessOps;
end template

template genPrivateAccessBody(MClass)
[mark("include","include_proc")]
[mergeOut("UDIF","includes","")]
package body [MClass:packageName].PrivateAccessOps is
\
	[genAttributeOperationBodies([MClass],"private-child")]
	[genRelationOperationBodies([MClass],"private-child")]
\
end [MClass:packageName].PrivateAccessOps;
end template



template MClass.genTaskBodySubunit()
[mark("include","include_proc")]
[mergeOut("UDIF","includes","")]
separate([MClass:cuName])
[genTaskTypeBody([MClass])]
end template



template MClass.genPTBodySubunit()
[mark("include","include_proc")]
[mergeOut("UDIF","includes","")]
separate([MClass:cuName])
[genProtectedTypeBody([MClass])]
end template



template genOperationSubunit(MOperation,MClass)
[mark("include","include_proc")]
[mergeOut("UDIF","includes","")]
separate([MClass:cuName])
[genOperationBody([MOperation],[MClass],TRUE)]
end template




template genElabDummyBody()
[if(![bodyRequired])]
procedure Force_Body is begin null; end Force_Body;
[end if]
end template




	

/* generate those parts of a package body for the instance MClass which are completely
   generated by the template and do not require any user modifications or extensions
   in the generated code */
template genClassBodyFixed(MClass)
\
[if(isEnumeration([MClass]) == FALSE)]
[   if([MClass:group] != 0)]
[// we may have to generate a local super class first if this is visible here]
[// we may have to generate our composites' type first]
[      if([MClass:genLevel] != "private")]
[         return]
[      end if]
[   setGenerationLevel([MClass],"implementation")]
[      loop(MClass->SuperClass where [SuperClass:group] == [MClass:group] && (getClassPrivacy([MClass]) == "public" || getClassPrivacy([MClass]) == "private extension"))]
[genClassBodyFixed([SuperClass])]
[      end loop]
[      loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && ![ToRole:isPointer])]
[genClassBodyFixed([ToClass])]
[      end loop]
[   end if]
[   if(isArray([MClass]))]
[genClassOperationsSpecs([MClass],"implementation")]
[   else if(isInterface([MClass]))]
[genClassOperationsSpecs([MClass],"implementation")]
[   else]
[genContextType([MClass],"implementation")]
[genClassWideAttributes1([MClass],"implementation")]
[genClassOperationsSpecs([MClass],"implementation")]
[genStateMachinePreType([MClass],"implementation")]
[genClassTypes([MClass],"implementation")]
[genStateMachinePostType([MClass],"implementation")]
[genAttributeOperationSpecs([MClass],"implementation")]
[genRelationOperationSpecs([MClass],"implementation")]
[genStateMachineSpec([MClass],"implementation")]
[genAttributeOperationBodies([MClass],"implementation")]
[genRelationOperationBodies([MClass],"implementation")]
[genClassWideAttributes2([MClass],"implementation")]
[      if([MClass].isSubunit())]
[         if(isTask([MClass]))]
task body [MClass:taskName] is separate;
[         else if(isPT([MClass]))]
protected body [MClass:ptName] is separate;
[         end if end if]
[      else]
[genStateMachineBodyFixed([MClass])]
[      end if]
[   end if end if]
[end if]
end template



/* generate those parts of a package body for the instance MClass which include
   user extensible parts, i.e. constructor, desctructor, operations, state machine
   action procedures */
template genClassBodyUser(MClass)
\
\
[if(isEnumeration([MClass]))]
[genClassOperationsBodies([MClass])]
[else]
[   if(isArray([MClass]))]
[genConstructorBody([MClass])]
[genDestructorBody([MClass])]
[genClassOperationsBodies([MClass])]
[   else if(isInterface([MClass]))]
[   else]
[genStateMachineBodyUser([MClass])]
[      if(![MClass].isSubunit())]
[         if(isTask([MClass]))]
[genTaskTypeBody([MClass])]
[         else if(isPT([MClass]))]
[genProtectedTypeBody([MClass])]
[         end if end if]
[      end if]
[genConstructorBody([MClass])]
[genDestructorBody([MClass])]
[genClassOperationsBodies([MClass])]
[   end if end if]
[end if]
end template

proc setSelectDelim(v)
   [selectDelim] = [v];
end proc

proc selectDelim()
   return [selectDelim];
end proc

proc openSelect()
   setSelectDelim("select");
end proc

template selectAlternative(text)
[selectDelim()]
	[getText()]
	[text]
[setSelectDelim("or")]
end template

template selectDelayAlternative(text)
[if(selectDelim() == "select")]
[text]
[else]
[selectAlternative([text])]
[end if]
end template

template selectElseAlternative(text)
[if(selectDelim() == "select")]
[text]
[else]
else
	[text]
[setSelectDelim("ERROR: after final else alternative")]
[end if]
end template

template selectTerminateAlternative()
[if(selectDelim() == "select")]
exit; -- Thus, the task will reach its END and terminate.
[else]
or
	terminate;
[setSelectDelim("ERROR: after final terminate alternative")]
[end if]
end template

template closeSelect()
[if(selectDelim() != "select")]
end select;
[end if]
end template

template genTaskTypeBody(MClass)
task body [MClass:taskName] is
[if(isTagged([MClass]))]
	This : [MClass.name]'class renames acc_This.all;
[end if]

	[mergeOut("UDTBFLD" condGetUniqueId([MClass]),"task body first local declarations","")]
[if(!isTagged([MClass]))]
	package This is -- allow notation "This.attr" from OCL guards and actions
	[genAttributeComponents([MClass])]
	[mark("passoctypes_"[MClass.name],"")]
	[genRelationshipComponents([MClass])]
	end This;
	use This;
[end if]
	[genStateMachineTaskBodyDecls([MClass])]
	[mergeOut("UDTBLLD" condGetUniqueId([MClass]),"task body last local declarations","")]

[if(isActiveClass([MClass]))]
begin
	[genStateMachineTaskBodyPart([MClass])]
[else]
[mergeOut("UDTBSP" condGetUniqueId([MClass]),"task body statement part",
	genDefaultTaskBody([MClass]))]
[end if]

exception
[insert("include","Ada.Exceptions")]\	
	when Ex : others => ACD_Runtime.Report_Exception 
		(Context  => "Task [MClass:taskName] terminated,",
		Excp_Name => Ada.Exceptions.Exception_Name(Ex),
		Excp_Info => Ada.Exceptions.Exception_Information(Ex));
end [MClass:taskName];
end template


template genProtectedTypeBody(MClass)
protected body [MClass:ptName] is

	--=============================================================================
	-- fixed part
	--=============================================================================
	[genAttributeOperationBodiesPT([MClass])]
	[genRelationOperationBodiesPT([MClass])]
	[genStateMachineBodyFixedPT([MClass])]

	--=============================================================================
	-- user extensible part
	--=============================================================================
	[genClassOperationsBodiesPT([MClass])]
	[genStateMachineBodyUserPT([MClass])]

end [MClass:ptName];
end template

template genDefaultTaskBody(MClass)
begin
[if(isTagged([MClass]))]
[   if(genClassOperationsBodiesTask([MClass]) == "")]
	null;
[   else]
	loop
	
		[openSelect()]
		[genClassOperationsBodiesTask([MClass])]
		[selectTerminateAlternative()]
		[closeSelect()]
	end loop;
[   end if]
[else]
[   if(genAttributeOperationBodiesTask([MClass])=="" && genRelationOperationBodiesTask([MClass]) == ""&& genClassOperationsBodiesTask([MClass]) == "")]
	null;
[   else]
	loop
		[openSelect()]
		[genAttributeOperationBodiesTask([MClass])]
		[genRelationOperationBodiesTask([MClass])]
		[genClassOperationsBodiesTask([MClass])]
		[selectTerminateAlternative()]
		[closeSelect()]
	end loop;
[   end if]
[end if]
end template
