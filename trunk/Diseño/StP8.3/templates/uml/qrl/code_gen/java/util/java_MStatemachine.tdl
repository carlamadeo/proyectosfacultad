/************************************************** 
 * java_MStatemachine.tdl
 * ----------------------
 *
 * Utility functions for statemachines, mainly for
 * the StateTable pattern.
 * 
 * Author:  Frank Lippert
 * Company: Aonix GmbH
 * Date:    18.12.2001
 *
 * Copyright 2001, Aonix, San Diego
 **************************************************/


// Return the initialstate of the statemachine
// If none is present (that is allowed!) return
// a randomly choosen state.
proc getFirstCurrentState(MClass)
	loop (MClass->MStatemachine->MState->MCreationState)
		return [MCreationState.name];
	end loop
	loop(MClass->MStatemachine->MState)
	  return [MState.name];
	end loop
end proc

/*	counts no. of transitions with different names
*/
proc getTransWithDifferentName(MClass)
	setCount(0);
	loop (MClass->MStatemachine->MState->ToState->MTransition->TriggerEvent)
		if ([[TriggerEvent.name]] == [TriggerEvent.name])
			break;
		else
			[[TriggerEvent.name]] = [TriggerEvent.name];
			addCount(1);
		end if
	end loop
	addCount(1);
	return getCount();
end proc

/*	counts the no. of states
*/
proc getNoOfStates(MClass)
	setCount(0);
	loop (MClass->MStatemachine->MState)
		addCount(1);
	end loop
	return getCount();
end proc

/*	avoid to generate same class names several times.
	This could occur, if there are transitions with same (event names and guard/conditions),
	but having different *source* states.
*/
proc isDoubleClassNames(MTransition)
	loop (MTransition->TriggerEvent)
		loop (MTransition->MGuard)
			if ([[TriggerEvent.name][MGuard.expression]] == [MGuard.expression])
				return TRUE;
			else
				[[TriggerEvent.name][MGuard.expression]] = [MGuard.expression];
				return FALSE;
			end if
		end loop
	end loop
end proc

/* each transition in the model is represented by a separate class.
	The class name is build of the event name and the name of the
	guard/condition.
*/
proc genTransClassName(MTransition)
[retVal] = "";
loop (MTransition->TriggerEvent)
[retVal] = replace([TriggerEvent.name], " +", "_");
loop (MTransition->MGuard)
	[retVal] = [retVal]"_"split([MGuard.expression],"(","L");
end loop
end loop
	return [retVal];
end proc

/*	get target state of transition
*/
proc getTargetState(MTransition)
loop(MTransition->ToState)
	return [ToState.name];
end loop
end proc

/*	get guard of transition, if it has one
*/
proc getGuard(MTransition)
loop(MTransition->MGuard)
	return split([MGuard.expression],"(","L")"()";
end loop
return "true";
end proc

/* 	index of the Trans_Base array that holds the transition objects.
	It's the max. no. of transition objects with same name, a
	single state can have 
*/ 
proc getMaxNoOfTrans(MClass)
	[maxNo] = 0;
	loop(MClass->MStatemachine->MState)
		setCount(0);
		loop(MState->ToState->MTransition)
			addCount(1);
		end loop
		if ([maxNo] < getCount())
			[maxNo] = getCount();
		end if
	end loop
	return [maxNo];
end proc


template SM_ConstructorCode(MClass)
[loop(MClass->MStatemachine->MState->MCreationState)]
currentState = _[toUpper([MState.name])]; 
[end loop]	
end template


template STP_ConstructorCode(MClass)
stateTable = new StateTable();
// This instance of State is needed to instantiate the inner classes
// from State
state = new State();
^
[loop(MClass->MStatemachine->MState)]
State.[MState.name] [toLower([MState.name])] = state.new [MState.name]();
stateTable.assignState([toLower([MState.name])], _[toUpper([MState.name])]);
^
[end loop]
[loop (MClass->MStatemachine->MState)]
TransitionContainer trans_[MState.name] = new TransitionContainer();
[loop (MState->ToState->MTransition)]
trans_[MState.name].setTransInterface(trans_[MState.name].new [genTransClassName([MTransition])](_[toUpper(getTargetState([MTransition]))]));  
stateTable.assignTrans(trans_[MState.name], _[toUpper([MState.name])], _[triggerEvName([MState])]);
^
[end loop]
[end loop]
end template