//*****************************************************************************
// $RCSfile: java_std.tdl,v $
// $Revision: 1.7 $
// $Date: 2002/04/04 14:48:44 $
// Author: Oliver Maus, Markus Kern
//*****************************************************************************

/*
USES ../tdl/std;
*/

////////////////////////////////////////////////////////////////////////////////
// standard functions
////////////////////////////////////////////////////////////////////////////////

/* Generates a marked section in the output. The content of this section can 
be changed by the user in the generated file. These changes will not be 
overwritten in subsequent cycles of code generation */
template mergeOut(uniqueId,desc)
//#ACD# M([uniqueId]) [desc]
//user defined code to be added here ...

//#end ACD#
end template


/* this procedure is called once by main (defined in cpp_main.tdl) before
   any other procedure or template. It sets up the merge mechanism for 
   incremental code generation (delMergeFile and appendMergeFile).
   The current language for type mapping is defined (setLanguage) */
proc init()
	delMergeFile();
	appendMergeFile("merge_config_JAVA.txt");
	setLanguage("Java");
end proc	

/*	write the description
*/
template outDesc(Description)
[loop(Instances->TokenSet([Description]))]
[TokenSet.line]
[end loop]
end template

/*	write the description commented
*/
template commentedOutDesc(Description)
[loop(Instances->TokenSet([Description]))]
// [TokenSet.line]
[end loop]
end template

/* return tag of tagged value with tag==str */
proc getTaggedValueTag(MElement, str)
	loop(MElement->TaggedValue AS TG Where [TG.tag] == [str])
	return TRUE;
	end loop
end proc

/* return value of tagged value with tag==str */
proc getTaggedValueValue(MElement, str)
	loop(MElement->TaggedValue AS TG Where [TG.tag] == [str])
	return [TG.value];
	end loop
end proc

/*	write the names of sendactions
*/
template getEventOperations(MTransition)
[loop(MTransition->SendAction)]
[replace([SendAction.name], ":=", "=")];
[end loop]
end template

/*	analyze the multiplicity at the opposite end of the association
	example: A-------->B
	                  *
	in the above example we have a many relation between class A and class B
	in this procedure we find out the multiplicity marked with * (many)
*/
proc getJavaMultiplicity(MAssociationEnd AS ToRole)
	// some meta properties, used below
	[ToRole:LowerValue] = "";
	[ToRole:UpperValue] = "";
		
	switch([ToRole.multiplicity])

	case "":
	case "1":
	case "0..1":
	case "1..0":
	case "1..1":
	case "0..0":
		return "One";

	case "*":
	case "0..*":
	case "n":
	case "N":
		return "Many";

	case "1..*":
		[ToRole:LowerValue] = split([multiplicity],".","L"); 
		return "Many";
		
	case regexp([ToRole.multiplicity],"[2-9]+\.\.\n"):	
	case regexp([ToRole.multiplicity],"[2-9]+\.\.\N"):	
	case regexp([ToRole.multiplicity],"[2-9]+\.\.\*"):	
		return "Many";
		
	case regexp([ToRole.multiplicity],"[0-9]+"):
		[ToRole:UpperValue] = [ToRole.multiplicity];
	  return "Fix";

	case regexp([ToRole.multiplicity],"[0-9]+\.\.[0-9]+"):
		[ToRole:LowerValue] = split([ToRole.multiplicity],".","L");
		[ToRole:UpperValue] = split([ToRole.multiplicity],".","T");
		return "Range";

	default:
		return "Many";
	end switch
end proc


 /*	is class external?
 */
proc classIsExternal(MClass)
  if (! [EXCLUSIONS])
    return "FALSE";
  else
	  loop(MClass->Note->Item Where [Item.type] == "UmlClassIsImported" && [Item.value] == "True")
			return "TRUE";
	  end loop
	end if
end proc

/* Is Package external
 */
proc packageIsExternal(MPackage)
  if (! [EXCLUSIONS])
    return "FALSE";
  else
	  loop(MPackage->Note->Item Where [Item.type] == "UmlPackageIsImported" && [Item.value] == "True")
			return "TRUE";
	  end loop
	end if
end proc


/*	is relation between classes bidirectional?
*/
proc isBidirectional(MAssociationEnd AS FromRole, MAssociationEnd AS ToRole)
	if ([FromRole.isNavigable] == [ToRole.isNavigable])
		return "True";
	end if
	return "False";
end proc


// Proofs, if a model element has a TaggedValue of the form
// "pattern=<PATTERN>".
proc hasPattern(MElement, pattern)
  loop(MElement->TaggedValue As TV Where toLower([TV.tag]) == "pattern")
    if (searchstr([TV.value], [pattern], "0") != "-1")
      return "TRUE";
    end if
  end loop
  return FALSE;
end proc
