/**************************************************
 * java_Statemachine.tdl
 * ---------------------
 *
 * Templates and procedures for the creation of
 * state machines, that means deterministic finite
 * automatons.  In Java codegeneration you can either
 * use nested switch statements or a pattern of nested
 * inner classes and a state table.
 *
 * Author:  Frank Lippert
 * Company: Aonix GmbH
 * Date:    20.10.2001
 *
 * Copyright 2001, Aonix, San Diego
 **************************************************/

proc createStatemachine(MClass)
  if (hasPattern([MClass], "statetable"))
    return createStatemachineClasses([MClass]);
  else
    return createStatemachineTable([MClass]);
  end if
end proc


template createStatemachineTable(MClass)
// ------------------------------------------------------------
// state machine (realized with nested switch statements)
// ------------------------------------------------------------
^
protected byte currentState;
[/* An attribute for each event a state can receive is generated and initialized
    getCount returns a number that is increased by addCount (defined in std.tdl) */]
[loop(MClass->ReceiveEvent;
setText("// events /////////////////////////////////////////////////////////////////"),
setCount(0);addCount(1))]
[getText()]
public static final byte _[toUpper(replace([ReceiveEvent.name], " +", "_"))] = [getCount()];
[end loop]


[/* An attribute for each state is generated and initialized
    getCount returns a number that is increased by addCount (defined in std.tdl) */]
[loop(MClass->MStatemachine->MState Where ! hasLoop(MState->MPseudoState);
setText("// states /////////////////////////////////////////////////////////////////"),
setCount(0);addCount(1))]
[getText()]
public static final byte _[toUpper([MState.name])] = [getCount()];
[end loop]


/// Event taker functions /////////////////////////////////////////////////
public void takeEvent(byte ev) {
  [/* handle each possible state, currentState holds the current state
      of the state machine */]
  switch(currentState) {
  [loop(MClass->MStatemachine->MState Where ! hasLoop(MState->MPseudoState))]
    [/* the state machine is in state MState now. Accept all events
        legal for this state */]
    case _[toUpper([MState.name])]:
      switch(ev) {
        [/* loop over all outgoing events */]
        [loop(MState->ToState->MTransition->TriggerEvent) ]
        [/* There are events with same name but having different guards.
        Here the case statement for the eventname has to be suppressed, only
        the guard and actions/sendevents are of interess.
        breakLoopOn is TRUE if event name already occured for the state MState
        It will not break if the eventname already occured but name of state
        MState occurres the first time. */]
        [if (breakLoopOn([TriggerEvent],[MState]) == "FALSE")]
        [setCount(0)] [/* s. getCount below */]
        [setTmpTriggerEventName([TriggerEvent])]  [/* set global var. tmpTriggerEvName */]
^
        [/* This is the inner loop filtering only events with same eventname as
        in outer loop. */]
        [loop(MState->ToState AS TS->MTransition AS MT->TriggerEvent AS TE where [TE.name]==[tmpTriggerEvName])]
        [/* Keep care to generate only one case statement, even if state has more than
        one events with same name */]
        [if (getCount() == "0")]
        case _[toUpper(replace([TriggerEvent.name], " +", "_"))]:
        [addCount(1)]
        [end if]
          [generateEventParameter([TE])]
          [generateGuardStatement([MT], [TS])]
        [end loop]
          break;
        [end if]
        [end loop]
        default:
        [if (hasUnnamedTransitions([MState]) && unnamedTransitionsOK([MState]))]
          [loop(MState->ToState As TS->MTransition As MT Where ! hasLoop(MT->TriggerEvent))]
          [generateGuardStatement([MT], [TS])]
          [end loop]
        [else]
        [/* An illegal event has been used. For now we just put
          an error message */]
          System.out.println("Wrong event occurred "  + \"[MClass.name] \" + \"[MState.name]\" + " " + ev);
        [end if]
          break;
      } // end event switch for state [MState.name]
      break;
  [end loop]
  } // end state switch
}
^
[loop(MClass->MStatemachine->MState->MNormalState;
setText("/// State action functions ////////////////////////////////////////////////"))]
[getText()]
protected void [MState.name]_Action() {
  [if (hasLoop(MState->MActivity))]
    [loop(MState->MActivity)]
      [loop(Instances->TokenSet([MActivity.name]))]
  [TokenSet.line]
       [end loop]
    [end loop]
  [end if]
  [mergeOut("UDAC::" getUniqueId([MState]) "_Action","action code")]
}
^
[end loop]
end template

// looks, if a state has any number of unnamed transitions
// We won't consider junctionpoints or dynamicpoints here!
proc hasUnnamedTransitions(MState)
  loop(MState->ToState->MTransition Where ! hasLoop(MTransition->TriggerEvent))
    return TRUE;
  end loop
  return FALSE;
end proc

// checks, if a state with unnamed transitions has
// -- either exactly _one_ transitions without a guard.
// -- or several transitions, of which everyone must 
//    have a guard. The guards must be all different!
proc unnamedTransitionsOK(MState)
  local count;
  local guards;
  local guard;
  [count] = loopCount(MState->ToState->MTransition Where ! hasLoop(MTransition->TriggerEvent));
  if ([count] == 1)
    return TRUE;
  else
    loop(MState->ToState->MTransition Where ! hasLoop(MTransition->TriggerEvent))
      if (! hasLoop(MTransition->MGuard))
        info = "One Transition in state \"" [MState.name] "\" is unnamed, but has no guard!\n"
               "\"" [MState.name] "\" has several transitions, so no transition code is generated!\n";
        return FALSE;
      else
        loop(MTransition->MGuard)
          [guard] = [MGuard.expression];
        end loop
        loop(Instances->TokenSet([guards]))
          if ([guard] == [TokenSet.line])
            info = "Guard condition \"" [guard] "\" occured already in transitions of\n"
                   "state \"" [MState.name] "\"! No transition code is generated!\n";
            return FALSE;
          end if
        end loop
      end if
      [guards] = [guards] "\n" [guard];
    end loop
    return TRUE;
  end if
end proc

// FL, START
template genEntryAction(MState)
[loop(MState->MAction->MActionType Where [MActionType.type] == "entry")]
  [loop(Instances->TokenSet([MAction.name]))]
[replace([TokenSet.line], ":=", "=")]
  [end loop]
[end loop]
end template

// More complicated than the function above: We are already in
// the "ToState" and must go back to that "FromState" from which
// "MTransition" is originating.
template genExitAction(MState As Target, MTransition As Trans)
[loop(Target->FromState->MTransition Where [MTransition.id] == [Trans.id])]
  [loop(FromState->MAction->MActionType Where [MActionType.type] == "exit")]
    [loop(Instances->TokenSet([MAction.name]))]
[replace([TokenSet.line], ":=", "=")]
    [end loop]
  [end loop]
[end loop]
end template
// FL, ENDE


/* Meta attributes are used to find out, whether the combination of
eventname and statename already occurred.
The meta attributes consists of the liteal "breakOn" followed
by the name of an event and the name of a state.*/
proc breakLoopOn(MEvent, MState)
  if ([breakOn[MEvent.name][MState.name]] == [MEvent.name])
    return "TRUE";
  else
    [breakOn[MEvent.name][MState.name]] = [MEvent.name];
    return "FALSE";
  end if
end proc


/* initialize temp var. tmpTriggerEvName */
proc setTmpTriggerEventName(MEvent)
  [tmpTriggerEvName] = [MEvent.name];
end proc


template generateEventParameter(MEvent)
[loop (MEvent->EvPara)]
[EvPara.type] [EvPara.name] = [EvPara.defaultValue];
[end loop]
end template


/* generated will be the guard (if one exists) as an if statement with
curly braces. Inside that braces will be generated the actions and
sendevents if existing.  */
template generateGuardStatement(MTransition, MState)
[if (hasLoop(MTransition->MGuard))]
[generateGuardStatementBegin([MTransition])]
  [/* An exit action is executed for _all_ outgoing transitions. Therefore]
  [   it comes before all actions of the outgoing transition. We look for exit]
  [   actions of the "FromState" here! */]
  [if (! hasLoop(MState->MPseudoState Where [MPseudoState.kind] == "JunctionPoint"))]
  [genExitAction([MState], [MTransition])]
  [getEventOperations([MTransition])]
  [getEventSendEvents([MTransition])]
  [end if]
  [// if the transitions leads to a DynamicChoicePoint]
  [if (hasLoop(MState->MPseudoState Where [MPseudoState.kind] == "DynamicChoicePoint" || [MPseudoState.kind] == "JunctionPoint"))]
    [loop(MState->MPseudoState Where [MPseudoState.kind] == "DynamicChoicePoint")]
  [getDynamicChoicePointStatement([MPseudoState])]
    [end loop]
    [loop(MState->MPseudoState Where [MPseudoState.kind] == "JunctionPoint")]
  [getJunctionPointStatement([MPseudoState], [MTransition])]
    [end loop]
  [else]
  [/* An entry action is executed for _all_ incoming transitions. Therefore]
  [   it comes before the activity */]
  [genEntryAction([MState])]
  [genNewCurrentState([MState]) /* set new current state */]
  [end if]
  break;
[generateGuardStatementEnd([MTransition])]
[else]
[/* no guard so generate only action list and sendevent list  */]
[/* An exit action is executed for _all_ outgoing transitions. Therefore]
[   it comes before all actions of the outgoing transition. We look for exit]
[   actions of the "FromState" here! */]
  [if (! hasLoop(MState->MPseudoState Where [MPseudoState.kind] == "JunctionPoint"))]
[genExitAction([MState], [MTransition])]
[getEventOperations([MTransition])]
[getEventSendEvents([MTransition])]
  [end if]
[// if the transitions leads to a DynamicChoicePoint]
  [if (hasLoop(MState->MPseudoState Where [MPseudoState.kind] == "DynamicChoicePoint" || [MPseudoState.kind] == "JunctionPoint"))]
    [loop(MState->MPseudoState Where [MPseudoState.kind] == "DynamicChoicePoint")]
[getDynamicChoicePointStatement([MPseudoState])]
    [end loop]
    [loop(MState->MPseudoState Where [MPseudoState.kind] == "JunctionPoint")]
[getJunctionPointStatement([MPseudoState], [MTransition])]
    [end loop]
  [else]
[/* An entry action is executed for _all_ incoming transitions. Therefore]
[   it comes before the activity */]
[genEntryAction([MState])]
[genNewCurrentState([MState]) /*set new current state*/]
  [end if]
[end if]
end template


// Returns Statement for  DynamicChoicePoints.
// After the first guard, the action of the
// incoming is evaluated. The result of this
// action influences the guards of the outgoing
// transitions.
proc getDynamicChoicePointStatement(MPseudoState)
  [MPseudoState:out_trans] = 0;
  local transitions = 0;
  local retval;
  
  [transitions] = loopCount(MPseudoState->ToState);
  >>
  [loop(MPseudoState->ToState AS TS)]
    [loop(TS->MTransition As MT->MGuard Where [MGuard.expression] != "else")]
      [incTrans([MPseudoState])]
      [if ([MPseudoState:out_trans] == 1)]
  if ([MGuard.expression]) {
      [else]
  else if ([MGuard.expression]) {
      [end if]
    [getEventOperations([MT])]
    [getEventSendEvents([MT])]
    [genEntryAction([TS])]
    [genNewCurrentState([TS])]
  }
    [end loop]
  [end loop]
  [if ([transitions] > 1)]
    [if (hasLoop(MPseudoState->ToState As TS->MTransition As MT->MGuard Where [MGuard.expression] == "else"))]
      [loop(MPseudoState->ToState As TS->MTransition As MT->MGuard Where [MGuard.expression] == "else")]
  else {
    [getEventOperations([MT])]
    [getEventSendEvents([MT])]
    [genEntryAction([TS])]
    [genNewCurrentState([TS])]
  }
      [end loop]
    [else]
  else {
  
  }
    [end if]
  [end if]
  >> [retval]
  return [retval];
end proc


// Returns Statement for static JunctionPoints
// All Guards must be evaluated _first_ before
// a transition can be triggered!
proc getJunctionPointStatement(MPseudoState, MTransition As FT)
  [MPseudoState:out_trans] = 0;
  local transitions = 0;
  local retval;
  
  [transitions] = loopCount(MPseudoState->ToState);
  >>
  [loop(MPseudoState->ToState AS TS->MTransition As MT)]
    [if (hasLoop(MT->MGuard))]
      [loop(MT->MGuard Where [MGuard.expression] != "else")]
        [incTrans([MPseudoState])]
        [if ([MPseudoState:out_trans] == 1)]
  if ([MGuard.expression]) {
        [else]
  else if ([MGuard.expression]) {
        [end if]
    [getEventOperations([FT])]
    [getEventSendEvents([FT])]
    [getEventOperations([MT])]
    [getEventSendEvents([MT])]
    [genEntryAction([TS])]
    [genNewCurrentState([TS])]
  }
      [end loop]
    [else]
  [getEventOperations([FT])]
  [getEventSendEvents([FT])]
  [getEventOperations([MT])]
  [getEventSendEvents([MT])]
  [genEntryAction([TS])]
  [genNewCurrentState([TS])]  
    [end if]
  [end loop]
  [if ([transitions] > 1)]
    [if (hasLoop(MPseudoState->ToState As TS->MTransition As MT->MGuard Where [MGuard.expression] == "else"))]
      [loop(MPseudoState->ToState As TS->MTransition As MT->MGuard Where [MGuard.expression] == "else")]
  else {
    [getEventOperations([FT])]
    [getEventSendEvents([FT])]
    [getEventOperations([MT])]
    [getEventSendEvents([MT])]
    [genEntryAction([TS])]
    [genNewCurrentState([TS])]
  }
      [end loop]
    [else]
  else {
  
  }
    [end if]
  [end if]
  >> [retval]
  return [retval];
end proc

proc incTrans(MPseudoState)
  [MPseudoState:out_trans] = add([MPseudoState:out_trans], 1);
end proc


template genNewCurrentState(MState)
currentState = _[toUpper([MState.name])];
[loop(MState->MNormalState)]
[MNormalState.name]_Action();
[end loop]
end template


template getEventSendEvents(MTransition)
[loop(MTransition->MTarget)]
[MTarget.target].\
  [loop(MTarget->MEvent)]
[MEvent.name](\
    [loop(MEvent->EvPara)]
[MTarget.target]._[toUpper([EvPara.name])]);
    [end loop]
  [end loop]
[end loop]
end template


proc generateGuardStatementBegin(MTransition)
  loop(MTransition->MGuard)
    return "if ("[MGuard.expression]") {";
  end loop
end proc


proc generateGuardStatementEnd(MTransition)
  loop(MTransition->MGuard)
    return "}";
  end loop
end proc



/////////////////////////////////////////////
// State Machine realized with nested classes
/////////////////////////////////////////////

/*  coordinates all the stuff that is needed for the
  state table pattern
*/
template createStatemachineClasses(MClass)
// ------------------------------------------------------------
// state machine (realized with nested classes)
// ------------------------------------------------------------
^
[genTakeEventProc([MClass])]
^
[genEnumOfStates_Events([MClass])]
^
[genTransitionContainer([MClass]) /* gen. the transition container */]
[genState([MClass])]
[genEntryActivityExitOps([MClass])]
[genStateTable([MClass])]
end template

template genEnumOfStates_Events(MClass)
[/* An attribute for each event a state can receive is generated and initialized
    getCount returns a number that is increased by addCount (defined in std.tdl) */]
[loop(MClass->ReceiveEvent;
setText("// events /////////////////////////////////////////////////////////////////"),
setCount(0);addCount(1))]
[getText()]
public static final int _[toUpper(replace([ReceiveEvent.name], " +", "_"))] = [getCount()];
[end loop]
^
[/* An attribute for each state is generated and initialized
    getCount returns a number that is increased by addCount (defined in std.tdl) */]
[loop(MClass->MStatemachine->MState;
setText("// states /////////////////////////////////////////////////////////////////"),
setCount(0);addCount(1))]
[getText()]
public static final int _[toUpper([MState.name])] = [getCount()];
[end loop]
end template


/*  Each state in the state machine is represented by a
  separate class, that is derived from the base class "State"
  A state is determined by the following operations:
  - entry() : the executed action, when a state is entered
  - exit()  : the executed action, when a state is exited,
  - activity(): that's just what a state has to do as long as it is active
*/
template genState(MClass)
^
class State {
  int stateID;
^
  public void entry()    { return; }
  public void exit()     { return; }
  public void activity() { return; }
^
  [loop (MClass->MStatemachine->MState)]
^
  // The following classes represent all possible states.
  // The implementation of the operations just call methods of
  // the enclosing context class
  class [replace([MState.name], " +", "_")] extends State {
    public void entry()     { [toLower([MState.name])]Entry(); }
    public void exit()      { [toLower([MState.name])]Exit(); }
    public void activity()  { [toLower([MState.name])]Activity(); }
  }
  [end loop]
}
end template


/*  Following are the implementation methods that are called from
  the entry-, exit-, activity operations of the implementation classes
  of the states (derived from State)
*/
template genEntryActivityExitOps(MClass)
[loop (MClass->MStatemachine->MState)]
public void [toLower([MState.name])]Entry() {
  [if (hasLoop(MState->MAction->MActionType Where [MActionType.type] == "entry"))]
    [loop(MState->MAction->MActionType Where [MActionType.type] == "entry")]
      [loop(Instances->TokenSet([MAction.name]))]
  [TokenSet.line]
      [end loop]
    [end loop]
  [else]
  return;
  [end if]
}
public void [toLower([MState.name])]Exit() {
  [if (hasLoop(MState->MAction->MActionType Where [MActionType.type] == "exit"))]
    [loop(MState->MAction->MActionType Where [MActionType.type] == "exit")]
      [loop(Instances->TokenSet([MAction.name]))]
  [TokenSet.line]
      [end loop]
    [end loop] 
  [else]
  return;
  [end if]
}
public void [toLower([MState.name])]Activity() {
  [if (hasLoop(MState->MActivity))]
    [loop(MState->MActivity)]
      [loop(Instances->TokenSet([MActivity.name]))]
  [TokenSet.line]
      [end loop]
    [end loop]
  [else]
  return;
  [end if]
}
[end loop]
end template


/*  Following are classes that represent transition objects
  The name is build of the event name and the name of the
  guard/condition.
  The implementation of the operations guard and action just
  calls operations of the enclosing context class.
*/
template genTransitionObjects(MClass)
[loop (MClass->MStatemachine->MState->MNormalState)]
[loop (MNormalState->ToState->MTransition)]
[if (!isDoubleClassNames([MTransition]))]
class [genTransClassName([MTransition])] extends Trans_Base {
  // Constructor
  [genTransClassName([MTransition])](int sb) { super(sb); }
  public boolean guard() { return [getGuard([MTransition])]; }
  public void action() {
    [getEventOperations([MTransition])]
  }
}
^
[end if]
[end loop]
[end loop]
[// it follows the same procedure for the creation state]
[loop (MClass->MStatemachine->MState->MCreationState)]
[loop (MCreationState->ToState->MTransition)]
[if (!isDoubleClassNames([MTransition]))]
class [genTransClassName([MTransition])] extends Trans_Base
{
  // Constructor
  [genTransClassName([MTransition])](int sb) { super(sb); }
  public boolean guard() { return true; }
  public void action() {
    [getEventOperations([MTransition])]
  }
}
[end if]
[end loop]
[end loop]
[// it follows the same procedure for the composite state]
[loop (MClass->MStatemachine->MState->MCompositeState)]
[loop (MCompositeState->ToState->MTransition)]
[if (!isDoubleClassNames([MTransition]))]
class [genTransClassName([MTransition])] extends Trans_Base
{
  // Constructor
  [genTransClassName([MTransition])](int sb) { super(sb); }
  public boolean guard() { return true; }
  public void action() {
    [getEventOperations([MTransition])]
  }
}
[end if]
[end loop]
[end loop]
^
end template


template genTransitionContainer(MClass)
class TransitionContainer {
  // stores the no. of transition objects (Trans_Base)
  int nGuards=0;
  // stores the index of the trans. object of which the guard was true
  int lastTrueGuard=0;
  // index of the Trans_Base array that holds the transition objects.
  // It's the max. no. of transition objects with same name, a
  // single state can have
  int noOfTrans= [getMaxNoOfTrans([MClass])];
  //  trob stores transition objects (Trans_Base), that meet following condition:
  //  - same event name
  //  - same source state
  Trans_Base trob\[] = new Trans_Base\[noOfTrans];
  TransitionContainer() {}

  // transition objects (Trans_Base) are stored in their respective Transition Container
  // at the first free location, nGuards has to be updated
  // the order of transition objects is not important
  public void setTransInterface(TransInterface ti) {
    int i;
    for (i=0;  i < noOfTrans; i++) {
      if (trob\[i] == null) {
        trob\[i] = (Trans_Base) ti;
        nGuards += 1; // how many guards do we have
        break;      // nGuards==1 means exactly one guard
      }
    }
  }
^
  public boolean guard() {
    boolean retGuard = false;
    // only one single transition object
    if (nGuards == 1) {
      return trob\[0].guard();
    }
    // search the number of transition objects for the one, that's guard
    // return true. Remember index in lastTrueGuard
    else {
      int i=0;
      for (i=0; i < noOfTrans; i++) {
        retGuard = trob\[i].guard();
        if (retGuard) {
          lastTrueGuard = i;
          return true;
        }
      }
      return false;
    }
  } // guard
  // execute the action associated with the transition object
  // access with index = lastTrueGuard, called by instance of StateTabe
  public void accept() {
    trob\[lastTrueGuard].action();
  }
^
  // set new current state
  public int getNextState() {
    int tmpLastTrueGuard = lastTrueGuard;
    lastTrueGuard=0;  // reset it, it's not longer needed
    return trob\[tmpLastTrueGuard].getNextState();
  }
^
  public void init_trin() {
    int i;
    for (i=0; i < noOfTrans; i++) {
      trob\[i] = null;
    }
  }
^
  [genTransBase([MClass])]
^
  [genTransitionObjects([MClass])]
}
end template


/*  This interface describes the services, that a transition object (Trans_Base)
  has to deliver. The operations are implemented in the
  transition objects itself (the classes, that are derived from Trans_Base)
  Normally the implementation of these interface operations just calls
  methods of the enclosing context class
*/
template genTransInterface(MClass)
interface TransInterface {
  public boolean guard();
  public void action();
  // implemented in abstract base class Trans_Base
  public int getNextState();
}
end template


/*  This is the abstract base class for the real transition objects
  derived from this class. It is introduced to keep the
  transition objects (derived from this class) as small as possible.
*/
template genTransBase(MClass)
public abstract class Trans_Base implements TransInterface {
  // store the target state of the transition object
  protected int nextState;
  // parameter is the target state of the transition object
  Trans_Base(int ns) { nextState = ns;}
  public int getNextState() { return nextState; }
}
end template


/*  generate takeEvent function
  events are forwarded to instance of StateTable
*/
template genTakeEventProc(MClass)
/**
 * Central event processing method of class [MClass.name].
 * Delegates all incoming events <code>ev</code>
 * to {@link [MClass.name].StateTable#takeEvent(int) }
 *
 * @param ev The event to be processed.
 * @see [MClass.name].StateTable#takeEvent(int)
 */
public void takeEvent(int ev) {
  stateTable.takeEvent(ev);
}
end template


template genStateTable(MClass)
^
class StateTable {
  // no. of states
  int noOfStates = [getNoOfStates([MClass])];
^
  // total number of transition with different names
  int noOfTrans = [getTransWithDifferentName([MClass])];
^
  // init the currentstate
  int currentState = _[toUpper(getFirstCurrentState([MClass]))];
^
  // holds all states (of type State), indexed by the state id.
  State stateArray\[] = new State\[noOfStates];
^
  // holds all transitions (Transition)
  // for each state, so the rows in the matrix correspond to the states,
  // the columns correspond to the transitions
  TransitionContainer stateTransMatrix\[]\[] = new TransitionContainer\[noOfStates]\[noOfTrans];
^
  // constructor
  StateTable() {
    // set array and matrix elements to null
    initiateWithNull();
  }
^
  // stores the State sb on position index in the array
  // that contains all states
  public void assignState(State sb, int index) {
    stateArray\[index] = sb;
  }
^
  // stores all transition containera for each state,
  // so the rows in the matrix correspond to the states,
  // the columns correspond to the transition containers
  // Parameters:
  //      1. transition container
  //      2. stateIndex (of source state)
  //      3. transition index no.
  // Remark: 2. & 3. are indices for the matrix
  public void assignTrans(TransitionContainer tb, int stateIndex, int transIndex) {
      stateTransMatrix\[stateIndex]\[transIndex] = tb;
  }
^
  // initiate the elements of stateArray and stateTransMatrix with null
  private void initiateWithNull() {
    int i, j;
    for (i=0; i < noOfStates; i++) {
      stateArray\[i]=null;
    }
    for (i=0; i < noOfStates; i++) {
      for (j=0; j < noOfTrans; j++) {
        stateTransMatrix\[i]\[j]=null;
      }
    }
  }
^
  // this is the entry point for StateTable instance to work on events.
  // first the event is send to the enclosing context class, that forwards
  // the event to the follwoing method takeEvent, where it will
  // be processed.
  public void takeEvent(int ev) {
    TransitionContainer transCont = null;
    int i;
    // first of all the right transition (Transition) must be retrieved
    // from the state transition matrix. The statemachine is in state
    // currentState so we look in the appropriate row currentState
    // for the correct transition just by using the event as index (ev)
    transCont = stateTransMatrix\[currentState]\[ev];
    if (transCont==null) {
      System.out.println("Could not process event\n");
      return;
    }
    // The current state could handle several transitions with same
    // name but different guards and actions. What is retrieved from the
    // matrix is only a container for transition objects (Trans_Base),
    // so if we have the case of a event name multiplicity
    // the transition has to look for the right transition object,
    // what is done in the method trans.guard().
    if (transCont.guard() == true) {   // execute guard of transition of currentstate
      // execute exit action of current state
      stateArray\[currentState].exit();
      // execute action of transition
      transCont.accept();
      // get new current state
      currentState=transCont.getNextState();
      // execute the entry action of the newly current state
      stateArray\[currentState].entry();
      // execute the activity of the new current state
      stateArray\[currentState].activity();
    }
  }
}
^
[genTransInterface([MClass])]
^
StateTable stateTable = null;
State state = null;
end template


/*  returns the event name for transition from MState to ToState
*/
proc triggerEvName(MState)
loop(MState->ToState->MTransition->TriggerEvent)
return toUpper(replace([TriggerEvent.name], " +", "_"));
end loop
end proc
