/************************************************** 
 * java_Class.tdl
 * --------------
 *
 * The "master" template for a Java class.
 * The order, in which indivual class members appear:
 *
 * 1) static attributes (constants too)
 * 2) instance attributes (both modeled and from reference)
 * 3) constructors
 * 4) operations
 *    a) modeled operations
 *    b) methods from implemented interfaces
 *    c) accessor methods coming from instance attributes
 *    d) eventually "finalize()";
 *    e) eventually "standard operations"
 * 5) If the class has a statemachine, code for a finite
 *    automaton is created, either by nested switch 
 *    statements or by a pattern of inner classes.
 * 6) nested classes or interfaces (which in turn can
 *    repeat the structure above recursivly)
 * 
 * Author:  Frank Lippert
 * Company: Aonix GmbH
 * Date:    17.12.2001
 *
 * Copyright 2001, Aonix, San Diego
 **************************************************/


template MNormalClass.gen_body()
[genClassDependencies([MNormalClass])]
  [if ([COMMENT_CLASSES])]
[genJavaDocComment([MNormalClass])]
  [end if]
[string_trim(replace([MNormalClass:access]" "[MNormalClass:modifiers]" class "[MNormalClass.name]genBaseClass([MNormalClass])genImplementIfc([MNormalClass]), "  +", " "))] {
  [if (hasLoop(MNormalClass->MAttribute Where [MAttribute.binding] == "static"))]
^
  // ------------------------------------------------------------
  // static attributes
  // ------------------------------------------------------------
    [loop(MNormalClass->MAttribute Where [MAttribute.binding] == "static")]
      [importType([MAttribute.type])]
      [if ([COMMENT_ATTRIBUTES])]
  [genJavaDocComment([MAttribute])]
      [end if]
      [if ([MAttribute:defval] == "" || [MAttribute:derived])]
  [string_trim(replace([MAttribute.access]" static "[MAttribute:modifiers]" "[MAttribute.type]" "[MAttribute.name], "  +", " "))];    
      [else]
  [string_trim(replace([MAttribute.access]" static "[MAttribute:modifiers]" "[MAttribute.type]" "[MAttribute.name], "  +", " "))] = [MAttribute:defval];
      [end if]
    [end loop]
  [end if]
  [if (hasLoop(MNormalClass->MAttribute Where [MAttribute.binding] == ""))]
^
  // ------------------------------------------------------------
  // instance attributes
  // ------------------------------------------------------------
    [loop(MNormalClass->MAttribute Where [MAttribute.binding] == "")]
      [importType([MAttribute.type])]
      [if ([COMMENT_ATTRIBUTES])]
  [genJavaDocComment([MAttribute])]
      [end if]
      [if ([MAttribute:defval] == "" || [MAttribute:derived])]
  [string_trim(replace([MAttribute.access]" "[MAttribute:modifiers]" "[MAttribute.type]" "[MAttribute.name], "  +", " "))];
      [else]
  [string_trim(replace([MAttribute.access]" "[MAttribute:modifiers]" "[MAttribute.type]" "[MAttribute.name], "  +", " "))] = [MAttribute:defval];    
      [end if]
    [end loop]
  [end if]
^
  [mergeOut("UDAT::"[MNormalClass.guid], "---- additional attributes")]
  [if (hasLoop(MNormalClass->MOperation Where [MOperation.name] == [MNormalClass.name]))]
^
  // ------------------------------------------------------------
  // constructors
  // ------------------------------------------------------------
    [loop(MNormalClass->MOperation Where [MOperation.name] == [MNormalClass.name])]
      [if ([COMMENT_METHODS])]
  [genJavaDocComment([MOperation])]
      [end if]
  [string_trim(replace([MOperation.access]" "[MOperation.name], "  +", " "))]([getOpParas([MOperation])])[getExceptions([MOperation])] {
    [mergeOutConstructor("UDCC::", [MOperation], "---- constructor body")]
  }
^
    [end loop]
  [end if]
  [mergeOut("UDCO::"[MNormalClass.guid], "---- additional constructors")]
  [if (hasLoop(MNormalClass->MOperation Where [MOperation.name] != [MNormalClass.name]))]
^
  // ------------------------------------------------------------
  // methods
  // ------------------------------------------------------------
    [loop(MNormalClass->MOperation Where [MOperation.name] != [MNormalClass.name])]
      [importType([MOperation.returnType])]
      [if ([COMMENT_METHODS])]
  [genJavaDocComment([MOperation])]
      [end if]
      [if ([MOperation:abstract] || [MOperation:native])]
  [string_trim(replace([MOperation.access]" "[MOperation.binding]" "[MOperation:modifiers]" "[MOperation.returnType], "  +", " "))] [MOperation.name]([getOpParas([MOperation])])[getExceptions([MOperation])];
      [else]
  [string_trim(replace([MOperation.access]" "[MOperation.binding]" "[MOperation:modifiers]" "[MOperation.returnType], "  +", " "))] [MOperation.name]([getOpParas([MOperation])])[getExceptions([MOperation])] {
    [mergeOutOperation("UDOP::", [MOperation], "---- method body")]
  }
^
      [end if]
    [end loop]
  [end if]
  [mergeOut("UDOP::"[MNormalClass.guid], "---- additional operations")]
  [if ([CREATE_STANDARD_OPS])]
  [createStandardOperations([MNormalClass])]
  [end if]
  [if (hasLoop(MNormalClass->MStatemachine))]
^
  [createStatemachine([MNormalClass])]
  [end if]
  [loop(MNormalClass->NestedClass)]
  [[NestedClass].gen_body()]
  [end loop]
}
end template


/* Generates a "implements"-clause for classes which
 * implement interfaces. The type of the interface is
 * imported, if such an interface resides in a different
 * package than the current class.
 */
proc genImplementIfc(MClass)
  local ifc;
  loop(MClass->Implement; setDelim(""); setDelim(", "))
    insert("import", [Implement.id]);
    [ifc] = [ifc] delim() [Implement.name];
  end loop
  if ([ifc] != "")
    [ifc] = " implements " [ifc];
  end if
  return [ifc];
end proc


template createStandardOperations(MNormalClass)
// ------------------------------------------------------------
// standard methods
// ------------------------------------------------------------
[if (! hasLoop(MNormalClass->MOperation Where [MOperation.name] == "toString"))]
^
/**
 * Generates a String representation of this object.
 * Loops over all non-static fields of this object.
 *
 * Users are encouraged to accustom this function to
 * their specific needs!
 *
 * @return The content (state) of this object as string.
 */
public String toString() {
  StringBuffer strbuf = new StringBuffer();
  strbuf.append("[MNormalClass.name]:\n");
  [loop(MNormalClass->MAttribute Where [MAttribute.binding] == "")]
    [if (isPrimitiveJavaType([MAttribute.type]))]
  strbuf.append("[MAttribute.name]: " + [MAttribute.name]).append("\n");
    [else]
  if ([MAttribute.name] != null)
    strbuf.append("[MAttribute.name]: " + [MAttribute.name].toString()).append("\n");
  else
    strbuf.append("[MAttribute.name]: null").append("\n"); 
    [end if]
  [end loop]
  //#ACD# M([MNormalClass.guid]-toString) ---- method body
  //user defined code to be added here ...
  
  //#end ACD#
  return strbuf.toString();
}
[end if]
[if (! hasLoop(MNormalClass->MOperation Where [MOperation.name] == "equals"))]
^
/**
 * Tests this instance against another object for equality.
 * Rather to test for simple object reference equality as in
 * {@link java.lang.Object#equals(Object) Object.equals(Object o)} 
 * this function tests against <i>semantic</i> equivalence of the 
 * content of the two objects.<br><br>
 *
 * Note that instances of classes without instance attributes return
 * always <code>true</code>, since they <b>must</b> have the same
 * state.<br><br>
 *
 * Users are encouraged to customize this function to
 * their specific needs!
 *
 * @param o The object this instance is compared to.
 * @return <code>true</code>, if the two objects are equivalent semantically.
 */
public boolean equals(Object o) {
  if (! (o instanceof [MNormalClass.name]))
    return false;
  else {
    [/* generate code only if class has a state, d.e. non-static attributes*/]
    [if (hasLoop(MNormalClass->MAttribute Where [MAttribute.binding] == ""))]
    [MNormalClass.name] c = ([MNormalClass.name]) o;
    if [generateEqualsClause([MNormalClass])]
      return true;
    else
      return false;
    [else]
    return true;
    [end if]
  }
}
[end if]
[if (! [MNormalClass:abstract] && ! hasLoop(MNormalClass->MOperation Where [MOperation.name] == "clone"))]
^
[/*]
  * You may change this method, so it copies
  * datastructures too, making the new object a
  * "deep" copy rather than a "shallow" copy.
  *
  * The class must not be abstract!
 [*/]
/**
 * Provides a (shallow) copy of this instance and returns it. 
 * It achieves that by looping over all non-static fields of 
 * this instance and assigning their values to the corresponding 
 * fields of the new object. <br><br>
 * Note, that there <b>must</b> be an accessible no-arg default 
 * constructor for this function to work, either explicitly in 
 * the class or by <b>not</b> defining any other constructors!
 *
 * @return The newly created object.
 */
public Object clone() {
  [MNormalClass.name] obj = new [MNormalClass.name]();
  [loop(MNormalClass->MAttribute Where [MAttribute.binding] == "" && ! [MAttribute:final])]
  obj.[MAttribute.name] = [MAttribute.name];
  [end loop]
  return obj;
}
[end if]
^
end template


// Generates the content of the if-statement in the "equals()"-function.
template generateEqualsClause(MNormalClass)
([loop(MNormalClass->MAttribute Where [MAttribute.binding] == ""; setDelim(""); setDelim("&& "))]
[if (isPrimitiveJavaType([MAttribute.type]))]
 [delim()]this.[MAttribute.name] == c.[MAttribute.name]
[else]
 [delim()](([MAttribute.name] == null && c.[MAttribute.name] == null) || ([MAttribute.name] != null && c.[MAttribute.name] != null && [MAttribute.name].equals(c.[MAttribute.name])))
[end if][end loop])
end template
