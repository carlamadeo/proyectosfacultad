//*****************************************************************************
// $RCSfile: cpp_gensm.tdl,v $
// $Revision: 1.9 $
// $Date: 2002/03/29 08:53:30 $
// Author: Markus Kern
//*****************************************************************************
/*
Generates the state machine for each active instance of meta type MClass.
genStateMachine is called by genH (defined in cpp_genh.tdl).
genStateMachineBody is called by genCPP (defined in cpp_gencpp.tdl).
*/

/* the interface of a state machine is given by:
   an enumeration of all events (objEvent)
   an enumeration of all states (objStates)
   an operation for sending an Event (takeEvent)
   a static operation instantiating the class and sending a creation event 
   (classEvent)
*/
USES cpp_utilsm;
template genStateMachine(MClass)
[	initDyn([MClass])]
public:
    [/* add each MEvent belonging to the MClass to objEvent. 
        setDelim()/delim() (defined in std.tdl) specify delimiter placement. */]
    enum objEvent {
        [buildEventList([MClass])]\
        [/* implicit event for automatic transition */]
[delim()]\
AutomaticTransition
        [/****************************************************/]
    };

    [/* add each MCreationState and each MNormalState belonging to the 
        MClass to objStates, i.e. MFinalState is omitted. */]
    enum objStates {
        [buildStateList([MClass])]
    };

    /// Event taker functions /////////////////////////////////////
    void takeEvent (const [MClass.name]::objEvent&);
    static [MClass.name] * classEvent (const [MClass.name]::objEvent&);

protected:
    [/* define for each MNormalState belonging to the MClass an action
        procedure. The action procedure contains the action to be performed
        when the state is reached. */]
    /// State action functions ////////////////////////////////////
    [loop(MClass->MStatemachine)] 
    [genAction([MStatemachine])] 
    [end loop]
end template

/* implement the operations of the state machine */
template genStateMachineBody(MClass)
//------------------------------------------------------------------------------
// S T A T E  M A C H I N E  S E C T I O N
//------------------------------------------------------------------------------

//--Class Event-----------------------------------------------------------------
[MClass.name] * [MClass.name]::classEvent (const [MClass.name]::objEvent& ev)
{
    [MClass.name] * newInstance = 0;

    switch(ev) {
    [/* accept each event (TriggerEvent) which causes a transition from an
        instance of MCreationState to some other state (ToState) */]
    [loop(MClass->MStatemachine->MState->MCreationState->ToState->MTransition->TriggerEvent)]
        case [MClass.name]::[TriggerEvent.name]:
            [/* for this event create a new instance of MClass
                and send the event to that instance */]
            {
                newInstance = new [MClass.name];
                newInstance->takeEvent(ev);
            }
            break;
    [end loop]
        default:
            [/* An illegal event has been used. For now we just put
                an error message */]
            cout << "illegal create event\n"; 
            break;
    }
    return newInstance;
}

//--Take Event------------------------------------------------------------------
void [MClass.name]::takeEvent (const [MClass.name]::objEvent& ev)
{
    [/* handle each possible state, currentState holds the current state
        of the state machine */]
    switch(currentState) 
    {   
        [genereAll([MClass])]
        default:
            [/* An illegal event has been used. For now we just put
                an error message */]
            cout << "illegal state " << currentState <<endl;
            break;

    } // end of switch current state
}

//--Action Procedures-----------------------------------------------------------
[loop(MClass->MStatemachine->MState Where ! hasLoop(MState->MPseudoState))]
//------------------------------------------------------------------------------
//
// State :      [MState.name]
//
//------------------------------------------------------------------------------
void [MClass.name]::[MState.name]_Action ()
{
    [mergeOut("UDAC::" getUniqueId([MState]),"Action Code")]
    takeEvent(AutomaticTransition);
}

[end loop]
end template

proc setTmpTriggerEventName(MEvent)
    [tmpTriggerEvName] = [MEvent.name];
end proc

template generateEventParameter(MEventPara As EvPara)
[EvPara.type] [EvPara.name] = [EvPara.defaultValue];\
end template

template generateGuardStatementBegin(MGuard)
if ([MGuard.expression]) {\
end template

template getEventOperations(MAction As SendAction)
[SendAction.name];\
end template

template getEventSendEvents(MTransition, MTarget As MT)
_[MT.target]->\
[loop(MTransition->MTarget->MEvent Where ([MT.id] == [MTarget.id]) )]
[MEvent.name](\
[loop(MEvent->EvPara)]
[getTargetType([MTarget])]::objEvent::[EvPara.name]\
[end loop]
);
[end loop]
end template

//template getEventSendEvents(MTransition, MTarget As MT)
//[loop(MTransition->MTarget->MEvent Where ([MT.id] == [MTarget.id]) )]
//send_[MEvent.name](\
//[loop(MEvent->EvPara)]
//[getTargetType([MTarget])]::objEvent::_[EvPara.name]\
//[end loop]
//);
//[end loop]
//end template

template genNewCurrentState(MState)
currentState = _[MState.name];
[if (hasLoop(MState->MFinalState where [MFinalState.name] == [MState.name]))] 
[else] 
    [MState.name]_Action(); 
[end if] 
end template

template generateGuardStatementEnd(MGuard)
}\
end template

/* Meta attributes are used to find out, whether the combination of
eventname and statename already occurred.
The meta attributes consists of the liteal "breakOn" followed
by the name of an event and the name of a state.*/
proc breakLoopOn(MEvent, MState)
    if ([breakOn[MEvent.name][MState.name]] == [MEvent.name])
        return "TRUE";
    else
        [breakOn[MEvent.name][MState.name]] = [MEvent.name];
        return "FALSE";
    end if
end proc

/* set a global variable to hold the type of the relation by the relation name
used by statemachine (target of sendevent)*/
proc setTargetType(MAssociationEnd)
        loop(MAssociationEnd->MClass)
                [TYPE_[MAssociationEnd.name]] = [MClass.name];
        end loop
        return;
end proc

/* get the global variable
set by the relationship generator */
proc getTargetType(MTarget)
        return [TYPE_[MTarget.target]];
end proc

template genereAll(MClass) 
[/* handle each possible state, currentState holds the current state*/] 
[/*of the state machine */] 
[loop( MClass->MStatemachine )] 
[genereAllState([MStatemachine],[MClass])] 
[end loop] 
end template 
    
template genereAllState(MStatemachine as MS,MClass) 
[/*generation for initial state*/] 
[loop( MS->MState->MCreationState as CS)] 
[genStateCase([CS],[MClass])] 
[end loop] 
[/*generation for normal state which are not initial state*/] 
[loop( MS->MState->MNormalState as NS)] 
[genStateCase([NS],[MClass])] 
[end loop] 
end template 
    
template genStateCase(MState, MClass) 
[if (isCompositeState([MState]))]\ 
[loop(MState->Submachine->MState as SubState where isCreationState([SubState]))]\ 
[genereState([SubState], [MClass])]\ 
[end loop]\ 
[// final component state => taken into account - leaves the state if any transition of the super state can be triggered]\ 
[loop(MState->Submachine->MState as SubState where isFinalState([SubState]))]\ 
[genereState([SubState], [MClass])]\ 
[end loop]\ 
[loop(MState->Submachine->MState as SubState->MNormalState where isNormalState([MNormalState]))]\ 
[genStateCase([SubState], [MClass])]\ 
[end loop]\ 
[else]\ 
[genereState([MState], [MClass])]\ 
[end if]\ 
end template 
    
template genereState(MState as CS, MClass) 
[/*generic generation for state*/] 
[/*if a state has a transition without event or guard, we consider that this transition 
  is the only one the state can fire*/] 
case [MClass.name]::[CS.name]: 
[if( hasLoop(CS->ToState->MTransition) )] 
    switch(ev) { 
    [if( hasTransitionWithoutEventAndGuard([CS]) )] 
    case [MClass.name]::AutomaticTransition: 
        [loop(CS->ToState AS TS->MTransition AS MT where isAutomatic([MT]) )] 
        [loop(MT->SendAction)] 
            [getEventOperations([SendAction])] 
        [end loop] 
        [loop(MT->MTarget)] 
            [getEventSendEvents([MT],[MTarget])] 
        [end loop] 
            [genTransition([MT],[CS],[MClass])] 
        [end loop] 
    break; 
[else] 
    [if( hasTransitionWithoutEventAndWithGuard([CS]))] 
        case [MClass.name]::AutomaticTransition: 
        [loop(CS->ToState AS TS->MTransition AS MT where isAutomaticWithGuard([MT]) )] 
        [loop(MT->MGuard)] 
        [generateGuardStatementBegin([MGuard])] 
        [loop(MT->SendAction)] 
        [getEventOperations([SendAction])] 
        [end loop] 
        [loop(MT->MTarget)] 
        [getEventSendEvents([MT],[MTarget])] 
        [end loop] 
        [genTransition([MT],[CS],[MClass])] 
        [generateGuardStatementEnd([MGuard])] 
        [end loop] 
        [end loop] 
            break;\ 
    [else] 
        case [MClass.name]::AutomaticTransition: 
            break; 
    [end if] 
    [if( hasTransitionWithEvent([CS]))] 
    [loop(CS->ToState->MTransition->TriggerEvent)] 
    [/* There are events with same name but having different guards. 
    Here the case statement for the eventname has to be suppressed, only 
    the guard and actions/sendevents are of interess. 
    breakLoopOn is TRUE if event name already occured for the state MState 
    It will not break if the eventname already occured but name of state 
    MState occurres the first time. */] 
    [if (breakLoopOn([TriggerEvent],[CS]) == "FALSE")] 
    [/* s. getCount below */] 
    [setCount(0)] 
    [/* set global var. tmpTriggerEvName */] 
    [setTmpTriggerEventName([TriggerEvent])] 
    [/* This is the inner loop filtering only events with same eventname as 
    in outer loop. */] 
    [loop(CS->ToState AS TS->MTransition AS MT->TriggerEvent AS TE where [TE.name]==[tmpTriggerEvName])] 
    [/* Keep care to generate only one case statement, even if state has more than 
    one events with same name */] 
    [if (getCount() == "0")] 
        case [MClass.name]::[TriggerEvent.name]:\ 
    [addCount(1)] 
    [end if] 
        { 
    [loop (TE->EvPara)] 
            [generateEventParameter([EvPara])] 
    [end loop] 
    [loop(MT->MGuard)] 
            [generateGuardStatementBegin([MGuard])] 
    [end loop] 
    [loop(MT->SendAction)] 
                [getEventOperations([SendAction])] 
    [end loop] 
    [loop(MT->MTarget)] 
                [getEventSendEvents([MT],[MTarget])] 
    [end loop] 
                [genTransition([MT],[CS],[MClass])] 
    [loop(MT->MGuard)] 
            [generateGuardStatementEnd([MGuard])] 
    [end loop] 
        } 
    [end loop] 
        break; 
    [end if] 
    [end loop] 
    [end if] 
    [end if] 
    
        default: 
            [/* An illegal event has been used. For now we just put an error message */] 
            cout << "illegal event " << ev << " in state " << currentState << endl; 
            break; 
    
    } // end of switch event on [CS.name] 
    [end if] 
    break; 
    
end template 
    
// Generates the transition: execute exit actions, transition actions, changes of state, entry actions, new state activity 
template genTransition(MTransition, MState as CurrentState, MClass) 
[nextNonIsCompositeStateName([MTransition], [CurrentState])]
[loop(Instances->MState as ToState where ([ToState.id] == [NextStateID]))]
[genTransition2([MTransition], [CurrentState], [ToState], [MClass])]
[end loop]
end template 

template genTransition2(MTransition, MState as CurrentState, MState as ToState, MClass) 
[SuperStatesIDListOfSourceAndTargetStatesForActionsToExecute([CurrentState], [ToState])]
currentState = [NextStateName]; 
[NextStateName]_Action(); 
end template 
// [CurrentState.name]_Action(); 
    
template genAction(MStatemachine) 
             [loop(MStatemachine->MState Where ! hasLoop(MState->MPseudoState))] 
                   [if( isCompositeState([MState]) ) ] 
                           [loop(MState->Submachine)] 
   [genAction([Submachine])] 
                           [end loop] 
                   [end if] 
void [MState.name]_Action(); 
           [end loop] 
end template 
