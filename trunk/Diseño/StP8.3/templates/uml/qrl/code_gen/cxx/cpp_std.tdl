//*****************************************************************************
// $RCSfile: cpp_std.tdl,v $
// $Revision: 1.7 $
// $Date: 2002/04/04 14:31:52 $
// Author: Markus Kern
//*****************************************************************************
/*
Contains C++ specific procedures and templates. These are used by cpp_main.tdl,
cpp_genh.tdl, cpp_gencpp.tdl and cpp_gensm.tdl
*/

/*
import language independent utilities
*/
USES ../tdl/std;

/* Generates a marked section in the output. The content of this section can 
be changed by the user in the generated file. These changes will not be 
overwritten in subsequent cycles of code generation */
template mergeOut(uniqueId,desc)
//#ACD# M([uniqueId]) [desc]

    // user defined code to be added here ...

//#end ACD#
end template


/* Generates a marked section in the output. The content of this section can
   be changed by the user in the generated file. These changes will not be
   overwritten in subsequent cycles of code generation.
   
   The user-defined section is preset with the contents of the note
   "UmlOperationCxxCode", a annotation for method source code.
   In the absence of this annotation, a default return value is generated.
*/
template mergeOutOperation(preamble, MOperation, desc)
  [if (needsDefaultValue([MOperation]))]
[getDataType([MOperation.returnType])] returnValue;

  [end if]
//#ACD# M([preamble][MOperation.guid]) [desc]
    
    // user defined code to be added here ...

//#end ACD#
  [if (hasLoop(MOperation->Note Where [Note.type] == "UmlOperationCxxCode" && [Note.description] != ""))]
    [loop(MOperation->Note Where [Note.type] == "UmlOperationCxxCode")]
      [loop(Instances->TokenSet([Note.description]))]
[TokenSet.line]
      [end loop]
    [end loop]
  [else]
    [if ([CREATE_DEF_RETURN] && getDataType([MOperation.returnType]) != "void" && getDataType([MOperation.returnType]) != "")]

return returnValue;
    [end if]
  [end if]
end template

// Determines, whether or not, the Operation needs a 
// default return value. Besides other factors, this
// depends on the setting of the global TDL variable
// [CREATE_DEF_RETURN]!
proc needsDefaultValue(MOperation)
  local needed = FALSE;
  
  if ([CREATE_DEF_RETURN])
    if (getDataType([MOperation.returnType]) != "void" && getDataType([MOperation.returnType]) != "" && ! hasLoop(MOperation->Note Where [Note.type] == "UmlOperationCxxCode" && [Note.description] != ""))
      [needed] = TRUE;
    end if
  end if
  
  return [needed];
end proc

/* this procedure is called once by main (defined in cpp_main.tdl) before
   any other procedure or template. It sets up the merge mechanism for 
   incremental code generation (delMergeFile and appendMergeFile).
   The current language for type mapping is defined (setLanguage) */
proc init()
    delMergeFile();
    appendMergeFile("merge_config_CPP.txt");
    setLanguage("CPP");
    
    /* if there is no role name, set the role name to the associated class name */
    loop(Instances->MAssociationEnd->MClass Where [MAssociationEnd.name] == "")
        [MAssociationEnd.name] = [MClass.name];
    end loop
end proc    

/* put binding of an attribute (empty for "normal") */
template genAttributeBinding(MAttribute)
[if([MAttribute.binding] != "normal")]
[MAttribute.binding] \
[end if]
end template

/* return True if the given attribute is defined as static */
proc isStaticAttribute(MAttribute)
if([MAttribute.binding] == "static")
    return True;
else
    return False;
end if
end proc

/* Generates the " const" keyword if the given attribute has been specified */
proc isAttConst(MAttribute)
loop (MAttribute->Note->Item where [Item.type] == "UmlMemberCxxIsConst" && [Item.value] == "True")
    return True;
end loop
end proc

/* Return True if the attribute has been specified as a const attribute */
template genAttConst(MAttribute)
[if (isAttConst([MAttribute]))]
const \
[end if]
end template

/* Generates the default value of the attribute if any */
template genAttDefVal(MAttribute)
[if([MAttribute.defaultValue] != "")]
 = [MAttribute.defaultValue]\
[end if]
end template

/* Return True if the default value of the attribute has been defined */
proc hasAttDefVal(MAttribute)
if([MAttribute.defaultValue] != "")
    return True;
else
    return False;
end if
end proc

/* Generates const for the operation argument if "in" mode
   parameter "policy" : in=>const as if no policy specified, 
   it is always "in" that is considered ! */
template genOpArgConst(MOperationPara)
[if(toLower([MOperationPara.mechanism]) == "in")]
const \
[end if]
end template

/* put binding of an operation (empty for "normal") */
/* if abstract operation then "virtual " */
template genOperationBinding(MOperation)    
[if (isAbstractOperation([MOperation]))]\
virtual \
[else]\
[if([MOperation.binding] != "normal")]\
[MOperation.binding] \
[end if end if]\
end template

/* put parameter list of an operation */
template genDefinitionOpParaList(MOperation)
[loop(MOperation->OpPara;setDelim("");setDelim(","))]
[delim()][genOpArgConst([OpPara])][getDataType([OpPara.type])] [classType(getDataType([OpPara.type]))][OpPara.name][genArgDefVal([OpPara])]\
[end loop]
end template

/* put parameter list of an operation */
template genOpParaList(MOperation)
[loop(MOperation->OpPara;setDelim("");setDelim(","))]
[delim()][genOpArgConst([OpPara])][getDataType([OpPara.type])] [classType(getDataType([OpPara.type]))][OpPara.name]\
[end loop]
end template

proc classType(type)
    loop(Instances->MClass Where [MClass.name] == [type] && [MClass.stereotype]!="DataType")
        return "*";
    end loop
    return "";
end proc

/* Generates the default value of the argument if any */
template genArgDefVal(MOperationPara)
[if([MOperationPara.defaultValue] != "")]
 = [MOperationPara.defaultValue]\
[end if]
end template


/* Return the attribute visibility :
   If the C++ item has been specified then taken into account
   else it is the analysis item that is taken into account */
proc getAttributeVisibility(MAttribute)
return [MAttribute.access:cpp];
end proc

/* Return the operation visibility :
   If the C++ item has been specified then taken into account
   else it is the analysis item that is taken into account */
proc getOperationVisibility(MOperation)
return [MOperation.access:cpp];
end proc

/* Generates the keyword "inline" if the operation is inlined */
template inlineOperation(MOperation)   
[loop (MOperation->Note->Item where [Item.type] == "UmlOperationCxxIsInline" && [Item.value] == "True")]
inline \
[end loop]
end template

/* Return True if the operation is inlined */
proc isInlineOperation(MOperation)   
if (hasLoop(MOperation->Note->Item where [Item.type] == "UmlOperationCxxIsInline" && [Item.value] == "True"))
    return True;
else
    return False;
end if
end proc

/* Generates the keyword "const" if the c++ item "Const?" is set */
template constOperation(MOperation)   
[loop (MOperation->Note->Item where [Item.type] == "UmlMemberCxxIsConst" && [Item.value] == "True")]
 const\
[end loop]
end template

/* Generates the keyword "=0" if the c++ item "Abstract?" is set */
template abstractOperation(MOperation)   
[loop (MOperation->Note->Item where [Item.type] == "UmlOperationIsAbstract" && [Item.value] == "True")]
 = 0\
[end loop]
end template

/* Return True if the operation is abstract */
proc isAbstractOperation(MOperation)
if (hasLoop (MOperation->Note->Item where [Item.type] == "UmlOperationIsAbstract" && [Item.value] == "True"))
    return True;
else
    return False;
end if
end proc

/* Return type */
proc returnType(MOperation)
    if ([MOperation.returnType] == "")
        return "void";
    else
        return [MOperation.returnType];
    end if
end proc