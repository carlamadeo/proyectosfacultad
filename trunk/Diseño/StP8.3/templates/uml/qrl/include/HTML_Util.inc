////////////////////////////////////////////////////////////////////////////////
//
// HTML_Util
//
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// DEFINITIONS:
///////////////////////////////////////////////////////////////////////////////

int INDENT_LEN = 5;

///////////////////////////////////////////////////////////////////////////////
//  SOURCE:
///////////////////////////////////////////////////////////////////////////////

// html_print_gendate:	Prints the generation date and time framed with rulings 
string html_print_gendate()
{
string	content;
string	gen_time,
		gen_user;

    gen_time = time_to_string(time_now(), "%d %B, %Y ");
    gen_user = toolinfo_variable("STP_USER");

    if (gen_user == NULL || gen_user == "")
        gen_user = "User " + user();

    content = "<FONT SIZE=1>" + html_style("I", "Page generated on " + gen_time + " by " + gen_user) + "</FONT>";

    return(content);
}

// html_ref_heading:	Prints the cross reference section with hyperlinks to
//						Start Page, Actors, Use Cases, Packages,  Classes,
//						Stereotypes and Diagrams
string  html_ref_heading( string str_path )
{
string	content;
string	spacer = "   ";
    
    content = "<BR>\n<PRE>\n";

	content += html_link (str_path + "Index.html", "Start Page", "") + spacer;

    if (e_gen_Actor_Pages)
        content += html_link (str_path + current_system() + "_Actor_Index.html", "Actors", "") + spacer;

    if (e_gen_Use_Case_Pages)
        content += html_link (str_path + current_system() + "_UseCase_Index.html", "Use Cases", "") + spacer;

    if (e_gen_Package_Pages)
        content += html_link (str_path + current_system() + "_Package_Index.html", "Packages", "") + spacer;

    if (e_gen_Class_Pages)
        content += html_link (str_path + current_system() + "_Class_Index.html", "Classes", "") + spacer;

    if (e_gen_Stereotype_Pages)
        content += html_link (str_path + current_system() + "_Stereotype_Index.html", "Stereotypes", "") + spacer;

    if (e_gen_Diagram_Pages)
        content += html_link (str_path + current_system() + "_Diagram_Index.html", "Diagrams", "") + spacer;

    content += "\n</PRE>\n";
    content += html_seperator("");
     
    return(content);
}

// html_label:	Prints a HTML label. This label can be referred to by a hyperlink
//				- link: Labelname
//				- txt:  Printed text for this label.
string html_label(string link, string txt)
{
string	content;
    
    content = "<A NAME=\"";
    content += html_escape_chars(link) + "\">";
    content += html_escape_chars(txt) +  "</A>";

    return(content);
}

// html_link:	Prints a hyperlink
//				- link:  Filename or labelname, where hyperlink points to
//				- txt:   Printed text for this link.
//				- style: Style of the printed text (bold, italic, ...)
string html_link(string link, string txt, string style)
{
string	content="";
list	style_list;
int		i;

    if (style != "")
    {
		style_list=string_to_list(style, ",");
		for (i=0;i<list_count(style_list);i++)
			content += "<" + list_get(style_list,i) + ">";
	}

	content += "<A HREF=\"";
	content += html_escape_chars(link);
	content += "\">";
    content += html_escape_chars(txt);
    content += "</A>";

    if (style != "")
    {
		for (i=0;i<list_count(style_list);i++)
			content += "</" + list_get(style_list,i) + ">";
		list_clear(style_list);
	}

    return(content);
}

string html_link_area(string link, string txt, int x0, int y0, int x1, int y1)
{
string	content="";

	content +=	"  <AREA ";
	content +=	"HREF=\"" +	html_escape_chars(link) + "\" ";
	content +=	"TITLE=\""+ html_escape_chars(txt) + "\" ";
	content +=	"SHAPE=RECT COORDS=\"" +
					to_string(x0) + "," +
					to_string(y0) + "," +
					to_string(x1) + "," +
					to_string(y1) + "\"";
	content +=	">\n";
	
	return(content);
}

// html_page_end:	Prints the standard end section of a HTML page. Is  
//					called at the end of a html page generation 
string html_page_end()
{
string content;
    
    content = html_seperator("");
    content += html_print_gendate();
    content += "</BODY>\n</HTML>\n";

    return(content);
}

// html_page_start:	Prints the standard starting section of a HTML page. Is  
//					called at the beginning of a html page generation 
//					- html_title: title of the currently generated page
string html_page_start(string html_title)
{
string	content;
string	gen_info =	"<!-- Generated by StP on " + 
					time_to_string(time_now(), "%B %e %Y, at %R") +
					"-->\n";

	content = "<HTML>\n<HEAD>\n";
	content += gen_info + "<TITLE>\n";

	// title might contain special characters
	content += html_escape_chars(html_title);
   
    content += "\n</TITLE>\n</HEAD>\n<BODY>\n";
   
    return(content);
}


string html_indent(string text, int depth)
{
string	content="";
int		i;

	if (depth>0)
	{
		content+="<TABLE CELLSPACING=0 CELLPADDING=0>\n<TR VALIGN=TOP>\n<TD>\n";
		for(i=0;i<depth*INDENT_LEN;i++) 
			content+="&nbsp;";
		content+="\n</TD>\n<TD>\n";
	}
	content+=text;
	if (depth>0)
		content+="</TD>\n</TR>\n</TABLE>\n";

	return(content);
}

string html_table(string heading, string text)
{
string	content="";

	content+="<TABLE CELLSPACING=0 CELLPADDING=0>\n<TR VALIGN=TOP>\n<TD>\n";
	content+=heading;
	content+="\n</TD>\n<TD>\n";
	content+=text;
	content+="</TD>\n</TR>\n</TABLE>\n";

	return(content);
}

// escaping special characters 
string html_escape_chars(string text)
{
	if (text!=" ")
	{
		text = string_search_and_replace(text, "&",  "&amp;"); 
		text = string_search_and_replace(text, "<",  "&lt;");
		text = string_search_and_replace(text, ">",  "&gt;");
		text = string_search_and_replace(text, "ä",  "&auml;");
		text = string_search_and_replace(text, "Ä",  "&Auml;");   
		text = string_search_and_replace(text, "ö",  "&ouml;");   
		text = string_search_and_replace(text, "Ö",  "&Ouml;");   
		text = string_search_and_replace(text, "ü",  "&uuml;");   
		text = string_search_and_replace(text, "Ü",  "&Uuml;");   
		text = string_search_and_replace(text, "ß",  "&szlig;");   
		text = string_search_and_replace(text, "\"", "&quot;"); 
	}
  
     return(text);
}

string html_print_description (string heading, string description, int indents)
{
string	content="";
string	line;
int     line_end,i;

	description = string_strip(description, "B", "\n\r\t ");
    // Begin Add ECR 7758
    if(string_find( to_lower(description), 0, "<html " ) != string_length(description) || 
       string_find( to_lower(description), 0, "<html>" ) != string_length(description))
	{
		int headpos;
		description = string_search_and_replace( description, "</html>", "" );
		headpos = string_find( description, 0 , "</head>" );
		if( string_length( description ) != headpos)
			description = string_extract( description,
    			headpos,
    			string_length( description ) - headpos -7 );
		content = description + "<br></br>";
	}
	else
	// End Add ECR 7758
	{
    	while (string_length(description)>0)
    	{
    		line_end=string_find(description,1,"\n");
    		line=string_strip(string_extract(description,0,line_end),"L","\n");
    		if ((string_length(description)-line_end)>0)
    			description=string_extract(description,line_end,string_length(description)-line_end);
    		else
    			description="";
    		line=html_escape_chars(line);
    		content+=line+"<BR>\n";
    	}
    }
	content=html_indent(content, indents);
	content=html_style("B", heading)+"\n"+content;
	
	return(content);
}

string html_ref_prevnext(int obj_id, list obj_idlist)
{
string 		content = "";
int			obj_idx, 
			obj_length;

    obj_idx = list_find(obj_idlist, 0, obj_id);
    obj_length = list_count(obj_idlist);

    // jumps to the index pages
    content = html_ref_heading("../");

    content += "<PRE>";
    if (obj_length > 1)								// otherwise no prev/next exist
    {
        if (obj_idx == 0)							// first in list
		{
			content += html_style ("B", "First") + "  ";
			content += html_style ("B", "Previous") + "  ";
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,1) ) + ".html",
									"Next", "" ) + "  ";
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,obj_length-1) ) + ".html",
									"Last", "");
        }
        else if (obj_idx < obj_length - 1)			// standard case 
        {                                                 
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,0) ) + ".html",
									"First", "" ) + "  ";
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,obj_idx-1) ) + ".html",
									"Previous", "" ) + "  ";
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,obj_idx+1) ) + ".html",
									"Next", "" ) + "  ";
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,obj_length-1) ) + ".html",
									"Last", "");
        }
        else if (obj_idx == obj_length - 1)			// last in list
		{
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,0) ) + ".html",
									"First", "" ) + "  ";
			content += html_link (	idlist_get_nodelink( list_get(obj_idlist,obj_length-2) ) + ".html",
									"Previous", "" ) + "  ";
			content += html_style ("B", "Next") + "  ";
			content += html_style ("B", "Last");
        }
    }
    content += "</PRE>\n";

    content += html_seperator("");

    return(content);
}

// Prints a horizontal separation line of the given size  
//             - hr_size: size of the ruling, may be empty 
string html_seperator(string hr_size)
{
     if (hr_size != "")
         return("<HR" + hr_size + ">\n");

     return("<HR>\n");
}

// html_style: Prints the given text using the given style.
//            - style: Style to be used
//            - txt:   Text
//
//            Possible html styles are:
//            * B       bold
//            * STRONG  strong
//            * EM      emphasized	
//            * I       italic
//            * SITE
//            * VAR
//            * TT
//            * CODE
//            * SAMP
//            * KBD
string html_style(string style, string txt)
{
string	content="";
list	style_list;
int		i;

    if (style != "")
    {
		style_list=string_to_list(style, ",");
		for (i=0;i<list_count(style_list);i++)
			content += "<" + list_get(style_list,i) + ">";
	}

    content += html_escape_chars(txt);

    if (style != "")
    {
		for (i=0;i<list_count(style_list);i++)
			content += "</" + list_get(style_list,i) + ">";
		list_clear(style_list);
	}

    return(content);
}

string html_ref_line(string ref_query, string ref_title, 
						  string target_dir, int end_newlines)
{
int		rcnt, rx;
node	node_ref;
set		set_ref;
string	content = "";

    set_ref = set_select(ref_query);
    rcnt = set_count(set_ref);

    if (rcnt > 0)
    {
		content += html_style("B", ref_title);

		for (rx = 0; rx < rcnt; rx++) 
        {
			if (rx > 0)
				content += ",  ";

			node_ref = set_get_element(set_ref, rx);

			if (idlist_link(node_ref.type,node_ref.id))
				content += html_link(	target_dir + node_ref.name + "_" + node_ref.id + ".html",
										idlist_get_nodename(node_ref.id), "" );
			else
				content += html_escape_chars(idlist_get_nodename(node_ref.id));
		}
  
		for (rx = 0; rx < end_newlines; rx++) 
			content += "<BR>\n";
	}
    // clean up
    set_clear(set_ref);

    return(content);
}

string html_ref_diag( node node_obj, list list_diag_types )
{
file 	 				file_ref;
int 					sx,i,scnt;
string 	 				content = "";
string 	 				query_ref_diags;
set 	 				set_ref_diags;
string					diag_type;
boolean					added=False;
    
	for (i=0;i<list_count(list_diag_types);i++)
    {
		diag_type=list_get(list_diag_types,i);

		query_ref_diags = "file[" + diag_type + " && node_refs[node[id=" + node_obj.id + "]]]";
		set_ref_diags = set_select( query_ref_diags );
		scnt = set_count( set_ref_diags );
		if( scnt > 0 )
		{
			if (!added)
			{
				content += html_style( "B", "Referenced in: \n" );
				added=True;
			}

			for( sx = 0; sx < scnt; sx++ )
			{
				file_ref = set_get_element( set_ref_diags, sx );

	            if (idlist_link("UmlDiagram",file_ref.id))
					content +=	"<LI>" + html_escape_chars(diag_type) + " " +
								html_link(	"../diagrams/" + diagram_type_convert(diag_type) + "_" +
											file_ref.name + "_" + file_ref.id + ".html",
											file_ref.name, "") + 
								"</LI>";
				else
					content += "<LI>" + html_escape_chars(diag_type) + " " + html_style("B", file_ref.name) + "</LI>";
			}
			content += "<BR>\n";
		}
    }
    if (added)
		content += "<BR>\n";

    return(content);
}

string html_ref_statemac(node node_obj)
{
string		content="";
string		str_name;
file		file_obj;
list		file_list;
node		node_class;
int			i;

	if (node_obj.type=="UmlOperation")
	{
		node_class=find_by_query("node[node_refs & UmlClass & id=" + node_obj.scope_node_id + "]");
		str_name=node_class.name + "::" + node_obj.name + "(" + node_obj.sig + ")";
		if (string_length(str_name)>255)								// must not be bigger than 255 characters
			str_name=string_extract(str_name,0,255);					// because of database problems
		file_list=list_select(	"file[node_refs[node[UmlStateMachine & name='" + str_name +
								"']]] sort by type,name");
	}
	else
		file_list=list_select("file[node_refs[node[UmlStateMachine & name='" + node_obj.name + "']]] sort by type,name");

	if (list_count(file_list)==0)
		return("");

	content += html_style( "B", "State Machines: \n" );
	for (i=0;i<list_count(file_list);i++)
	{
		file_obj=list_get(file_list,i);
		if (idlist_link("UmlDiagram",file_obj.id))
			content +=	"<LI>" + html_escape_chars(file_obj.type) + " " +
						html_link( "../diagrams/" + diagram_type_convert(file_obj.type) + "_" + file_obj.name + 
									"_" + file_obj.id + ".html",
						file_obj.name, "") + "</LI>";
		else
			content += "<LI>" + html_escape_chars(file_obj.type) + " " + html_style("B", file_obj.name) + "</LI>";
		content += "<BR>\n";
	}
	content += "<BR>\n";

	return(content);
}

string html_print_obj_description(string note_type, int obj_id)
{
string	content="";
note	note_var;

    if (note_type != "GenericObject")
    {
		note_var = find_by_query("note[${note_type} && obj_id=" + obj_id + "]");
        if (note_var != NULL && note_var.desc != "")
        {
           content += html_print_description("Description:", note_var.desc, 1);
           content += "<BR>\n";
        }
    }
    
    // Always add description of GenericObject
    note_var = find_by_query("note[GenericObject && obj_id=" + obj_id + "]");
    if (note_var != NULL && note_var.desc != "")
    {
        content += html_print_description("Description:", note_var.desc, 1);
		content += "<BR>\n";
	}

    return(content);
}

string html_gen_info(node ref_node)
{
item        info_item;
int         ix;
list        list_item;
node		stereot_node;
string      content="",content2;
boolean		written=False;

// Stereotype
    info_item = find_by_query("item[UmlStereotype && obj_id=" + ref_node.id + "]");
    if (info_item != NULL && info_item.value != "")
    {
		stereot_node = find_by_query("node[type=UmlStereotype && node_refs && name='${info_item.value}']");
		content += html_style("B", "Stereotype:")+" ";
		if (stereot_node!=NULL)
		{
			if (idlist_link("UmlStereotype",stereot_node.id))
			{
				content += html_link(	"../stereotypes/" + info_item.value + "_" +
										stereot_node.id + ".html", info_item.value, "");
			}
			else
			{
				content += html_escape_chars(info_item.value);
			}
		}
		else
		{
			if (idlist_link("UmlStereotype",idlist_predef_stereot_id(info_item.value,ref_node.type)))
			{
				content += html_link("../stereotypes/" + info_item.value + "_pre.html", info_item.value, "");
			}
			else
			{
				content += html_escape_chars(info_item.value);
			}
		}
		content += "<BR>\n";
		written = True;
    }

// Constraints
    list_item = list_select("item[UmlConstraintItem && obj_id=" + ref_node.id + "]");
    if ((list_item != NULL) && (list_count(list_item)>0))
    {
        content2 = "";
        for (ix=0;ix<list_count(list_item);ix++)
        {
            info_item = list_get(list_item,ix);
    		content2 += info_item.value + "<BR>\n";
        }
   		content += html_table( html_style("B", "Constraints:"), content2 );
		written = True;
    }
    if ( list_item!=NULL )
        list_clear(list_item);

// TaggedValues
    list_item = list_select("item[UmlTaggedValue && obj_id=" + ref_node.id + "]");
    if ((list_item != NULL) && (list_count(list_item)>0))
    {
        content2 = "";
        for (ix=0;ix<list_count(list_item);ix++)
        {
            info_item = list_get(list_item,ix);
    		content2 += info_item.value + "<BR>\n";
        }
   		content += html_table( html_style("B", "Tagged Values:"), content2 );
		written = True;
    }
    if ( list_item!=NULL )
        list_clear(list_item);

// class ???
    if (ref_node.type=="UmlClass")
    {

// Visibility (only classes)
        info_item = find_by_query("item[UmlClassVisibility && obj_id=" + ref_node.id + "]");
        if (info_item != NULL && info_item.value != "")
        {
    		content += html_style("B", "Visibility:")+" ";
        	content += html_escape_chars(info_item.value) + "<BR>\n";
    		written = True;
        }

// Multiplicity (only classes)
        info_item = find_by_query("item[UmlMultiplicity && obj_id=" + ref_node.id + "]");
        if (info_item != NULL && info_item.value != "")
        {
            content += html_style("B", "Multiplicity:")+" ";
            content += html_escape_chars(info_item.value) + "<BR>\n";
            written = True;
        }

        if (written) content += "<BR>\n";

// extend with items (only classes)
        content += html_print_obj_description("UmlClassDefinition", ref_node.id);
    }
    
    return(content);
}

// ECR 7496 -->
int lastIdlistId = 0;
string baseIdListName = "";

string list_to_idlist(list l, string type)
{
    int i;

    set s = set_create("int");
    for(i = 0; i < list_count(l); ++ i) {
        set_add(s, list_get(l, i));
    }

    string idlistName;
    if(baseIdListName == "") {
        // generate a unique name for the idlist
        idlistName = "I" + user() + hostname() + "_" + getpid();
        string aChar;
        for(i = 0; i < string_length(idlistName); ++ i) {
            aChar = string_extract(idlistName, i, 1);
            if(aChar >= "0" && aChar <= "9" ||
               aChar >= "A" && aChar <= "Z" ||
               aChar >= "a" && aChar <= "z" ||
               aChar == "_")
                baseIdListName += aChar;
            else
                baseIdListName += "_";
        }
    }

    idlistName = baseIdListName + "_" + lastIdlistId;
    ++ lastIdlistId;

    id_list_update(idlistName, type, s, NULL);
    return idlistName;
}
// ECR 7496 <--
