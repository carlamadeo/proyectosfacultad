//////////////////////////////////////////////////////////////////////////////
//
//      sccsid[] = %W% %Y% %D%
//      StP/SE
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1992 - 1995
//      All rights reserved
//
//////////////////////////////////////////////////////////////////////////////

#include "qrl/check/dfe_semantics_common.inc"
#include "qrl/check/balance.inc"


// objects_tp
//
// holds all the objects that were mapped from the diagram being checked.
// Minimizes queries since most relationships can be deduced from these
// object collections.  Each list contains cnode_tp structs.

struct objects_tp
{
    list	dflows;		// DataFlow cnode_tp's
    list	cflows;		// ControlFlow cnode_tp's
    list        processes;	// Process cnode_tp's
    list        cspecs;		// Cspec cnode_tp's
    list        stores;		// Store cnode_tp's
    list        splits;		// SplitFlow cnode_tp's
    list        externals;	// External cnode_tp's
    list        offpages;	// offpage cnode_tp's
};

//////////////////////////////////////////////////////////////////////////////
//
// main entry point to dfe semantic checking.
//
// called from both qrp (check/dfe.qrl) and from the dfe property sheet
//
//////////////////////////////////////////////////////////////////////////////


// New Global variables to support faster semantic checks
list ToIndexl;
list FromIndexl;
int IndexFactor = 2;
int Multiplier = 10000;
int StartId = 40000;


int
DfeCheckSemanticsOp(list files,
		    list nodes, 
		    list links, 
		    int balance, 
		    int decomp,
		    int pspec,
		    int cspec,
		    int verbose)
{
    options_tp  options;
    objects_tp  objects;
    int i, errors = 0;
    string s;

    // populate options struct

    options.balance = balance;
    options.decomp = decomp;
    options.pspec = pspec;
    options.cspec = cspec;
    options.verbose = verbose;

    __DbgSStarttime = __DbgSMytime = 0;
    // Debug??
    s = environment_variable("DebugSemantics"); 
    if (str_has_val(s) && s == "1")
        __DbgS = True;
    if (str_has_val(s) && s == "2")
    {
        __DbgS = True;
        _SC_Debug = True;
    }

    if (__DbgS)
        print_error("Dfe Check Semantics: " + TIM());
    for (i = 0; i < list_count(files); i++)
    {
	options.file = list_get(files, i);
	print_message("Checking semantics for '" + options.file.name + "'...");

	if (file_history(options.file))
	{
	    errors += 1;
	    print_message("Semantic check failed.");
	} else
	{
	    cacheClear();
	    objects = DfeSemanticsInit(options, nodes, links);

	    if (objects != NULL)
	    {
		errors += DfeCheckObjects(options, objects);
	    }

            if (__DbgS)
               print_error("Dfe Check Semantics: " + TIMTOTAL() + " seconds total.");
	}
    }
    if (!errors)
    {
	print_message("Check semantics completed with no errors.");
    } else if (errors == 1)
    {
	print_message("Check semantics completed with 1 error.");
    } else
    {
	print_message("Check semantics completed with " + errors + " errors.");
    }
    return(errors);
}



// initialize the objects_tp structure

objects_tp 
DfeSemanticsInit(options_tp options, list n, list l)
{
    objects_tp  objects;
    cnode_tp    cnode;
    item        item;
    node        node;
    link        link;
    string      query;
    int         i, j, elem;
    list	nodes, links;

    objects.dflows = list_create("cnode_tp", 0);
    objects.cflows = list_create("cnode_tp", 0);
    objects.processes = list_create("cnode_tp", 0);
    objects.cspecs = list_create("cnode_tp", 0);
    objects.stores = list_create("cnode_tp", 0);
    objects.splits = list_create("cnode_tp", 0);
    objects.externals = list_create("cnode_tp", 0);
    objects.offpages = list_create("cnode_tp", 0);

    //if (n == NULL)
    //{
	query = "node[node_refs[file_id == ${options.file.id}]]";
	nodes = list_select(query);
    //} else
    //{
	//nodes = n;
    //}
    //if (l == NULL)
    //{
	query = "link[link_refs[file_id == ${options.file.id}]]";
	links = list_select(query);
    //} else
    //{
	//links = l;
    //}
    if (list_count(nodes) == 0 && list_count(links) == 0)
    {
	return(NULL);
    }
    for (i = 0; i < list_count(links); i++)
    {
	link = list_get(links, i);
	cnode.link = link;

	if (link.type == "DataFlow")
	{
	    list_append(objects.dflows, cnode);
	} else if (link.type == "ControlFlow")
	{
	    list_append(objects.cflows, cnode);
	}
    }
    cnode.link = NULL;

    for (i = 0; i < list_count(nodes); i++)
    {
	node = list_get(nodes, i);
	cnode.node = node;

	if (node.type == "Process")
	{
	    item = find_by_query("item[RelativeIndex && obj_id == ${node.id}]");
	    cnode.pindex = item.value;

	    if (options.file.name == "top")
	    {
		cnode.decompname = "0";
	    } else if (options.file.name == "0")
	    {
		cnode.decompname = cnode.pindex;
	    } else
	    {
		cnode.decompname = options.file.name + "." + cnode.pindex;
	    }
	    list_append(objects.processes, cnode);
	    cnode.pindex = NULL;
	    cnode.decompname = NULL;
	} else if (node.type == "Store")
	{
	    list_append(objects.stores, cnode);
	} else if (node.type == "Cspec")
	{
	    cnode.decompname = options.file.name;
	    list_append(objects.cspecs, cnode);
	    cnode.decompname = NULL;
	} else if (node.type == "External")
	{
	    list_append(objects.externals, cnode);
	} else if (node.type == "SplitFlow")
	{
	    list_append(objects.splits, cnode);
	} else if (node.type == "FlowAnchor")
	{
	    list_append(objects.offpages, cnode);
	} else if (node.type == "OffPageProcess")
	{
	    list_append(objects.offpages, cnode);
	} else if (node.type == "OffPageExternal")
	{
	    list_append(objects.offpages, cnode);
	}
    }

    return(objects);
}



// check all objects based on options values

int
DfeCheckObjects(options_tp options, objects_tp objects)
{
    int	      i, errors = 0;
    cnode_tp  cnode;

    if (options.pspec)
    {
	if (options.verbose)
	{
	    print_message("Checking for decompositions and Pspecs...");
	}
	for (i = 0; i < list_count(objects.processes); i++)
	{
	    cnode = list_get(objects.processes, i);
	    errors += DfeCheckPspec(options.file, cnode);

	    if (cnode.haspspec)
		errors += DfeCheckControlIns(options.file, cnode, objects.cflows);
	}
    }
    if (options.cspec)
    {
	if (options.verbose)
	{
	    print_message("Checking for Control Spec Tables/Diagrams...");
	}
	for (i = 0; i < list_count(objects.cspecs); i++)
	{
	    cnode = list_get(objects.cspecs, i);
	    errors += DfeCheckCspec(options.file, cnode);
	}
    }
    if (options.decomp || options.balance)
    {
	// need to get data definitions...

	if (options.verbose)
	{
	    print_message("Gathering data definitions for Flows and Stores...");
	}
	errors += DfeSemanticsGetData(options, objects);

	if (options.decomp)
	{
	    if (options.verbose)
	    {
		print_message("Checking decomposition...");
	    }
	    errors += DfeCheckDecomp(options, objects);
	}
	if (options.balance)
	{
	    list             ins = list_create("data_tp", 0);
	    list             outs = list_create("data_tp", 0);
	    list             store = list_create("data_tp", 0);
	    afterbalance_tp  result;

	    if (options.verbose)
	    {
		print_message("Checking flow balance for SplitFlows...");
	    }
	    for (i = 0; i < list_count(objects.splits); i++)
	    {
		cnode = list_get(objects.splits, i);

		CnodeGetInsAndOuts(cnode, objects, ins, outs, True);

		result = CheckBalance(options.file, 
				      cnode, 
				      outs, 
				      ins);

		errors += SplitFlowBalanceResults(options, cnode, result);
	    }
	    if (options.verbose)
	    {
		print_message("Checking flow balance for Stores...");
	    }
	    for (i = 0; i < list_count(objects.stores); i++)
	    {
		cnode = list_get(objects.stores, i);

		if (cnode.definition == NULL)
		    continue;

		StoreGetAllInsAndOuts(cnode, objects, ins, outs, True);

		list_clear(store);
		list_append(store, cnode.definition);

		result = CheckBalance(options.file,
				      cnode, 
				      ins, 
				      store);

		errors += StoreBalanceResults(options, cnode, result, StoreIn);

		result = CheckBalance(options.file, 
				      cnode, 
				      outs,
				      store); 

		errors += StoreBalanceResults(options, cnode, result, StoreOut);
	    }
	}
    }
    return(errors);
}




// print the primitive match errors
//
// if a tree element is not matched but all it's children are then
// print an error for it, else recurse over it's children till you find
// the most primitive match error

int
reportChildren(cnode_tp cnode, 
	       list syms,
	       tree_tp t, 
	       string m1, 
	       string m2,
	       boolean isError)
{
    tree_tp    ct;
    int        i, matched, children, errors = 0;

    if (t.children == NULL)
    {
	children = 0;
    } else
    {
	children = list_count(t.children);
    }
    for (matched = 0, i = 0; i < children; i++)
    {
	ct = list_get(t.children, i);

	if (!ct.matched)
	{
	    errors += reportChildren(cnode, syms, ct, m1, m2, isError);
	} else
	{
	    matched += 1;
	}
    }
    if (matched == children)
    {
	if (isError)
	{
	    print_error("'" + t.data.node.name + m1 + cnode.node.type + 
			" '" + cnode.node.name + m2, syms);
	    errors += 1;
	} else
	{
	    print_message("'" + t.data.node.name + m1 + cnode.node.type + 
			  " '" + cnode.node.name + m2);
	}
    }
    return(errors);
}

// print errors based on balance result

int
StoreBalanceResults(options_tp options, 
		    cnode_tp cnode,
		    afterbalance_tp result, 
		    balance_tp which)
{
    int      i, errors = 0;
    list     syms;
    tree_tp  t;

    for (i = 0; result.ins != NULL && i < list_count(result.ins); i++)
    {
	t = list_get(result.ins, i);

	if (t.matched == 0)
	{
	    if (which == StoreIn)
	    {
		if (t.data.parent == NULL)
		{
		    // this link is not referenced in this diagram
		    // so don't report an error

		    continue;
		}
                syms = list_copy(node_appids(cnode.node, options.file));
                list_concatenate(syms, link_appids(t.data.parent,
                                                   options.file));

                print_error("'" + t.data.node.name + "' flows into " +
                                cnode.node.type + " '" + cnode.node.name +
                                "' but is not a part of the Store.",
                                syms);
                errors += 1;
	    } else
	    {
		syms = list_copy(node_appids(cnode.node, options.file));
		list_concatenate(syms, link_appids(t.data.parent, 
						   options.file));

		print_error("'" + t.data.node.name + "' flows out of " +
				cnode.node.type + " '" + cnode.node.name +
				"' but is not part of the Store.",
				syms);
		errors += 1;
	    }
	}
    }
    for (i = 0; result.outs != NULL && i < list_count(result.outs); i++)
    {
	t = list_get(result.outs, i);
	
	if (t.matched == 0)
	{
	    if (which == StoreIn)
	    {
		errors += reportChildren(cnode, 
				         node_appids(cnode.node, options.file),
				         t, 
					 "' is part of ",
				         "' but does not flow in.",
				         True);
	    } else
	    {
		// this is not an error since it just means that you
		// are storing some data that you never reference again.

		reportChildren(cnode, 
			       NULL,
			       t, 
			       "' is part of ", 
			       "' but does not flow out.",
			       False);
	    }
	} 
    }
    return(errors);
}

list
GetResults(tree_tp tree, boolean dups)
{
    int      i;
    tree_tp  child;
    list     result = list_create("data_tp", 0);

    if (tree.children == NULL || (dups && tree.matched < 1))
    {
	return(result);
    }
    for (i = 0; i < list_count(tree.children); i++)
    {
	child = list_get(tree.children, i);

	if (child.direct)
	{
	    list_append(result, child.data);
	}
	list_concatenate(result, GetResults(list_get(tree.children, i), dups));
    }
    return(result);
}

// print errors based on balance result

int 
SplitFlowBalanceResults(options_tp options, 
			cnode_tp cnode,
			afterbalance_tp result)
{
    int      i, errors = 0;
    list     syms, errs, tmp;
    string   errstring;
    tree_tp  t;

    // these are balanced backwards to prevent premature pruning

    tmp = result.outs;
    result.outs = result.ins;
    result.ins = tmp;

    //message("SplitFlow Balance Result:" + result);

    for (i = 0; result.ins != NULL && i < list_count(result.ins); i++)
    {
	t = list_get(result.ins, i);

	if (t.matched != 1)
	{
	    syms = list_copy(node_appids(cnode.node, options.file));
	    list_concatenate(syms, link_appids(t.data.parent, options.file));

	    if (t.matched == 0)
	    {
		errs = GetResults(t, False);

		if (list_count(errs) == 0)
		{
		    print_error(t.data.node.type +
				" '" + t.data.node.name + "' flows into " +
				cnode.node.type + " but does not flow out.",
				syms);
		} else
		{
		    errstring = StringFromDataList(errs);
		    list_concatenate(syms, 
				     AppidsFromDataList(errs, options.file));

		    print_error(t.data.node.type +
				" '" + t.data.node.name + "' flows into " +
				cnode.node.type + " but only " +
				errstring + " flow(s) out.",
				syms);
		}
	    } else
	    {
		errs = GetResults(t, True);
		errstring = StringFromDataList(errs);
		list_concatenate(syms, AppidsFromDataList(errs, options.file));

		print_error("Duplicate Selection - " + 
			    t.data.node.type +
			    " '" + t.data.node.name + "' flows into " +
			    cnode.node.type + " but " + errstring +
			    " flow out.",
			    syms);
	    }
	    errors += 1;
	}
    }
    for (i = 0; result.outs != NULL && i < list_count(result.outs); i++)
    {
	t = list_get(result.outs, i);

	if (t.matched != 1)
	{
	    syms = list_copy(node_appids(cnode.node, options.file));
	    list_concatenate(syms, link_appids(t.data.parent, options.file));

	    print_error(t.data.node.type +
			" '" + t.data.node.name + "' flows out of " +
			cnode.node.type + " but does not flow in.",
			syms);
	    errors += 1;
	}
    }
    return(errors);
}

// take a list of data_tp's and return a string concatenation of names

string
StringFromDataList(list errs)
{
    string   result;
    int      i;
    data_tp  d;

    for (i = 0; i < list_count(errs); i++)
    {
	d = list_get(errs, i);

	if (i == 0)
	{
	    result = "'" + d.parent.name + "'";
	} else
	{
	    result = result + " & '" + d.parent.name + "'";
	}
    }
    return(result);
}

// take a list of data_tp's and return their appids

list
AppidsFromDataList(list errs, file file)
{
    list     result;
    int      i;
    data_tp  d;

    for (i = 0; i < list_count(errs); i++)
    {
	d = list_get(errs, i);

	if (i == 0)
	{
	    result = link_appids(d.parent, file);
	} else
	{
	    list_concatenate(result, link_appids(d.parent, file));
	}
    }
    return(result);
}

// print errors based on balance result

int
DecompBalanceResults(options_tp options,
		     cnode_tp cnode,
		     afterbalance_tp result, 
		     balance_tp which)
{
    int      i, j, errors = 0;
    tree_tp  t;
    list     errs;
    string   errstring;

    for (i = 0; result.ins != NULL && i < list_count(result.ins); i++)
    {
	t = list_get(result.ins, i);

	if (which == DecompositionIn)
	{
	    if (t.matched == 0)
	    {
		errs = GetResults(t, False);

		if (list_count(errs) == 0)
		{
		    print_error(t.data.parent.type + 
				" '" + t.data.node.name + "' flows in " +
				"from OffPage but does not flow into " +
				cnode.node.type + " '" + 
				cnode.node.name + "'.",
				link_appids(t.data.parent, options.file));
		} else
		{
		    errstring = StringFromDataList(errs);

		    print_error(t.data.parent.type + 
				" '" + t.data.node.name + "' flows in " +
				"from OffPage but only " +
				errstring + " flow(s) into " +
				cnode.node.type + " '" + 
				cnode.node.name + "'.",
				link_appids(t.data.parent, options.file));
		}
		errors += 1;
	    }
	} else
	{
	    if (t.matched == 0)
	    {
		errs = GetResults(t, False);

		if (list_count(errs) == 0)
		{
		    print_error(t.data.parent.type + 
				" '" + t.data.node.name + "' flows out " +
				"to OffPage but does not flow out of " +
				cnode.node.type + 
				" '" + cnode.node.name + "'.",
				link_appids(t.data.parent, options.file));
		} else
		{
		    errstring = StringFromDataList(errs);

		    print_error(t.data.parent.type + 
				" '" + t.data.node.name + "' flows out " +
				"to OffPage but only " +
				errstring + " flow(s) out of " +
				cnode.node.type + " '" + 
				cnode.node.name + "'.",
				link_appids(t.data.parent, options.file));
		}
		errors += 1;
	    }
	}
    }
    for (i = 0; result.outs != NULL && i < list_count(result.outs); i++)
    {
	t = list_get(result.outs, i);

	if (which == DecompositionIn)
	{
	    if (t.matched == 0)
	    {
		errs = GetResults(t, False);

		if (list_count(errs) == 0)
		{
		    print_error(t.data.parent.type + " '" + t.data.node.name + 
				"' flows into " + cnode.node.type + " '" + 
				cnode.node.name + 
				"' but does not flow in from OffPage.",
				NULL);
		} else
		{
		    errstring = StringFromDataList(errs);

		    print_error(t.data.parent.type + " '" + t.data.node.name + 
				"' flows into " + cnode.node.type + " '" + 
				cnode.node.name + 
				"' but only " + errstring +
				" flow(s) in from OffPage.",
				AppidsFromDataList(errs, options.file));
		}
		errors += 1;
	    } else if (t.matched > 1)
	    {
		errs = GetResults(t, True);
		errstring = StringFromDataList(errs);

		print_error("Duplicate Selection - " +
			    t.data.parent.type + " '" + t.data.node.name + 
			    "' flows into " + cnode.node.type + " '" + 
			    cnode.node.name + "' but " + errstring +
			    " flow in from OffPage.",
			    AppidsFromDataList(errs, options.file));
		errors += 1;
	    }
	} else
	{
	    if (t.matched == 0)
	    {
		errs = GetResults(t, False);

		if (list_count(errs) == 0)
		{
		    print_error(t.data.parent.type + " '" + t.data.node.name + 
				"' flows out from " + cnode.node.type + " '" + 
				cnode.node.name +
				"' but does not flow out to OffPage.",
				NULL);
		} else
		{
		    errstring = StringFromDataList(errs);

		    print_error(t.data.parent.type + " '" + t.data.node.name + 
				"' flows out from " + cnode.node.type + " '" + 
				cnode.node.name + 
				"' but only " + errstring +
				" flow(s) out to OffPage.",
				AppidsFromDataList(errs, options.file));
		}
		errors += 1;
	    } else if (t.matched > 1)
	    {
		errs = GetResults(t, True);
		errstring = StringFromDataList(errs);

		print_error("Duplicate Selection - " +
			    t.data.parent.type + " '" + t.data.node.name + 
			    "' flows out from " + cnode.node.type + " '" + 
			    cnode.node.name + "' but " + errstring +
			    " flow out to OffPage.",
			    AppidsFromDataList(errs, options.file));
		errors += 1;
	    }
	}
    }
    return(errors);
}

//////////////////////////////////////////////////////////////////////////////
//
// Check decomposition.
//
// 1. all data flowing into the parent process must flow in from
//    OffPage on this diagram (or from the same Store).
//
// 2. all data flowing out of the parent process must flow out
//    to OffPage on this diagram (or to the same Store).
//
//////////////////////////////////////////////////////////////////////////////

int
DfeCheckDecomp(options_tp options, objects_tp objects)
{
    string           fname, pindex, query, s;
    int              i, j, errors = 0;
    objects_tp       parent;
    cnode_tp         cnode, pcnode, dcnode;
    file             file;
    node             node, pnode;
    link             link;
    list	     links, pins = list_create("data_tp", 0);
    list	     pouts = list_create("data_tp", 0);
    list	     ins = list_create("data_tp", 0);
    list	     outs = list_create("data_tp", 0);
    afterbalance_tp  result;
    node_ref	     nref;

    if (options.file.name == "top")
    {
	return(0);
    }
    if (options.file.name == "0")
    {
	fname = "top";
	pindex = "0";
    } else
    {
	j = string_length(options.file.name);

	for(i = j - 1; i >= 0; i--)
	{
	    s = string_extract(options.file.name, i, 1);

	    if (s == ".")
	    {
		break;
	    }
	}
	if (i < 0)
	{
	    pindex = options.file.name;
	    fname = "0";
	} else
	{
	    pindex = string_extract(options.file.name, i + 1, j - i - 1);
	    fname = string_extract(options.file.name, 0, i);
	}
    }
    file = find_by_query("file[DfeDiagram && name == '${fname}']");

    if (file != NULL)
    {
	query = "node[Process && node_refs[file_id == ${file.id}] && " +
		"items[RelativeIndex && value == '${pindex}']]";

	node = find_by_query(query);
    }
    if (file == NULL || node == NULL)
    {
	print_error("Parent Process does not exist.");
	return(1);
    }
    query = "link[link_refs[file_id==${file.id}] && to_node_id==${node.id}]";
    links = list_select(query);

    query = "link[link_refs[file_id==${file.id}] && from_node_id==${node.id}]";
    list_concatenate(links, list_select(query));

    parent.dflows = list_create("cnode_tp", 0);
    parent.cflows = list_create("cnode_tp", 0);

    for (i = 0; i < list_count(links); i++)
    {
	link = list_get(links, i);
	pnode = NULL;

	// if the link goes to or from a Store then we need to find
	// corresponding links in the current diagram and add them
	// in to the balance equation as if they were connected to
	// offpage.

	if (link.to_node_id == node.id)
	{
	    pnode = find_by_query("node[Store && id == ${link.from_node_id}]");
	} else
	{
	    pnode = find_by_query("node[Store && id == ${link.to_node_id}]");
	}
	if (pnode != NULL)
	{
	    dcnode.node = pnode;
	    CnodeGetInsAndOuts(dcnode, objects, ins, outs, False);
	}
	cnode.link = link;
	CnodeGetDataDef(options, cnode, False, True);

	if (cnode.definition == NULL)
	    continue;

	if (link.type == "DataFlow")
	{
	    list_append(parent.dflows, cnode);
	} else
	{
	    list_append(parent.cflows, cnode);
	}
    }
    pcnode.node = node;
    CnodeGetInsAndOuts(pcnode, parent, pins, pouts, False);

    for (i = 0; i < list_count(objects.offpages); i++)
    {
	cnode = list_get(objects.offpages, i);
	CnodeGetInsAndOuts(cnode, objects, ins, outs, False);
    }
    // anything out of parent should connect to (i.e. in) OffPage & vice versa

    result = CheckBalance(options.file, 
			  pcnode, 
			  outs, 
			  pins);

    errors += DecompBalanceResults(options, pcnode, result, DecompositionIn);

    result = CheckBalance(options.file, 
			  pcnode, 
			  ins, 
			  pouts);

    errors += DecompBalanceResults(options, pcnode, result, DecompositionOut);

    return(errors);
}

// get data definitions of all flows and stores
//
// iterates through the objects_tp struct and for each flow/store
// populates it's defintion field with it's data definition

int
DfeSemanticsGetData(options_tp options, objects_tp objects)
{
    int       i, errors = 0;
    cnode_tp  cnode;

    for (i = 0; i < list_count(objects.cflows); i++)
    {
	cnode = list_get(objects.cflows, i);
	errors += CnodeGetDataDef(options, cnode, False, False);
	list_set(objects.cflows, i, cnode);
    }
    for (i = 0; i < list_count(objects.dflows); i++)
    {
	cnode = list_get(objects.dflows, i);
	errors += CnodeGetDataDef(options, cnode, False, False);
	list_set(objects.dflows, i, cnode);
    }
    for (i = 0; i < list_count(objects.stores); i++)
    {
	cnode = list_get(objects.stores, i);
	errors += CnodeGetDataDef(options, cnode, True, False);
	list_set(objects.stores, i, cnode);
    }
    return(errors);
}


void
StoreGetAllInsAndOuts(cnode_tp cnode,
                      objects_tp objects,
                      list ins,
                      list outs,
                      boolean purge)
{
    string    query;
    link      link;
    cnode_tp  lcnode;
    int i;
    list linkl;

    // get the ones on this diagram...

    CnodeGetInsAndOuts(cnode, objects, ins, outs, purge);

    // then get all the rest

    linkl = list_select("link[link_refs && to_node_id == ${cnode.node.id}]");
    for(i=0; i<list_count(linkl); i++)
    {
        link = list_get(linkl, i);
	lcnode.link = link;
	CnodeGetDataDef(NULL, lcnode, False, True);

	if (lcnode.definition == NULL)
	    continue;

	lcnode.definition.parent = NULL;

	if (!ListContains(ins, lcnode.definition))
	{
	    list_append(ins, lcnode.definition);
	}
    }

    linkl = list_select("link[link_refs && from_node_id == ${cnode.node.id}]");
    for(i=0; i<list_count(linkl); i++)
    {
	lcnode.link = link;
	CnodeGetDataDef(NULL, lcnode, False, True);

	if (lcnode.definition == NULL)
	    continue;

	lcnode.definition.parent = NULL;

	if (!ListContains(outs, lcnode.definition))
	{
	    list_append(outs, lcnode.definition);
	}
    }
}

// get all the in and out data elements from the objects list

void
CnodeGetInsAndOuts(cnode_tp cnode, 
		   objects_tp objects, 
		   list ins, 
		   list outs,
		   boolean purge)
{
    cnode_tp  lcnode;
    int       i;

    if (purge)
    {
	list_clear(ins);
	list_clear(outs);
    }
    for (i = 0; i < list_count(objects.cflows); i++)
    {
	lcnode = list_get(objects.cflows, i);

	if (lcnode.definition == NULL)
	    continue;

	if (lcnode.link.from_node_id == cnode.node.id)
	{
	    if (!ListContains(outs, lcnode.definition))
	    {
		list_append(outs, lcnode.definition);
	    }
	} else if (lcnode.link.to_node_id == cnode.node.id)
	{
	    if (!ListContains(ins, lcnode.definition))
	    {
		list_append(ins, lcnode.definition);
	    }
	}
    }
    for (i = 0; i < list_count(objects.dflows); i++)
    {
	lcnode = list_get(objects.dflows, i);

	if (lcnode.definition == NULL)
	    continue;

	if (lcnode.link.from_node_id == cnode.node.id)
	{
	    if (!ListContains(outs, lcnode.definition))
	    {
		list_append(outs, lcnode.definition);
	    }
	} else if (lcnode.link.to_node_id == cnode.node.id)
	{
	    if (!ListContains(ins, lcnode.definition))
	    {
		list_append(ins, lcnode.definition);
	    }
	}
    }
}


