external string use_case_name;

#include "qrl/tsdl_extract.inc"
#include "qrl/basic_textract_dt.inc"
#include "qrl/include/error.inc"

#include "val/qrl/include/TConfig.inc"
#include "val/qrl/include/TUseCase.inc"
#include "val/qrl/include/val_string_globals.inc"
#include "val/qrl/include/CreateDir.inc"


  string OUTPUTPATH = current_projdir() + current_system() + "/test_files/";
  string OUTPUTDIR;
  string FILETEXT;

  boolean EVENTCONDITION;
  boolean DATACONDITION;
  boolean TESTEXHAUSITIVE;
  set TESTEXHAUSITIVESET;
  set EVENTCONDITIONSET;
  set DATACONDITIONSET;

  set DataItemsDataTypes;


void 
main ()
{


message ("In Development");
return;

  list ScenarioList;
  int count1, i;
  int count2, j;
  string test_unit_id, scenario_name;
  node scenario;
  int scenario_id;
  set DataTypes;
  string ActorIDs;

  DataItemsDataTypes = set_create ("string");
  TESTEXHAUSITIVESET = set_create ("string");
  DATACONDITIONSET = set_create ("string");
  EVENTCONDITIONSET = set_create ("string");

  set_clear(DataItemsDataTypes);

  test_unit_id = Get_T_test_unit_id(use_case_name, "");

  OUTPUTDIR = OUTPUTPATH + test_unit_id;
  message ("Generating SDF for Use Case: " + use_case_name); 

  ActorIDs = GetActorIDList(use_case_name);

  ScenarioList = GetScenarioList(use_case_name);
  count2 = list_count (ScenarioList);

  if (count2 == 0)
    {
      message ("Use Case: " + use_case_name + " has no scenarios");
      return;
    }

  for (j=0;j<count2;j=j+1)
    {
      DATACONDITION = False;
      EVENTCONDITION = False;
      TESTEXHAUSITIVE = False;

      set_clear(TESTEXHAUSITIVESET);
      set_clear(DATACONDITIONSET);
      set_clear(EVENTCONDITIONSET);

      scenario = list_get(ScenarioList,j);
      scenario_name = RemoveSpaces(scenario.name);
      scenario_id = scenario.id;
      message ("  Generating action sentence for Scenario: " + scenario_name );


      Build_Action_Statement(scenario_name, scenario_id, ActorIDs);

      if (EVENTCONDITION == True)
        print_event_condition_statement (EVENTCONDITIONSET, scenario_name );

      if (DATACONDITION == True)
        print_data_condition_statement (DATACONDITIONSET, scenario_name );

    }

  message ("");


  DataTypes = Build_Dataitem_Statements(DataItemsDataTypes);
  Build_Datatype_Statements(DataTypes);
  Build_Footer();
//  WriteFileText (OUTPUTDIR, FILETEXT);
      message ( FILETEXT);
  FILETEXT = "";


}

void
Build_Action_Statement( string scenario_name, int scenario_id,
                string actorids)
{
  list InputEvents, OutputEvents;



  InputEvents = list_create ("string", 0);
  OutputEvents = list_create ("string", 0);

  list_clear(InputEvents);
  list_clear(OutputEvents);

  InputEvents = GetInputEvents("Input", scenario_id, actorids);
  OutputEvents = GetOutputEvents("Output", scenario_id, actorids);

  
  print_action_header ( scenario_name);

  print_uses_data (InputEvents);
  print_produces_data (OutputEvents);

  if (EVENTCONDITION == True || DATACONDITION == True )
     print_acts_only_if(scenario_name);
//  print_satisfies(event_id);
//  print_is_selected_by(event_id);
//  print_is_concluded_on(event_id);


  print_is_tested_exhaustively (EVENTCONDITIONSET, TESTEXHAUSITIVESET);

  print_end_action();

}


int
check_existence( string use_case_name, string scenario_name )
{
  string query;
  node nodevar;

  query = "node[OMTScenarioName && node_refs && name == '${scenario_name}'
            && scope_node [ OMTUseCaseParent && name == '${use_case_name}']]";

  nodevar = find_by_query(query);

  if (nodevar == NULL)
     return (0);
  else
     return (nodevar.id);

}

void
print_action_header(  string scenario_name )
{
  FILETEXT = FILETEXT +  ("Action " +  scenario_name + "\n");

  FILETEXT = FILETEXT +  ("   is actiontype internal;\n\n" );

}

void
print_acts_only_if ( string scenario_name)
{
  int i,count;

  if (EVENTCONDITION || DATACONDITION)
    FILETEXT = FILETEXT +  ("   acts only if\n");

  if (EVENTCONDITION && DATACONDITION)
    {
      FILETEXT = FILETEXT +  "     ( " + scenario_name + "_EVENTS &&\n";
      FILETEXT = FILETEXT +  "       " + scenario_name + "_DATA );\n\n";
    }
  else if (EVENTCONDITION )
    {
      FILETEXT = FILETEXT +  "     ( " + scenario_name + "_EVENTS );\n\n";
    }
  else if (DATACONDITION )
    {
      FILETEXT = FILETEXT +  "     ( " + scenario_name + "_DATA );\n\n";
    }


}


void
print_event_condition_statement (set eventnames, string scenario_name )
{
  int i,count;


  count = set_count(eventnames);


  for(i=0;i<count;i=i+1)
    {
       if (i==0)
         {
           FILETEXT = FILETEXT +  ("condition\n");
           FILETEXT = FILETEXT +  ("  "+ scenario_name + "_EVENTS\n");
           FILETEXT = FILETEXT +  ("  is true if (\n");
         }

       FILETEXT =  FILETEXT +  "       " + set_get_element(eventnames,i) + 
           " == did_occur";

       if (i<count-1)
          FILETEXT = FILETEXT +  " &&\n";

    }

  FILETEXT = FILETEXT + " );\n.\n\n";
}


void
print_data_condition_statement (set datanames, string scenario_name )
{
  int i,count;


  count = set_count(datanames);


  for(i=0;i<count;i=i+1)
    {
       if (i==0)
         {
           FILETEXT = FILETEXT +  ("condition\n");
           FILETEXT = FILETEXT +  ("  "+ scenario_name + "_DATA\n");
           FILETEXT = FILETEXT +  ("  is true if (\n");
         }

       FILETEXT =  FILETEXT +  "       " + set_get_element(datanames,i) + 
           " as_specified";

       if (i<count-1)
          FILETEXT = FILETEXT +  " &&\n";

    }

  FILETEXT = FILETEXT + " );\n.\n\n";
}

void
print_satisfies ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TSatisfies && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  satisfies\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}

void
print_is_selected_by ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TIsSelectedBy && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  is selected by\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}



void
print_is_concluded_on ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TIsConcludedOn && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  is concluded on\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}




void
print_is_tested_exhaustively ( set eventset, set dataset )
{
  int i,count;
  int j,count2;
  string event;

  count = set_count (eventset);
  count2 = set_count (dataset);


  if (count > 0 || count2 > 0 )
    {
      FILETEXT = FILETEXT +  "   is tested exhaustively on dataitem\n";
    }
  for (i=0; i<count; i=i+1)
    {
      event = set_get_element(eventset, i);
      FILETEXT = FILETEXT +  "     " + event;
      if (i < count - 1)
        FILETEXT = FILETEXT + (",\n");
    }

  if (count2 > 0)
    FILETEXT = FILETEXT + (",\n");

  for (i=0; i<count2; i=i+1)
    {
      FILETEXT = FILETEXT +  "     " + set_get_element(dataset, i);
      if (i < count2 - 1)
        FILETEXT = FILETEXT + (",\n");
    }

  if (count > 0 || count2 > 0 )
    {
      FILETEXT = FILETEXT + (";\n\n");
    }
       
}



void
print_uses_data ( list inputevents)
{

  int event_id, i,count;
  string eventname, fromclass, toclass, actionname;
  link_ref linkrefvar;


  FILETEXT = FILETEXT +  ("   uses dataitem\n");

  count = list_count(inputevents);

  for (i=0; i<count; i=i+1)
    {
       linkrefvar = list_get(inputevents, i);
       eventname = GetEventName(linkrefvar.link_id);

       EVENTCONDITION = True;
       set_add (EVENTCONDITIONSET, eventname);

       event_id = GetEventID(linkrefvar.link_id);

       set_add (DataItemsDataTypes, eventname + SEPARATOR + 
                     "EVENT" + SEPARATOR2 + "input_event_type");
       Build_Dataitem_Set(event_id );

       if (i>0)
          FILETEXT = FILETEXT + ",\n";

       FILETEXT = FILETEXT + "     " + eventname;

       GetUsesData(event_id);
    }

  FILETEXT = FILETEXT + ";\n\n";

}


void
GetUsesData ( int event_id)
{
  int i,count;
  note notevar;
  list TNote, notelist;
  item itemvar,itemvar2,itemvar4;

  string q1 = "note [TestDataItem && obj_id == ${event_id}]";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";
  string q3 = "item [TExhaustiveTest && note_id == ${notevar.id}]";
  string q4 = "item [TFixedValue && note_id == ${notevar.id}]";

  notelist = list_select(q1);
  TNote = SortBySequenceNumber(notelist, event_id);


  count = list_count(TNote);

  for (i=0; i<count; i=i+1)
    {
      notevar = list_get(TNote, i);
      itemvar = find_by_query(q2);
      itemvar2 = find_by_query(q3);
      itemvar4 = find_by_query(q4);

      if (itemvar4 == NULL)
        {
          DATACONDITION = True;
          set_add ( DATACONDITIONSET, itemvar.value);
        }

      FILETEXT = FILETEXT +  (",\n         " + RemoveSpaces(itemvar.value));

      if (itemvar2 != NULL && itemvar4 == NULL)
        {
           TESTEXHAUSITIVE = True;
           set_add ( TESTEXHAUSITIVESET, itemvar.value);
        }
    }

}



void
print_produces_data ( list outputevents)
{

  list EventList;
  int event_id, i,count;
  string eventname, fromclass, toclass, actionname;
  link_ref linkrefvar;

  count = list_count(outputevents);


  if (count >0)
     FILETEXT = FILETEXT +  ("   produces dataitem\n");


  for (i=0; i<count; i=i+1)
    {
       linkrefvar = list_get(outputevents, i);
       eventname = GetEventName(linkrefvar.link_id);
       event_id = GetEventID(linkrefvar.link_id);

       set_add (DataItemsDataTypes, eventname + SEPARATOR + 
                     "FIXED" + SEPARATOR2 + "did_occur");
       Build_Dataitem_Set(event_id );

       if (i>0)
          FILETEXT = FILETEXT + ",\n";

       FILETEXT = FILETEXT + "     " + eventname;
       GetProducesData(event_id);
    }

   if (count > 0) 
     FILETEXT = FILETEXT + ";\n\n";
}


void
GetProducesData ( int event_id)
{
  int i,count;
  note notevar;
  list TNote, notelist;
  item itemvar;

  string q1 = "note [TestDataItem && obj_id == ${event_id}]";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";

  notelist = list_select(q1);
  TNote = SortBySequenceNumber(notelist, event_id);


  count = list_count(TNote);

  for (i=0; i<count; i=i+1)
    {
      notevar = list_get(TNote, i);
      itemvar = find_by_query(q2);
      FILETEXT = FILETEXT +  (",\n         " + RemoveSpaces(itemvar.value));
    }

}



void
print_end_action()
{

  FILETEXT = FILETEXT + (".\n\n\n");

}

void
Build_Dataitem_Set(int id)
{
  list dataitems;
  int i,count;
  note notevar;
  item itemvar1, itemvar3, itemvar4, itemvar5;
  string default="UNSPECIFIED" + SEPARATOR2 + "UNSPECIFIED";
  string typename= default;

  string q1 = "note [TestDataItem && obj_id == ${id}] sort by name";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";
  string q3 = "item [TFixedValue && note_id == ${notevar.id}]";
  string q4 = "item [TDataType && note_id == ${notevar.id}]";
  string q5 = "item [TDataTypeName && note_id == ${notevar.id}]";

  dataitems = list_select(q1);

  count = list_count(dataitems);

  for (i=0;i<count;i=i+1)
    {
      notevar = list_get(dataitems,i);
      itemvar1 = find_by_query(q2);

      itemvar3 = find_by_query(q3);
      itemvar4 = find_by_query(q4);
      itemvar5 = find_by_query(q5);

      if (itemvar3 != NULL)
        {
           typename = "FIXED" + SEPARATOR2 + itemvar3.value;
        }

      else if (itemvar4 != NULL)
        {
           typename = "DEFINED" + SEPARATOR2 + itemvar4.value;
        }

      else if (itemvar5 != NULL)
        {
           typename = "DEFINED" + SEPARATOR2 + itemvar5.value;
        }


      set_add (DataItemsDataTypes, itemvar1.value + SEPARATOR + typename);


    }
}


set
Build_Dataitem_Statements(set DataItemsDataTypes)
{
  list listvar, datatypelist;
  string stringvar;
  string dataitem, datatypestring, datatype, datatypetype;
  int i,count;
  set DataTypes;

  DataTypes = set_create ("string");

  count = set_count(DataItemsDataTypes);

  for (i=0;i<count;i=i+1)
    {
      stringvar = set_get_element(DataItemsDataTypes,i);

      listvar = string_to_list(stringvar, SEPARATOR );
      dataitem = list_get(listvar,0);
      datatypestring = list_get(listvar,1);

      datatypelist = string_to_list(datatypestring, SEPARATOR2);
      datatypetype = list_get(datatypelist,0);
      datatype = list_get(datatypelist,1);

//message (dataitem + "   " + datatypetype + "   " + datatype);

      if (datatypetype != "EVENT" && datatypetype != "UNSPECIFIED"
                  && datatypetype != "FIXED")
        set_add (DataTypes, datatype);

      if (datatypetype == "UNSPECIFIED")
        {
          FILETEXT = FILETEXT +  ("Dataitem " + dataitem + ";\n");
          FILETEXT = FILETEXT +  
               ("   has placeholder value \"" + datatype + "\";\n");
          FILETEXT = FILETEXT +  (".\n\n");
        }
      else if (datatypetype == "FIXED")
        {
          FILETEXT = FILETEXT +  ("Dataitem " + dataitem + ";\n");
          FILETEXT = FILETEXT +  
               ("   has fixed value \"" + datatype + "\";\n");
          FILETEXT = FILETEXT +  (".\n\n");
        }
      else
        {
          FILETEXT = FILETEXT +  ("Dataitem " + dataitem + ";\n");
          FILETEXT = FILETEXT +  
               ("   is an instance of datatype " + datatype + ";\n");
          FILETEXT = FILETEXT +  (".\n\n");
        }
    }

  return (DataTypes);

}

void
Build_Datatype_Statements(set datatypes)
{
  int i,count;
  string datatypename;
  node nodevar;
  item itemvar;

  string q1 = "node [TTestType && name == '${datatypename}']";
  string q2 = "item [TDataTypeClass && obj_id == ${nodevar.id}]";

  count = set_count (datatypes);

  for (i=0;i<count;i=i+1)
    {
      datatypename = set_get_element(datatypes,i);
      nodevar = find_by_query(q1);

      if (nodevar != NULL)
        {
          itemvar = find_by_query(q2);

          if (itemvar != NULL)
            {
              if (itemvar.value == "integer" || itemvar.value == "real")
                Build_IntegerReal_TypeDef(datatypename, itemvar.value, 
                  nodevar.id);
              else if (itemvar.value == "string")
                Build_String_TypeDef(datatypename, itemvar.value, 
                  nodevar.id);
              else
                {
                  message ("  WARNING: " + datatypename + 
                      " is not defined in an StP type table");
                }
            }
          else
            {
              message ("  WARNING: " + datatypename + " is not defined in an StP type table");
            }

        }
      else
        {
           message ("  WARNING: " + datatypename + " is not defined in an StP type table");
        }

    }
}

void
Build_IntegerReal_TypeDef(string datatypename, string name, int id)
{
  item itemvar;
  list itemlist;
  int i,count;

  string q1 = "item [TMinimumValue && obj_id == ${id}]";
  string q2 = "item [TMaximumValue && obj_id == ${id}]";
  string q3 = "item [TResolution && obj_id == ${id}]";
  string q4 = "item [TTestValue && obj_id == ${id}]";
  string q5 = "item [TInvalidSubdomain && obj_id == ${id}]";


  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass " + name  + ";\n");

  itemvar = find_by_query(q1);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range minimum " + itemvar.value  + ";\n");
    }

  itemvar = find_by_query(q2);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range maximum " + itemvar.value  + ";\n");
    }

  itemvar = find_by_query(q3);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range resolution " + itemvar.value  + ";\n");
    }

  itemlist = list_select(q4);
  count = list_count(itemlist);
  for (i=0;i<count;i=i+1 )
    {
      if (i==0)
         FILETEXT = FILETEXT +  ("  has values ");

      itemvar = list_get(itemlist, i);

      FILETEXT = FILETEXT +  (itemvar.value);

      if (i < count - 1)
         FILETEXT = FILETEXT + (",\n             ");
      else 
         FILETEXT = FILETEXT + (";\n");
    }

  FILETEXT = FILETEXT +  ("\n  has valid subdomain as_specified;\n");

  itemvar = find_by_query(q5);
  if (itemvar != NULL)
    {
      if (itemvar.value != "None")
         {
           FILETEXT = FILETEXT +  ("  has invalid subdomain ");
           FILETEXT = FILETEXT +  (GetInvalidSubdomain(itemvar.value)  + ";\n");
         }
    }
  FILETEXT = FILETEXT +  (".\n\n");

}



void
Build_String_TypeDef(string datatypename, string name, int id)
{
  item itemvar;
  list itemlist;
  int i,count;

  string q4 = "item [TTestValue && obj_id == ${id}]";
  string q5 = "item [TInvalidSubdomain && obj_id == ${id}]";


  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass " + name  + ";\n");

  itemlist = list_select(q4);
  count = list_count(itemlist);
  for (i=0;i<count;i=i+1 )
    {
      if (i==0)
         FILETEXT = FILETEXT +  ("  has values ");

      itemvar = list_get(itemlist, i);

      FILETEXT = FILETEXT +  ("\"" + itemvar.value + "\"");

      if (i < count - 1)
         FILETEXT = FILETEXT + (",\n             ");
      else 
         FILETEXT = FILETEXT + (";\n");
    }

  FILETEXT = FILETEXT +  ("\n  has valid subdomain as_specified;\n");

  itemvar = find_by_query(q5);
  if (itemvar != NULL)
    {
      if (itemvar.value != "None")
         {
           FILETEXT = FILETEXT +  ("  has invalid subdomain ");
           FILETEXT = FILETEXT +  (GetInvalidSubdomain(itemvar.value)  + ";\n");
         }
    }
  FILETEXT = FILETEXT +  (".\n\n");

}


void
Build_Unspecified_TypeDef(string datatypename)
{
  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass unspecified;\n");
  FILETEXT = FILETEXT +  ("  has placeholder value \"UNSPECIFIED\";\n");
  FILETEXT = FILETEXT +  ("  has valid subdomain as_specified;\n");
  FILETEXT = FILETEXT +  (".\n\n");
}

void
Build_Footer()
{
  FILETEXT = FILETEXT + ("\n\npe_mark\n\n");
}

string
GetInvalidSubdomain(string name)
{

  if (name == "NotInList")
    return ("not_in_list");
  else if (name == "OutOfType")
    return ("out_of_type");
  else if (name == "AboveBounds")
    return ("above_bounds");
  else if (name == "BelowBounds")
    return ("below_bounds");
  else if (name == "OutOfBounds")
    return ("out_of_bounds");
  else if (name == "Abnormal")
    return ("abnormal");

}


void
WriteFileText (string OUTPUTDIR, string FILETEXT)
{
  string outputfile = OUTPUTDIR + "/sdf";

  if(write_file_access(outputfile))
     write_file (outputfile, FILETEXT);

  else
    {
      // system ("mkdir " + OUTPUTDIR);
      CreateDirectory(OUTPUTDIR);
      if(write_file_access(outputfile))
         message ("File not available for writing");
      else 
         write_file (outputfile, FILETEXT);

    }
}


string
GetEventName( int link_id)
{
  link linkvar;
  item itemvar;

  string query1 = "item [ TScriptVariable && obj_id ==  ${link_id} ]";
  string query2 = "link [ id == ${link_id} ]";

  itemvar = find_by_query (query1);
  linkvar = find_by_query (query2);

  if (itemvar == NULL && linkvar == NULL)
     return (NULL);

  if (itemvar != NULL && itemvar.value != "")
    return (RemoveSpaces(itemvar.value) );
  else if (string_length (linkvar.name) >20 )
    return ( RemoveSpaces(string_extract(linkvar.name, 0, 20)) );
  else
    return (RemoveSpaces(linkvar.name));

}


int
GetEventID( int link_id)
{
  link linkvar;
  string query = "link [ id == ${link_id} ]";

  linkvar = find_by_query (query);

  if (linkvar == NULL)
    return (0);
  else 
    return (linkvar.id);


}


string
GetClassName( int node_id)
{
  node nodevar;
  string query = "node [ OMTClass && node_refs [id == ${node_id} ]]";

  nodevar = find_by_query (query);

  if (nodevar == NULL)
    return ("NULL");
  else 
    return (nodevar.name);

}


list
GetInputEvents(string type, int scenario_id, string actorids)
{
 
  string linkref_query, noderef_query;
  node_ref nr;

  if (actorids == "")
      actorids = "0";

  noderef_query = "node_ref [node_id == ${scenario_id} ] ";

  nr = find_by_query (noderef_query);

  linkref_query = "link_ref [ file_id == ${nr.file_id} && 
           link [ OMTEventInstance   &&
           from_node[${actorids}] ] ] sort by ycoord";

  return ( list_select (linkref_query) );

}


list
GetOutputEvents(string type, int scenario_id, string actorids)
{
 
  string linkref_query, noderef_query;
  node_ref nr;

  if (actorids == "")
      actorids = "0";

  noderef_query = "node_ref [node_id == ${scenario_id} ] ";

  nr = find_by_query (noderef_query);

  linkref_query = "link_ref [ file_id == ${nr.file_id} && 
           link [ OMTEventInstance   &&
           to_node[${actorids}] ] ] sort by ycoord";

  return ( list_select (linkref_query) );

}

