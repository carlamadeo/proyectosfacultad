external string UseCases;


#include "qrl/tsdl_extract.inc"
#include "qrl/basic_textract_dt.inc"
#include "qrl/include/error.inc"

#include "val/qrl/include/TConfig.inc"
#include "val/qrl/include/TUseCase.inc"
#include "val/qrl/include/val_string_globals.inc"
#include "val/qrl/include/CreateDir.inc"


  string OUTPUTPATH = current_projdir() + current_system() + "/test_files/";
  string OUTPUTDIR;
  string FILETEXT="";

  set DataItemsDataTypes;


void 
main ()
{
  list UseCaseList, ScenarioList;
  int count1, i;
  int count2, j;
  string use_case_name, test_unit_id, scenario_name;
  node scenario;
  int scenario_id;
  set DataTypes;
  string ActorIDs;

  DataItemsDataTypes = set_create ("string");

  UseCaseList = string_to_list (UseCases, " ");

  count1 = list_count (UseCaseList);

  for (i=0;i<count1;i=i+1)
    {
      set_clear(DataItemsDataTypes);

      use_case_name = list_get(UseCaseList,i);

      test_unit_id = Get_T_test_unit_id(use_case_name, "");

      OUTPUTDIR = OUTPUTPATH + test_unit_id;
      message ("Generating Data for Use Case: " + use_case_name); 

      ActorIDs = GetActorIDList(use_case_name);

      ScenarioList = GetScenarioList(use_case_name);
      count2 = list_count (ScenarioList);
      for (j=0;j<count2;j=j+1)
        {
          scenario = list_get(ScenarioList,j);
          scenario_name = scenario.name;
          scenario_id = scenario.id;
          message ("  Generating Data for Scenario: " + scenario_name );
          FILETEXT = FILETEXT + "USECASE: " + use_case_name + "\n";
          FILETEXT = FILETEXT +"  SCENARIO: " + scenario_name + "\n";


          Build_Event_Section(scenario_name, scenario_id, ActorIDs);
        }

      print ( FILETEXT);
//      message ( FILETEXT);
      FILETEXT = "";
    }

}


void
Build_Event_Section( string scenario_name, int scenario_id,
                string actorids)
{
  list Events;
  list EventList;
  int event_id, i,count;
  string eventname, fromclass, toclass, actionname;
  link_ref linkrefvar;
  int eventnumber = 0;


  Events = list_create ("string", 0);

  list_clear(Events);

  Events = GetEvents( scenario_id, actorids);


  EventList = list_create("string",0);

  count = list_count(Events);

  for (i=0; i<count; i=i+1)
    {
       linkrefvar = list_get(Events, i);
       eventname = GetEventName(linkrefvar.link_id);
       event_id = linkrefvar.link_id;

       FILETEXT = FILETEXT + "\n    " + ++eventnumber + ". EVENT: " + eventname + "\n";
       FILETEXT = FILETEXT + "         FROM CLASS: " +
            GetSourceName(event_id) + "\n";
       FILETEXT = FILETEXT + "         TO   CLASS: " +
            GetDestinationName(event_id) + "\n";

       GetData(event_id);
    }

  FILETEXT = FILETEXT + "\n\n";

}



int
check_existence( string use_case_name, string scenario_name )
{
  string query;
  node nodevar;

  query = "node[OMTScenarioName && node_refs && name == '${scenario_name}'
            && scope_node [ OMTUseCaseParent && name == '${use_case_name}']]";

  nodevar = find_by_query(query);

  if (nodevar == NULL)
     return (0);
  else
     return (nodevar.id);

}

void
print_action_header(  string scenario_name )
{
  FILETEXT = FILETEXT +  ("Action " +  scenario_name + "\n");

  FILETEXT = FILETEXT +  ("   is actiontype internal;\n\n" );

  FILETEXT = FILETEXT + "  has description \"" + 
     Get_T_SPacketDescription (scenario_name, "OMTScenarioName") + "\";\n\n";
}

void
print_acts_only_if ( list eventnames )
{
  int i,count;

  FILETEXT = FILETEXT +  ("   acts only if\n");

  count = list_count(eventnames);


  for(i=0;i<count;i=i+1)
    {
       if (i==0)
          FILETEXT = FILETEXT +  "     (\n";

       FILETEXT = 
              FILETEXT +  "       " + list_get(eventnames,i) + " == did_occur";

       if (i<count-1)
          FILETEXT = FILETEXT +  " &&\n";

    }

  FILETEXT = FILETEXT + "\n     );\n\n";
}

void
print_satisfies ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TSatisfies && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  satisfies\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}

void
print_is_selected_by ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TIsSelectedBy && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  is selected by\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}



void
print_is_concluded_on ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TIsConcludedOn && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  is concluded on\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}




void
print_is_tested_exhaustively ( list eventlist )
{
  int i,count;
  string event;

  count = list_count (eventlist);

  FILETEXT = FILETEXT +  ("   is tested exhaustively on dataitem\n");

  for (i=0; i<count; i=i+1)
    {
      event = list_get(eventlist, i);
      FILETEXT = FILETEXT +  ("     " + event);
      if (i < count - 1)
        FILETEXT = FILETEXT + (",\n");
      else 
        FILETEXT = FILETEXT + (";\n\n");
    }
       
}

/*
  string q1 = "note [TestAction && obj_id == ${scenario_id} &&
       items [TExhaustive ]]";
  string q2 = "item [TExhaustive && note_id == ${notevar.id}]";

  notevar = find_by_query(q1);

  if (notevar != NULL)
    {
      TItem = list_select(q2);
      count = list_count(TItem);

      FILETEXT = FILETEXT +  ("   is tested exhaustively on dataitem\n");

      for (i=0; i<count; i=i+1)
        {
          itemvar = list_get(TItem, i);
          FILETEXT = FILETEXT +  ("     " + itemvar.value);
          if (i < count - 1)
            FILETEXT = FILETEXT + (",\n");
          else 
            FILETEXT = FILETEXT + (";\n\n");
        }
    }
*/



void
GetData ( int event_id)
{
  int i,count;
  note notevar;
  list TNote, notelist;
  item itemvar;

  string q1 = "note [TestDataItem && obj_id == ${event_id}]";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";

  notelist = list_select(q1);
  TNote = SortBySequenceNumber(notelist, event_id);

  count = list_count(TNote);

  for (i=0; i<count; i=i+1)
    {
      notevar = list_get(TNote, i);
      itemvar = find_by_query(q2);
      FILETEXT = FILETEXT + "         DATA:  " + itemvar.value + "\n";
    }

}



void
Build_Dataitem_Set(int id)
{
  list dataitems;
  int i,count;
  note notevar;
  item itemvar1, itemvar3, itemvar4, itemvar5;
  string default="UNSPECIFIED" + SEPARATOR2 + "UNSPECIFIED";
  string typename= default;

  string q1 = "note [TestDataItem && obj_id == ${id}] sort by name";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";
  string q3 = "item [TFixedValue && note_id == ${notevar.id}]";
  string q4 = "item [TDataType && note_id == ${notevar.id}]";
  string q5 = "item [TDataTypeName && note_id == ${notevar.id}]";

  dataitems = list_select(q1);

  count = list_count(dataitems);

  for (i=0;i<count;i=i+1)
    {
      notevar = list_get(dataitems,i);
      itemvar1 = find_by_query(q2);

      itemvar3 = find_by_query(q3);
      itemvar4 = find_by_query(q4);
      itemvar5 = find_by_query(q5);

      if (itemvar3 != NULL)
        {
           typename = "FIXED" + SEPARATOR2 + itemvar3.value;
        }

      else if (itemvar4 != NULL)
        {
           typename = "DEFINED" + SEPARATOR2 + itemvar4.value;
        }

      else if (itemvar5 != NULL)
        {
           typename = "DEFINED" + SEPARATOR2 + itemvar5.value;
        }


      set_add (DataItemsDataTypes, itemvar1.value + SEPARATOR + typename);


    }
}


set
Build_Dataitem_Statements(set DataItemsDataTypes)
{
  list listvar, datatypelist;
  string stringvar;
  string dataitem, datatypestring, datatype, datatypetype;
  int i,count;
  set DataTypes;

  DataTypes = set_create ("string");

  count = set_count(DataItemsDataTypes);

  for (i=0;i<count;i=i+1)
    {
      stringvar = set_get_element(DataItemsDataTypes,i);

      listvar = string_to_list(stringvar, SEPARATOR );
      dataitem = list_get(listvar,0);
      datatypestring = list_get(listvar,1);

      datatypelist = string_to_list(datatypestring, SEPARATOR2);
      datatypetype = list_get(datatypelist,0);
      datatype = list_get(datatypelist,1);

//message (dataitem + "   " + datatypetype + "   " + datatype);

      if (datatypetype != "EVENT" && datatypetype != "UNSPECIFIED"
                  && datatypetype != "FIXED")
        set_add (DataTypes, datatype);

      if (datatypetype == "UNSPECIFIED")
        {
          FILETEXT = FILETEXT +  ("Dataitem " + dataitem + ";\n");
          FILETEXT = FILETEXT +  
               ("   has placeholder value \"" + datatype + "\";\n");
          FILETEXT = FILETEXT +  (".\n\n");
        }
      else if (datatypetype == "FIXED")
        {
          FILETEXT = FILETEXT +  ("Dataitem " + dataitem + ";\n");
          FILETEXT = FILETEXT +  
               ("   has fixed value \"" + datatype + "\";\n");
          FILETEXT = FILETEXT +  (".\n\n");
        }
      else
        {
          FILETEXT = FILETEXT +  ("Dataitem " + dataitem + ";\n");
          FILETEXT = FILETEXT +  
               ("   is an instance of datatype " + datatype + ";\n");
          FILETEXT = FILETEXT +  (".\n\n");
        }
    }

  return (DataTypes);

}

void
Build_Datatype_Statements(set datatypes)
{
  int i,count;
  string datatypename;
  node nodevar;
  item itemvar;

  string q1 = "node [TTestType && name == '${datatypename}']";
  string q2 = "item [TDataTypeClass && obj_id == ${nodevar.id}]";

  count = set_count (datatypes);

  for (i=0;i<count;i=i+1)
    {
      datatypename = set_get_element(datatypes,i);
      nodevar = find_by_query(q1);

      if (nodevar != NULL)
        {
          itemvar = find_by_query(q2);

          if (itemvar != NULL)
            {
              if (itemvar.value == "integer" || itemvar.value == "real")
                Build_IntegerReal_TypeDef(datatypename, itemvar.value, 
                  nodevar.id);
              else if (itemvar.value == "string")
                Build_String_TypeDef(datatypename, itemvar.value, 
                  nodevar.id);
              else
                {
                  message ("  WARNING: " + datatypename + 
                      " is not defined in an StP type table");
                }
            }
          else
            {
              message ("  WARNING: " + datatypename + " is not defined in an StP type table");
            }

        }
      else
        {
           message ("  WARNING: " + datatypename + " is not defined in an StP type table");
        }

    }
}

void
Build_IntegerReal_TypeDef(string datatypename, string name, int id)
{
  item itemvar;
  list itemlist;
  int i,count;

  string q1 = "item [TMinimumValue && obj_id == ${id}]";
  string q2 = "item [TMaximumValue && obj_id == ${id}]";
  string q3 = "item [TResolution && obj_id == ${id}]";
  string q4 = "item [TTestValue && obj_id == ${id}]";
  string q5 = "item [TInvalidSubdomain && obj_id == ${id}]";


  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass " + name  + ";\n");

  itemvar = find_by_query(q1);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range minimum " + itemvar.value  + ";\n");
    }

  itemvar = find_by_query(q2);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range maximum " + itemvar.value  + ";\n");
    }

  itemvar = find_by_query(q3);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range resolution " + itemvar.value  + ";\n");
    }

  itemlist = list_select(q4);
  count = list_count(itemlist);
  for (i=0;i<count;i=i+1 )
    {
      if (i==0)
         FILETEXT = FILETEXT +  ("  has values ");

      itemvar = list_get(itemlist, i);

      FILETEXT = FILETEXT +  (itemvar.value);

      if (i < count - 1)
         FILETEXT = FILETEXT + (",\n             ");
      else 
         FILETEXT = FILETEXT + (";\n");
    }

  FILETEXT = FILETEXT +  ("\n  has valid subdomain as_specified;\n");

  itemvar = find_by_query(q5);
  if (itemvar != NULL)
    {
      if (itemvar.value != "None")
         {
           FILETEXT = FILETEXT +  ("  has invalid subdomain ");
           FILETEXT = FILETEXT +  (GetInvalidSubdomain(itemvar.value)  + ";\n");
         }
    }
  FILETEXT = FILETEXT +  (".\n\n");

}



void
Build_String_TypeDef(string datatypename, string name, int id)
{
  item itemvar;
  list itemlist;
  int i,count;

  string q4 = "item [TTestValue && obj_id == ${id}]";
  string q5 = "item [TInvalidSubdomain && obj_id == ${id}]";


  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass " + name  + ";\n");

  itemlist = list_select(q4);
  count = list_count(itemlist);
  for (i=0;i<count;i=i+1 )
    {
      if (i==0)
         FILETEXT = FILETEXT +  ("  has values ");

      itemvar = list_get(itemlist, i);

      FILETEXT = FILETEXT +  ("\"" + itemvar.value + "\"");

      if (i < count - 1)
         FILETEXT = FILETEXT + (",\n             ");
      else 
         FILETEXT = FILETEXT + (";\n");
    }

  FILETEXT = FILETEXT +  ("\n  has valid subdomain as_specified;\n");

  itemvar = find_by_query(q5);
  if (itemvar != NULL)
    {
      if (itemvar.value != "None")
         {
           FILETEXT = FILETEXT +  ("  has invalid subdomain ");
           FILETEXT = FILETEXT +  (GetInvalidSubdomain(itemvar.value)  + ";\n");
         }
    }
  FILETEXT = FILETEXT +  (".\n\n");

}


void
Build_Unspecified_TypeDef(string datatypename)
{
  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass unspecified;\n");
  FILETEXT = FILETEXT +  ("  has placeholder value \"UNSPECIFIED\";\n");
  FILETEXT = FILETEXT +  ("  has valid subdomain as_specified;\n");
  FILETEXT = FILETEXT +  (".\n\n");
}

void
Build_Footer()
{
  FILETEXT = FILETEXT + ("\n\npe_mark\n\n");
}

string
GetInvalidSubdomain(string name)
{

  if (name == "NotInList")
    return ("not_in_list");
  else if (name == "OutOfType")
    return ("out_of_type");
  else if (name == "AboveBounds")
    return ("above_bounds");
  else if (name == "BelowBounds")
    return ("below_bounds");
  else if (name == "OutOfBounds")
    return ("out_of_bounds");
  else if (name == "Abnormal")
    return ("abnormal");

}


void
WriteFileText (string OUTPUTDIR, string FILETEXT)
{
  string outputfile = OUTPUTDIR + "/sdf";

  if(write_file_access(outputfile))
     write_file (outputfile, FILETEXT);

  else
    {
      //system ("mkdir " + OUTPUTDIR);
      CreateDirectory(OUTPUTDIR);
      if(write_file_access(outputfile))
         message ("File not available for writing");
      else 
         write_file (outputfile, FILETEXT);

    }
}


string
GetEventName( int link_id)
{
  link linkvar;
  string query = "link [ id == ${link_id} ]";

  linkvar = find_by_query (query);

  if (linkvar == NULL)
    return ("NULL");
  else 
    return (linkvar.name);

}


string
GetSourceName( int link_id)
{
  link linkvar;
  string linkquery = "link [ id == ${link_id} ]";
  node nodevar;
  string nodequery = "node [ OMTClass && id == ${linkvar.from_node_id} ]";


  linkvar = find_by_query (linkquery);

  if (linkvar == NULL)
    return ("");
  else 
    {
      nodevar = find_by_query(nodequery);
      return (nodevar.name);
    }


}



string
GetDestinationName( int link_id)
{
  link linkvar;
  string linkquery = "link [ id == ${link_id} ]";
  node nodevar;
  string nodequery = "node [ OMTClass && id == ${linkvar.to_node_id} ]";


  linkvar = find_by_query (linkquery);

  if (linkvar == NULL)
    return ("");
  else 
    {
      nodevar = find_by_query(nodequery);
      return (nodevar.name);
    }

}


string
GetClassName( int node_id)
{
  node nodevar;
  string query = "node [ OMTClass && node_refs [id == ${node_id} ]]";

  nodevar = find_by_query (query);

  if (nodevar == NULL)
    return ("NULL");
  else 
    return (nodevar.name);

}


list
GetEvents(int scenario_id, string actorids)
{
 
  string linkref_query, noderef_query;
  node_ref nr;

  if (actorids == "")
      actorids = "0";

  noderef_query = "node_ref [node_id == ${scenario_id} ] ";

  nr = find_by_query (noderef_query);

  linkref_query = "link_ref [ file_id == ${nr.file_id} && 
           link [ OMTEventInstance   ] ] sort by ycoord";

  return ( list_select (linkref_query) );

}


