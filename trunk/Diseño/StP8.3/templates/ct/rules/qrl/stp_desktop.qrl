// ECR 6227 begin
void change_current_sybase_user(string new_user)
{
    string server;

    put_environment_variable("IDE_OMS_DBUSER=" + new_user);

    server = get_rep_server(current_projdir(), current_system());
    if (server == "MS Jet")
        return;

    if (server == "")
        server = environment_variable("DSQUERY");
    if (server == "")
        return;

    server = to_upper(server);
    if (new_user == "sa")
        server += "_A";
    put_environment_variable(server + "=");
}
// ECR 6227 end

// SPR 2278 - added activeFunc to grey menu entries when system not open
int activeUseCase()
{
    if(current_system() == "")
        return 0;
    else
        return 1;
}

int activeCXXCodeGen()
{
    if(stp_is_in_object_menu("GenerateCXXCodeObjects"))
        return 1;
    else
        return 0;                         
}

int activeJavaCodeGen()
{
    if(stp_is_in_object_menu("GenerateJavaCodeObjects"))
        return 1;
    else
        return 0;
}

// Begin Add ECR 7640
int activeAda95TdlCodeGen()
{
    if(stp_is_in_object_menu("GenerateAda95TdlCodeObjects"))
        return 1;
    else
        return 0;
}

int activeCXXTdlCodeGen()
{
    if(stp_is_in_object_menu("GenerateCXXTdlCodeObjects"))
        return 1;
    else
        return 0;
}

int activeJavaTdlCodeGen()
{
    if(stp_is_in_object_menu("GenerateJavaTdlCodeObjects"))
        return 1;
    else
        return 0;
}

int activeEjbTdlCodeGen()
{
    if(stp_is_in_object_menu("GenerateJ2EEEJBTdlCodeObjects"))
        return 1;
    else
        return 0;
}
// End Add ECR 7640

int activeIDLCodeGen()
{
    if(stp_is_in_object_menu("GenerateIDLCodeObjects"))
        return 1;
    else
        return 0;
}

int activeAda95CodeGen()
{
    if(stp_is_in_object_menu("GenerateAda95CodeObjects"))
        return 1;
    else
        return 0;
}

int activeTOOLCodeGen()
{
    if(stp_is_in_object_menu("GenerateTOOLCodeObjects"))
        return 1;
    else
        return 0;
}

int activeSmalltalkCodeGen()
{
    if(stp_is_in_object_menu("GenerateSmalltalkCodeObjects"))
        return 1;
    else
        return 0;
}

int activeAda83CodeGen()
{
    if(stp_is_in_object_menu("GenerateAda83CodeObjects"))
        return 1;
    else
        return 0;
}

int activePersistanceCodeGen()
{
    if(stp_is_in_object_menu("GeneratePersistanceCodeObjects"))
        return 1;
    else
        return 0;
}

int edit_annot_active_func()
{
    if(stp_is_in_object_menu("EditAnnotation"))
        return 1;
    else
        return 0;
}

int rename_hierarchy_active_func()
{
    if(stp_is_in_object_menu("RenameHierarchy"))
        return 1;
    else
        return 0;
}

int se_gor_active_func()
{
    if(stp_is_in_object_menu("DesktopGlobalObjectRename"))
        return 1;
    else
        return 0;
}

int se_check_selectively_active_func()
{
    if(stp_is_in_object_menu("CheckSemanticsSelectively"))
        return 1;
    else
        return 0;
}

int se_check_all_active_func()
{
    if(stp_is_in_object_menu("CheckSemanticsAll") ||
           stp_is_in_object_menu("CheckSemanticsTableTypes"))
        return 1;
    else
        return 0;
}

void se_check_diagrams_or_tables()
{
    if ( stp_is_in_object_menu("CheckSemanticsAll"))
        stp_run_command("","CheckSemanticsAll");
    else
        stp_run_command("","CheckSemanticsTableTypes");
}

int se_check_all_tables_active_func()
{
    if(stp_is_in_object_menu("CheckSemanticsAllTables"))
        return 1;
    else
        return 0;
}

int se_check_table_type_active_func()
{
    if(stp_is_in_object_menu("CheckSemanticsTables"))
        return 1;
    else
        return 0;
}

int oo_show_class_description_active_func()
{
    if(stp_is_in_object_menu("ShowDescriptionofClass"))
        return 1;
    else
        return 0;
}

int oo_consistency_active_func()
{
    if(stp_is_in_object_menu("Consistency"))
        return 1;
    else
        return 0;
}

int oo_semantics_active_func()
{
    if(stp_is_in_object_menu("CheckIntraModelSemantics"))
        return 1;
    else
        return 0;
}

int smdb_active_func()
{
    if (is_smdb_available())
        return 1;
    else
        return 0;
}


// broke this out to here so that it will work on NT - before we were
// passing both commands to the Unix shell
//
int rename_diagram(string quiet, string editor, string diagram,
                   string new_name, string filetype)
{
    list new_name_list;

    print_message( "Starting diagram rename." );

    if (system( "stputil -forward_messages " + editor_get_msgd_handle() +
                " -s " + current_system() +
                " -p " + current_projdir() +
                " " + quiet +
                " -C 'rename -e " + editor +
                " " + diagram +
                " " + new_name + "'" ) == 0 &&
        system( "qrp -forward_messages " + editor_get_msgd_handle() +
                " -s " + current_system() +
                " -p " + current_projdir() +
                " qrl/rename/file_rename.qrl -x filetype " + filetype +
                " -x name '" + new_name + "'" ) == 0 )
        print_message( "Diagram renamed from '" + diagram + "' to '"
                       + new_name + "'." );
    else
        print_error( "Diagram rename failed." );
    return 0;
}

int
flaunch()
{
    string myProduct;
    string pathComp;
    string forteNT = "CMD /c ";
    string forteC  = "ftexec -fi bt:";
    string forteF  = "/forte/idecla0.btd";     // the forte file should exist
    string forteE  = "/forte/idecla0";         // the name passed to ftexec
    string forteImage = "";
    int i;

    if (is_product_uml())
        myProduct = "uml";
    else if (is_product_omt())
        myProduct = "omt";
    else
    {
        ide_warning("Product should be either OMT or UML");
        return 0;
    }

    string stpRoot = list_get(string_to_list(bin_directory(), "bin"), 0);
     
    // locate the forte executable image
    list path = string_to_list(toolinfo_variable( myProduct + "_stp_file_path"), ";");
    for (i=0; i < list_count(path); i++)
    {
        pathComp = list_get(path, i);
        if (!file_exists(pathComp + forteF))
           pathComp = stpRoot + pathComp;
        if (file_exists(pathComp + forteF))
        {
            if (is_unix_platform())
                forteImage = forteC + pathComp + forteE;
            else
                forteImage = forteNT + forteC + pathComp + forteE;
            break;
        }
    }

    if (forteImage == "")
    {
        ide_warning("Cannot locate the FORTE image in the templates");
        return 0;
    }

    if (environment_variable("FORTE_WORKSPACE") == NULL)
    {
        ide_warning("FORTE_WORKSPACE environment variable undefined");
        return 0;
    }

    if (environment_variable("FORTE_REPOSNAME") == NULL)
    {
        ide_warning("FORTE_REPOSNAME environment variable undefined");
        return 0;
    }

// ECR 6351
// MB: Changed for Forte Reverse
// Replace '\', just to make sure that it will work on Unix also.
//        
    system(string_search_and_replace(forteImage + " " + 
        editor_get_msgd_handle() + " " + 
        myProduct + " " +
        current_system() + " " + 
        current_projdir() + " " +
        environment_variable("FORTE_WORKSPACE") + " " + 
        environment_variable("FORTE_REPOSNAME") + " " +
        bin_directory(), "\\", "/"));

    return 0;
}
    
// Active funcs for code menu


int
activeSeCCodeGen()
{
    if (stp_editor_file_type_selected() == "Sce" ||
            stp_selection_has_command("GenerateCCodeObject"))
        return 1;
    else
        return 0;
}

int
activeSePdlCodeGen()
{
    if (stp_editor_file_type_selected() == "Sce")
        return 1;
    else
        return 0;
}

int
activeSePspecCodeGen()
{
    if (stp_editor_file_type_selected() == "DyDfe" || 
              stp_editor_file_type_selected() == "GsDfe")
        return 1;
    else
        return 0;
}
 
int
activeSeBnfCodeGen()
{
    if (stp_editor_file_type_selected() == "Dse")
        return 1;
    else
        return 0;
}
 
int
activeSeReRmDir()
{
    if (stp_editor_file_type_selected() == "SEDirectory")
        return 1;
    else
        return 0;
}
 
int
activeSeReRmFile()
{
    if (stp_editor_file_type_selected() == "SEFile")
        return 1;
    else
        return 0;
}
 
int
activeOoCodeGen()
{
    string ed_type = stp_editor_file_type_selected();
 
    if (ed_type == "OMTObjectModelFiles" ||
        ed_type == "BoochClassFiles")
        return 1;
    else
        return 0;
}
 
int
activeOoSubsysCodeGen()
{
    if (stp_editor_file_type_selected() == "OMTSubsystemObjects")
        return 1;
    else
        return 0;
}
 
int
activeOoCatCodeGen()
{
    if (stp_editor_file_type_selected() == "BoochCategoryObjects")
        return 1;
    else
        return 0;
}
 
int
activeOoClassCodeGen()
{
    if (stp_editor_file_type_selected() == "OOClassObjects")
        return 1;
    else
        return 0;
}

int
activeImSqlCodeGen()
{
    string ed_type = stp_editor_file_type_selected();

    if (ed_type == "Bachman" || 
        ed_type == "Chen")
        return 1;
    else
        return 0;
}

int
active_whole_model_semantic_check_diagram()
{
  string ed_type = stp_editor_file_type_selected();

  if (ed_type == "UmlClassDiagramFiles")
      return stp_is_in_object_menu("CheckUmlClassDiagramFileSemantics");
  else if (ed_type == "UmlUseCaseDiagramFiles")
      return stp_is_in_object_menu("CheckUmlUseCaseDiagramFileSemantics");
  else if (ed_type == "UmlSequenceDiagramFiles")
      return stp_is_in_object_menu("CheckUmlSequenceDiagramFileSemantics");
  else if (ed_type == "UmlCollaborationDiagramFiles")
      return stp_is_in_object_menu("CheckUmlCollaborationDiagramFileSemantics");
  else if (ed_type == "UmlStereotypeDiagramFiles")
      return stp_is_in_object_menu("CheckUmlStereotypeDiagramFileSemantics");
  else if (ed_type == "UmlActivityDiagramFiles")
      return stp_is_in_object_menu("CheckUmlActivityDiagramFileSemantics");
  else if (ed_type == "UmlStateDiagramFiles")
      return stp_is_in_object_menu("CheckUmlStateDiagramFileSemantics");
  else if (ed_type == "UmlDeploymentDiagramFiles")
      return stp_is_in_object_menu("CheckUmlDeploymentDiagramFileSemantics");
  else if (ed_type == "UmlComponentDiagramFiles")
      return stp_is_in_object_menu("CheckUmlComponentDiagramFileSemantics");
  else
      return 0;
}

int
active_diagram_or_table_class_selected()
{

    if (diagram_or_table_class_selected())
        return 1;

    return 0;
}


// ECR 6125 begin
list nullList = list_create("string", 0);

int ServerTypeValueChanged_cb(ui_event_tp event, ui_prop theprop, int id, string value)
{
    ui_prop server_name_prop = to_ui_prop(to_ui_owner(theprop), "server_name");
    list lServerLabels, lServerValues;
    if ("0" == value)
    {
        // ECR 6755(6)
        string sServerNames = repos_server_names("Sybase");
        if("" == sServerNames)
            return 0;
        lServerLabels = string_to_list(sServerNames, "|");
        list_insert(lServerLabels, 0, "Default Sybase Server");
        lServerValues = string_to_list(sServerNames, "|");
        list_insert(lServerValues, 0, "Default_Sybase_Server");
        ui_init_abbr_menu(server_name_prop, lServerLabels, lServerValues, nullList);
        ui_activate(server_name_prop, True);
    }
    else
    {
        lServerLabels = string_to_list("                     |Default_Sybase_Server", "|");
        ui_init_abbr_menu(server_name_prop, lServerLabels, lServerLabels, nullList);
        ui_activate(server_name_prop, False);
    }
    return 0;
}

int ServerNameActivated_cb(ui_event_tp event, ui_prop theprop, int id, string value)
{
    list lServerLabels, lServerValues;
    if(0 == ui_get_value(to_ui_prop(to_ui_owner(theprop), "server_type")))
    {
        // ECR 6755(6)
        string sServerNames = repos_server_names("Sybase");
        if("" == sServerNames)
            return 0;
        lServerLabels = string_to_list(sServerNames, "|");
        list_insert(lServerLabels, 0, "Default Sybase Server");
        lServerValues = string_to_list(sServerNames, "|");
        list_insert(lServerValues, 0, "Default_Sybase_Server");
        ui_init_abbr_menu(theprop, lServerLabels, lServerValues, nullList);
    }
    else
    {
        lServerLabels = string_to_list("                     |Default_Sybase_Server", "|");
        ui_init_abbr_menu(theprop, lServerLabels, lServerLabels, nullList);
    }
    return 0;
}

int SybaseServerNameActivated_cb(ui_event_tp event, ui_prop theprop, int id, string value)
{
    // ECR 6755(6)
    string sServerNames = repos_server_names("Sybase");
    if("" == sServerNames)
        return 0;
    list lServerLabels = string_to_list(sServerNames, "|");
    list lServerValues = string_to_list(sServerNames, "|");
    list_insert(lServerLabels, 0, "Default Sybase Server");
    list_insert(lServerValues, 0, "Default_Sybase_Server");
    ui_init_abbr_menu(theprop, lServerLabels, lServerValues, nullList);
    return 0;
}
// ECR 6125 end


// call back to activate 'fast' check box for sybase systems only
int
rec_proj_sys_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop prop;
    string dir;
    string sys;
    string filename;
    list file_contents;

    if ((prop = to_ui_prop("RepBuild", "projdir")) == NULL)
	return 0;
    dir = ui_text_value(prop);
    if ((prop = to_ui_prop("RepBuild", "system_name")) == NULL)
	return 0;
    sys = ui_text_value(prop);

    if ((prop = to_ui_prop("RepBuild", "scripts_fast")) == NULL)
	return 0;
    filename = dir + "/" + sys + "/.repinfo";

    if ((!file_exists(filename)) || (!read_file_access(filename)))
	return 0;
    file_contents = string_to_list( read_file(filename), "\n");
    if (list_find( file_contents, 0 ,"repositoryType=MS Jet" ) ==
        list_count( file_contents ))
        ui_activate(prop, True);
    else
        ui_activate(prop, False);

    return 0;
}

// Begin change ECR 3651
int
stp_rep_build_cmd(string rep_proj_sys, string opt)
{
// ECR#5618a {{
	rep_proj_sys = string_strip( rep_proj_sys, "T", "\\/" );
// }} ECR#5618a

    string rep_proj = path_part( rep_proj_sys );
    string rep_sys = file_part( rep_proj_sys );
    // End Change ECR 3651
    string cmd = " -C \"sys_recover_rep(\\\"${rep_proj}\\\", \\\"${rep_sys}\\\"";

    path_convert_to_right_slash(rep_proj);
    path_convert_to_right_slash(rep_sys);

	list build_args = string_to_list(opt, ",");
    int i;
    for (i=0; i < list_count(build_args); i++)
    {
        cmd += ",";
        cmd += list_get(build_args, i);
    }
    if (list_count(build_args) == 1)
        cmd += ",False";

    cmd += ")\"";

    return system("qrp" + forward_messages_arg() + projdir_system_args() + cmd);
}

boolean
stp_sys_has_rep(string rep_proj_sys)
{
    string rep_proj = path_part( rep_proj_sys );
    string rep_sys = file_part( rep_proj_sys );
    
    sys_has_rep( rep_proj, rep_sys );
    return True;
}
// End ECR 3651


int
do_nothing()

{
    return 0;
}

// ECR 3651
int select_proj_sys_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str;

    ui_owner uiOwner = to_ui_owner(theprop);
    str = ui_get_value(to_ui_prop(uiOwner, "projdir_system"));

    str = editor_show_dirchooser("Select System Directory", str);

    if (str != NULL && string_length(str) != 0)
    {
        str = path_normalize(str);
        ui_set_value(to_ui_prop(uiOwner, "projdir_system"), str);
    }

    return 0;
}

int select_output_dir_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str;

    ui_owner uiOwner = to_ui_owner(theprop);
    str = ui_get_value(to_ui_prop(uiOwner, "output_dir"));

    str = editor_show_dirchooser("Select Output Directory", str);

    if (str != NULL && string_length(str) != 0)
    {
        str = path_normalize(str);
        ui_set_value(to_ui_prop(uiOwner, "output_dir"), str);
    }

    return 0;
}

int select_output_dir_se_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str;

    ui_owner uiOwner = to_ui_owner(theprop);
    str = ui_get_value(to_ui_prop(uiOwner, "file_directory"));

    str = editor_show_dirchooser("Select Output Directory", str);

    if (str != NULL && string_length(str) != 0)
    {
        str = path_normalize(str);
        ui_set_value(to_ui_prop(uiOwner, "file_directory"), str);
    }

    return 0;
}

int select_dumpdir_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str;
    string def_dump_dir = path_compose( current_projdir(), current_system(), "dump" );
    ui_owner uiOwner = to_ui_owner(theprop);

    if( ! file_exists( def_dump_dir ) )
    {
        // try to create it
        if( mkdir( def_dump_dir ) == -1 )
            def_dump_dir = path_part( def_dump_dir );
    }
    
    str = editor_show_dirchooser("Select Dump Directory", def_dump_dir);

    if (str != NULL && string_length(str) != 0)
    {
        str = path_normalize(str);
        ui_set_value(to_ui_prop(uiOwner, "dump_dir"), str);
    }

    return 0;
}
// ECR 3651

// ECR 3688 begin
int select_stp_system_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str = current_projdir();
    ui_owner uiOwner = to_ui_owner(theprop);

    str = editor_show_systemchooser("Choose Target System", str);
    if (str != NULL && string_length(str) != 0)
    {
        ui_set_value(to_ui_prop(uiOwner, "to_proj_sys"), str);
    }

    return 0;
}
// ECR 3688 end

// ECR4244 begin add new function copy_files
// function to copy the selected file(s) 
// As long as the stputil copy command can handle only one file,
// we have to handle bulk copy here 
int copy_files(string editorType, string filesToCopy,
               string withAnnotations, string force, 
               string targetProjectSys, string newName)
{
    boolean isOk = True;

    file     copyFile;

    int      fcnt, fx;

    list     copyList;

    string   copyCommand,
             fileName,
             targetProject,
             targetSystem,
             targetName,
             targetPath;

    print_message( "Starting diagram copy." );

    // make sure we have something to copy
    if (string_length(filesToCopy) < 1)
    {
       print_error("No file(s) to copy !");
       return 1;
    }

    // convert the file string to a list
    copyList = list_create("string", 0);
    copyList = string_to_list(filesToCopy, " ");
    fcnt     = list_count(copyList);

    // check correctness:
    // - if no project/system is given, we are copying within the
    //   same system. 
    //   -> Only one file may be selected
    //   -> We need a new file name
    // - if a project/system is given
    //   -> the target system must exist !!!
    //   - if one file is selected
    //     -> we may use a new name
    //   - else (more than one file is selected
    //     -> we may not use a new name, but have to copy the files with
    //        their original name

    if (targetProjectSys == "")
    {
       // we are copying within our current system
       targetProject = current_projdir();
       targetSystem  = current_system();

       // more than one file selected ?
       if (fcnt > 1)
       {
          print_error("You can copy only one file within the same system !" );
          isOk = False;
       }

       // new file name given ?
       if (newName == "")
       {
          print_error("You must enter a new name to copy this file within the same system !" );
          isOk = False;
       }
    }
    else
    {
       // if value is empty, use the current project/system name
       targetProject = path_part( targetProjectSys );
       targetSystem  = file_part( targetProjectSys );

       // is the target system a valid stp system ?
       if (!sys_has_rep(targetProject, targetSystem))
       {
          print_error("Your target system <" + targetProject + ":" + targetSystem + "> is not a valid StP system !" );
          isOk = False;
       }

       // more than one file selected but a new file name given
       if ((fcnt > 1) && (newName != ""))
       {
          print_error("You must select only one file if you want to give the copy a new name !" );
          isOk = False;
       }
    }

    if (!isOk)
    {
       list_clear(copyList);
       return 1;
    }

    copyCommand = "stputil -forward_messages " + editor_get_msgd_handle()
                + " -p " + current_projdir() + " -s " + current_system()
                + " -Quiet " + force 
                + " -C \"copy -e " + editorType + " " + withAnnotations + " ";
    targetPath  = " " + targetProject + ":" + targetSystem + ":";

    for (fx = 0; fx < fcnt; fx++)
    {
        fileName = list_get(copyList, fx);

        if   ((fcnt == 1) && (newName != ""))
             targetName = targetPath + newName;
        else targetName = targetPath + fileName;

        print_message("Copying " + fileName + " to " + targetName + " ...");

        system(copyCommand + fileName + targetName + "\"");
    }

    list_clear(copyList);

    print_message( "Finished diagram copy." );
    return 0;
}
// ECR4244 end add new function copy_files

// ECR 3651a begin
int select_old_projdir_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str;

    ui_owner uiOwner = to_ui_owner(theprop);
    str = ui_get_value(to_ui_prop(uiOwner, "old_projdir"));

    str = editor_show_dirchooser("Select Old Project Directory", str);

    if (str != NULL && string_length(str) != 0)
    {
        str = path_normalize(str);
        ui_set_value(to_ui_prop(uiOwner, "old_projdir"), str);
    }

    return 0;
}

int select_new_projdir_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str;

    ui_owner uiOwner = to_ui_owner(theprop);
    str = ui_get_value(to_ui_prop(uiOwner, "new_projdir"));

    str = editor_show_dirchooser("Select New Project Directory", str);

    if (str != NULL && string_length(str) != 0)
    {
        str = path_normalize(str);
        ui_set_value(to_ui_prop(uiOwner, "new_projdir"), str);
    }

    return 0;
}
// ECR 3651a end

//ECR 5110 begin
int edit_menu_active_func()
{
    if (stp_is_command_enabled("EditDiagram") ||
        stp_is_command_enabled("EditTable") || 
        stp_is_command_enabled("TableTypeEditTable"))
    {
        return 1;
    }
    return 0;
}

int print_menu_active_func()
{
    if (stp_is_command_enabled("PrintDiagram") ||
        stp_is_command_enabled("PrintTable") || 
        stp_is_command_enabled("TableTypePrintTable"))
    {
        return 1;
    }
    return 0;
}

int print_as_menu_active_func()
{
    if (stp_is_command_enabled("PrintDiagramAs") ||
        stp_is_command_enabled("PrintTableAs") || 
        stp_is_command_enabled("TableTypePrintTableAs"))
    {
        return 1;
    }
    return 0;
}

int copy_menu_active_func()
{
    if (stp_is_command_enabled("Copy") ||
        stp_is_command_enabled("TableTypeCopy"))
    {
        return 1;
    }
    return 0;
}

int delete_menu_active_func()
{
    if (stp_is_command_enabled("Delete") ||
        stp_is_command_enabled("TableTypeDelete"))
    {
        return 1;
    }
    return 0;
}

int rename_menu_active_func()
{
    if (stp_is_command_enabled("Rename") ||
        stp_is_command_enabled("TableTypeRename"))
    {
        return 1;
    }
    return 0;
}
//ECR 5110 end

// ECR 5449 begin
int new_editor_active_func()
{
    if (stp_is_class_command_enabled("StartDiagramEditor") ||
        stp_is_class_command_enabled("StartTableEditor") ||
        stp_is_class_command_enabled("StartTableTypeEditor") ||
        stp_is_class_command_enabled("StartGUI"))
    {
        return 1;
    }
    return 0;
    
}
// ECR 5449 end

// ECR 6211 begin
int sys_load_rep_ex(string projdir, string system, string dump_dir, boolean scripts_fast, string bool_scripts_load_user_info)
{
	if (bool_scripts_load_user_info == "True")
		return sys_load_rep(projdir, system, dump_dir, False, scripts_fast, True);
	else
		return sys_load_rep(projdir, system, dump_dir, False, scripts_fast, False);
}

// ECR 6211 end

// Begin Add ECR 7612
boolean codegen_active( string ti_var )
{
    string val = toolinfo_variable( ti_var );
    if( val != NULL )
    {
        if( to_lower( val ) == "true" )
            return True;
    }
    return False;
}
// End Add ECR 7612

#include "ct/rules/qrl/baseline.qrl"

// ECR 4052
#include "uml/rules/qrl/stp_model_management.inc"

// ECR 2602 (changed location for ECR 4731)
#include_if_exists "rules/qrl/trees.qrl"

// ECR 6320 - ReportMaker
#include "rules/qrl/rme_common.inc"

//  Add any user customizations to the file included below:
#include_if_exists "user/ct/rules/qrl/user_stp_desktop.qrl"

// ECR 7389
#include "rules/qrl/toolinfo_edit.qrl"
