//////////////////////////////////////////////////////////////////////////////
//
// 	sccsid[] = %W% %Y% %D%
// 	StP/Core
// 	Confidential property of Interactive Development Environments, Inc.
// 	Copyright (c) 1992-1994
// 	All rights reserved
//
//////////////////////////////////////////////////////////////////////////////

#include "ct/rules/qrl/version.inc"
#include "ct/rules/qrl/commands.inc"

void
FileLoad(string filename)
{
    node            node;
    link            link;
    cntx            cntx;
    file            file;

    filename = to_oms_string(filename);

    node = find_by_query("node[annot_file[name='${filename}']]");

    if (node != NULL)
    {
	node            object = node;
    } else
    {
	link = find_by_query("link[annot_file[name='${filename}']]");

	if (link != NULL)
	{
	    link            object = link;
	} else
	{
	    cntx = find_by_query("cntx[annot_file[name='${filename}']]");

	    if (cntx != NULL)
	    {
		cntx            object = cntx;
	    } else
	    {
		file = find_by_query("file[annot_file[name='${filename}']]");

		if (file != NULL)
		{
		    file            object = file;
		} else
		{
		    string object = NULL;
		}
	    }
	}
    }
    if (object != NULL)
    {
	editor_builtin("AnnotEdit " + object.id);
    }
    return;
}

void
LoadByNameType(string name, string app_type, string pdm_type)
{
    if (pdm_type == "node")
    {
	node            object;
    } else if (pdm_type == "link")
    {
	link            object;
    } else if (pdm_type == "cntx")
    {
	cntx            object;
    } else if (pdm_type == "file")
    {
	file            object;
    } else
    {
	return;
    }
    name = to_oms_string(name);
    object = find_by_query("${pdm_type}[${app_type} & name='${name}']");

    if (object != NULL)
    {
	editor_send_msg("oae", "AnnotEdit " + object.id, -2);
    }
    return;
}

// for se migration
// 3/28/96  Migrates pdl's also

void
MigratePspecs()
{
    list l;
    int desclen, realdesc, endrealdesc, i, handle, alen;
    string newdesc;
    oae_note oae_n;
    note pspecnote;
 
    // if we find a string like  description
    //                           ...
    //                           end pspec
    // (end module for pdl's)
    // cut out everything but the stuff inbetween.

    l = list_select("note[Pspec]");

    for (i = 0; i < list_count(l); i++)
    {
        pspecnote = list_get(l, i);

        if (pspecnote.desc != NULL && pspecnote.desc != "")
        {
            desclen = string_length(pspecnote.desc);
 
            realdesc = string_find(pspecnote.desc, 0, "\ndescription\n");
 
            if (realdesc != desclen)
            {
                endrealdesc = string_find(pspecnote.desc, realdesc, "\nend pspec");
                if (endrealdesc != desclen)
                {
		    alen = endrealdesc - realdesc - 13;
		    if (alen <= 0 || alen >= desclen)
			continue;

                    newdesc = string_extract(pspecnote.desc, realdesc + 13, alen);

                    // resave the description
		    editor_builtin("AnnotEdit " + pspecnote.obj_id);
		    editor_builtin("NoteSelect Pspec");
                    oae_n = oae_selected_note();
                    oae_note_set_description(oae_n, newdesc);
		    editor_builtin("FileSave");
        		    editor_builtin("AnnotUnload");
                }
            }
        }
    }
 
    // pdl now.
    l = list_select("note[modulePDL]");

    for (i = 0; i < list_count(l); i++)
    {
        pspecnote = list_get(l, i);

        if (pspecnote.desc != NULL && pspecnote.desc != "")
        {
            desclen = string_length(pspecnote.desc);
 
            realdesc = string_find(pspecnote.desc, 0, "\ndescription\n");
 
            if (realdesc != desclen)
            {
                endrealdesc = string_find(pspecnote.desc, realdesc, "\nend module");
                if (endrealdesc != desclen)
                {
		    alen = endrealdesc - realdesc - 13;
		    if (alen <= 0 || alen >= desclen)
			continue;

                    newdesc = string_extract(pspecnote.desc, realdesc + 13, alen);

                    // resave the description
		    editor_builtin("AnnotEdit " + pspecnote.obj_id);
		    editor_builtin("NoteSelect modulePDL");
                    oae_n = oae_selected_note();
                    oae_note_set_description(oae_n, newdesc);
		    editor_builtin("FileSave");
		    editor_builtin("AnnotUnload");
                }
            }
        }
    }
    return;
}

boolean
buffer_is_modified()
{
    return(oae_is_modified());
}

boolean
FileSaveAndCommit(boolean notused)
{
    if (editor_builtin("FileSave"))
	return(False);

    return(True);
}

// file printing

const string C_QRP = "qrp -p ${projdir} -s ${system} -t rtf -o ${outfile} -x objects '${objid}' ct/qrl/basic/annotation.qrl";

void
FilePrint()
{
    subproc_tp   proc;
    int		 objid = oae_object_id();
    string       outfile = path_compose(current_projdir(), current_system(),
                           file_filestore("ObjectAnnotation"), 
                           oae_filename());
    // ECR 6936 start
    if (is_unix_platform()) {
        print_message("Printing Annotation..."); 
        system( "qrp -p "+ current_projdir()  +" -s " +  current_system() + " -t ascii -o " + outfile + " -x objects '"+ objid +"' ct/qrl/basic/annotation.qrl; " +
                "echo \"/^$/d\"> "+outfile+".sed; echo \"/^.*- [0123456789] -.*$/d\">> "+ outfile +".sed; echo \"s/^.*$/(&)/g\" >> "+outfile+".sed; " +
                "sed -f " + outfile + ".sed < " + outfile + " > " + outfile + ".tmp");

        string PSOut = read_file(path_compose(stp_get_product_path(), "templates/ct/print_format/level2tmpl.ps"));
        string Annotation = read_file(outfile + ".tmp");
        PSOut += "/Annotattion [\n" + Annotation + "\n] def\n";
        PSOut += "/Ls 1	def\n" +
                 "/AFont /Courier findfont 12.000000 scalefont def\n" +
                 "/Fg [0] def\n" +
                 "/PageDict <<\n" +
 	                "\t/PageHeight\t" +     "792\n"  +
 	                "\t/PageWidth\t"  +     "612\n"  +
         	        "\t/Ml 36 /Mr 36 /Mu 36 /Mb 36\n"  +
 	                "\t/isLandscape\t"  +   "false\n"  +
 	                "\t/CaptionLabel\t" +   "(" + oae_filename() + ", page #p of #P)\n"  +
 	                "\t/CFont\t" +          "AFont\n" +
 	                "\t/CAx\t"   +          "2\n" +
 	                "\t/CAy\t"   +          "1\n" +
                ">> def\n";
        PSOut += read_file(path_compose(stp_get_product_path(), "templates/ct/print_format/oaeps001.ps"));
        string psfile = outfile + ".ps";
        write_file(psfile, PSOut);

        string PRINTER = environment_variable("PRINTER");
        if (PRINTER==NULL || PRINTER=="") {
                PRINTER = environment_variable("LPDEST");
        }
        
        if (PRINTER==NULL || PRINTER=="") {
                print_error("Print Failed - No default printer found. " +
                            "The output is written to " + psfile + " file instead. " +
                            "Please check PRINTER or LPDEST environment variables.");
        } else {
                string print_cmd = toolinfo_variable("stp_ps_print");
                if (print_cmd == NULL || print_cmd == "") {
                        print_cmd = "lpr -r -P" + PRINTER + " " + psfile + " @";
                }
                put_environment_variable("psprinter=" + PRINTER);
                put_environment_variable("psfile=" + psfile);
                system(print_cmd);
                system("rm -f " + psfile);
                print_message("Print Completed.");
        }
        system("rm -f "+outfile+".tmp "+outfile+".sed "+outfile);
    } else {
        outfile = outfile + ".rtf";
        print_message("Printing Annotation...");
        proc.pid = editor_system(C_QRP, "printDoneProc");
        proc.success_msg = "Print Completed.";
        proc.failure_msg = "Print Failed.";
		proc.tmpfile = outfile;
        proc.outfile = NULL;
        proc.client_data = outfile;
        list_append(subProcs, proc);
    }    
    // ECR 6936 end
}

int
printDoneProc(int pid, int status)
{
    subproc_tp  proc = subProc(pid);

    if (status == 0)
    {
	print_message("Print Preview...");

	// SPR 2267 - oae printing fix
	oae_print(proc.client_data);
    }
    return(doneProc(pid, status));
}

// called during SE synchronization - sends a reply message to confirm
// that updates have been completed
//
void
SEREReply( int reply_handle, boolean ok )
{
    if ( ok )
      editor_send_msg( "SESynchronize", "OK", reply_handle );
    else
      editor_send_msg( "SESynchronize", "FAILED", reply_handle );
}

// SPR 4052 Model Management
void
setNoteAndItem( int id, string note, string item, string value, boolean refreshTree )
{
    editor_builtin(OAE_CMD_ANNOT_EDIT + id );
    if(note != "") {
        editor_builtin(OAE_CMD_NOTE_SEL + note );
        if(item != "") {
            editor_builtin(OAE_CMD_ITEM_SEL + item );
            // ECR 4969 start
            if(value != "")
                editor_builtin(OAE_CMD_ITEM_SETVAL + value );
            else
                editor_builtin(OAE_CMD_ITEM_DEL);
            // ECR 4969 end
        }
    }
    editor_builtin(OAE_CMD_FILE_SAVE );
    editor_builtin(OAE_CMD_ANNOT_UNLOAD );
    // ECR 5009
    if(refreshTree == True)
        editor_send_msg("stp", "EditorQrlEval stp_refresh_trees();", -1);
}

void
removeNote( int id, string note, boolean refreshTree )
{
    editor_builtin(OAE_CMD_ANNOT_EDIT + id );
    if(note != "") {
        editor_builtin(OAE_CMD_NOTE_SEL + note );
        editor_builtin("NoteRemove " + note );
    }
    editor_builtin(OAE_CMD_FILE_SAVE );
    editor_builtin(OAE_CMD_ANNOT_UNLOAD );
    // ECR 5009
    if(refreshTree == True)
        editor_send_msg("stp", "EditorQrlEval stp_refresh_trees();", -1);
}

#include "rules/qrl/oo_oae_funcs.inc"
#include "rules/qrl/uml_oae_funcs.inc"

// ECR 3789 begin
boolean debug_set_annot_values = False;

// This is the same as SetAnnotValuesFromFile but it works on the object currently
// being annotated and does not quit after processing. This is very useful for 
// working on items in batch in between of normal message processing so we can
// e.g. intersperse the standard ps.inc processing by this.
//

int 
SetAnnotValuesFromFilesIntegrated( string master_file ) 
{
  string desc_str, line, oms_id, note_type, note_id, item_type, value, value_str;
  oae_note oae_n;
  int i, c1, c2, c3, c4;
  int debug = 1;
  
  if( debug_set_annot_values ) {
    message( "NGOAE: Reading " + master_file );
  }

  list annots = string_to_list( read_file( master_file ), "\n" );

  for( i=0; i<list_count( annots ); i++ ) {

    // extract the individual elements from the master file
    // Note that oms_id is ignored for this version of the routine (integrated),
    // but kept in the file for compatibilty with the other version so they
    // can be exchanged
    // <oms_id>:<note_type>:<note_name>:<item_type>:<value or description file>
    // fields to be ignored (i.e note_name) should be set to the string NULL
    //
    line = list_get( annots, i );
    c1 = string_find( line, 0, ":" );
    c2 = string_find( line, c1+1, ":" );
    c3 = string_find( line, c2+1, ":" );
    c4 = string_find( line, c3+1, ":" );
    oms_id = string_extract( line, 0, c1 );
    note_type = string_extract( line, c1+1, c2-(c1+1) );
    note_id = string_extract( line, c2+1, c3-(c2+1) );
    item_type = string_extract( line, c3+1, c4-(c3+1) );

    if( string_length( line ) > (c4+1) ) {
      // there's something after the last :
      value = string_extract( line, c4+1, string_length( line ) - (c4+1) );
    } else {
      // this means we are going to delete that item !!
      value = "";
    }

    // if this is an item to be set we get the value directly from the master file
    // if not we read it from the associated description file
    // We have to make a distinction in case of the removal indicator
    // "----", otherwise the code would try to read a file by the
    // name of "NULL"
    //
    if( item_type == "NULL" && note_id != "----") {
      if( debug_set_annot_values ) {
		 message( "NGOAE: Setting " + note_type + " description for " + oms_id + " from " + value );
      }
      value_str = read_file( value );
    } else {
      value_str = value;
      if( debug_set_annot_values ) {
 			message( "NGOAE: Setting " + note_type + ":" + item_type + " value for " + oms_id +
   " to " + value_str );
      }
    }

    // load the annotation and select the note
    // Commentet out for the integrated version editor_builtin( OAE_CMD_ANNOT_EDIT + oms_id );

	//               We have to treat the new "removal indicator" like we 
	// 				 treat the NULL string, otherwise the code would look
	//				 for a note named "----", which is not what we want here
	//
      if( note_id == "NULL" || note_id == "----") 
      {
      	editor_builtin( OAE_CMD_NOTE_SEL + note_type );
         
      } 
      else 
      {
	    editor_builtin( OAE_CMD_NOTE_SEL + note_type + ":" + note_id );
      }

    oae_n = oae_selected_note();

	//               We need to be able to delete an entire note from
	//				 user_ps.inc for ps_FKCombination (though this might
	//				 be useful for other applications as well. We use the
	//				 NoteName field for notifying us to delete a field
	//
	if( note_id == "----" )
	{
		editor_builtin( "EditorDelete" );
	}
    // either set the note description or the item value
    else if( item_type == "NULL" ) 
    {
      oae_note_set_description( oae_n, value_str );
    } 
    // 000301-01 AG: We need to be able to use the ADD mechanism to allow
    //				 for items with multiplicity > 1. We do this, by allowing
    //				 an "+" sign in front of the item_type as indication
    //
    else if( "+" == string_extract( item_type, 0, 1 ) )
    {
    	item_type = string_search_and_replace( item_type, "+", "" );
    	editor_builtin( OAE_CMD_ITEM_ADD + item_type );
    	editor_builtin( OAE_CMD_ITEM_SETVAL + "\""+ value_str +"\"" );
	}
	else
    {
      editor_builtin( OAE_CMD_ITEM_SEL + item_type );
      if( value_str != "" ) 
      {
 		editor_builtin( OAE_CMD_ITEM_SETVAL + "\""+ value_str +"\"" );
      } 
      else 
      {
 		editor_builtin( OAE_CMD_ITEM_DEL );
      }
    }

    // save
	// Saving and unloading has been removed for the integrated version

}

 
//  append_file( "c:/temp/annotfix.bench", time_to_string( time_now( ), NULL) );
  return( 1 );

}

//
//            Introduced variable to remember last obj_id so we do load/save
//			  only when necessary
//
//
int SetAnnotValuesFromFiles( string master_file ) {
  string desc_str, line, oms_id, note_type, note_id, item_type, value, value_str;
  oae_note oae_n;
  int i, c1, c2, c3, c4;
  int debug = 1;
  int last_objid = 0;


  if( debug_set_annot_values ) {
    message( "NGOAE: Reading " + master_file );
  }

  list annots = string_to_list( read_file( master_file ), "\n" );

  for( i=0; i<list_count( annots ); i++ ) 
  {

    // extract the individual elements from the master file
    // <oms_id>:<note_type>:<note_name>:<item_type>:<value or description file>
    line = list_get( annots, i );
    c1 = string_find( line, 0, ":" );
    c2 = string_find( line, c1+1, ":" );
    c3 = string_find( line, c2+1, ":" );
    c4 = string_find( line, c3+1, ":" );
    oms_id = string_extract( line, 0, c1 );
    note_type = string_extract( line, c1+1, c2-(c1+1) );
    note_id = string_extract( line, c2+1, c3-(c2+1) );
    item_type = string_extract( line, c3+1, c4-(c3+1) );
    if( string_length( line ) > (c4+1) ) 
    {
      // there's something after the last :
      value = string_extract( line, c4+1, string_length( line ) - (c4+1) );
    } 
    else 
    {
      // this means we are going to delete that item !!
      value = "";
    }

    // if this is an item to be set we get the value directly from the master file
    // if not we read it from the associated description file
    if( item_type == "NULL" ) 
    {
      if( debug_set_annot_values ) {
 			message( "NGOAE: Setting " + note_type + " description for " + oms_id + " from " + value );
      }
      //            Allow inlining of NoteDescription text by specifiying a tag "<<Description>>"
      // 			Then, from the next line on, everything is read until a <<END-DESCRIPTION>>
      //			übernehmen
      if( value != "<<DESCRIPTION>>" )
      {
      	value_str = read_file( value );
      }
      else
      {
      	value_str = "";
      	for( i = i +1; i<list_count(annots); i++ )
      	{
      		value_str = value_str + list_get( annots , i );
      		if( string_find( list_get( annots, i ), 0 ,"<<END-DESCRIPTION>>" ) <
      			string_length( list_get( annots, i ) ) )
      		{
      			break;
      		}
      		else
      			value_str = value_str +"\n" ;
      	}
      }
    } 
    else 
    {
      value_str = value;
      if( debug_set_annot_values ) 
      {
 			message( "NGOAE: Setting " + note_type + ":" + item_type + " value for " + oms_id +
   " to " + value_str );
      }
    }
    

	// Check to see if the object on the last line in the control field
	// differs from the current object. If yes, we need to save the
	// object, because it is a new one now
	//
    if( last_objid != to_int(oms_id) )
    {
    	// If last_obj == 0, we have the first line and thus there is
    	// no need to save the current note (in fact, there is none)
    	//
    	if( last_objid != 0 )
    	{
    		// save if necessary
		    editor_builtin( OAE_CMD_FILE_SAVE );
		    editor_builtin( OAE_CMD_ANNOT_UNLOAD );

    	}
    
    	// Now load the note from the current line and set last_objid
    	//
    	editor_builtin( OAE_CMD_ANNOT_EDIT + oms_id );
    	last_objid = to_int(oms_id);
	}
		
    if( note_id == "NULL" ) 
    {
       	editor_builtin( OAE_CMD_NOTE_SEL + note_type );
    } else 
    {
		editor_builtin( OAE_CMD_NOTE_SEL + note_type + ":" + note_id );
	}


    oae_n = oae_selected_note();

    // either set the note description or the item value
    if( item_type == "NULL" ) 
    {
      oae_note_set_description( oae_n, value_str );
    } else 
    {
    	editor_builtin( OAE_CMD_ITEM_SEL + item_type );
      	if( value_str != "" ) 
      	{
 			editor_builtin( OAE_CMD_ITEM_SETVAL + "\""+ value_str +"\"" );
      	} else 
      	{
 			editor_builtin( OAE_CMD_ITEM_DEL );
      	}
    }


  }
  // need to save the last annotation, because it is not saved by the
  // annotation loading mechanism above (it does not have a next line,
  // that's why )
  //
  editor_builtin( OAE_CMD_FILE_SAVE );
  editor_builtin( OAE_CMD_ANNOT_UNLOAD );

  return( 1 );
}


// clean up temporary annotation files
int CleanAnnotTmpFiles( string master_file ) {
  string line, oms_id, note_type, note_id, item_type, value;
  int i, c1, c2, c3, c4;
  list annots = string_to_list( read_file( master_file ), "\n" );
  int debug = 0;

  for( i=0; i<list_count( annots ); i++ ) {

    // extract the individual elements from the master file
    // <oms_id>:<note_type>:<item_type>:<value or description file>
    line = list_get( annots, i );
    c1 = string_find( line, 0, ":" );
    c2 = string_find( line, c1+1, ":" );
    c3 = string_find( line, c2+1, ":" );
    c4 = string_find( line, c3+1, ":" );
    oms_id = string_extract( line, 0, c1 );
    note_type = string_extract( line, c1+1, c2-(c1+1) );
    note_id = string_extract( line, c2+1, c3-(c2+1) );
    item_type = string_extract( line, c3+1, c4-(c3+1) );
    if( string_length( line ) > (c4+1) ) {
      // there's something after the last :
      value = string_extract( line, c4+1, string_length( line ) - (c4+1) );
    } else {
      // this means we are going to delete that item !!
      value = "";
    }

    if( item_type == "NULL" ) {
      if( debug_set_annot_values )
 			message( "NGOAE: delete " + value );
      		delete_file( value );
    }

  }

  if( debug_set_annot_values )
    message( "NGOAE: delete " + master_file );
  		delete_file( master_file );

  // oae_builtin( "EditorQuit" );

  return( 1 );
}
// ECR 3789 end

//  Add any user customizations to the file included below:
#include_if_exists "user/ct/rules/qrl/user_oae.qrl"
