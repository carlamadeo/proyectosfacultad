#include "qrl/include/general.inc"

// this is needed by SE as the parser_sh can send a 'execute_chooser'
// message
#include "rules/qrl/file_chooser.qrl"

string VccSelectedFiles="";

string
VccBaselineInfoFile()
{
    return current_projdir() + current_system() + "/.vcc_info";
}


boolean
VccBaselineExists(string baselineTag)
{
    // JED - finish this
    return False;
}

boolean
VccIsValidBaselineTag(string baselineTag)
{
    // JED - finish this
    if (NULL != baselineTag && string_length(baselineTag) > 0)
        return True;
    return False;
}


int 
VccReset_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    ui_prop addlFiles = to_ui_prop(ui_owner_name(theprop),"VccAddlFiles");
    ui_list_clear(addlFiles);
    VccSelectedFiles="";
    return 0;
}


int 
VccInit_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    ui_prop addlFiles = to_ui_prop(ui_owner_name(theprop),"VccAddlFiles");
    int i;
    int ct;
    ui_list_item_tp item;

    if (NULL != addlFiles)
    {
        ui_list_clear(addlFiles);
        string s = read_file(VccBaselineInfoFile());
        VccSelectedFiles=s;
        if (NULL != s) {
            list l = string_to_list(s,"\n");
            ct = list_count(l);
            list l2;
            if ( False )
                // JED - disabled, but would result in icons in list
            {
                l2 = list_create("ui_list_item_tp",0);

                for (i=0; i<ct; i++)
                {
                    item.label = list_get(l, i);
                    if (read_dir_access(item.label))
                        item.image = DirImage;
                    else 
                        item.image = FileImage;    

                    list_append(l2, item);
                }
            }
            else
            {
                l2 = l;
            }
            ui_list_append(addlFiles,l2);
        }
    }
    else
        print_error("VccInit_cb: NULL addlFiles");

    return 0;
}

int
VccApply_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop baselineProp =  to_ui_prop("VccCreateBaseline","VccBaselineTag");
    string baselineTag = ui_text_value(baselineProp);

    string errMsg = "";

    if (VccBaselineExists(baselineTag))
        errMsg = "Error: Baseline '" + baselineTag + "' already exists.";

    if ("" == errMsg && !VccIsValidBaselineTag(baselineTag))
        errMsg = "Error: Invalid baseline tag '" + baselineTag + "'.";

    if ("" != errMsg)
    {
        print_error(errMsg);
        return -1;
    }

    if ("" == VccSelectedFiles)
    {
        delete_file(VccBaselineInfoFile());
        return 0;
    }

    write_file(VccBaselineInfoFile(),VccSelectedFiles);

    return 0;
}


int
VccSelectAdditional_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop_sheet_pop_up( "VccPickAddlFiles" );
    ui_prop src, dest;
    dest = to_ui_prop("VccPickAddlFiles","Files");
    src = to_ui_prop("VccCreateBaseline","VccAddlFiles");
    if (NULL == src || NULL == dest)
    {
        print_error("Unable to set properties.");
        return 0;
    }

    list l = ui_list_items(src);

    ui_list_clear(dest);
    if (NULL != l || list_count(l) > 0)
        ui_list_append(dest,l);
    return 0;
}

int
VccSetFiles_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop src, dest;

    src = to_ui_prop("VccPickAddlFiles","Files");
    dest = to_ui_prop("VccCreateBaseline","VccAddlFiles");
    if (NULL == src || NULL == dest)
    {
        print_error("Unable to set properties.");
        return 0;
    }

    list l = ui_list_items(src);

    ui_list_clear(dest);
    if (NULL != l || list_count(l) > 0)
        ui_list_append(dest,l);

    int ct = list_count(l);
    int i;
    ui_list_item_tp item;
    VccSelectedFiles="";

    for (i=0; i<ct; i++)
    {
        if (VccSelectedFiles != "")
            VccSelectedFiles += "\n";
        item = list_get(l,i);
        VccSelectedFiles += item.label;
    }
    return 1;
}

int
VccDirChooserFill_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop chooser_prop;
    string dir;
    int i;

    // JED - This hack is so the default callback won't be envoked
    file_chooser_skip_cb = True;

    chooser_prop = to_ui_prop(ui_owner_name(theprop),"ChooserDirectory");
    dir = ui_text_value(chooser_prop);

    if (str_no_val(dir))
    {
	print_error("A pattern or directory is required.");
	return 0;
    }

    string vccTop = current_projdir() + current_system() + "/";
    int len = string_length(vccTop);

    // restrict to system dir
    dir = expand_directory_filter(dir);
    if (string_length(dir) < len ||
            string_extract(dir,0,string_length(vccTop)) != vccTop)
        dir = vccTop;

    VccFillChooser(ui_owner_name(theprop),dir, False);

    // put the dir, which might be modified, in directory window
    ui_text_set_value(chooser_prop, dir);

    return 0;
}

// this list hold all the directories we exclude
list excludedFiles = NULL;
boolean excludeInit = False;

int 
VccFillChooser(string owner, string dir, boolean right_justify)
{
    ui_prop dir_prop;
    list dlist;
    int i, cnt;
    list l = list_create("ui_list_item_tp", 0);
    ui_list_item_tp item;

    if (!excludeInit)
    {
        excludeInit = True;

        excludedFiles = string_to_list(
            "ant_files ate_files bach_files backup br_files chen_files " +
            "class_files crud_files cse_files cte_files dete_files dfe_files " +
            "dme_files dmte_files dse_files fce_files filter_files fme_files " +
            "imtbr_files misc_files module_files object_files oite_files " +
            "ome_files omt_files ootbr_files otbr_files process_files " +
            "prs_files qrl_files revc_files rqtbl_files sce_files sebr_files " +
            "spe_files spt_files src_files stbl_files ste_files ted_files " +
            "test_files uactivityd_files uae_files ucde_files uclass_files " +
            "uclassd_files uclasst_files ucollaborationd_files " +
            "ucomponentd_files udeploymentd_files usde_files " +
            "usequenced_files ustated_files ustatet_files " +
            "ustereotyped_files uusecased_files"," ");
    }


    dir_prop = to_ui_prop(owner,"DirSelector");

    ui_footer_set_value(to_ui_prop("REParse", "Status"), "");
    ui_busy(to_ui_owner(dir_prop), True);
    dlist = get_dir_list(dir);
    if (dlist == NULL)
    {
        ui_busy(to_ui_owner(dir_prop), False);
        return 0;
    }

    ui_list_clear(dir_prop);

    string vccTop = current_projdir() + current_system() + "/";
    boolean doFilter = False;
    if (path_part(dir) == vccTop)
        doFilter = True;

    if (root_part(dir) != dir && !doFilter)
    {
        item.image = UpArrowImage;
        item.label = Parent;
        ui_list_append(dir_prop, item);
    }

    cnt = list_count(dlist);

    if (cnt > 0 && cnt < 1000)
        ui_footer_set_value(to_ui_prop(owner, "Status"), "Processing " + cnt + " items.");
    else if (cnt > 1000 && cnt < 5000)
        ui_footer_set_value(to_ui_prop(owner, "Status"), "Processing " + cnt + " items. This takes a few moments.");
    else
        ui_footer_set_value(to_ui_prop(owner, "Status"), "Processing " + cnt + " items. This can take several minutes.");

    for (i = 0; i < cnt; i++)
    {
        item.label = list_get(dlist, i);
        // skip files if we're filtering (if we're in system directory)
        if (doFilter && list_count(excludedFiles) !=
                list_find(excludedFiles,0,file_part(item.label)))
            continue;

        if (read_dir_access(item.label))
            item.image = DirImage;
        else
            if (doFilter)
                continue;  // only include directories from sys dir
            else
                item.image = FileImage;    

        list_append(l, item);
    }

    if (list_count(l) > 0)
        ui_list_append(dir_prop, l);

    if ( right_justify )
	ui_list_set_hscroll_pos( dir_prop, 200 );

    ui_busy(to_ui_owner(dir_prop), False);
    return 0;
}


int 
VccFileChooserDoubleClick_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop prop, chooser_prop;
    int row, i, indent = 0;
    string val;
    list l;
    boolean add_slash = False;

    file_chooser_skip_cb = True;

    prop = to_ui_prop(ui_owner_name(theprop),"DirSelector");
    chooser_prop = to_ui_prop(ui_owner_name(theprop),"ChooserDirectory");
    row = ui_list_selected_row(prop);

    if (row >= 0)
        val = ui_list_row_label(prop, row);        // LastValue does not work here
    else
        return 0;

    // JED - orig if (row == 0) //Parent Directory
    if (val == Parent) //Parent Directory
    {
        int orig_len = string_length( ui_text_value(chooser_prop) );
        if (ui_list_num_items(prop) > 1)
            val = ui_list_row_label(prop, 0);
        else
            val = ui_text_value(chooser_prop);

        if(path_part(val) == root_part(val))
            val = root_part(val);
        else
            val = parent_directory(parent_directory(val));
        indent = string_length( val ) - orig_len;
    }
    else
    {
        if (! read_dir_access(val))
        {
            print_message(val + " is not a directory.");
            return 0;
        }
        indent = string_length( val ) -
                 string_length( ui_text_value(chooser_prop));
    }

    val = expand_directory_filter(val);
    VccFillChooser(ui_owner_name(theprop),val, True);

    // put the dir in directory window
    ui_text_set_value(chooser_prop, val);
    return 0;

}
