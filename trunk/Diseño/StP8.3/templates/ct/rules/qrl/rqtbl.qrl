//
//      sccsid[] = @(#)rqtbl.qrl        5.55  95/08/11
//      StP/OO
//        StP Core
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1992-1995
//      All rights reserved
//

// general qrl utility functions
#include "rules/qrl/ct.inc"

// this comes from the core
#include "rules/qrl/gte_qrl_std.inc"

// gte specific functions
#include "rules/qrl/gte.inc"

// has functions to communicate with non graphical annotation editor
#include "ct/qrl/include/opt_displaymark.inc"

// routines to do allocations via annotations
#include "rules/qrl/requirement_allocation.inc"

// routines to facillate drag/drop functionality
#include "rules/qrl/drag_drop.inc"

// gor for requirements ...
#include "rules/qrl/rqtbl_object_rename.inc"

const string REQ_SUBSYSTEM_LABEL = "Subsystem:" ;
const string REQ_PARENT_SUBSYSTEM_LABEL = "Parent Subsystem:" ;

const string REQ_unique_id_terminus_TOOLINFO = "REQ_unique_id_terminus" ;
const string REQ_unique_id_terminus_DEFAULT = "\;" ;

REQ_PhaseType REQ_Phase = Analysis ;
string REQ_PhaseString = "Analysis" ;

ObjectInfoType REQ_ObjectInfo = NULL ;

node REQ_SatisfactionNode = NULL ;
link REQ_SatisfactionLink = NULL ;
cntx REQ_SatisfactionCntx = NULL ;
int REQ_SatisfactionId = 0 ;

string REQ_LinkOrNodeOrCntx = "node" ;

string REQ_AssignmentItem = REQ_ANALYSIS_ASSIGNMENT_ITEM ;

string REQ_CurrentSubsystem = "" ;

// A list of ints corresponding to rows.
int REQ_NextSatisfactionIndex = -1 ;
list REQ_reqs_satisfied_list ;
boolean REQ_reqs_satisfied_initialized = False ;

string copyBuffer = "";

void JED_Copy ()
{
  int row = gte_get_current_cell_row() ;
  int col = gte_get_current_cell_col() ;
  copyBuffer = gte_get_cell_label(row,col);
}
 
void JED_Paste ()
// Does a paste of a the string copyBuffer into the cell
// Switches the read-only state as necessary
// JED - The CurrentCellLabel() call uses a FillTable expression,
// which bypasses the normal checks
{
  // boolean isReadOnly = gte_get_current_cell_is_readonly();
  // int row = gte_get_current_cell_row() ;
  // int col = gte_get_current_cell_col() ;
  // if (isReadOnly) {
  //    CoordCellSetReadOnly(row, col, False);
  // }
  CurrentCellLabel(copyBuffer);
  // if (isReadOnly) {
  //    CoordCellSetReadOnly(row, col, True);
  // }
}

//// JED - debugging functions
//void JED_select(int r1, int c1, int r2, int c2, int r, int c)
//{
//  // print_warning("JED - selecting " + r1 + ", " + c1 + ", " + r2 + ", " + c2 + ", " + r + ", " + c);
//  gte_set_selection(r1,c1,r2,c2,r,c);
//}
//
//void JED_Span()
//{
//  // print_warning("JED - spanning");
//  gte_span();
//}
//
//void JED_Unspan()
//{
//  // print_warning("JED - unspanning");
//  gte_unspan();
//}

// ECR 6626 begin - commented
//void
//EditorStartupFunction ()
//{
//    gte_load_default_visibility();  // ECR 4072 
//}
// ECR 6626 end

void
EditorLoadFileCallback (string diag_name)
{
  REQ_SetSubsystem (diag_name) ;
}

void
REQ_LoadFunc ()
{
}

string
REQ_CurrentFileName (int hsect, int vsect, int row, int col)
{
  return (gte_substitute_string ("${file}")) ;
}

void
REQ_CleanFile ()
{
  string FileName = REQ_CurrentFileName (0,0,0,0) ;

  // To prevent verification message for nameless file.
  if (FileName != "")
    {
      SetSatisfactionLine ("") ;
      REQClearAllKnownMarks () ;
      ResetRequirementTitle() ;
      //gte_stpem ("FileSave") ;
    }
}

void
TableInitialize (int Id, string LinkOrNodeOrCntx, node Node, link Link, 
                 cntx Cntx, string Subsystem, string Phase)
{
  print_message ("") ;

  int goto_row ;
  int satisfaction_row = gte_get_first_row (REQ_SatisfactionHsect()) ;

  string Name ;
  string Type ;
  string FileName = REQ_CurrentFileName (0,0,0,0) ;


  if (Subsystem != FileName)
    {
      REQ_CleanFile () ;

      // Assumes "REQ_PreserveTableDirty" was called before this routine 
      REQ_ResetTableDirty () ;

      gte_stpem ("FileLoad "+ Subsystem) ;

      REQ_PreserveTableDirty () ;

      goto_row = gte_get_first_row (REQ_RequirementsHsect()) ;

      // This is a test to see if the new file was cleaned before it was saved.
      // If it wasn't cleaned, then forcibly clean it.  This is necesary so that
      // the user is not given incorrect information about what requirements 
      // are satisfied and which cells satisfy a query.
      //

      if ("" != gte_get_cell_label (satisfaction_row, 1))
        {
          REQForceClearMarks () ;
        }
    }
  else
    {
      goto_row = gte_get_hsect_first_vis_row (REQ_RequirementsHsect()) ;
    }

  if (Phase == "")
    {
      Phase = REQ_GetPhaseStringFromTable () ;
    }

  REQClearAllKnownMarks() ;

  // Set state variables
  set_requirements_phase (Phase) ;
  REQ_SatisfactionId = Id ;
  REQ_LinkOrNodeOrCntx = LinkOrNodeOrCntx ;

  REQ_CurrentSubsystem = Subsystem ;

  if (Id == 0)
    {
      Name = "" ;
      Type = "" ;
    }
  else
    {
      if (REQ_LinkOrNodeOrCntx == "node")
        {
          Type = Node.type ;
          Name = Node.name ;
          REQ_SatisfactionNode = Node ;
          REQ_SatisfactionLink = NULL ;
          REQ_SatisfactionCntx = NULL ;

          REQ_ObjectInfo.omsType = Type ;
          REQ_ObjectInfo.omsName = Name ;
          REQ_ObjectInfo.omsClass = "node" ;
          REQ_ObjectInfo.oid = REQ_SatisfactionId ;

          node_ref Ref = find_by_query ("node_ref [node_id==${Id}]") ;
          if (Ref == NULL)
            {
              print_message 
                ("You need to save a diagram or table which contains the "+
                 Node.type+" \""+Node.name+ "\".") ;
            }

        }
      else if (REQ_LinkOrNodeOrCntx == "link")
        {
          Type = Link.type ;
          Name = Link.name ;
          REQ_SatisfactionNode = NULL ;
          REQ_SatisfactionLink = Link ;
          REQ_SatisfactionCntx = NULL ;

          REQ_ObjectInfo.omsType = Type ;
          REQ_ObjectInfo.omsName = Name ;
          REQ_ObjectInfo.omsClass = "link" ;
          REQ_ObjectInfo.oid = REQ_SatisfactionId ;

          link_ref Ref = find_by_query ("link_ref [link_id==${Id}]") ;
          if (Ref == NULL)
            {
              print_message 
                ("You need to save a diagram or table which contains the "+
                 Link.type+" \""+ Link.name+ "\".") ;
            }
        }
      else if (REQ_LinkOrNodeOrCntx == "cntx")
        {
          Type = Cntx.type ;
          Name = Cntx.name ;
          REQ_SatisfactionNode = NULL ;
          REQ_SatisfactionLink = NULL ;
          REQ_SatisfactionCntx = Cntx ;

          REQ_ObjectInfo.omsType = Type ;
          REQ_ObjectInfo.omsName = Name ;
          REQ_ObjectInfo.omsClass = "cntx" ;
          REQ_ObjectInfo.oid = REQ_SatisfactionId ;

          cntx_ref Ref = find_by_query ("cntx_ref [cntx_id==${Id}]") ;
          if (Ref == NULL)
            {
              print_message 
                ("You need to save a diagram or table which contains the "+
                 Cntx.type+" \""+ Cntx.name+ "\".") ;
            }
        }
    }

  // Mark requirements as satisfied, if any
  //if (REQ_SatisfactionId != 0)
  //{
  //REQ_MarkSatisfactionRequirements ();
  //}

  // Hide Subsystem hsect
  //gte_set_hsect_visibility (REQ_SubsystemHsect(), False) ;

  // Hide Parent Subsytem hsect
  //gte_set_hsect_visibility (REQ_SubsystemParentHsect(), False) ;

  // Make visible Leaf requirements
  gte_set_hsect_visibility (REQ_RequirementsHsect(), True) ;
  gte_set_hsect_visibility (REQ_RequirementsTitleHsect(), True) ;
  gte_set_vsect_visibility (REQ_LeafReqVsect(), True) ;
  gte_set_vsect_visibility (REQ_LeafDefinitionVsect(), True) ;

  // Hide superseded requirements vsect
  //gte_set_vsect_visibility (REQ_ParentReqVsect(), False) ;

  // Hide Superseded Requirement Definitions hsect
  //gte_set_hsect_visibility (REQ_ParentDefinitionHsect(), False) ;
  //gte_set_hsect_visibility (REQ_ParentDefinitionTitleHsect(), False) ;


  // Set Satisfaction Row

  string CellLabel ;

  if (REQ_SatisfactionId !=0)
    {
      CellLabel = Type +" \""+ Name +"\" "+ "\("+REQ_SatisfactionId+"\)" ;

      // Force satisfaction hsect to be visible
      gte_set_hsect_visibility (REQ_SatisfactionHsect(), True) ;
      gte_set_hsect_visibility (REQ_WhiteHsect(), True) ;
    }
  else
    {
      CellLabel = "" ;
      // Force satisfaction hsect to be invisible
      gte_set_hsect_visibility (REQ_SatisfactionHsect(), False) ;
      gte_set_hsect_visibility (REQ_WhiteHsect(), False) ;
    }

  SetSatisfactionLine (CellLabel) ;


  // Set subsystem row
  int SubsystemRow = gte_get_first_row (REQ_SubsystemHsect()) ;

  gte_set_selection (SubsystemRow, 1, SubsystemRow, 1, SubsystemRow, 1) ;

  CurrentCellLabel(REQ_SUBSYSTEM_LABEL + " " + Subsystem) ;


  // Return table to the same position as when entered.
  gte_set_hsect_first_vis_row (REQ_RequirementsHsect(), goto_row) ;
  gte_goto (goto_row, gte_get_first_col (REQ_LeafReqVsect())) ;

  gte_set_selection (satisfaction_row, 1, satisfaction_row, 1, 
              satisfaction_row, 1) ;

}

boolean REQ_TableIsDirty = True ;

void
REQ_PreserveTableDirty ()
{
  REQ_TableIsDirty = gte_is_modified () ;
}

void
REQ_ResetTableDirty ()
{
  if (!REQ_TableIsDirty) gte_set_is_modified (False) ;
}




void
REQ_Reset ()
{
  gte_disable_refresh () ;
  REQ_PreserveTableDirty () ;
  gte_disable_action_completed();

  REQForceClearMarks () ;

  string Subsystem ;

  Subsystem = REQ_CurrentFileName(0,0,0,0) ;

  TableInitialize (    
                   REQ_SatisfactionId, REQ_LinkOrNodeOrCntx, 
                   REQ_SatisfactionNode, REQ_SatisfactionLink, REQ_SatisfactionCntx,
                   Subsystem, REQ_PhaseString) ;

  gte_enable_refresh() ;
  gte_refresh_table() ;
  REQ_ResetTableDirty () ;
  gte_enable_action_completed();
}


void
set_requirements_phase (string Phase)
{
  if (Phase == "Analysis")
    {
      REQ_Phase = Analysis ;
      REQ_AssignmentItem = REQ_ANALYSIS_ASSIGNMENT_ITEM ;
      REQ_PhaseString = "Analysis" ;
    }
  else if (Phase == "Design")
    {
      REQ_Phase = Design ;
      REQ_AssignmentItem = REQ_DESIGN_ASSIGNMENT_ITEM ;
      REQ_PhaseString = "Design" ;
    }
  else if (Phase == "Test")
    {
      REQ_Phase = Test ;
      REQ_AssignmentItem = REQ_TEST_ASSIGNMENT_ITEM ;
      REQ_PhaseString = "Test" ;
    }
  else if (Phase == "Implementation")
    {
      REQ_Phase = Implementation ;
      REQ_AssignmentItem = REQ_IMPLEMENTATION_ASSIGNMENT_ITEM ;
      REQ_PhaseString = "Implementation" ;
    }

  SetRequirementTitle () ;
}

list
REQ_reqs_satisfied()
{
  if (!REQ_reqs_satisfied_initialized)
    {
      REQ_reqs_satisfied_list = list_create ("int", 0) ;
      REQ_reqs_satisfied_initialized = True ;
    }
  return (REQ_reqs_satisfied_list) ;
}

struct REQ_CellType
{
  int row ;
  int col ;
} ;

// A list of REQ_CellType
list REQ_query_results_list ;
boolean REQ_query_results_initialized = False ;
int REQ_current_query_result = -1 ;

list REQ_query_results ()
{
  if (!REQ_query_results_initialized)
    {
      REQ_query_results_list = list_create ("REQ_CellType", 0) ;
      REQ_query_results_initialized = True ;
    }
  return (REQ_query_results_list) ;
}

void
SetSatisfactionLine (string label)
{
  int satisfaction_row = gte_get_first_row (REQ_SatisfactionHsect()) ;
  gte_set_selection (satisfaction_row, 1, satisfaction_row, 1, 
              satisfaction_row, 1) ;

  CurrentCellLabel(label) ; 
}


boolean REQ_UserAwareOfPhases = False ;

void
SetRequirementTitle ()
{
  string CellLabel ;

  if (!REQ_UserAwareOfPhases && REQ_Phase == Analysis)
    {
      CellLabel = "Requirement" ;
    }
  else
    {
      CellLabel = REQ_PhaseString + "\nRequirement" ;
    }
  int title_row = gte_get_first_row (REQ_RequirementsTitleHsect()) ;
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  gte_set_selection (title_row, leaf_col, title_row, leaf_col, 
              title_row, leaf_col) ;

  CurrentCellLabel (CellLabel) ;
}

void
ResetRequirementTitle ()
{
  string CellLabel = "Requirement" ;
  int title_row = gte_get_first_row (REQ_RequirementsTitleHsect()) ;
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  gte_set_selection (title_row, leaf_col, title_row, leaf_col, 
              title_row, leaf_col) ;

  CurrentCellLabel (CellLabel) ;
}

void
REQ_SetUserAwareOfPhases (boolean flag)
{
  REQ_UserAwareOfPhases = flag ;
}




// This routine forcibly clears all shading and bolding of cells due to
// requirement assignment or query results.  This routine is to be called
// when there is no confidence in the data structures that remember the cells
// representing query results or requirement assignments.  This routine is
// expensive to run.

void
REQForceClearMarks ()
{
  REQ_ClearSatisfaction () ;
  SetSatisfactionLine ("") ;

  REQ_ClearQuery () ;
}


// This routine uses the data structures that remember the cells that represent
// query results and requirement assignments to unmark these cells.

void
REQClearAllKnownMarks ()
{
  REQ_ResetSatisfaction () ;
    
  REQ_ResetQuery ();
}


void
REQ_SetSubsystem (string Subsystem)
{

  gte_disable_refresh () ;
  gte_disable_action_completed();
  REQ_PreserveTableDirty () ;

  TableInitialize (    REQ_SatisfactionId, REQ_LinkOrNodeOrCntx, 
                       REQ_SatisfactionNode, REQ_SatisfactionLink,
                       REQ_SatisfactionCntx, Subsystem, REQ_PhaseString) ;

  REQ_ResetTableDirty () ;
  gte_enable_refresh() ;
  gte_refresh_table() ;
  gte_enable_action_completed();
}



// Used to save info from the user until all information is obtained.

int REQ_IdSave = 0 ;
string REQ_SubsystemSave = "" ;
string REQ_LinkOrNodeOrCntxSave = "" ;


void
RequirementTableInitializeForNode (int node_id)
{
  EditorShowOnNavReceive();
  REQ_IdSave = node_id ;
  REQ_LinkOrNodeOrCntxSave = "node" ;

  BeginInitialization (node_id) ;
}

void
RequirementTableInitializeForLink (int link_id)
{
  EditorShowOnNavReceive();
  REQ_LinkOrNodeOrCntxSave = "link" ;
  REQ_IdSave = link_id ;

  BeginInitialization (link_id) ;
}

void
RequirementTableInitializeForCntx (int cntx_id)
{
  EditorShowOnNavReceive();
  REQ_LinkOrNodeOrCntxSave = "cntx" ;
  REQ_IdSave = cntx_id ;

  BeginInitialization (cntx_id) ;
}

void
FinishInitialization (int Id, string Subsystem, string PhaseString)
{
  node Node = NULL ;
  link Link = NULL ;
  cntx Cntx = NULL ;

  if (REQ_LinkOrNodeOrCntxSave == "node")
    {
      Node = node_from_oid(Id);
    }
  else if (REQ_LinkOrNodeOrCntxSave == "link")
    {
      Link = link_from_oid(Id);
    }
  else if (REQ_LinkOrNodeOrCntxSave == "cntx")
    {
      Cntx = cntx_from_oid(Id);
    }


  if (Node == NULL && Link == NULL && Cntx == NULL)
    {
      gte_print_error ("RQTBL: Cannot find "+ 
                       REQ_LinkOrNodeOrCntxSave+ " with id " + Id) ;
    }
  else 
    {
      gte_disable_refresh () ;
      gte_disable_action_completed();
   
      if  (REQ_LinkOrNodeOrCntxSave == "node")
        {
          TableInitialize 
            (Id, "node", Node, NULL, NULL, Subsystem, PhaseString) ;
        }
      else if (REQ_LinkOrNodeOrCntxSave == "link")
        {
          TableInitialize 
            (Id, "link", NULL, Link, NULL, Subsystem, PhaseString) ;
        }
      else if (REQ_LinkOrNodeOrCntxSave == "cntx")
        {
          TableInitialize 
            (Id, "cntx", NULL, NULL, Cntx, Subsystem, PhaseString) ;
        }

      gte_enable_refresh() ;
      gte_refresh_table() ;
      REQ_ResetTableDirty () ;
      gte_enable_action_completed();
    }

  editor_set_is_busy (False);
}



void 
RequirementTableInitialize_subsys()

{
  if (REQ_LinkOrNodeOrCntxSave == "node")
    FinishInitialization (REQ_IdSave, REQ_SubsystemSave, REQ_PhaseString) ;

  else if (REQ_LinkOrNodeOrCntxSave == "link")
    FinishInitialization (REQ_IdSave, REQ_SubsystemSave, REQ_PhaseString) ;

  else if (REQ_LinkOrNodeOrCntxSave == "cntx")
    FinishInitialization (REQ_IdSave, REQ_SubsystemSave, REQ_PhaseString) ;

  return;
}


void
RequirementTableInitialize_subsys_no_cb (string val)

{
  REQ_SubsystemSave = val;
  RequirementTableInitialize_subsys();

  return;
}



void
RequirementTableInitialize_subsys_cb ()
{
  list result = editor_selector_selected_names();
  REQ_SubsystemSave = list_get(result, 0);
  RequirementTableInitialize_subsys();

  return;
}



void
RequirementTableInitialize_phase_cb ()
{
  list result = editor_selector_selected_labels () ;
  string Phase = list_get (result, 0)  ;

  if (REQ_LinkOrNodeOrCntxSave == "node")
    {
      FinishInitialization (REQ_IdSave, REQ_SubsystemSave, Phase) ;
    }
  else if (REQ_LinkOrNodeOrCntxSave == "link")
    {
      FinishInitialization (REQ_IdSave, REQ_SubsystemSave, Phase) ;
    }
  else if (REQ_LinkOrNodeOrCntxSave == "cntx")
    {
      FinishInitialization (REQ_IdSave, REQ_SubsystemSave, Phase) ;
    }
}

void
BeginInitialization (int Id)
{
  //editor_set_is_busy (True);

  // If the CurrentSubsystem is not set, query the user for subsystem
  // and phase before initializing the table editor.

  gte_disable_refresh () ;
  REQ_PreserveTableDirty () ;
  gte_disable_action_completed();
  boolean FoundTables = 
    REQ_RequirementSubsystemMenu (Id, "RequirementTableInitialize_subsys_cb();");

 // if (!FoundTables)  Always refresh to clear up dialog area 
 //   {
      gte_enable_refresh() ;
      gte_enable_action_completed();
 //   }
}





string
REQLeafRequirementHasParent (int hsect, int vsect, int row, int col)
{
  REQ_ForMappingPreserveCurrentSettings () ;

  // Returns a non-zero value if parent cell exists.
  int parent_col = REQ_GetParentColumn (gte_get_row (hsect, row)) ;

  REQ_ForMappingGoBackToSettingsSaved () ;

  if (parent_col == 0)
    {
      return (NULL) ;
    }
  else
    {
      return ("T") ;
    }
}

int
REQGetFirstGoodReqirementParentColumn (int hsect, int row)
{
  REQ_ForMappingPreserveCurrentSettings () ;
  // Returns a non-zero value if parent cell exists.
  int parent_col = REQ_GetParentColumn (gte_get_row (hsect, row)) ;

  if (parent_col != 0)
    {
      // Convert to global row coordinates.
      // Convert to parent vsect coordinates.
      parent_col = parent_col - gte_get_first_col (REQ_ParentReqVsect()) + 1 ;
    }
  REQ_ForMappingGoBackToSettingsSaved () ;

  return (parent_col) ;
}


string
ParentRequirementHasParent (int hsect, int vsect, int row, int col)
{
  int this_col = gte_get_col (vsect, col) ;
  int first_col = gte_get_first_col (vsect) ;
  string label = gte_get_cell_label (gte_get_row (hsect,row), this_col) ;

  if (this_col > first_col)
    return ("T") ;
  else
    return (NULL) ;
}


int
GetParentCol (int row)
{
  int last_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  int i ;
  int parent_column = 0 ;

  for (i=last_col; i>0; i=i-1)
    {
     
    }
}



int REQ_WhiteHsect_SAVE = -1 ;
int
REQ_WhiteHsect ()
{
  if (-1==REQ_WhiteHsect_SAVE) 
    {
      REQ_WhiteHsect_SAVE = gte_lookup_symbol("WhiteSpaceHsect") ;
    }
  return (REQ_WhiteHsect_SAVE) ;
}

int REQ_SubsystemHsect_SAVE = -1 ;
int
REQ_SubsystemHsect ()
{
  if (-1==REQ_SubsystemHsect_SAVE) 
    {
      REQ_SubsystemHsect_SAVE = gte_lookup_symbol("SubsystemHsect") ;
    }
  return (REQ_SubsystemHsect_SAVE) ;
}


int REQ_SubsystemParentHsect_SAVE = -1 ;
int
REQ_SubsystemParentHsect ()
{
  if (-1==REQ_SubsystemParentHsect_SAVE) 
    {
      REQ_SubsystemParentHsect_SAVE = gte_lookup_symbol("SubsystemParentHsect") ;
    }
  return (REQ_SubsystemParentHsect_SAVE) ;
}


int REQ_SatisfactionHsect_SAVE = -1 ;
int
REQ_SatisfactionHsect ()
{
  if (-1==REQ_SatisfactionHsect_SAVE) 
    {
      REQ_SatisfactionHsect_SAVE = gte_lookup_symbol("SatisfactionHsect") ;
    }
  return (REQ_SatisfactionHsect_SAVE) ;
}

int REQ_RequirementsTitle_SAVE = -1 ;
int
REQ_RequirementsTitleHsect ()
{
  if (-1==REQ_RequirementsTitle_SAVE) 
    {
      REQ_RequirementsTitle_SAVE = gte_lookup_symbol("RequirementsTitleHsect") ;
    }
  return (REQ_RequirementsTitle_SAVE) ;
}

int REQ_LeafDefinitionVsect_SAVE = -1 ;
int
REQ_LeafDefinitionVsect ()
{
  if (-1==REQ_LeafDefinitionVsect_SAVE) 
    {
      REQ_LeafDefinitionVsect_SAVE = gte_lookup_symbol("LeafDefinitionVsect") ;
    }
  return (REQ_LeafDefinitionVsect_SAVE) ;
}


int REQ_ParentReqVsect_SAVE = -1 ;
int
REQ_ParentReqVsect ()
{
  if (-1==REQ_ParentReqVsect_SAVE) 
    {
      REQ_ParentReqVsect_SAVE = gte_lookup_symbol("ParentReqVsect") ;
    }
  return (REQ_ParentReqVsect_SAVE) ;
}

int REQ_LeafReqVsect_SAVE = -1 ;
int
REQ_LeafReqVsect ()
{
  if (-1==REQ_LeafReqVsect_SAVE) 
    {
      REQ_LeafReqVsect_SAVE = gte_lookup_symbol("LeafReqVsect") ;
    }
  return (REQ_LeafReqVsect_SAVE) ;
}

int REQ_RequirementsHsect_SAVE = -1 ;
int
REQ_RequirementsHsect ()
{
  if (-1==REQ_RequirementsHsect_SAVE) 
    {
      REQ_RequirementsHsect_SAVE = gte_lookup_symbol("RequirementsHsect") ;
    }
  return (REQ_RequirementsHsect_SAVE) ;
}

int REQ_ParentDefinitionHsect_SAVE = -1 ;
int
REQ_ParentDefinitionHsect ()
{
  if (-1==REQ_ParentDefinitionHsect_SAVE) 
    {
      REQ_ParentDefinitionHsect_SAVE = gte_lookup_symbol("ParentDefinitionHsect") ;
    }
  return (REQ_ParentDefinitionHsect_SAVE) ;
}

int REQ_ParentDefinitionNameVsect_SAVE = -1 ;
int
REQ_ParentDefinitionNameVsect ()
{
  if (-1==REQ_ParentDefinitionNameVsect_SAVE) 
    {
      REQ_ParentDefinitionNameVsect_SAVE = gte_lookup_symbol("ParentDefinitionNameVsect") ;
    }
  return (REQ_ParentDefinitionNameVsect_SAVE) ;
}

int REQ_ParentDefinitionTextVsect_SAVE = -1 ;
int
REQ_ParentDefinitionTextVsect ()
{
  if (-1==REQ_ParentDefinitionTextVsect_SAVE) 
    {
      REQ_ParentDefinitionTextVsect_SAVE = gte_lookup_symbol("ParentDefinitionTextVsect") ;
    }
  return (REQ_ParentDefinitionTextVsect_SAVE) ;
}


int REQ_ParentDefinitionTitleHsect_SAVE = -1 ;
int
REQ_ParentDefinitionTitleHsect ()
{
  if (-1==REQ_ParentDefinitionTitleHsect_SAVE) 
    {
      REQ_ParentDefinitionTitleHsect_SAVE = gte_lookup_symbol("ParentDefinitionTitleHsect") ;
    }
  return (REQ_ParentDefinitionTitleHsect_SAVE) ;
}


int
REQ_TopRowInSpan (int row, int col)
{
  gte_set_selection (row, col, row, col, row, col) ;
  return (gte_get_first_row_in_selected()) ;
}

int
REQ_BottomRowInSpan (int row, int col)
{
  RowSpanType result = REQ_RowSpanRange(row,col);
  return result.end_row;
}

struct RowSpanType
{
  int start_row ;
  int end_row ;
} ;

RowSpanType
REQ_RowSpanRange (int row, int col)
{
  gte_set_selection (row, col, row, col, row, col) ;

  RowSpanType result ;
  result.start_row = gte_get_first_row_in_selected () ;
  result.end_row   = result.start_row ;

  int i ;
  int last_row = gte_get_last_row (gte_get_hsect(row)) ;
  int start_row = row ;

  for (i=result.start_row+1; i<= last_row; i=i+1)
    {
      gte_set_selection (i, col, i, col, i, col) ;

      if (result.start_row == gte_get_first_row_in_selected())
        {
          result.end_row = result.end_row + 1 ;
        }
      else
        {
          break ;
        }
    }
  return (result) ;
}

struct ColSpanType
{
  int start_col ;
  int end_col ;
} ;


ColSpanType
REQ_ColSpanRange (int row, int col)
{

  gte_set_selection (row, col, row, col, row, col) ;

  ColSpanType result ;
  result.start_col = gte_get_first_col_in_selected () ;
  result.end_col = result.start_col ;

  int i ;
  int last_col = gte_get_last_col (gte_get_vsect (col)) ;

  for (i=result.start_col+1; i<= last_col; i=i+1)
    {
      gte_set_selection (row, i, row, i, row, i) ;

      if (result.start_col == gte_get_first_col_in_selected())
        {
          result.end_col = result.end_col + 1 ;
        }
      else
        {
          break ;
        }
    }
  return (result) ;
}


boolean
NoLabel (int row, int col)
{
  string label = gte_get_cell_label(row, col) ;


  if (IsBlank (label))
    {
      return (True) ;
    }
  else
    {
      return (False) ;
    }
}

boolean
REQ_SpanningParentRow (int row)
{
  ColSpanType cs =
    REQ_ColSpanRange(row,gte_get_last_col (REQ_ParentReqVsect()));

  if (cs.start_col == cs.end_col) {
    return False;
  } else {
    return True;
  }
// JED - left in so we don't lose it yet
//  int last_col = gte_get_last_col (REQ_ParentReqVsect()) ;
//  int start_col ;
//
//  gte_set_selection (row, last_col, row, last_col, row, last_col) ;
//  start_col = gte_get_first_col_in_selected () ;
//
//  if (start_col == last_col)
//    {
//      return (False) ;
//    }
//  else
//    {
//      return (True) ;
//    }
}

// Returns the youngest parent in row.  
//
int
REQ_GetParentColumn (int row)
{
  int first_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int last_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  int parent_col ;

  // if not spanning, then find the first non-blank parent cell to the left.
  //
  if (!REQ_SpanningParentRow (row)) 
    {
      int col ;
      for (col=last_col; col >= first_col ; col=col-1)
        {
          if (!NoLabel (row,col))
            {
              break ;
            }
        }
      parent_col = col ;
    }
  // else if spanning, then parent is just left of the spanning cell
  else 
    {
      ColSpanType ColSpan= REQ_ColSpanRange (row, last_col) ;

      parent_col = ColSpan.start_col - 1 ;
    }

  return (parent_col) ;
}

void
FillSelectionWhite()
{
  gte_filltable_string("FillTable { { Hsect { Index Current}" +
                       "{ Vsect { Index Current } { Row { Index Current }" +
                       "{ Cell { Index Current } {Shading Unshaded}}}}}}");
}
void
FillSelectionParentShade()
{
  gte_filltable_string("FillTable { { Hsect { Index Current}" +
                       "{ Vsect { Index Current } { Row { Index Current }" +
                       "{ Cell { Index Current } {Shading Shade2}}}}}}");
}
void
FillSelectionSatisfiedShade()
{
  gte_filltable_string("FillTable { { Hsect { Index Current}" +
                       "{ Vsect { Index Current } { Row { Index Current }" +
                       "{ Cell { Index Current } {Shading Shade1}}}}}}");
}

void
REQ_UpdateBookeepingForNewCol (int new_col)
{
  int i ;
  int count ;

  // Query List
  count = list_count (REQ_query_results()) ;
  REQ_CellType cell ;
  for (i=0; i < count; i=i+1)
    {
      cell = list_get (REQ_query_results(), i) ;
      if (cell.col >= new_col)
        {
          cell.col = cell.col + 1 ;
          list_set (REQ_query_results(), i, cell) ;
        }
    }
}
void
REQ_UpdateBookeepingForDeletedCol (int deleted_col)
{
  int i ;
  int count ;

  // Query List
  int num_deleted = 0 ;
  list copy = list_copy (REQ_query_results()) ;
  count = list_count (REQ_query_results()) ;
  REQ_CellType cell ;

  for (i=0; i < count; i=i+1)
    {
      cell = list_get (copy, i) ;

      if (col == deleted_col)
        {
          list_delete (REQ_query_results(), i-num_deleted) ;
          num_deleted = num_deleted + 1 ;
        }
      else if (col > deleted_col)
        {
          cell.col = cell.col - 1 ;
          list_set (REQ_query_results(), i-num_deleted, cell) ;
        }
    }
}

string SubsystemTitleBar = NULL ;
string ParentSubsystemTitleBar = NULL ;
string SatisfactionTitleBar = NULL ;

// A hack to counter the behavior of the gte to refresh spanning cells
// from the rules file.
void
REQ_SaveTitleBars ()
{
  int SubsystemRow = gte_get_first_row (REQ_SubsystemHsect()) ;
  int ParentSubsystemRow = gte_get_first_row (REQ_SubsystemParentHsect()) ;
  int satisfaction_row = gte_get_first_row (REQ_SatisfactionHsect()) ;

  SubsystemTitleBar = gte_get_cell_label (SubsystemRow, 1) ;
  ParentSubsystemTitleBar = gte_get_cell_label (ParentSubsystemRow, 1) ;
  SatisfactionTitleBar = gte_get_cell_label (satisfaction_row, 1) ;

}

void
REQ_RestoreTitleBars ()
{
  int SubsystemRow = gte_get_first_row (REQ_SubsystemHsect()) ;
  int ParentSubsystemRow = gte_get_first_row (REQ_SubsystemParentHsect()) ;
  int satisfaction_row = gte_get_first_row (REQ_SatisfactionHsect()) ;

  if (SubsystemTitleBar != NULL)
    {
      gte_set_selection (SubsystemRow, 1, SubsystemRow, 1, SubsystemRow, 1) ;
      CurrentCellLabel(SubsystemTitleBar) ;
    }

  if (ParentSubsystemTitleBar != NULL)
    {
      gte_set_selection (ParentSubsystemRow, 1, 
                  ParentSubsystemRow, 1, ParentSubsystemRow, 1) ;

      CurrentCellLabel(ParentSubsystemTitleBar) ;
    }

  if (SatisfactionTitleBar != NULL)
    {
      gte_set_selection (satisfaction_row, 1, satisfaction_row, 1, 
                  satisfaction_row, 1) ;

      CurrentCellLabel(SatisfactionTitleBar) ;
    }
}


void 
REQ_AddParentColumn ()
{
  int first_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int last_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  int first_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int last_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  // a hack to maintain integrity of spanning title bars.
  REQ_SaveTitleBars () ;


  // JED begin
  gte_insert_col_after(last_col,1);

  REQ_UpdateBookeepingForNewCol (last_col+1) ;
  REQ_RestoreTitleBars () ;
  return;
// end JED
//  // JED - orig
//  gte_insert_col (last_col, 1) ;
//
//        
//  last_col = last_col + 1 ;
//
//  int row ;
//  int parent_col  = last_col;
//
//  for (row=first_row; row <= last_row; row=row+1)
//    {
//      parent_col = REQ_GetParentColumn (row) ;
//
//      // Copy over cell contents if parent cell is in the immediate column
//      //
//      if (parent_col >= last_col-1) 
//        {
//          if (!NoLabel (row, last_col))
//            {
//              // print_warning("!NoLabel (row, last_col)");
//              gte_set_selection (row, last_col, row, last_col, row, last_col) ;
//              JED_Copy() ;
//              //gte_stpem ("TableElementClear") ;
//              CurrentCellLabel("") ;
//              gte_unspan();
//              gte_set_selection 
//                (row, last_col-1, row, last_col-1, row, last_col-1) ;
//              JED_Paste () ;
//            }
//        }
//
//
//      // if white zone
//      if (parent_col < last_col-1)
//        {
//          // Need to create span if not yet spanned.  
//          //
//          if (parent_col == last_col-2)
//            {
//              gte_set_selection 
//                (row, parent_col+1, row, last_col-1, row, last_col-1);
//              gte_unspan();
//              gte_set_selection (row, parent_col+1, row, last_col, row, last_col);
//              gte_span();
//            }
//          gte_set_selection (row, last_col, row, last_col, row, last_col) ;
//          FillSelectionWhite () ;
//        }
//    }
//
//  REQ_UpdateBookeepingForNewCol (last_col) ;
//  REQ_RestoreTitleBars () ;
}



void
MakeNewParentLastCol ()
{
  REQ_AddParentColumn ();
}


void
REQ_UpdateBookeepingForNewRow (int new_row)
{
  int i ;
  int count ;

  // Satisfaction List
  count = list_count (REQ_reqs_satisfied()) ;
  int row ;
  for (i=0; i < count; i=i+1)
    {
      row = list_get (REQ_reqs_satisfied(), i) ;
      if (row >= new_row)
        {
          list_set (REQ_reqs_satisfied(), i, row+1) ;
        }
    }

  // Query List
  count = list_count (REQ_query_results()) ;
  REQ_CellType cell ;
  for (i=0; i < count; i=i+1)
    {
      cell = list_get (REQ_query_results(), i) ;
      if (cell.row >= new_row)
        {
          cell.row = cell.row + 1 ;
          list_set (REQ_query_results(), i, cell) ;
        }
    }
}

void
REQ_UpdateBookeepingForDeletedRow (int deleted_row)
{
  int i ;
  int count ;
  list copy ; 
  int num_deleted ;

  // Satisfaction List
  count = list_count (REQ_reqs_satisfied()) ;
  int row ;
  num_deleted = 0 ;
   
  copy = list_copy (REQ_reqs_satisfied()) ;

  for (i=0; i < count; i=i+1)
    {
      row = list_get (copy, i) ;
      if (row == deleted_row)
        {
          list_delete (REQ_reqs_satisfied(), i-num_deleted) ;
          num_deleted = num_deleted + 1 ;
        }
      else if (row > deleted_row)
        {
          list_set (REQ_reqs_satisfied(), i-num_deleted, row-1) ;
        }
    }

  list_clear (copy) ;

  // Query List
  num_deleted = 0 ;
  count = list_count (REQ_query_results()) ;
  copy = list_copy (REQ_query_results()) ;
  REQ_CellType cell ;

  for (i=0; i < count; i=i+1)
    {
      cell = list_get (copy, i) ;
      if (cell.row == deleted_row)
        {
          list_delete (REQ_query_results(), i-num_deleted) ;
          num_deleted = num_deleted + 1 ;
        }
      else if (cell.row > deleted_row)
        {
          cell.row = cell.row - 1 ;
          list_set (REQ_query_results(), i-num_deleted, cell) ;
        }
    }
}
void
REQ_UpdateBookeepingForDeletedColumn (int deleted_col)
{
  int i ;
  int count ;
  list copy ; 
  int num_deleted ;

  // Query List
  num_deleted = 0 ;
  count = list_count (REQ_query_results()) ;
  copy = list_copy (REQ_query_results()) ;
  REQ_CellType cell ;

  for (i=0; i < count; i=i+1)
    {
      cell = list_get (copy, i) ;
      if (cell.col == deleted_col)
        {
          list_delete (REQ_query_results(), i-num_deleted) ;
          num_deleted = num_deleted + 1 ;
        }
      else if (cell.col > deleted_col)
        {
          cell.col = cell.col - 1 ;
          list_set (REQ_query_results(), i-num_deleted, cell) ;
        }
    }
}

void
REQ_UpdateBookeepingForModifiedRow (int row)
{
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  REQ_CellType cell ;
  cell.row = row ;
  cell.col = leaf_col ;
  REQ_UnmarkQueryCell (cell) ;

  REQ_MarkAsUnsatisfied (row) ;
}

void
REQ_AddReqRow (int row, int max_merge_col)
{
  int first_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int last_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  if (row >= first_row && row <= last_row)
    {
      gte_insert_row (row, 1) ;

      REQ_UpdateBookeepingForNewRow (row) ;

      // update row to point to existing row because the new row is
      // inserted above this one
      row = row + 1 ;

	  // repair the spanning from the top to here
      RowSpanType RowSpan ;
      ColSpanType ColSpan ;
      int first_col = gte_get_first_col (REQ_ParentReqVsect()) ;
      int last_col = gte_get_last_col (REQ_ParentReqVsect()) ;

      int col ;
      int top_row ;
      for (col=first_col; col <= max_merge_col; col=col+1)
        {

          top_row = REQ_TopRowInSpan (row, col) ;

          // Inserting a row above the first row in a span will not span
          // automatically, while other rows will do so.  Consequently,
          // if inserting above the first row, it is necessary to massage
          // the spanning.
          if (row == top_row)
            {
              RowSpan = REQ_RowSpanRange (row, col) ;
			  // JED added
			  // This code needed to restore both the column and row
			  // spanning
			  ColSpan = REQ_ColSpanRange (row, col) ;

              gte_set_selection (row, col, row, col, row, col) ;
              gte_unspan();
              gte_set_selection (row, col, row, col, row, col) ;
              JED_Copy() ;
              gte_set_selection (row-1, col, RowSpan.end_row, ColSpan.end_col, 
					     row-1, col) ;
              gte_span();
              JED_Paste () ;
            }
        }
    }
}

int
REQ_RefineIsActive ()
{
  int result ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  int definition_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  int row_selected = gte_get_current_cell_row() ;
  int col_selected = gte_get_current_cell_col() ;

  int parent_col ;

  // if selected something in the requirements table
  //
  if (row_selected >= min_req_row && row_selected <= max_req_row) 
    {
      // if selected a leaf requirement
      if (col_selected >= leaf_col && !NoLabel (row_selected, leaf_col)) 
        {
          result = ACTIVE_FUNC_IS_ACTIVE ;
        }
      // else selected a Parent Requirement
      else if (col_selected < leaf_col && !NoLabel (row_selected, col_selected))
        {
          result = ACTIVE_FUNC_IS_ACTIVE ;
        }
      else
        {
          result = ACTIVE_FUNC_IS_INACTIVE ;
        }
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }
  return (result) ;
}

void
REQ_DoRefine (int Row, int Col, boolean AddRow)
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  int definition_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  int parent_col ;

  // if selected a leaf requirement
  if (Col >= leaf_col && !NoLabel (Row, leaf_col)) 
    {
      // Force Parent Vsect to be visible
      gte_set_vsect_visibility (REQ_ParentReqVsect(), True) ;

      REQ_LabelType leaf_label = REQ_ParsedLabel (Row, leaf_col) ;

      REQ_CellType leaf_rqmt = REQ_FindUniqueId (leaf_label.unique_id, 
                              Row, min_parent_col, Row, max_parent_col) ;

      if (leaf_rqmt.row != -1)
        {
          gte_print_error ("Requirement "+ leaf_label.unique_id +
                          " has itself as a parent in column "+ leaf_rqmt.col) ;
        }
      else
        {
          int NewRow ;
          int OldRow = Row ;

          if (AddRow)
            {
              // After this call, "Row" will point to the new row since
              // the new row is inserted before old row.  

              REQ_AddReqRow(Row, max_parent_col) ;
              max_req_row = max_req_row + 1 ;

              OldRow = Row + 1 ;
              NewRow = Row ;
            }
          else
            {
              NewRow = OldRow ;
            }

          parent_col = REQ_GetParentColumn (NewRow) + 1 ;

          // immediate parent case (need to create column)
          if (parent_col > max_parent_col)
            {
              REQ_AddParentColumn() ;
              max_parent_col = max_parent_col + 1 ;
              leaf_col = leaf_col + 1 ;
              definition_col = definition_col + 1 ;
              int i ;

              // Fill white above and below new parent
              if (NewRow > min_req_row)
                {
                  for (i=min_req_row; i < NewRow; i=i+1)
                    {
                      gte_set_selection (i, max_parent_col,
                                  i, max_parent_col,
                                  i, max_parent_col) ;
                      FillSelectionWhite() ;
                    }
                }

              if (OldRow < max_req_row)
                {
                  for (i=OldRow+1; i <= max_req_row; i=i+1)
                    {
                      gte_set_selection (i, max_parent_col,
                                  i, max_parent_col,
                                  i, max_parent_col) ;
                      FillSelectionWhite() ;
                    }
                }
            }


          RowSpanType RowSpan ; 
          RowSpan = REQ_RowSpanRange (NewRow, parent_col) ;

          // copy leaf into parent definitions
          REQ_CreateParentDefinitionFromLeaf (OldRow) ;

          // copy leaf text
          gte_set_selection (OldRow, leaf_col, 
                      OldRow, leaf_col, OldRow, leaf_col) ;
          JED_Copy() ;
          //gte_stpem ("TableElementClear") ;
          CurrentCellLabel("") ;

          //clear leaf definition
          gte_set_selection (OldRow, definition_col,
                      OldRow, definition_col, 
                      OldRow, definition_col) ;

          CurrentCellLabel("") ;
   
          // unspan parent column
          gte_set_selection (NewRow, parent_col, NewRow, parent_col, 
                      NewRow, parent_col) ;
          gte_unspan();

          // JED fix
          // Unspan the old row. It may be part of another span.
          gte_set_selection (NewRow, parent_col, 
                      OldRow, parent_col, 
                      OldRow, parent_col) ;
          gte_unspan();

          // span part of column for new parent and copy in text
          gte_set_selection (NewRow, parent_col, 
                      OldRow, parent_col, 
                      OldRow, parent_col) ;
          gte_span();
          JED_Paste () ;
          //FillSelectionParentShade() ;

          // repair above new parent column
          if (RowSpan.start_row < NewRow)
            {
              gte_set_selection (RowSpan.start_row, parent_col, 
                          NewRow-1, parent_col, NewRow-1, parent_col) ;
            
              gte_span();
            }

          // repair below new parent column
          if (RowSpan.end_row > OldRow)
            {
              gte_set_selection (OldRow+1, parent_col, 
                          RowSpan.end_row, parent_col,
                          OldRow+1, parent_col) ;
            
              gte_span();
            }

          // repair white space between parent and leaf rqmt
          if (parent_col < max_parent_col)
            {
              gte_set_selection (NewRow, parent_col+1, 
                          OldRow, max_parent_col, OldRow, max_parent_col) ;
              gte_unspan();

              int i ;
              for (i=NewRow; i<= OldRow; i=i+1)
                {
                  gte_set_selection (i, parent_col+1, i, max_parent_col,
                              i, max_parent_col) ;
                  gte_span();
                  FillSelectionWhite() ;
                }
            }

          // In case selected row was marked as satisfied.
          REQ_MarkAsUnsatisfied (OldRow) ;

          // In case selected row was a query result.
          REQ_CellType cell ;
          cell.row = OldRow;
          cell.col = leaf_col ;
          REQ_UnmarkQueryCell (cell) ;

          //REQ_MarkListAsSatisfied (REQ_reqs_satisfied()) ;

          // Mark new leaves
          gte_goto (NewRow, leaf_col) ;

          gte_set_selection (NewRow, leaf_col,
                      NewRow+1, leaf_col, 
                      NewRow, leaf_col) ;
        }
    }
  // else selected a Parent Requirement
  else if (Col >= min_parent_col && Col < leaf_col && !NoLabel (Row, Col))
    {
      RowSpanType RowSpan = REQ_RowSpanRange (Row, Col) ;
      int NewRow = RowSpan.end_row + 1 ;

      string FillTable = 
        REQ_FillTableStringForRow 
        (RowSpan.end_row, REQ_ParentReqVsect(), 
         REQ_LeafDefinitionVsect(), Col) ;

      string RowTag ;

      if (RowSpan.end_row == max_req_row)
        {
          RowTag = "Append" ;
        }
      else
        {
          REQ_AddReqRow (NewRow, 0) ;
          RowTag = to_string (NewRow - min_req_row + 1) ;
        }

      FillTable = 
        string_search_and_replace (FillTable, REQ_RowTag, RowTag) ;

      gte_filltable_string (FillTable) ;

      REQ_RespanHierarchyRow (NewRow) ;

      gte_goto (NewRow, leaf_col) ;

      gte_set_selection (NewRow, leaf_col,
                  NewRow, leaf_col, 
                  NewRow, leaf_col) ;
    }
}


void
REQ_Refine ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  int definition_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  int row_selected = gte_get_current_cell_row() ;
  int col_selected = gte_get_current_cell_col() ;

  int parent_col ;

  // if selected something in the requirements table
  //
  if (row_selected >= min_req_row && row_selected <= max_req_row) 
    {
      gte_disable_action_completed();
      gte_disable_refresh ();

      REQ_DoRefine (row_selected, col_selected, True) ;

      // Deactivate any ascii import undos
      REQ_ImportUndoActive = False ;

      gte_enable_refresh() ;
      gte_refresh_table() ;
      gte_enable_action_completed();
    }
}



string REQ_unique_id_terminus_SAVE = NULL ;

string
REQ_unique_id_terminus ()
{
  if (REQ_unique_id_terminus_SAVE == NULL)
    {
      REQ_unique_id_terminus_SAVE = toolinfo_variable("REQ_unique_id_terminus");

      if (REQ_unique_id_terminus_SAVE == NULL)
        {
          REQ_unique_id_terminus_SAVE = REQ_unique_id_terminus_DEFAULT ;
        }
    }
  return (REQ_unique_id_terminus_SAVE) ;
}

struct REQ_LabelType
{
  string  unique_id ;
  string  informal_name ;
} ;

REQ_LabelType
REQ_ParseString (string label)
{
  REQ_LabelType result ;
  string unique_id ;
  string informal_name ;

  if (!IsBlank (label))
    {
      label = string_search_and_replace (label, "\n", " ") ;
      label = string_search_and_replace (label, "\t", " ") ;
      while (string_find (label, 0, "  ") != string_length (label))
        {
          label = string_search_and_replace (label, "  ", " ") ;
        }

      int index = string_find (label, 0, REQ_unique_id_terminus()) ;
      int length = string_length (label) ;

      // terminator not found
      if (index == length)
        {
          unique_id = label ;  
          informal_name = NULL ;  
        }
      else
        {
          unique_id = string_extract (label, 0, index) ;

          // if terminator is last character
          if (index == length-1)
            {
              informal_name = NULL ;
            }
          else
            {
              informal_name = string_extract (label, index+1, length-index-1) ;  
            }
        }

      if (unique_id != NULL)
        {
          unique_id = string_strip (unique_id, "B", " ") ;
        }


      if (informal_name != NULL)
        {
          informal_name = string_strip (informal_name, "B", " ") ;
        }
    }
  else
    {
      
      unique_id = NULL ;  
      informal_name = NULL ;  
    }

  result.unique_id = unique_id ;
  result.informal_name = informal_name ;
  return (result) ;
}

REQ_LabelType
REQ_ParsedLabel (int row, int col)
{
  REQ_LabelType result ;
  string label = gte_get_cell_label (row, col) ;

  result = REQ_ParseString (label) ;
  return (result) ;
}



void
REQ_MarkAsSatisfied (int row)
{
  int leaf_col       = gte_get_first_col (REQ_LeafReqVsect()) ;
  int max_parent_col = gte_get_last_col  (REQ_ParentReqVsect()) ;
  int definition_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int parent_col = REQ_GetParentColumn (row) ;

  if (parent_col < max_parent_col)
    {
      gte_set_selection (row, parent_col+1, row, max_parent_col,
                  row, max_parent_col) ;

      gte_unspan();

      gte_set_selection (row, parent_col+1, row, max_parent_col,
                  row, max_parent_col) ;

      gte_span();

      gte_set_selection (row, max_parent_col, row, max_parent_col,
                  row, max_parent_col) ;

      FillSelectionSatisfiedShade() ;
    }

  gte_set_selection (row, leaf_col, row, leaf_col, row, leaf_col) ;
  FillSelectionSatisfiedShade() ;

  gte_set_selection (row, definition_col, row, definition_col,
              row, definition_col) ;

  FillSelectionSatisfiedShade() ;

  int count = list_count(REQ_reqs_satisfied()) ;

  int index = list_find (REQ_reqs_satisfied(), 0, row) ;
  if (count == index)
    {
      list_append (REQ_reqs_satisfied(), row) ;
    }
}


void
REQ_MarkAsUnsatisfied (int row)
{
  int leaf_col       = gte_get_first_col (REQ_LeafReqVsect()) ;
  int max_parent_col = gte_get_last_col  (REQ_ParentReqVsect()) ;
  int definition_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int parent_col = REQ_GetParentColumn (row) ;
  if (parent_col < max_parent_col)
    {
      gte_set_selection (row, parent_col+1, row, max_parent_col,
                  row, max_parent_col) ;

      gte_unspan();

      gte_set_selection (row, parent_col+1, row, max_parent_col,
                  row, max_parent_col) ;

      gte_span();

      gte_set_selection (row, max_parent_col, row, max_parent_col,
                  row, max_parent_col) ;

      FillSelectionWhite() ;
    }

  gte_set_selection (row, leaf_col, row, leaf_col, row, leaf_col) ;
  FillSelectionWhite() ;

  gte_set_selection (row, definition_col, row, definition_col,
              row, definition_col) ;
  FillSelectionWhite() ;

  int count = list_count(REQ_reqs_satisfied()) ;
  int index = list_find (REQ_reqs_satisfied(), 0, row) ;
  if (count != index)
    {
      list_delete (REQ_reqs_satisfied(), index) ;
    }
}

void
print_satisfaction_list (string title)
{
  int count = list_count(REQ_reqs_satisfied()) ;
  int i ;
  for (i=0; i< count; i=i+1)
    {
      message ("   "+list_get (REQ_reqs_satisfied(), i)) ;
    }
  message ("==============================") ;
}

void
REQ_ClearSatisfaction ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  int row ;

  for (row=min_req_row; row <= max_req_row; row=row+1)
    {
      REQ_MarkAsUnsatisfied (row) ;
    }
}



list
REQ_SelectedLeavesUniqueIdsList ()
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  list result = list_create("string", 0) ;


  if (low_row >= min_req_row && low_col >= leaf_col) 
    {
      if (high_row > max_req_row)
        {
          high_row = max_req_row ;
        }

      REQ_LabelType label ;
      int row ;
      for (row=low_row; row <= high_row; row=row+1)
        {
          label = REQ_ParsedLabel (row, leaf_col) ;

          if (!IsBlank (label.unique_id))
            {
              list_append (result, label.unique_id) ;
            }
        }
    }
  return (result) ;
}


list
REQ_SelectedUniqueIdsList ()
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  int high_col = gte_get_last_col_in_selected () ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_req_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  list result = list_create("string", 0) ;

  if (low_row >= min_req_row) 
    {
      if (high_row > max_req_row)
        {
          high_row = max_req_row ;
        }

      if (high_col > max_req_col)
        {
          high_col = max_req_col ;
        }

      if (low_col > max_req_col)
        {
          low_col = max_req_col ;
        }

      REQ_LabelType label ;
      int row ;
      int col ;

      for (row=low_row; row <= high_row; row=row+1)
        {
          for (col=low_col; col <= high_col; col=col+1)
            {
              label = REQ_ParsedLabel (row, col) ;

              if (!IsBlank (label.unique_id))
                {
                  list_append (result, label.unique_id) ;
                }
            }
        }
    }
  return (result) ;
}


set // of nodes and links
REQ_AssignedLinksAndNodes (list UniqueIdList)
{
  set Result = set_create ("all") ;

  int index ;
  string unique_id ;
  int count = list_count (UniqueIdList) ;

  string LinkQuery = 
    "link[items[${REQ_AssignmentItem} && (${value_list})]" +
    "&& link_refs]" ;

  string NodeQuery = 
    "node[items[${REQ_AssignmentItem} && (${value_list})]" +
    "&& node_refs]" ;

  string CntxQuery = 
    "cntx[items[${REQ_AssignmentItem} && (${value_list})]" +
    "&& cntx_refs]" ;

  string value_list = "" ;

  for (index=0; index < count; index=index+1)
    {
      if (index != 0)
        {
          value_list = value_list + " || " ;
        }
      unique_id = list_get (UniqueIdList, index) ;
      value_list = value_list + "value='"+ to_oms_string (unique_id) + "'" ;
    }

  // Links
  string LinkQuery1 
    = "link[items[" + REQ_AssignmentItem + "] && link_refs]" ;
  string LinkQuery2 
    = "link[items[ ${value_list} ] && link_refs]" ;

  set LinkSet1 = set_create ("link") ;
  set LinkSet2 = set_create ("link") ;

  LinkSet1 = set_select (LinkQuery1) ;
  LinkSet2 = set_select (LinkQuery2) ;
  set_intersection (LinkSet2, LinkSet1) ;


  // Nodes
  string NodeQuery1
    = "node[items[" + REQ_AssignmentItem + "] && node_refs]" ;
 
  string NodeQuery2
    = "node[items[${value_list}] && node_refs]" ;

  set NodeSet1 = set_create ("node") ;
  set NodeSet2 = set_create ("node") ;

  NodeSet1 = set_select (NodeQuery1) ;
  NodeSet2 = set_select (NodeQuery2) ;
  set_intersection (NodeSet2, NodeSet1) ;

  // Cntxes
  string CntxQuery1
    = "cntx[items[" + REQ_AssignmentItem + "] && cntx_refs]" ;
 
  string CntxQuery2
    = "cntx[items[${value_list}] && cntx_refs]" ;

  set CntxSet1 = set_create ("cntx") ;
  set CntxSet2 = set_create ("cntx") ;

  CntxSet1 = set_select (CntxQuery1) ;
  CntxSet2 = set_select (CntxQuery2) ;
  set_intersection (CntxSet2, CntxSet1) ;

  set_union (Result, LinkSet2) ;
  set_union (Result, NodeSet2) ;
  set_union (Result, CntxSet2) ;

  return (Result) ;
}

int
REQ_InheritIsActive ()
{
  int row = gte_get_current_cell_row ();
  int col = gte_get_current_cell_col () ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col       = gte_get_first_col (REQ_LeafReqVsect()) ;

  int result ;

  if (col >= leaf_col && row >= min_req_row && row <= max_req_row
      && !NoLabel (row, leaf_col))
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (result) ;
}

string REQ_UniqueId_SAVE = NULL ;

void
REQ_Inherit_cb ()
{
  gte_disable_refresh () ;
  gte_disable_action_completed();

  list OidList = editor_selector_selected_objects() ;
  int OidCount = list_count (OidList) ;

  REQ_AssignRqmtToOidList (OidList, REQ_UniqueId_SAVE, REQ_Phase) ;

  //if (list_find (OidList, 0, REQ_SatisfactionId) != OidCount) 
  //{
  //REQ_MarkListAsSatisfied (REQ_GetLeavesWithId (REQ_UniqueId_SAVE)) ;
  //}

  REQ_GoBackToSettingsSaved () ;
  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}

void
REQ_Inherit ()
{
  gte_disable_refresh () ;
  gte_disable_action_completed();
  REQ_PreserveCurrentSettings () ;

  int row = gte_get_current_cell_row ();
  int col = gte_get_current_cell_col () ;

  int min_parent_col = gte_get_first_col  (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col  (REQ_ParentReqVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  list ParentUniqueIds ;
  int ParentCount ;


  REQ_LabelType Label ;

  list AssignedList ;
  set AssignedSet ;
  set CurrentSet ;

  list ThisUniqueIdList = list_create ("string", 1) ;

   
  int AssignedCount ;

  if (REQ_InheritIsActive() == ACTIVE_FUNC_IS_ACTIVE)
    {
      Label   = REQ_ParsedLabel (row, leaf_col) ;
      if (!IsBlank (Label.unique_id))
        {
          string ButtonLabel = "Allocate \""+ Label.unique_id +"\"";

          list_set (ThisUniqueIdList, 0, Label.unique_id) ;

          gte_set_selection (row, min_parent_col, row, max_parent_col,
                      row, min_parent_col) ;

          ParentUniqueIds = set_to_list(list_to_set 
                                        (REQ_SelectedUniqueIdsList ())) ;

          ParentCount = list_count (ParentUniqueIds) ;
          if (ParentCount > 0)
            {
              AssignedSet = REQ_AssignedLinksAndNodes (ParentUniqueIds) ;

              CurrentSet = REQ_AssignedLinksAndNodes (ThisUniqueIdList) ;
              set_difference (AssignedSet, CurrentSet) ;

              AssignedList = set_to_list (AssignedSet) ;

              AssignedCount = list_count (AssignedList) ;

              if (AssignedCount > 0)
                {
                  REQ_UniqueId_SAVE = Label.unique_id ;

                  int index = editor_item_selector (
                                                    AssignedList,                         // list of possibilities 
                                                    "REQ_Inherit_cb();",                  // callback
                                                    ButtonLabel,                          // label
                                                    False
                                                    ) ;

                }
              else
                {
                  gte_print_message ("No requirements to inherit.") ;
                  list Empty = list_create ("string", 0) ;
                  list_append (Empty, " ") ;

                  int index = editor_item_selector (
                                                    Empty,                    // list of possibilities 
                                                    "NoOp_cb();",             // callback
                                                    ButtonLabel,              // label
                                                    True
                                                    ) ;
                }
            }
          else
            {
              gte_print_message 
                ("Requirement has not superseded any requirements.") ;
            }
        }
    }
  REQ_GoBackToSettingsSaved () ;
  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}


int
REQ_AssignIsActive ()
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  int high_col = gte_get_last_col_in_selected () ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col       = gte_get_first_col (REQ_LeafReqVsect()) ;

  int result ;

  if (REQ_SatisfactionId != 0 && low_col >= leaf_col && 
      low_row >= min_req_row && high_row <= max_req_row &&
      !NoLabel (low_row, low_col))
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (result) ;
}

void
REQ_Assign ()
{
  REQ_PreserveTableDirty () ;
  gte_disable_refresh () ;
  gte_disable_action_completed();

  int low_row = gte_get_first_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  boolean refresh_occurred = False ;

  list unique_ids = REQ_SelectedLeavesUniqueIdsList () ;
  int num_reqs_selected = list_count (unique_ids) ;

  if (REQ_SatisfactionId != 0 && num_reqs_selected > 0)
    {
      string unique_id ;
      int index ;
      string msg ;

      for (index=0; index < num_reqs_selected; index=index+1) 
        {
          unique_id = list_get (unique_ids, index) ;
          //REQ_MarkListAsSatisfied (REQ_GetLeavesWithId (unique_id)) ;
          msg = REQ_AllocationMsgString (REQ_Phase, unique_id, 
                                         REQ_ObjectInfo.omsName, REQ_ObjectInfo.omsType,
                                         REQ_SatisfactionId) ;

          print_message (msg) ;
        }

      gte_goto (low_row, low_col) ;
      gte_enable_refresh () ;
      gte_refresh_table () ;
      refresh_occurred = True ;

      REQ_AssignRqmtListToOid (unique_ids, REQ_SatisfactionId, REQ_Phase) ;
    }

  if (REQ_SatisfactionId == 0)
    {
      gte_print_message ("There is not any current target object.") ; 
    }

  if (!refresh_occurred)
    {
      gte_goto (low_row, low_col) ;
      gte_enable_refresh () ;
      gte_refresh_table () ;
    }

  REQ_ResetTableDirty () ;
  gte_enable_action_completed();
}



void
REQ_Unassign ()
{
  REQ_PreserveTableDirty () ;
  gte_disable_refresh () ;
  gte_disable_action_completed();

  int low_row = gte_get_first_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  boolean refresh_occurred = False ;

  list unique_ids = REQ_SelectedLeavesUniqueIdsList () ;
  int num_reqs_selected = list_count (unique_ids) ;

  if (REQ_SatisfactionId != 0 && num_reqs_selected > 0)
    {
      string unique_id ;
      int index ;
      string msg ;

      for (index=0; index < num_reqs_selected; index=index+1) 
        {
          unique_id = list_get (unique_ids, index) ;
          //REQ_UnmarkListAsSatisfied (REQ_GetLeavesWithId (unique_id)) ;
          msg = REQ_DeAllocationMsgString (REQ_Phase, unique_id, 
                                           REQ_ObjectInfo.omsName, REQ_ObjectInfo.omsType,
                                           REQ_SatisfactionId) ;

          print_message (msg) ;
        }

      gte_goto (low_row, low_col) ;
      gte_enable_refresh () ;
      gte_refresh_table () ;
      refresh_occurred = True ;

      REQ_UnassignRqmtListToOid (unique_ids, REQ_SatisfactionId, REQ_Phase) ;
    }

  if (REQ_SatisfactionId == 0)
    {
      gte_print_message ("There is not any current target object.") ; 
    }

  if (!refresh_occurred)
    {
      gte_goto (low_row, low_col) ;
      gte_enable_refresh () ;
      gte_refresh_table () ;
    }

  REQ_ResetTableDirty () ;
  gte_enable_action_completed();
}

string
REQ_MakeUniqueIdSearchKey (string unique_id)
{

  // This is to ensure that a different collection of newlines, spaces, etc.
  // don't cause the search to fail.

  string search_key = unique_id ;

  if (unique_id != "" && unique_id != NULL)
    {
      int first_space_index = string_find (unique_id, 0, " ") ;
      if (first_space_index == string_length (unique_id))
        {
          search_key = unique_id ;
        }
      else
        {
          search_key = string_extract (unique_id, 0, first_space_index) ;
        }
    }
  return (search_key) ;
}

list
REQ_GetCellsWithId (string unique_id)
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  int high_col = gte_get_last_col_in_selected () ;

  list result = list_create ("REQ_CellType", 0) ;

  REQ_CellType cell ;

  int row ;
  int col ;

  REQ_LabelType label ;

  gte_stpem("BufferFindOpt +c -i +l +m +r");

  int row_selected ;
  int col_selected ;
  RowSpanType RowSpan ;

  string search_key = REQ_MakeUniqueIdSearchKey (unique_id) ;

  for (col= low_col ; col <= high_col ; col= col+1)
    {
      row = low_row ;

      gte_set_selection (row, col, high_row, col, row, col) ;

      while (row <= high_row && gte_find (search_key))
        {
          row_selected = gte_get_current_cell_row() ;

          label = REQ_ParsedLabel (row_selected, col) ;

          if (label.unique_id == unique_id)
            {
              cell.row = row_selected ;
              cell.col = col ;

              list_append (result, cell) ;
            }

          RowSpan = REQ_RowSpanRange (row, col) ;

          row = RowSpan.end_row + 1 ;

          if (row <= high_row)
            {
              gte_set_selection (row, col, high_row, col, high_row, col) ;
            }
        }
    }
  return (result) ;
}


list 
REQ_GetLeavesWithId (string unique_id)
{

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  list req_list = list_create ("int", 0) ;
  int row_selected ;
  int start_row ;

  REQ_LabelType label ;

  gte_stpem("BufferFindOpt +c -i +l +m +r +q");
  start_row = min_req_row ;

  string search_key = REQ_MakeUniqueIdSearchKey (unique_id) ;

  gte_set_selection (start_row, leaf_col, max_req_row, leaf_col, 
              start_row, leaf_col) ;

  while (start_row <= max_req_row && gte_find (search_key)) 
    {
      row_selected = gte_get_current_cell_row() ;

      label = REQ_ParsedLabel (row_selected, leaf_col) ;

      if (label.unique_id == unique_id)
        {
          list_append (req_list, row_selected) ;
        }

      // To protect against possible spanning rows, which makes the current
      // row the first row in the span.
      if (row_selected > start_row)
        {
          start_row = row_selected + 1 ;
        }
      else
        {
          start_row = start_row + 1 ;
        }

      if (start_row <= max_req_row)
        {
          gte_set_selection (start_row, leaf_col, max_req_row, leaf_col,
                      start_row, leaf_col) ;
        }
    }
  return (req_list) ;
}


void
REQ_MarkListAsSatisfied (list req_list)
{
  int i ;
  int count = list_count (req_list) ;
  if (count > 0)
    {
      string type = list_get_type (req_list, 0) ;
      if (type == "int")
        {
          for (i=0; i< count; i=i+1)
            {
              REQ_MarkAsSatisfied (list_get (req_list, i)) ;
            }
        }
      else if (type == "REQ_CellType")
        {
          REQ_CellType Cell ;
          for (i=0; i< count; i=i+1)
            {
              Cell = list_get (req_list, i) ;
              REQ_MarkAsSatisfied (Cell.row) ;
            }
        }
    }
}

void
REQ_UnmarkListAsSatisfied (list req_list)
{
  int i ;
  int count = list_count (req_list) ;
  for (i=0; i<count; i=i+1)
    {
      REQ_MarkAsUnsatisfied (list_get(req_list, i)) ;
    }
}

int
REQ_GetNextSatisfactionIsActive ()
{
  int result ;

  if (list_count (REQ_reqs_satisfied()) > 0)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (result) ;
}

void
REQ_GetNextSatisfaction ()
{
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int count = list_count (REQ_reqs_satisfied()) ;
  REQ_CellType cell ;

  if (count > 0)
    {
      if (REQ_NextSatisfactionIndex == -1)
        {
          REQ_NextSatisfactionIndex = 0 ;
        }
      else if (REQ_NextSatisfactionIndex >= count -1)
        {
          REQ_NextSatisfactionIndex = 0 ;
        }
      else
        {
          REQ_NextSatisfactionIndex = REQ_NextSatisfactionIndex + 1 ;
        }
      int row = list_get (REQ_reqs_satisfied(), REQ_NextSatisfactionIndex) ;
      gte_goto (row, leaf_col) ;
      gte_set_selection (row, leaf_col, row, leaf_col, row, leaf_col) ;
    }
}


void
REQ_ResetSatisfaction ()
{
  REQ_NextSatisfactionIndex = -1 ;
  REQ_UnmarkListAsSatisfied (list_copy(REQ_reqs_satisfied())) ;
}

void
REQ_TestAndMarkAsSatisfied (string unique_id)
{

  if (REQ_SatisfactionId != 0)
    {

      string query="item [${REQ_AssignmentItem} && value=='${unique_id}'" +
        " && ${REQ_LinkOrNodeOrCntx} [${REQ_SatisfactionId}&& ${REQ_LinkOrNodeOrCntx}_refs]]" ; 

      item Item = find_by_query (query) ;

      if (Item != NULL)
        {
          REQ_MarkListAsSatisfied (REQ_GetLeavesWithId (unique_id)) ;
        }
    }
}

void
REQ_MarkSatisfactionRequirements ()
{

  if (REQ_SatisfactionId != 0)
    {
      string query=
        "item [" + REQ_AssignmentItem + "&& " +
        REQ_LinkOrNodeOrCntx + "[" +
        REQ_SatisfactionId + " && " + REQ_LinkOrNodeOrCntx + "_refs]]" ; 

      list req_list = list_create ("int", 0) ;
      item Item ;

      for_each_in_select (query, Item)
        {
          list_concatenate (req_list, REQ_GetLeavesWithId (Item.value)) ;
        }

        REQ_MarkListAsSatisfied (req_list) ;
    }
}

int 
REQ_ShowAllocatedIsActive ()
{
  int result ;

  if (REQ_SatisfactionId > 0)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (result) ;
}


void
REQ_ShadeAllocatedRqmts()
{
  REQ_PreserveTableDirty () ;
  gte_disable_refresh () ;
  REQ_ClearSatisfaction () ;

  REQ_MarkSatisfactionRequirements () ;

  gte_enable_refresh () ;
  REQ_ResetTableDirty () ;
  gte_refresh_table () ;
}

int
REQ_SatisfactionQueryIsActive ()
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  int high_col = gte_get_last_col_in_selected () ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col       = gte_get_first_col (REQ_LeafReqVsect()) ;

  int result ;

  if (low_row >= min_req_row && high_row <= max_req_row)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (result) ;
}

string
REQ_FileTypeToEditor (string FileType)
{
  string Result ;

  list List = file_editor_names (FileType) ;
  if (list_count (List) > 0)
    {
      Result = list_get (List, 0) ;
    }
  else
    {
      Result = NULL ;
    }
  return (Result) ;
}

void
REQ_GoToReference (list ReferenceList)
{

  int FileId ;

  string FileType ;
  string FileName ;
  string appid ;

  file File ;

  if (ReferenceList != NULL && list_count (ReferenceList) > 0)
    {
      string LinkOrNodeOrCntx = list_get_type (ReferenceList, 0) ;

      if (LinkOrNodeOrCntx == "node_ref" || LinkOrNodeOrCntx == "link_ref" 
          || LinkOrNodeOrCntx == "cntx_ref")
        {
          if (LinkOrNodeOrCntx == "node_ref") 
            {
              node_ref NodeRef = list_get (ReferenceList, 0) ;
              FileId = NodeRef.file_id ;
              appid = NodeRef.appid ;
            }
          else if (LinkOrNodeOrCntx == "link_ref")
            {
              link_ref LinkRef = list_get (ReferenceList, 0) ;
              FileId = LinkRef.file_id ;
              appid = LinkRef.appid ;
            }
          else if (LinkOrNodeOrCntx == "cntx_ref")
            {
              cntx_ref CntxRef = list_get (ReferenceList, 0) ;
              FileId = CntxRef.file_id ;
              appid = CntxRef.appid ;
            }

          File = find_by_query ("file [${FileId}]") ;

          string Editor = REQ_FileTypeToEditor (File.type) ;

          if (Editor != NULL)
            {
              editor_send_msg(Editor, 
                              "EditorQrlEval \"NavLoadAndFind(\\\"" +
                              File.name +
                              "\\\",\\\"" +
                              appid +
                              "\\\")\;\"", 
                              CH_FIRST);
            } else
              {
                gte_print_message 
                  ("RQTBL: Cannot currently navigate to that object.") ;
              }
        }
    }
}

list REQ_NavigationSelectionList = list_create ("all", 0) ;

void
REQ_Navigate_cb ()
{
  int i ;
  int count ;
  list SendOff = list_create ("all", 0) ;
  int Choice = list_get (editor_selector_selected_objects(), 0) ;
  node_ref NodeRef ;
  link_ref LinkRef ;
  cntx_ref CntxRef ;

  if (REQ_NavigationSelectionList != NULL && 
      list_count (REQ_NavigationSelectionList) > 0)
    {
      string LinkOrNodeOrCntx = list_get_type (REQ_NavigationSelectionList, 0) ;

      count = list_count (REQ_NavigationSelectionList) ;

      for (i=0; i< count; i=i+1)
        {
          if (LinkOrNodeOrCntx == "node_ref")
            {
              NodeRef = list_get (REQ_NavigationSelectionList, i) ;
              if (NodeRef.id == Choice)
                {
                  list_append (SendOff, NodeRef) ;
                  break ;
                }
            }
          else if (LinkOrNodeOrCntx == "link_ref")
            {
              LinkRef = list_get (REQ_NavigationSelectionList, i) ;
              if (LinkRef.id == Choice)
                {
                  list_append (SendOff, LinkRef) ;
                  break ;
                }
            }
          else if (LinkOrNodeOrCntx == "cntx_ref")
            {
              CntxRef = list_get (REQ_NavigationSelectionList, i) ;
              if (CntxRef.id == Choice)
                {
                  list_append (SendOff, CntxRef) ;
                  break ;
                }
            }
        }
    }

  REQ_GoToReference (SendOff) ;
}

void
REQ_Navigate (list ObjectList)
{
  if (ObjectList != NULL && list_count (ObjectList) > 0)
    {
      string LinkOrNodeOrCntx = list_get_type (ObjectList, 0) ;
      string Name ;
      string ReferenceQuery ;
      int Id ;

      if (LinkOrNodeOrCntx == "node" || LinkOrNodeOrCntx == "link" || LinkOrNodeOrCntx == "cntx")
        {
          if (LinkOrNodeOrCntx == "node") 
            {
              node Node = list_get (ObjectList, 0) ;
              Name = Node.name ;
              ReferenceQuery = "node_ref [node_id == ${Node.id}]" ;
              Id = Node.id ;
            }
          else if (LinkOrNodeOrCntx == "link")
            {
              link Link = list_get (ObjectList, 0) ;
              Name = Link.name ;
              ReferenceQuery = "link_ref [link_id == ${Link.id}]" ;
              Id = Link.id ;
            }
          else if (LinkOrNodeOrCntx == "cntx")
            {
              cntx Cntx = list_get (ObjectList, 0) ;
              Name = Cntx.name ;
              ReferenceQuery = "cntx_ref [cntx_id == ${Cntx.id}]" ;
              Id = Cntx.id ;
            }
      
          list_clear (REQ_NavigationSelectionList) ;
          REQ_NavigationSelectionList = list_select (ReferenceQuery) ;

          if (list_count (REQ_NavigationSelectionList) > 1)
            {
              int index = editor_item_selector (
                                                REQ_NavigationSelectionList,           // list of possibilities 
                                                "REQ_Navigate_cb();",                  // callback
                                                "Navigate to Object",                  // label
                                                True
                                                ) ;

            }
          else if (list_count (REQ_NavigationSelectionList) == 1)
            {
              REQ_GoToReference (REQ_NavigationSelectionList) ;
            }
          else
            {
              gte_print_error ("RQTBL: Cannot find reference for "+LinkOrNodeOrCntx+
                               " " + Name + " ("+Id+").") ;
            }
        }
    }
}


list REQ_BrowseAndNavigateSelectionList = list_create ("all", 0) ;

void
BrowseAndNavigate_cb ()
{
  int i ;
  int count ;
  list SendOff = list_create ("all", 0) ;
  int Choice = list_get (editor_selector_selected_objects(), 0) ;
  node Node ;
  link Link ;
  cntx Cntx ;

  if (REQ_BrowseAndNavigateSelectionList!= NULL &&
      list_count (REQ_BrowseAndNavigateSelectionList) > 0)

    {
      string LinkOrNodeOrCntx ; 

      count = list_count (REQ_BrowseAndNavigateSelectionList) ;
      for (i=0; i< count; i=i+1)
        {  
          LinkOrNodeOrCntx = list_get_type (REQ_BrowseAndNavigateSelectionList, i) ;

          if (LinkOrNodeOrCntx == "node")
            {
              Node = list_get (REQ_BrowseAndNavigateSelectionList, i) ;
              if (Node.id == Choice)
                {
                  list_append (SendOff, Node) ;
                  break ;
                }
            }
          else if (LinkOrNodeOrCntx == "link")
            {
              Link = list_get (REQ_BrowseAndNavigateSelectionList, i) ;
              if (Link.id == Choice)
                {
                  list_append (SendOff, Link) ;
                  break ;
                }
            }
          else if (LinkOrNodeOrCntx == "cntx")
            {
              Cntx = list_get (REQ_BrowseAndNavigateSelectionList, i) ;
              if (Cntx.id == Choice)
                {
                  list_append (SendOff, Cntx) ;
                  break ;
                }
            }
        }
    }

  REQ_Navigate (SendOff) ;
}


void
NoOp_cb ()
{
}

void
BrowseAndNavigate (list List)
{
  list_clear (REQ_BrowseAndNavigateSelectionList) ;

  REQ_BrowseAndNavigateSelectionList = list_copy (List) ;

  if (list_count (REQ_BrowseAndNavigateSelectionList) == 0)
    print_error("No target objects found.");
  else
    {
      int index = editor_item_selector (
                                        REQ_BrowseAndNavigateSelectionList,    // list of possibilities 
                                        "BrowseAndNavigate_cb();",             // callback
                                        "Navigate to Object",                  // label
                                        True);
    }

  return;
}




list // of nodes and links
REQ_AllSatisfiedObjectsList (list UniqueIdList)
{
    int Count   = list_count (UniqueIdList) ;
    list Result = list_create ("all", 0) ;
 
    if (Count > 0)
    {
	string unique_id ;
	int index ;
	string values = "" ;

	for (index=0; index < Count; index=index+1)
	{
	    if (index != 0)
		values = values + " || " ;

	    unique_id = list_get (UniqueIdList, index) ;

	    values = values + "value='"+ to_oms_string (unique_id) + "'" ;
	}

	id_list_create("item[${REQ_AssignmentItem} && (${values})]", "item_id_list");
	list_concatenate(Result, list_select("node[items[item_id_list]]"));
	list_concatenate(Result, list_select("cntx[items[item_id_list]]"));
	list_concatenate(Result, list_select("link[items[item_id_list]]"));
	id_list_free("item_id_list");
    }
    return Result;
}


//
//list // of nodes and links
//OLD_REQ_AllSatisfiedObjectsList (list UniqueIdList)
//{
//   int Count   = list_count (UniqueIdList) ;
//   list Result = list_create ("all", 0) ;
//   set ResultSet = set_create ("all") ;
//
//   if (Count > 0)
//   {
//      string unique_id ;
//      int index ;
//      string value_list = "" ;
//
//      for (index=0; index < Count; index=index+1)
//      {
//         if (index != 0)
//         {
//            value_list = value_list + " || " ;
//         }
//         unique_id = list_get (UniqueIdList, index) ;
//
//         value_list = value_list + "value='"+ to_oms_string (unique_id) + "'" ;
//      }
//      //string NodeQuery 
//           //= "node[items[" + REQ_AssignmentItem + "&& (" + value_list 
//                     //+ ")] && node_refs]" ;
//
//      string NodeQuery1
//           = "node[items[" + REQ_AssignmentItem + "] && node_refs]" ;
// 
//      string NodeQuery2
//           = "node[items[" + value_list + "] && node_refs]" ;
//
//      set NodeSet1 = set_create ("node") ;
//      set NodeSet2 = set_create ("node") ;
//
//      NodeSet1 = set_select (NodeQuery1) ;
//      NodeSet2 = set_select (NodeQuery2) ;
//      set_intersection (NodeSet2, NodeSet1) ;
//
//
//
//      //string LinkQuery 
//           //= "link[items[" + REQ_AssignmentItem + "&& (" + value_list 
//                     //+ ")] && link_refs]" ;
//      string LinkQuery1 
//           = "link[items[" + REQ_AssignmentItem + "] && link_refs]" ;
//      string LinkQuery2 
//           = "link[items[" + value_list + "] && link_refs]" ;
//
//      set LinkSet1 = set_create ("link") ;
//      set LinkSet2 = set_create ("link") ;
//
//      LinkSet1 = set_select (LinkQuery1) ;
//      LinkSet2 = set_select (LinkQuery2) ;
//      set_intersection (LinkSet2, LinkSet1) ;
//      
//      string CntxQuery1
//           = "cntx[items[" + REQ_AssignmentItem + "] && cntx_refs]" ;
// 
//      string CntxQuery2
//           = "cntx[items[" + value_list + "] && cntx_refs]" ;
//
//      set CntxSet1 = set_create ("cntx") ;
//      set CntxSet2 = set_create ("cntx") ;
//
//      CntxSet1 = set_select (CntxQuery1) ;
//      CntxSet2 = set_select (CntxQuery2) ;
//      set_intersection (CntxSet2, CntxSet1) ;
//      
//      set_union (ResultSet, NodeSet2) ;
//      set_union (ResultSet, LinkSet2) ;
//      set_union (ResultSet, CntxSet2) ;
//
//      Result = set_to_list (ResultSet) ;
//   }
//
//   return (Result) ;
//}



void
REQ_AllSatisfied ()
{
  REQ_PreserveCurrentSettings () ;
  list unique_ids = REQ_SelectedUniqueIdsList () ;
  int num_reqs_selected = list_count (unique_ids) ;

  list QueryList = REQ_AllSatisfiedObjectsList (unique_ids) ;

  BrowseAndNavigate (QueryList) ;
  REQ_GoBackToSettingsSaved () ;
}


void
OLD_REQ_AllSatisfied ()
{
  REQ_PreserveCurrentSettings () ;
  list unique_ids = REQ_SelectedUniqueIdsList () ;
  int num_reqs_selected = list_count (unique_ids) ;

  list QueryList = OLD_REQ_AllSatisfiedObjectsList (unique_ids) ;

  BrowseAndNavigate (QueryList) ;
  REQ_GoBackToSettingsSaved () ;
}

set
REQ_SelectedUniqueIdsSet ()
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  int high_col = gte_get_last_col_in_selected () ;

  set result = set_create("string") ;

  REQ_LabelType label ;
  int row ;
  int col ;
  for (row=low_row; row <= high_row; row=row+1)
    {
      for (col = low_col; col <= high_col; col = col+1)
        {
          label = REQ_ParsedLabel (row, col) ;

          if (!IsBlank (label.unique_id))
            {
              set_add (result, label.unique_id) ;
            }
        }
    }
  return (result) ;
}

set
REQ_AllAssignedRqmtsSet ()
{
  set result = set_create ("string") ;   
  item Item ;

  const string query = "item[${REQ_AssignmentItem}]" ; 
  REQ_NodeOrLinkOrCntxType Object ;

  print_message ("Query working...") ;
  for_each_in_select (query, Item)
    {
      Object = REQ_NodeOrLinkOrCntx (Item.obj_id) ;

      if (Object.Node != NULL || Object.Link != NULL || Object.Cntx != NULL)
        {
          set_add (result, Item.value) ;
        }
    }
    print_message ("") ;
    return (result) ;
}



void
REQ_MakeSelectedCellTextBold ()
{
  gte_filltable_string("FillTable { { Hsect { Index Current}" +
                       "{ Vsect { Index Current } { Row { Index Current }" +
                       "{ Cell { Index Current } {Bold True}}}}}}");
}

void
REQ_MakeSelectedCellTextNormal ()
{
  gte_filltable_string("FillTable { { Hsect { Index Current}" +
                       "{ Vsect { Index Current } { Row { Index Current }" +
                       "{ Cell { Index Current } {Bold False}}}}}}");
}

void
REQ_UnmarkQueryCell (REQ_CellType cell)
{

  gte_set_selection (cell.row, cell.col, 
              cell.row, cell.col, 
              cell.row, cell.col) ;

  REQ_MakeSelectedCellTextNormal () ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  if (cell.col == leaf_col)
    {
      int definition_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
      gte_set_selection (cell.row, definition_col, 
                  cell.row, definition_col, 
                  cell.row, definition_col) ;
      REQ_MakeSelectedCellTextNormal () ;
    }

  int count = list_count(REQ_query_results()) ;
  int index = list_find (REQ_query_results(), 0, cell) ;
  if (count != index)
    {
      list_delete (REQ_query_results(), index) ;
      REQ_current_query_result = REQ_current_query_result -1 ;
    }
}

void
REQ_MarkQueryCell (REQ_CellType cell)
{


  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  gte_set_selection (cell.row, cell.col, 
              cell.row, cell.col, 
              cell.row, cell.col) ;


  REQ_MakeSelectedCellTextBold () ;

  if (cell.col == leaf_col)
    {
      int definition_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
      gte_set_selection (cell.row, definition_col, 
                  cell.row, definition_col, 
                  cell.row, definition_col) ;
      REQ_MakeSelectedCellTextBold () ;
    }

  int count = list_count(REQ_query_results()) ;
  int index = list_find (REQ_query_results(), 0, cell) ;

  if (count == index)
    {
      list_append (REQ_query_results(), cell) ;
    }

}

void
REQ_UnmarkListForQuery (list cell_list)
{
  REQ_CellType cell ;
  int count = list_count (cell_list) ;
  int index ;

  for (index=0; index < count; index=index+1)
    {
      REQ_UnmarkQueryCell (list_get (cell_list, index)) ;
    }
}

void
REQ_MarkListForQuery (list cell_list)
{
  REQ_CellType cell ;
  int count = list_count (cell_list) ;
  int index ;

  for (index=0; index < count; index=index+1)
    {
      REQ_MarkQueryCell (list_get (cell_list, index)) ;
    }
}

void
REQ_ClearQuery ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_col  = gte_get_first_col (REQ_ParentReqVsect()) ;
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  int row ;
  int col ;
  REQ_CellType cell ;
  RowSpanType RowSpan ;

  for (col=min_col; col<=leaf_col; col=col+1)
    {
      cell.col = col ;
      for (row=min_req_row; row <= max_req_row; row = row+1)
        {
          cell.row = row ;
          REQ_UnmarkQueryCell (cell) ;
          if (col < leaf_col)
            {
              RowSpan = 
                REQ_RowSpanRange (row, col) ;

              row = RowSpan.end_row ;
            }
        }
    }
}

void
REQ_ResetQuery ()
{
  REQ_UnmarkListForQuery (list_copy(REQ_query_results())) ;
  REQ_current_query_result = -1 ;
}

int
REQ_GetNextQueryIsActive ()
{
  int result ;

  if (REQ_current_query_result != -1 && list_count (REQ_query_results()) > 0)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (result) ;
}

void
REQ_GetNextQuery ()
{
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int count = list_count (REQ_query_results()) ;
  REQ_CellType cell ;

  if (count > 0)
    {
      if (REQ_current_query_result == -1)
        {
          REQ_current_query_result = 0 ;
        }
      else if (REQ_current_query_result >= count -1)
        {
          REQ_current_query_result = 0 ;
        }
      else
        {
          REQ_current_query_result = REQ_current_query_result + 1 ;
        }
      cell = list_get (REQ_query_results(), REQ_current_query_result) ;
      gte_goto (cell.row, cell.col) ;
      int high_col = cell.col ;

      if (cell.col == leaf_col)
        {
          high_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
        }
      gte_set_selection (cell.row, cell.col, cell.row, high_col, 
                  cell.row, cell.col) ;
    }
}


int
REQ_UnassignAny_IsActive ()
{
  int row = gte_get_current_cell_row ();
  int col = gte_get_current_cell_col () ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int leaf_col = gte_get_last_col (REQ_LeafReqVsect()) ;

  int result = ACTIVE_FUNC_IS_INACTIVE ;

  // If user selects leaf definitions.
  if (col > leaf_col)
    {
      col = leaf_col ;
    }

  if (row >= min_req_row && row <= max_req_row &&
      col >= min_col && col <= leaf_col &&
      !NoLabel (row, col))
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }

  return (result) ;
}

void
REQ_UnassignAny_cb()
{
  gte_disable_refresh () ;
  gte_disable_action_completed();

  list OidList = editor_selector_selected_objects() ;
  int OidCount = list_count (OidList) ;

  REQ_UnassignRqmtToOidList (OidList, REQ_UnassignAnyUniqueId_SAVE, REQ_Phase);

  //if (list_find (OidList, 0, REQ_SatisfactionId) != OidCount) 
  //{
  //REQ_UnmarkListAsSatisfied 
  //(REQ_GetLeavesWithId (REQ_UnassignAnyUniqueId_SAVE));
  //}

  REQ_GoBackToSettingsSaved () ;
  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}


string REQ_UnassignAnyUniqueId_SAVE = NULL ;


void
REQ_UnassignAny ()
{
  int i ;

  int row = gte_get_current_cell_row ();
  int col = gte_get_current_cell_col () ;

  int leaf_col = gte_get_last_col (REQ_LeafReqVsect()) ;

  if (col > leaf_col)
    {
      col = leaf_col ;
    }

  REQ_PreserveCurrentSettings () ;
  gte_disable_refresh () ;
  gte_disable_action_completed();

  REQ_LabelType label = REQ_ParsedLabel (row, col) ;
  REQ_UnassignAnyUniqueId_SAVE = label.unique_id ;

  list UniqueIdList = list_create ("string", 1) ;

  list_set (UniqueIdList, 0, REQ_UnassignAnyUniqueId_SAVE) ;
  string ButtonLabel = "Deallocate \""+ REQ_UnassignAnyUniqueId_SAVE + "\"" ;

  list SatisfiedObjects = REQ_AllSatisfiedObjectsList (UniqueIdList) ;

  if (list_count (SatisfiedObjects) > 0)
    {
      int index = editor_item_selector (
                                        SatisfiedObjects,                      // list of possibilities 
                                        "REQ_UnassignAny_cb();",               // callback
                                        ButtonLabel,                           // label
                                        False
                                        ) ;
    }
  else
    {
      gte_print_message ("No objects to deallocate.") ;
      list Empty = list_create ("string", 0) ;
      list_append (Empty, " ") ;

      int index = editor_item_selector (
                                        Empty,                    // list of possibilities 
                                        "NoOp_cb();",             // callback
                                        ButtonLabel,              // label
                                        True
                                        ) ;
    }


  REQ_GoBackToSettingsSaved () ;
  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}

void
REQ_ShowAllSatisfiedParents ()
{
  int min_parent_def_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_parent_def_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  int parent_name_col = gte_get_first_col (REQ_ParentDefinitionNameVsect());

  int min_hierarchy_col = gte_get_first_col  (REQ_ParentReqVsect()) ;
  int max_hierarchy_col = gte_get_last_col  (REQ_ParentReqVsect()) ;

  int min_hierarchy_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_hierarchy_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  REQ_PreserveTableDirty () ;
  REQ_ResetSatisfaction () ;

  gte_disable_refresh ();
  gte_disable_action_completed();
  gte_set_selection (min_parent_def_row, parent_name_col, 
              max_parent_def_row, parent_name_col,
              min_parent_def_row, parent_name_col) ;

  set parent_rqmts = REQ_SelectedUniqueIdsSet() ;
  set satisfied_rqmts = REQ_AllAssignedRqmtsSet () ;

  int count = set_intersection (satisfied_rqmts, parent_rqmts) ;

  list query_cells = list_create ("REQ_CellType", 0) ;
  int index ;


  for (index=0; index < count; index=index+1)
    {
      gte_set_selection (min_hierarchy_row, min_hierarchy_col,
                  max_hierarchy_row, max_hierarchy_col,
                  min_hierarchy_col, max_hierarchy_col) ;

      list_concatenate (query_cells, 
                        REQ_GetCellsWithId (set_get_element(satisfied_rqmts, index))) ;
    }


  if (count > 0) 
    {
      // Force Parent Vsect to be visible
      gte_set_vsect_visibility (REQ_ParentReqVsect(), True) ;

      //REQ_MarkListForQuery (query_cells) ;
      REQ_MarkListAsSatisfied (query_cells) ;
      gte_unset_selection ();
      REQ_GetNextQuery ();

      gte_enable_refresh() ;
      gte_refresh_table() ;
      REQ_ResetTableDirty () ;
      gte_enable_action_completed();
    }
  else
    {
      gte_print_message ("No superseded requirements are assigned.") ;

      gte_enable_refresh() ;
      gte_refresh_table() ;
      gte_unset_selection ();
      REQ_ResetTableDirty () ;
      gte_enable_action_completed();
    }
}

void
REQ_ShowAllUnsatisfiedLeaves ()
{
  REQ_PreserveTableDirty () ;
  REQ_PreserveCurrentSettings () ;

  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  gte_disable_refresh ();
  gte_disable_action_completed();

  REQ_ClearSatisfaction () ;

  gte_set_selection (min_req_row, leaf_col, max_req_row, leaf_col,
              min_req_row, leaf_col) ;

  set leaf_rqmts = REQ_SelectedUniqueIdsSet() ;
  set satisfied_rqmts = REQ_AllAssignedRqmtsSet () ;

  int count = set_difference (leaf_rqmts, satisfied_rqmts) ;
  int index ;
  int i ;
  list query_cells = list_create ("REQ_CellType", 0) ;
  list row_list = list_create ("int", 0) ;
  int row_count ;
  REQ_CellType cell ;

  for (index=0; index < count; index=index+1)
    {
      row_list = REQ_GetLeavesWithId (set_get_element(leaf_rqmts, index)) ;
      row_count = list_count (row_list) ;

      for (i=0; i<row_count; i=i+1)
        {
          cell.row = list_get (row_list, i) ; 
          cell.col = leaf_col ;
          list_append (query_cells, cell) ;
        }
    }

  if (count > 0) 
    {
      //REQ_MarkListForQuery (query_cells) ;
      REQ_MarkListAsSatisfied (query_cells) ;
      gte_unset_selection ();
      REQ_GetNextQuery ();
      gte_enable_refresh() ;
      gte_refresh_table() ;
      REQ_ResetTableDirty () ;
      gte_enable_action_completed();
    }
  else
    {
      gte_print_message ("No unsatisfied requirements found.") ;
      REQ_GoBackToSettingsSaved () ;
      gte_enable_refresh() ;
      gte_refresh_table() ;
      REQ_ResetTableDirty () ;
      gte_enable_action_completed();
    }
}

string
REQ_InformalName (int hsect, int vsect, int row, int col)
{
  int this_col = gte_get_col (vsect, col) ;
  int this_row = gte_get_row (hsect, row) ;
  REQ_LabelType label = REQ_ParsedLabel (this_row, this_col) ;
  return (label.informal_name) ;
}

string
REQ_UniqueId (int hsect, int vsect, int row, int col)
{
  int this_col = gte_get_col (vsect, col) ;
  int this_row = gte_get_row (hsect, row) ;
  
  REQ_LabelType label = REQ_ParsedLabel (this_row, this_col) ;
  return (label.unique_id) ;
}

REQ_CellType
REQ_FindUniqueId (string unique_id, int start_row, int start_col,
                  int end_row, int end_col) 
{
  REQ_CellType result ;
  result.row = -1 ;
  result.col = -1 ;
  
  gte_stpem("BufferFindOpt +c -i +l +m +r +q");
  string search_key = REQ_MakeUniqueIdSearchKey (unique_id) ;
  
  gte_set_selection 
    (start_row, start_col, end_row, end_col, start_row, start_col) ;
  
  // The current row/col is fixed if in spanning cell.
  int current_row ;
  int current_col ;
  
  int row = start_row ;
  int col = start_col ;
  REQ_LabelType label ;
  
  while (row <= end_row) 
    {
      while (col <= end_col && gte_find (search_key))
        {
          current_row = gte_get_current_cell_row() ;
          current_col = gte_get_current_cell_col () ;
          
          label = REQ_ParsedLabel (current_row, current_col) ;
          
          if (label.unique_id == unique_id)
            {
              result.row = current_row ;
              result.col = current_col ;
              break ;
            }
          else
            {
              col = col + 1 ;
              if (col <= end_col)
                {
                  gte_set_selection (row, col, end_row, end_col, row, col) ;
                }
            }
        }
      
      // Hasn't been set yet
      if (result.row == -1)
        {
          row = row + 1 ;
          col = start_col ;
          
          if (row <= end_row)
            {
              gte_set_selection (row, col, end_row, end_col, row, col) ;
            }
        }
      else
        {
          break ;
        }
    }
  return (result) ;
}

void
REQ_MoveParentDefinitionToLeaf (string unique_id, int leaf_row)
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int leaf_def_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
  
  int min_parent_col = gte_get_first_col  (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col  (REQ_ParentReqVsect()) ;
  
  int min_parent_def_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_parent_def_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  
  int parent_def_name_col = gte_get_first_col 
    (REQ_ParentDefinitionNameVsect());
  int parent_def_text_col = gte_get_first_col 
    (REQ_ParentDefinitionTextVsect());
  
  REQ_CellType parent_definition_cell = REQ_FindUniqueId (unique_id,  
                                                          min_parent_def_row, parent_def_name_col, 
                                                          max_parent_def_row, parent_def_name_col) ;
  
  REQ_CellType parent_req_cell = REQ_FindUniqueId (unique_id,
                                                   min_req_row, min_parent_col,
                                                   max_req_row, max_parent_col) ;
  
  // if the unique id is in the parent definition, copy the info over to leaf
  //
  if (-1 != parent_definition_cell.row) 
    {
      int parent_row = parent_definition_cell.row ;
      
      gte_set_selection (parent_row, parent_def_name_col,
                  parent_row, parent_def_name_col,
                  parent_row, parent_def_name_col) ;
      
      JED_Copy() ;
      
      gte_set_selection (leaf_row, leaf_col, leaf_row, leaf_col, 
                  leaf_row, leaf_col) ;
      
      JED_Paste () ;
      
      gte_set_selection (parent_row, parent_def_text_col,
                  parent_row, parent_def_text_col,
                  parent_row, parent_def_text_col) ;
      
      JED_Copy() ;
      
      
      gte_set_selection (leaf_row, leaf_def_col, leaf_row, leaf_def_col,
                  leaf_row, leaf_def_col) ;
      
      JED_Paste () ;
    }
  
  
  // if parent requirement is not in the hiearchy, delete the definition
  if (-1 == parent_req_cell.row)
    {
      if (min_parent_def_row == max_parent_def_row)
        {
          gte_set_selection (min_parent_def_row, parent_def_name_col,
                      min_parent_def_row, parent_def_name_col,
                      min_parent_def_row, parent_def_name_col) ;
          CurrentCellLabel("") ;
          
          gte_set_selection (min_parent_def_row, parent_def_text_col,
                      min_parent_def_row, parent_def_text_col,
                      min_parent_def_row, parent_def_text_col) ;
          CurrentCellLabel("") ;
        }
      else
        {
          gte_delete_row (parent_definition_cell.row) ;
        }
    }
}


void
REQ_CreateParentDefinitionFromLeaf (int leaf_row)
{
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int min_parent_def_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_parent_def_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  
  int leaf_def_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
  
  int parent_def_name_col = gte_get_first_col 
    (REQ_ParentDefinitionNameVsect());
  
  int parent_def_text_col = gte_get_first_col 
    (REQ_ParentDefinitionTextVsect());
  
  REQ_LabelType leaf_label = REQ_ParsedLabel (leaf_row, leaf_col) ;
  
  REQ_CellType parent_cell = REQ_FindUniqueId (leaf_label.unique_id,
                                               min_parent_def_row, parent_def_name_col,
                                               max_parent_def_row, parent_def_name_col) ;
  
  // if unique id is not already in the parent descriptions, create definition
  if (-1 == parent_cell.row)
    {
      if (!IsBlank (gte_get_cell_label 
                    (min_parent_def_row, parent_def_name_col)))
        {
          gte_insert_row (min_parent_def_row, 1) ;
          max_parent_def_row = max_parent_def_row + 1 ;
        }
      
      gte_set_selection (leaf_row, leaf_col, leaf_row, leaf_col, 
                  leaf_row, leaf_col) ;
      
      JED_Copy() ;
      
      gte_set_selection (min_parent_def_row, parent_def_name_col,
                  min_parent_def_row, parent_def_name_col,
                  min_parent_def_row, parent_def_name_col) ;
      
      JED_Paste () ;
      
      gte_set_selection (leaf_row, leaf_def_col, leaf_row, leaf_def_col,
                  leaf_row, leaf_def_col) ;
      
      JED_Copy() ;
      
      gte_set_selection (min_parent_def_row, parent_def_text_col,
                  min_parent_def_row, parent_def_text_col,
                  min_parent_def_row, parent_def_text_col) ;
      
      JED_Paste () ;
    }
}

string
REQ_SubsystemParentName (int hsect, int vsect, int row, int col)
{
  row = gte_get_first_row (REQ_SubsystemParentHsect()) ;
  int def_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
  string label = gte_get_cell_label (row, def_col) ;
  return (label) ;
}

void
REQ_DoCreate (int Row, boolean makeWhite)
{
  int min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  string RowTag ;
  
  if (Row > max_req_row)
    {
      Row = max_req_row + 1 ;
      RowTag = "Append" ;
    }
  else 
    {
      if (Row < min_req_row)
        {
          Row = min_req_row ;
        }
      
      gte_set_selection (Row, min_parent_col, 
                  Row, max_parent_col,
                  Row, min_parent_col) ;
      gte_unspan () ;
      
      REQ_AddReqRow (Row, min_parent_col-1) ;
      RowTag = to_string (Row - min_req_row + 1) ;
    }
  
  string FillTable = 
    string_search_and_replace (
                               
                               REQ_FillTableStringForRow 
                               (max_req_row, REQ_ParentReqVsect(), 
                                REQ_LeafDefinitionVsect(), 0),
                               
                               REQ_RowTag, RowTag) ;
  
  gte_filltable_string (FillTable) ;
  
  if (makeWhite) REQ_FixHorizontalSpanning (Row) ;
  
  REQ_RespanHierarchyRow (Row-1) ;
  REQ_RespanHierarchyRow (Row+1) ;
}

void
REQ_Create ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  int row_selected = gte_get_current_cell_row () ;
  int col_selected = gte_get_current_cell_col () ;
  
  int insertion_row = min_req_row ;
  gte_disable_refresh ();
  gte_disable_action_completed();
  
  if (row_selected <= max_req_row && row_selected >= min_req_row)
    {
      RowSpanType RowSpan = REQ_RowSpanRange (row_selected, col_selected);
      row_selected = RowSpan.end_row ;
      insertion_row = row_selected + 1 ;
    }
  
  REQ_DoCreate (insertion_row, True) ;
  
  // Go to new leaf
  gte_set_selection (insertion_row, leaf_col,
              insertion_row, leaf_col,
              insertion_row, leaf_col) ;
  
  gte_goto (insertion_row, leaf_col) ;
  
  gte_enable_refresh() ;
  gte_refresh_table() ;
  gte_enable_action_completed();
}

boolean
REQ_NoMoreParentsInLastColumn ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  boolean result = True ;
  int row = min_req_row ;
  RowSpanType RowSpan ;
  
  while (row <= max_req_row && result == True)
    {
      RowSpan = REQ_RowSpanRange (row, max_parent_col);
      if (RowSpan.start_row != RowSpan.end_row)
        {
          result = False ;
        }
      else if (!NoLabel (row, max_parent_col))
        {
          result = False ;
        }
      else
        {
          row = row + 1 ;
        }
    }
  return (result) ;
}

struct REQ_NodeOrLinkOrCntxType {
  node Node ;
  link Link ;
  cntx Cntx ;
} ;


REQ_NodeOrLinkOrCntxType
REQ_NodeOrLinkOrCntx (int id)
{
  const string NodeQuery = "node [${id} && node_refs]" ;
  const string LinkQuery = "link [${id} && link_refs]" ;
  const string CntxQuery = "cntx [${id} && cntx_refs]" ;
  
  REQ_NodeOrLinkOrCntxType Result ;
  Result.Node = NULL ;
  Result.Link = NULL ;
  Result.Cntx = NULL ;
  
  Result.Node = find_by_query (NodeQuery) ;
  
  if (Result.Node == NULL)
    {
      Result.Link = find_by_query (LinkQuery) ;
      if (Result.Link == NULL)
        {
          Result.Cntx = find_by_query (CntxQuery) ;
        }
    }
  return (Result) ;
}



void
REQ_Delete ()
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  int high_col = gte_get_last_col_in_selected () ;
  
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int max_parent_col ;
  int min_parent_col ;
  
  int leaf_col ;
  
  int first_table_col ;
  int last_table_col  ;
  int col ;
  
  if (REQ_DeleteIsActive() == ACTIVE_FUNC_IS_ACTIVE)
    {
      gte_disable_refresh ();
      gte_disable_action_completed();
      int parent_col ;
      RowSpanType RowSpan ; 
      int row ;
      REQ_LabelType label ;
      REQ_LabelType leaf_label ;
      
      // Refresh delete
      REQ_DeleteUndoInit () ;
      
      row = high_row ;
      
      string unique_id ;
      const string item_query = "item [(${REQ_ANALYSIS_ASSIGNMENT_ITEM} ||"
        +       "${REQ_DESIGN_ASSIGNMENT_ITEM} ||"
        +       "${REQ_IMPLEMENTATION_ASSIGNMENT_ITEM} ||"
        +       "${REQ_TEST_ASSIGNMENT_ITEM}) && "
        +       "value == '${unique_id}' ] " ;
      
      item Item = NULL ;
      node Node = NULL ;
      link Link = NULL ;
      cntx Cntx = NULL ;
      string phase ;
      string type ;
      string name ;
      boolean NoMoreParentsInLastColumn  ;
      REQ_NodeOrLinkOrCntxType Object ;
      
      for (row = high_row; row >= low_row; row=row-1)
        {
          parent_col = REQ_GetParentColumn (row) ;
          
          RowSpan = REQ_RowSpanRange (row, parent_col) ;
          
          leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
          
          leaf_label = REQ_ParsedLabel (row, leaf_col) ;
          
          if (!IsBlank (leaf_label.unique_id))
            {
              unique_id = to_oms_string (leaf_label.unique_id) ;
              
              Item = find_by_query (item_query) ;
              
              // Do not delete if requirement is assigned.
              //
              if (Item != NULL)
                {
                  Object = REQ_NodeOrLinkOrCntx (Item.obj_id) ;
                  
                  if (Object.Node != NULL || Object.Link != NULL 
                      || Object.Cntx !=NULL)
                    {
                      if (Object.Node != NULL)
                        {
                          name = Object.Node.name ;
                          type = Object.Node.type ;
                        }
                      else if (Object.Link != NULL)
                        {
                          name = Object.Link.name ;
                          type = Object.Link.type ;
                        }
                      else 
                        {
                          name = Object.Cntx.name ;
                          type = Object.Cntx.type ;
                        }
                      
                      phase = REQ_PhaseStringFromItem (Item) ;
                      
                      gte_print_error ("Cannot delete requirement \""+ unique_id +
                                       "\"\; it is a "+ phase + " requirement " +
                                       "for the " + type + " \"" + name + "\" (" + 
                                       Item.obj_id + ").") ;
                      continue ;
                    }
                }
              
            }
          
          // if parent has a single child requirement (no vertical spanning)
          if (parent_col > 0 && RowSpan.start_row == RowSpan.end_row)
            {
              REQ_AddToDeleteUndoList (row, True) ;
              
              label = REQ_ParsedLabel (row, parent_col) ;
              
              gte_set_selection (row, parent_col, 
                          row, parent_col, 
                          row, parent_col) ;
              
              // Copy Parent label
              JED_Copy() ;
              
              // Clear Parent label
              CurrentCellLabel("") ;
              
              min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
              max_parent_col = gte_get_last_col  (REQ_ParentReqVsect()) ;
              
              // Fix up parent horizontal spanning
              gte_set_selection (row, parent_col, 
                          row, max_parent_col,
                          row, parent_col) ;
              
              gte_unspan();
              
              gte_set_selection (row, parent_col, 
                          row, max_parent_col,
                          row, parent_col) ;
              gte_span();
              
              FillSelectionWhite() ;
              
              NoMoreParentsInLastColumn = REQ_NoMoreParentsInLastColumn() ;
              
              // Delete Last Parent Column if blank
              if (min_parent_col != max_parent_col && NoMoreParentsInLastColumn)
                {
                  REQ_SaveTitleBars () ;
                  gte_delete_col (max_parent_col) ;
                  REQ_RestoreTitleBars () ;
                  
                  REQ_UpdateBookeepingForDeletedColumn (max_parent_col) ;
                }
              
              // Hide Parent Vsect if no more parents visible.
              if (min_parent_col == max_parent_col && NoMoreParentsInLastColumn)
                {
                  gte_set_vsect_visibility (REQ_ParentReqVsect(), False) ;
                }
              
              // Paste parent to leaf requirement
              REQ_MoveParentDefinitionToLeaf (label.unique_id, row) ;
              
              REQ_UpdateBookeepingForModifiedRow (row) ;
              
              // Mark row as satisfied, if need be
              //REQ_TestAndMarkAsSatisfied (label.unique_id) ;
              
            }
          else
            {
              REQ_AddToDeleteUndoList (row, False) ;
              
              max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
              
              // don't delete the last row, but clear it
              if (min_req_row == max_req_row)
                {
                  
                  first_table_col = gte_get_first_col (REQ_ParentReqVsect()) ;
                  last_table_col  = gte_get_last_col (REQ_LeafDefinitionVsect()) ;
                  
                  for (col=first_table_col; col <= last_table_col; col=col+1)
                    {
                      gte_set_selection (row, col, 
                                  row, col,
                                  row, col) ;
                      
                      CurrentCellLabel("") ;
                    }
                  
                  REQ_UpdateBookeepingForModifiedRow (row) ;
                }
              else
                {
                  gte_delete_row (row) ;
                  REQ_UpdateBookeepingForDeletedRow (row) ;
                  REQ_RespanHierarchyRow (row) ;
                }
            }
          
        }
      
      leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
      max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
      
      if (low_row > max_req_row)
        {
          low_row = max_req_row ;
        }
      
      gte_set_selection (low_row, leaf_col, 
                  low_row, leaf_col, 
                  low_row, leaf_col) ;
      
      gte_enable_refresh() ;
      gte_refresh_table() ;
      gte_enable_action_completed();
      
      // Deactivate any ascii import undos
      REQ_ImportUndoActive = False ;
    }
}


int
REQ_DeleteIsActive ()
{
  int low_row = gte_get_first_row_in_selected () ;
  int high_row = gte_get_last_row_in_selected () ;
  int low_col = gte_get_first_col_in_selected () ;
  int high_col = gte_get_last_col_in_selected () ;
  
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int leaf_col       = gte_get_first_col (REQ_LeafReqVsect()) ;
  
  int result ;
  
  if (low_col >= leaf_col && 
      low_row >= min_req_row && high_row <= max_req_row)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }
  return (result) ;
}

int
REQ_SortIsActive ()
{
  int row_selected = gte_get_current_cell_row() ;
  
  int min_hier_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_hier_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_super_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_super_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  
  int result ;
  
  if (row_selected >= min_hier_row && row_selected <= max_hier_row)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else if (row_selected >= min_super_row && row_selected <= max_super_row)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }
  return (result) ;
}

void
REQ_AlphaSort ()
{
  int row_selected = gte_get_current_cell_row() ;
  
  int min_hier_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_hier_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_super_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_super_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  
  int result ;
  
  if (row_selected >= min_hier_row && row_selected <= max_hier_row)
    {
      REQ_SortHierarchy ("AlphaSort") ;
    }
  else if (row_selected >= min_super_row && row_selected <= max_super_row)
    {
      REQ_SortParentDefinitions ("AlphaSort") ;
    }
}

void
REQ_NumericSort ()
{
  int row_selected = gte_get_current_cell_row() ;
  
  int min_hier_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_hier_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_super_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_super_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  
  int result ;
  
  if (row_selected >= min_hier_row && row_selected <= max_hier_row)
    {
      REQ_SortHierarchy ("NumberSort") ;
    }
  else if (row_selected >= min_super_row && row_selected <= max_super_row)
    {
      REQ_SortParentDefinitions ("NumberSort") ;
    }
}

void
REQ_SortHierarchy (string SortName)
{
  int row_selected = gte_get_current_cell_row() ;
  int col_selected = gte_get_current_cell_col() ;
  
  REQ_PreserveTableDirty () ;
  gte_disable_refresh () ;
  gte_disable_action_completed();
  
  REQ_ResetQuery () ;
  REQ_ResetSatisfaction () ;
  
  // necessary to restore row and col selected after the above Reset operations.
  //
  gte_set_selection (row_selected, col_selected,
              row_selected, col_selected,
              row_selected, col_selected) ;
  
  gte_stpem ("TableSortRows "+ SortName+ " " + REQ_RequirementsHsect()) ;   
  
  REQ_FixParentHierarchySpanning () ;
  
  //REQ_MarkSatisfactionRequirements () ;
  
  gte_set_selection (row_selected, col_selected,
              row_selected, col_selected,
              row_selected, col_selected) ;
  
  gte_goto (row_selected, col_selected) ;
  
  // Deactivate any ascii import undos
  REQ_ImportUndoActive = False ;
  
  gte_enable_refresh () ;
  gte_refresh_table () ;
  REQ_ResetTableDirty () ;
  gte_enable_action_completed();
}


void
REQ_SortParentDefinitions (string SortName)
{
  int row_selected = gte_get_current_cell_row() ;
  int col_selected = gte_get_current_cell_col() ;
  
  gte_disable_refresh () ;
  REQ_PreserveTableDirty () ;
  gte_disable_action_completed();
  
  gte_stpem ("TableSortRows "+ SortName+ " " + REQ_ParentDefinitionHsect()) ;   
  
  REQ_FixParentDefinitionSpanning () ;
  
  gte_set_selection (row_selected, col_selected,
              row_selected, col_selected,
              row_selected, col_selected) ;
  
  gte_goto (row_selected, col_selected) ;
  
  gte_enable_refresh () ;
  gte_refresh_table () ;
  REQ_ResetTableDirty () ;
  gte_enable_action_completed();
  
  // Deactivate any ascii import undos
  REQ_ImportUndoActive = False ;
}

void
REQ_FixParentHierarchySpanning ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_req_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  
  int row ;
  int col ;
  
  string last_label ;
  string this_label ;
  int last_row ;
  
  for (col = min_req_col; col <= max_req_col; col = col+1)
    {
      last_row = min_req_row ;
      last_label = gte_get_cell_label (min_req_row, col) ;
      
      for (row = min_req_row; row <= max_req_row; row=row+1)
        {
          this_label = gte_get_cell_label (row, col) ;
          
          if (this_label != last_label)
            {
              if (!IsBlank (last_label))
                {
                  Vspan (last_row, col, row-last_row) ;
                }
              
              last_label = this_label ;
              last_row = row ;
            }
        }
      
      // span end
      if (!IsBlank (last_label))
        {
          Vspan (last_row, col, row-last_row) ;
        }
    }
  
  int parent_col ;
  
  // Fix horizontal spanning
  for (row = min_req_row; row <= max_req_row; row=row+1)
    {
      REQ_FixHorizontalSpanning (row) ;
    }
}

void
REQ_FixHorizontalSpanning (int Row)
{
  int parent_col ;
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_req_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  
  int i ;
  
  
  if (Row >= min_req_row && Row <= max_req_row)
    {
      parent_col = REQ_GetParentColumn (Row) + 1 ;
      
      for (i=min_req_col; i<parent_col; i=i+1)
        {
          gte_set_selection (Row, i, Row, i, Row, i) ;
          FillSelectionParentShade() ;
        }
      
      if (parent_col <= max_req_col)
        {
          gte_set_selection (Row, parent_col, Row, max_req_col, Row, parent_col) ;
          gte_unspan () ;
          gte_set_selection (Row, parent_col, Row, max_req_col, Row, parent_col) ;
          gte_span () ;
          gte_set_selection (Row, parent_col, Row, max_req_col, Row, parent_col) ;
          FillSelectionWhite () ;
        }
    }
}

void
REQ_FixParentDefinitionSpanning ()
{
  int min_parent_def_name_col = gte_get_first_col 
    (REQ_ParentDefinitionNameVsect());
  
  int max_parent_def_name_col = gte_get_last_col 
    (REQ_ParentDefinitionNameVsect());
  
  int parent_def_text_col = gte_get_first_col 
    (REQ_ParentDefinitionTextVsect());
  
  int min_parent_def_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_parent_def_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  
  int row ;
  int col ;
  
  for (row = min_parent_def_row; row <= max_parent_def_row; row = row+1) 
    {
      Hspan (row, min_parent_def_name_col, 
             max_parent_def_name_col-min_parent_def_name_col + 1) ;
    }
}

void
REQ_UnspanParentHierarchy ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_req_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  RowSpanType RowSpan ;
  ColSpanType ColSpan ;
  
  int row ;
  int col ;
  
  for (col = min_req_col; col <= max_req_col; col = col+1)
    {
      row = min_req_row ;
      
      while (row <= max_req_row)
        {
          RowSpan = REQ_RowSpanRange (row, col) ;
          
          // if spanning
          if (RowSpan.start_row != RowSpan.end_row)
            {
              UnVspan (RowSpan.start_row, col) ;
              row = RowSpan.end_row + 1 ;
            }
          else
            {
              row = row + 1 ;
            }
        }
    }
}

void
Hspan (int row, int col, int num_cells)
{
  gte_set_selection (row, col, row, col, row, col) ;
  CurrentCellHorzSpan (num_cells) ;
}

void
Vspan (int row, int col, int num_cells)
{
  gte_set_selection (row, col, row, col, row, col) ;
  CurrentCellVertSpan (num_cells) ;
}

void
UnHspan (int row, int col)
{
  gte_set_selection (row, col, row, col, row, col) ;
  CurrentCellHorzUnspan () ;
}

void
UnVspan (int row, int col)
{
  gte_set_selection (row, col, row, col, row, col) ;
  CurrentCellVertUnspan () ;
}


void
REQ_RespanHierarchyRow (int unspanned_row)
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  int min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_req_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  int col ;
  string match_label ;
  string this_label ;
  int first_spanning_row ;
  int last_spanning_row ;
  
  if (unspanned_row >= min_req_row && unspanned_row <= max_req_row)
    {
      for (col = min_req_col; col <= max_req_col; col=col+1)
        {
          match_label = gte_get_cell_label (unspanned_row, col) ;
          if (!IsBlank (match_label))
            {
              // get top row
              first_spanning_row = unspanned_row ;
              
              while (True)
                {
                  this_label = gte_get_cell_label (first_spanning_row, col) ;
                  
                  if (first_spanning_row < min_req_row)
                    {
                      first_spanning_row = min_req_row ;
                      break ;
                    }
                  else if (this_label != match_label)
                    {
                      first_spanning_row = first_spanning_row + 1 ;
                      break ;
                    }
                  else
                    {
                      first_spanning_row = first_spanning_row - 1 ;
                    }
                }
              
              
              // get bottom row
              
              last_spanning_row = unspanned_row ;
              
              while (True)
                {
                  this_label = gte_get_cell_label (last_spanning_row, col) ;
                  
                  if (last_spanning_row > max_req_row)
                    {
                      last_spanning_row = max_req_row ;
                      break ;
                    }
                  else if (this_label != match_label)
                    {
                      last_spanning_row = last_spanning_row - 1 ;
                      break ;
                    }
                  else
                    {
                      last_spanning_row = last_spanning_row + 1 ;
                    }
                }
              
              gte_set_selection (first_spanning_row, col,
                          last_spanning_row, col,
                          last_spanning_row, col) ;
              
              gte_unspan();
              
              gte_set_selection (first_spanning_row, col,
                          last_spanning_row, col,
                          last_spanning_row, col) ;
              gte_span();
            }
        }
      REQ_FixHorizontalSpanning (unspanned_row) ;
    }
}

int
REQ_MoveSatisfiedToTopIsActive ()
{
  int result ;
  
  if (list_count (REQ_reqs_satisfied()) > 0)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }
  return (result) ;
}

int
list_max_index (list List)
{
  int count = list_count (List) ;
  int max_index = 0 ;
  
  if (count > 0)
    {
      int i ;
      
      for (i=count-1; i > 0; i=i-1)
        {
          if (list_get (List, i) > list_get (List, max_index))
            {
              max_index = i ;
            }
        }
    }
  return (max_index) ;
}

void
REQ_MoveSatisfiedToTop ()
{
  list satisfied_list = list_copy (REQ_reqs_satisfied()) ;
  int row ;
  int count = list_count (satisfied_list) ;
  
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  
  int min_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  
  int i ;
  
  gte_disable_refresh () ;
  REQ_PreserveTableDirty () ;
  gte_disable_action_completed();
  
  REQ_ResetSatisfaction () ;
  REQ_ResetQuery () ;
  
  list new_satisfied_list = list_create ("int", 0) ;
  
  for (i=0; i<count; i=i+1)
    {
      row = list_get (satisfied_list, i) + i ;
      
      gte_set_selection (row, min_col, row, max_col, row, min_col) ;
      gte_unspan();
      JED_Copy() ;
      
      gte_insert_row (min_req_row, 1) ;
      
      gte_set_selection (min_req_row, min_col, min_req_row, max_col,
                  min_req_row, min_col) ;
      
      JED_Paste () ;
      
      list_append (new_satisfied_list, min_req_row+i) ;
      
      REQ_RespanHierarchyRow (min_req_row) ;
    }
  
  int max_index ;
  
  for (i=0; i<count; i=i+1)
    {
      max_index = list_max_index (satisfied_list) ;
      
      row = list_get (satisfied_list, max_index) + count ;
      
      REQ_RespanHierarchyRow (row) ;
      gte_delete_row (row) ;
      list_delete (satisfied_list, max_index) ;
    }
  
  REQ_MarkListAsSatisfied (new_satisfied_list) ;
  
  gte_set_selection (min_req_row, leaf_col, min_req_row, leaf_col,
              min_req_row, leaf_col) ;
  
  gte_goto (min_req_row, leaf_col) ;

  gte_enable_refresh () ;
  gte_refresh_table () ;
  REQ_ResetTableDirty () ;
  gte_enable_action_completed();
}

void
REQ_ShowRequirementCycles ()
{
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
    
  gte_disable_refresh ();
  REQ_PreserveTableDirty () ;
  REQ_ClearSatisfaction () ;
  gte_disable_action_completed();
  
  list query_cells = list_create ("REQ_CellType", 0) ;
  REQ_CellType cell ;
  
  int row ;
  int col ;
  REQ_LabelType label ;
  REQ_LabelType parent_label ;
  
  for (row=min_req_row; row <= max_req_row; row=row+1)
    {
      label = REQ_ParsedLabel (row, leaf_col) ;
      
      if (!IsBlank (label.unique_id))
        {
          for (col = min_parent_col; col <= max_parent_col; col = col+1)
            {
              parent_label = REQ_ParsedLabel (row, col) ;
              if (parent_label.unique_id == label.unique_id)
                {
                  cell.row = row ;
                  cell.col = leaf_col ;
                  list_append (query_cells, cell) ;
                }
            }
        }
    }
  
  if (list_count (query_cells) > 0) 
    {
      gte_set_vsect_visibility (REQ_ParentReqVsect(), True) ;
      //REQ_MarkListForQuery (query_cells) ;
      REQ_MarkListAsSatisfied (query_cells) ;
      gte_unset_selection ();
      REQ_GetNextQuery ();

      gte_enable_refresh() ;
      gte_refresh_table() ;
      REQ_ResetTableDirty () ;
      gte_enable_action_completed();
    }
  else
    {
      gte_print_message ("No requirement cycles found.") ;

      gte_enable_refresh() ;
      gte_refresh_table() ;
      gte_unset_selection ();
      REQ_ResetTableDirty () ;
      gte_enable_action_completed();
    }
}


string 
REQ_LabelColConcat (int hsect, int vsect, int row, int col)
{
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int sel_col = gte_get_first_col_in_selected () ;
  
  string result = "" ;
  int i ;
  string next ;
  
  // for some reason, "col" returned in this case is the abolute column,
  // and is not relative to the vsect in which it is contained.
  
  if (col > leaf_col)
    {
      col = leaf_col ;
    }
  
  for (i=col; i<= leaf_col; i=i+1)
    {
      next = REQ_UniqueId (hsect, vsect, row, i) ;
      if (IsBlank (next))
        {
          next = " " ;
        }
      result= result + next ; 
    }
  
  return (result) ;
}

string
REQ_MassageDeweyNumber (string String)
{
  const int MAX_CHARS_PER_CATEGORY = 30 ;
  const string Delimiters = ".,/@#$%^&*()_-+=\\|[]{};~<>?!" ;
  
  string Result = "" ;
  
  if (string_length (String) > 0)
    {
      list StringList = string_to_list (String, Delimiters) ;
      int Count = list_count (StringList) ;
      int i ;
      int j ;
      string Bucket ;
      int Difference ;
      int Length ;
      
      for (i=0; i< Count; i=i+1)
        {
          Bucket = list_get (StringList, i) ;
          Length = string_length (Bucket) ;
          Difference = MAX_CHARS_PER_CATEGORY - Length ;
          if (Difference < 0)
            {
              Bucket = string_extract (Bucket, 0, MAX_CHARS_PER_CATEGORY) ;
            }
          else                        // pad Bucket to be right amount of characters.
            {
              for (j=0; j<Difference; j=j+1)
                {
                  if (i == 0)
                    {
                      Bucket = "0" + Bucket ;
                    }
                  else
                    {
                      Bucket = Bucket + "0" ;
                    }
                }
            }
          Result = Result + Bucket ;
        }
    }
  
  return (Result) ;
}

string 
REQ_DeweyLabel (int hsect, int vsect, int row, int col)
{
  string Result = "" ;
  
  string Label = REQ_UniqueId (hsect, vsect, row, col) ;
  
  if (IsBlank (Label))
    {
      Result = " " ;
    }
  else
    {
      Result = REQ_MassageDeweyNumber (Label) ;
    }
  
  return (Result) ;
}


string 
REQ_DeweyColConcat (int hsect, int vsect, int row, int col)
{
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int sel_col = gte_get_first_col_in_selected () ;
  
  string result = "" ;
  int i ;
  string next ;
  
  // for some reason, "col" returned in this case is the abolute column,
  // and is not relative to the vsect in which it is contained.
  
  if (col > leaf_col)
    {
      col = leaf_col ;
    }
  
  for (i=col; i<= leaf_col; i=i+1)
    {
      result= result + REQ_DeweyLabel (hsect, vsect, row, i) ;
    }
  
  return (result) ;
}






string REQ_LastImportPathEntered = "" ;

void
REQ_AskForImportFile()
{
  editor_string_selector(REQ_LastImportPathEntered, // init val
                         "REQ_AskForImportFile_CallBack();",                    // callback
                         "Import Requirements from ASCII File",                                    // window label
                         "File Name:",                                                                                    // Text label
                         "Import Requirements",                                                                                            // Apply label
                         "Cancel"                                                                                                                            // cancel label
                         );         
}

boolean
REQ_AskForImportFile_CallBack()
{
  string        FileName ;
  boolean     status = False ;
  
  if (editor_string_selector_action() != "Cancel")
    {
      FileName = editor_string_selector_value();
      
      if (FileName != NULL)
        {
          REQ_LastImportPathEntered = FileName ;
        }
      
      if (read_file_access (FileName))
        {
          REQ_Import(FileName) ;
        }
      else
        {
          status = True ;                // redisplay window
          
          gte_print_error ("Cannot find file \""+FileName+"\"," +
                           " or it is not readable.") ; 
        }
    }
  
  return (status) ;
}


// structure to define a row to be used by file-read functions
struct ReqRowType {
  list ReqList ;
  list DefinitionList ;
} ;

// These variables are used to undo an ascii import.
int REQ_HierarchyInsertionRow = 0 ;
int REQ_SupersededInsertionRow = 0 ;
boolean REQ_ImportUndoActive = False ;


int
REQ_ImportUndoIsActive ()
{
  int result ;
  
  if (REQ_ImportUndoActive)
    {
      result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }
  
  return (result) ;
}


void
REQ_ImportUndo ()
{
  gte_disable_refresh () ;
  gte_disable_action_completed();
  if (REQ_ImportUndoIsActive() == ACTIVE_FUNC_IS_ACTIVE) 
    {
      int row ;
      int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;
      int goto = REQ_HierarchyInsertionRow ;
      
      for (row = REQ_HierarchyInsertionRow; row <= max_row; row=row+1)
        {
          gte_delete_row (row) ;
        }
      
      max_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
      
      for (row = REQ_SupersededInsertionRow; row <= max_row; row=row+1)
        {
          gte_delete_row (row) ;
        }
      gte_goto (goto, 1) ;
    }
  
  REQ_ImportUndoActive = False ;
  
  gte_enable_refresh () ;
  gte_refresh_table() ;
  gte_enable_action_completed();
}

void
REQ_Import (string FileName)
{

  gte_disable_refresh () ;
  gte_disable_action_completed();
  
  REQ_HierarchyInsertionRow  =  gte_get_last_row (REQ_RequirementsHsect())+1 ;
  REQ_SupersededInsertionRow =  gte_get_last_row 
    (REQ_ParentDefinitionHsect())+1 ;
  
  // a list of ReqRowType
  list file =  REQ_ReadRequirementFile (FileName) ;
  
  string FillTableString = REQ_MakeFillTable (file) ;
  
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int min_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_parent_col = gte_get_last_col (REQ_ParentReqVsect()) ;
  
  gte_set_selection (min_req_row, min_parent_col, 
              max_req_row, max_parent_col,
              min_req_row, min_parent_col) ;
  
  gte_unspan();
  
  //message (FillTableString) ;

  gte_filltable_string (FillTableString) ;
  
  //gte_filltable_file (FileName) ;
  
  REQ_FixParentHierarchySpanning () ;
  
  //REQ_MarkSatisfactionRequirements () ;
  
  min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  gte_goto (max_req_row, max_parent_col) ;
  
  gte_enable_refresh () ;
  gte_refresh_table() ;
  gte_enable_action_completed();
  
  // Turn on undo
  REQ_ImportUndoActive = True ;
}


int
next_good_line (list file, int line, string separator) 
{
  int result ;
  int file_size = list_count (file) ;
  
  for (; line < file_size; line=line+1)
    {
      if (separator != list_get (file,line)) 
        {
          break ;
        }
    }
  return (line) ;
}

int
next_blank_line (list file, int line, string separator) 
{
  int result ;
  int file_size = list_count (file) ;
  
  for (; line < file_size; line=line+1)
    {
      if (separator == list_get (file,line))
        {
          break ;
        }
    }
  return (line) ;
}

string
REQ_separator_character (list file)
{
  string result = NULL ;
  
  string first_line = list_get(file,0) ;
  
  if (string_length (first_line) > 0)
    {
      result = string_extract (first_line, 0, 1) ;
    }
  return (result) ;
}

// returns a list of "ReqRowType"
list
REQ_ReadRequirementFile (string FileName)
{
  string file_string = read_file (FileName) ;
  
  list file = string_to_list (read_file (FileName), "\n") ;
  
  list result = list_create ("ReqRowType", 0) ;
  int FileLength = list_count (file) ;
  
  if (FileLength > 0)
    {
      string separator = REQ_separator_character (file) ;

      ReqRowType Row ;
      int i ;
      int line ;
      int ReqCount ;
      string Description ;
      
      int ThisLine = next_good_line (file, 0, separator) ;
      int LastLine ;

      while (ThisLine < FileLength)
        {
          Row.ReqList = string_to_list (list_get (file, ThisLine), separator) ; 
          ReqCount    = list_count (Row.ReqList) ;
          LastLine = ThisLine + 1 ;
          
          // guarantees definition list to be same length as # of rqmts found
          Row.DefinitionList = list_create ("string", ReqCount) ;
          
          for (i=0; i<ReqCount && ThisLine < FileLength; i=i+1)
            {
              ThisLine = next_good_line (file, LastLine, separator) ;
              LastLine = next_blank_line (file, ThisLine, separator) ;
              Description = "" ;
              
              for (line=ThisLine; line < LastLine; line=line+1)
                {
                  if (line != ThisLine)
                    {
                      Description = Description + "\\n" ;
                    }
                  
                  Description = Description + list_get (file, line) ;
                }

              list_set (Row.DefinitionList, i, Description) ;
            }
          
          list_append (result, Row) ;
          
          list_clear (Row.DefinitionList) ;
          list_clear (Row.ReqList) ;
          
          ThisLine = next_good_line (file, LastLine, separator) ;
        }
    }
  return (result) ;
}

string
REQ_FillTableEscape (string String)
{
	if (NULL != String) {
	  return (string_escape (String, "\"")) ;
	}
	return "";
}

// converts a list of "ReqRowType" into a FillTable string
string
REQ_MakeFillTable (list RowList)
{
  int RowCount = list_count (RowList) ;
  
  int min_req_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_req_row = gte_get_last_row (REQ_RequirementsHsect()) ;
  
  int i ;
  int j ;
  string Table = "FillTable REQTable {" ;
  
  // Requirement Hierarchy Hsect
  
  Table = Table + "{Hsect {Index " + REQ_RequirementsHsect () + "}" ;
  
  // Parent Requirements Vsect
  
  Table = Table + " {Vsect {Index " + REQ_ParentReqVsect () + "}" ;
  
  // Parent Vsect Rows
  
  int SupersededCount ;
  ReqRowType Row ;
  
  for (i=0; i < RowCount; i=i+1)
    {
      // Row Start
      if (i==0)
        {
          Table = Table + " {Row {Index Append } " ;
        }
      else
        {
          Table = Table + " {Row " ;
        }
      
      Row = list_get (RowList, i) ;
      SupersededCount = list_count (Row.ReqList) - 1 ;
      
      for (j=0; j < SupersededCount; j=j+1)
        {
          Table = Table + "{Cell {Label \""+ 
            REQ_FillTableEscape (list_get (Row.ReqList, j)) + "\" }" +
            "{Shading Shade2}}" ;
        }

      // Empty Row still must have label statement.
      if (SupersededCount == 0)
        {
          Table = Table + "{Cell {Label \"\"}}" ;
        }

      // Row End
      Table = Table + "}\n" ;
    }
  
  // Parent Vsect End
  Table = Table + "}" ;
  /////////////////////////////////////////////////
    
    
  // Leaf Vsect Start
  Table = Table + " {Vsect {Index " + REQ_LeafReqVsect () + "}" ;
  
  for (i=0; i < RowCount; i=i+1) 
    {
      // Row Start
      if (i==0)
        {
          Table = Table + " {Row {Index Append}" ;
        }
      else
        {
          Table = Table + " {Row  " ;
        }
      
      Row = list_get (RowList, i) ;
      
      Table = Table + "{Cell {Label \""+ 
        REQ_FillTableEscape (list_get (Row.ReqList, list_count (Row.ReqList)-1))
        + "\" }}" ;
      
      // Row End
      Table = Table + "}\n" ;
    }
  // Leaf Vsect End
  Table = Table + "}\n" ;
  
  //////////////////////////////////////////
  
  // Leaf Definition Vsect Start
  Table = Table + " {Vsect {Index " + REQ_LeafDefinitionVsect () + "}" ;
  
  for (i=0; i < RowCount; i=i+1)
    {
      // Row Start
      if (i==0)
        {
          Table = Table + " {Row {Index Append}" ;
        }
      else
        {
          Table = Table + " {Row  " ;
        }
      
      Row = list_get (RowList, i) ;
      
      Table = Table + "{Cell {Label \""+ 
        REQ_FillTableEscape 
        (list_get (Row.DefinitionList, list_count (Row.ReqList)-1)) + 
        "\" }}" ;
      
      // Row End
      Table = Table + "}\n" ;
    }
  
  // Leaf Definition Vsect End
  Table = Table + "}\n" ;
  ////////////////////////////////////////////
  
  // Requirement Hierarchy Hsect End
  Table = Table + "}\n" ;
  
  
  // Superseded Requirements Hsect
  int min_parent_def_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_parent_def_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  int parent_name_col = gte_get_first_col (REQ_ParentDefinitionNameVsect());
  
  gte_set_selection (min_parent_def_row, parent_name_col, 
              max_parent_def_row, parent_name_col,
              min_parent_def_row, parent_name_col) ;
  
  set ExistingSupersededRqmtSet = REQ_SelectedUniqueIdsSet() ;
  
  Table = Table + "{Hsect {Index " + REQ_ParentDefinitionHsect () + "}\n"  ;
  
  // Superseded Requirements Definition Name Vsect
  
  Table = Table + " {Vsect {Index " + REQ_ParentDefinitionNameVsect () 
    +"}\n" ;
  
  set SupersededSet = set_create ("string") ;
  string SupersededName ;
  REQ_LabelType Label ;
  
  boolean IsFirst = True ;
  
  for (i=0; i < RowCount; i=i+1)
    {
      
      Row = list_get (RowList, i) ;
      SupersededCount = list_count (Row.ReqList) - 1 ;
      
      for (j=0; j < SupersededCount; j=j+1)
        {
          SupersededName = list_get (Row.ReqList, j) ;
          Label = REQ_ParseString (SupersededName) ;
          
          // Only add superseded once
          if (!set_is_member(ExistingSupersededRqmtSet, Label.unique_id)
              && (!set_is_member (SupersededSet, Label.unique_id)))
            {
              set_add (SupersededSet, Label.unique_id) ;
              
              // Row Start
              if (IsFirst)
                {
                  Table = Table + " {Row {Index Append} " ;
                  IsFirst = False ;
                }
              else
                {
                  Table = Table + " {Row " ;
                }
              
              Table = Table + 
                "{Cell {Label \""+ REQ_FillTableEscape(SupersededName)
                + "\" }}" ;
              
              // Row End
              Table = Table + "}\n" ;
            }
        }
    }
  
  // Superseded Definition Name Vsect End
  
  Table = Table + "}\n" ;
  /////////////////////////////////////////
    
  // Superseded Definition Text Start
  Table = Table + " {Vsect {Index " + REQ_ParentDefinitionTextVsect () +"}\n" ;
  REQ_LabelType label ;
  
  set_clear (SupersededSet) ;
  
  // This loop needs to be identical to above loop to make sure rows
  // are in synch.
  
  IsFirst = True ;
  
  for (i=0; i < RowCount; i=i+1)
    {
      Row = list_get (RowList, i) ;
      SupersededCount = list_count (Row.ReqList) - 1 ;
      
      for (j=0; j < SupersededCount; j=j+1)
        {
          SupersededName = list_get (Row.ReqList, j) ;
          Label = REQ_ParseString (SupersededName) ;
          
          // Only add parent once
          if (!set_is_member(ExistingSupersededRqmtSet, Label.unique_id)
              && (!set_is_member (SupersededSet, Label.unique_id)))
            {
              set_add (SupersededSet, Label.unique_id) ;
              
              // Row Start
              if (IsFirst)
                {
                  Table = Table + " {Row {Index Append} " ;
                  IsFirst = False ;
                }
              else
                {
                  Table = Table + " {Row " ;
                }
              
              Table = Table + 
                "{Cell {Label \""+ 
                REQ_FillTableEscape (list_get (Row.DefinitionList, j)) 
                + "\" }}" ;
              
              // Row End
              Table = Table + "}\n" ;
            }
        }
    }
  // Superseded Definition Text End
  
  Table = Table + "}\n" ;
  
  
  // Superseded Requirement Hsect End
  Table = Table + "}\n" ;

  // End Fill Table
  Table = Table + "}\n" ;

  return (Table) ;
}

//const string REQ_RowTag = "Append" ;
const string REQ_RowTag = "??????!!!!!!######" ;


string
REQ_FillTableStringForRow (int Row, int StartVsect, int EndVsect, 
                           int LastCopyCol)
{
  string Result = "" ;
  int Col ;
  int FirstCol ;
  int LastCol ;
  string Label ;

  Result = "FillTable REQTable {{Hsect {Index " + gte_get_hsect (Row) + "}" ;

  int Vsect ;

  for (Vsect = StartVsect; Vsect <= EndVsect; Vsect=Vsect+1)
    {
      Result = Result + " {Vsect {Index " + Vsect + "}" ;

      Result = Result + " {Row {Index "+ REQ_RowTag + "} " ;

      FirstCol = gte_get_first_col (Vsect) ;
      LastCol = gte_get_last_col (Vsect) ;

      for (Col = FirstCol; Col <= LastCol; Col = Col+1)
        {
          //gte_set_selection (Row, Col, Row, Col, Row, Col) ;
          //gte_unspan () ;
          gte_set_selection (Row, Col, Row, Col, Row, Col) ;

          if (Col <= LastCopyCol)
            {
              Label = gte_get_cell_label (Row, Col) ;
            }
          else
            {
              Label = "" ;
            }
          Result = Result + "{Cell {Label \"" + 
            REQ_FillTableEscape (Label)+ "\" }}"  ;
        }

      Result = Result + "}" ; //End Row
      Result = Result + "}" ; //End Vsect
    }

  Result = Result + "}}" ; // End of Hsect and FillTable

  return (Result) ;
}

list REQ_DeletedRowList = list_create ("int", 0) ;
list REQ_DeleteParentColList = list_create ("int", 0) ;
list REQ_DeleteParentList = list_create ("string", 0) ;
list REQ_DeleteLeafList = list_create ("string", 0) ;
list REQ_DeleteLeafDefList = list_create ("string", 0) ;
list REQ_DeleteFillTableList = list_create ("string", 0) ;

void
REQ_DeleteUndoInit ()
{
  list_clear (REQ_DeletedRowList) ;
  list_clear (REQ_DeleteParentList) ;
  list_clear (REQ_DeleteParentColList) ;
  list_clear (REQ_DeleteLeafList) ;
  list_clear (REQ_DeleteLeafDefList) ;
  list_clear (REQ_DeleteFillTableList) ;
}

const int REQ_NeedRefine = -1 ;

void
REQ_AddToDeleteUndoList (int Row, boolean NeedRefine)
{
  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_req_col = gte_get_last_col (REQ_ParentReqVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  if (Row >= min_row && Row<= max_row)
    {
      list_append (REQ_DeletedRowList, Row) ;
      list_append (REQ_DeleteLeafList, gte_get_cell_label (Row, leaf_col)) ;
      list_append (REQ_DeleteLeafDefList, gte_get_cell_label (Row, def_col)) ;
      list_append (REQ_DeleteFillTableList, 
                   REQ_FillTableStringForRow 
                   (Row, REQ_ParentReqVsect(), REQ_LeafDefinitionVsect(),
                    gte_get_last_col (REQ_LeafDefinitionVsect()))) ;

      int ParentCol = REQ_GetParentColumn (Row) ;

      if (NeedRefine)
        {
          // signifies that a Refine is necessary to bring back leaf
          list_append (REQ_DeleteParentColList, REQ_NeedRefine) ;
        }
      else
        {
          list_append (REQ_DeleteParentColList, ParentCol) ;
        }

      if (ParentCol > 0)
        {
          list_append (REQ_DeleteParentList, 
                       gte_get_cell_label (Row, ParentCol)) ;
        }
      else
        {
          list_append (REQ_DeleteParentList, "") ;
        }

    }
}

int 
REQ_DoDeleteUndo_IsActive ()
{
  int result = ACTIVE_FUNC_IS_ACTIVE ;

  if (list_count (REQ_DeletedRowList) == 0)
    {
      result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (result) ;
}

int
REQ_undo_IsActive ()
{
   int result = ACTIVE_FUNC_IS_INACTIVE;

   return (result);
}

int
REQ_redo_IsActive ()
{
   int result = ACTIVE_FUNC_IS_INACTIVE;

   return (result);
}
void
REQ_FillInLeaf (int Row, string LeafLabel, string DefinitionLabel)
{
  // Fill in leaf and leaf definition.
  //
  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  gte_set_selection (Row, leaf_col, Row, leaf_col, Row, leaf_col) ;
  CurrentCellLabel(LeafLabel) ;
  gte_set_selection (Row, def_col, Row, def_col, Row, def_col) ;
  CurrentCellLabel(DefinitionLabel) ;
}

void
REQ_DoDeleteUndo ()
{
  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_req_col = gte_get_last_col (REQ_ParentReqVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int i ;
  int Count = list_count (REQ_DeletedRowList) ;
  int ParentCol ;
  int Row ;
  string ParentLabel ;
  string FillTable ;
  string RowTag ;
  string LeafLabel ;
  string LeafDef ;

  gte_disable_refresh () ;
  gte_disable_action_completed();

  if (REQ_DoDeleteUndo_IsActive() == ACTIVE_FUNC_IS_ACTIVE)
    {
      // Start with the most recent deletion
      for (i=Count-1; i>=0; i=i-1)
        {
          Row         = list_get (REQ_DeletedRowList, i) ;
          ParentCol   = list_get (REQ_DeleteParentColList, i) ;
          ParentLabel = list_get (REQ_DeleteParentList, i) ;
          FillTable   = list_get (REQ_DeleteFillTableList, i) ;

          LeafLabel   = list_get (REQ_DeleteLeafList, i) ;
          LeafDef     = list_get (REQ_DeleteLeafDefList, i) ;

          min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
          max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

          min_req_col = gte_get_first_col (REQ_ParentReqVsect()) ;
          max_req_col = gte_get_last_col (REQ_ParentReqVsect()) ;

          leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
          def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

          // if deleted rqmt had no parents
          //
          if (ParentCol == 0)
            {
              if (Row == min_row)
                {
                  // if the table is empty
                  if (0 == REQ_GetParentColumn (Row) && NoLabel (Row,leaf_col))
                    {
                      REQ_FillInLeaf (Row, LeafLabel, LeafDef) ;
                    }
                  else
                    {
                      REQ_DoCreate (Row, True) ;
                      REQ_FillInLeaf (Row, LeafLabel, LeafDef) ;
                    }
                }
              else if (Row == max_row+1)
                {
                  FillTable = 
                    string_search_and_replace (FillTable, REQ_RowTag, "Append") ;
   
                  gte_filltable_string (FillTable) ;
                }
              else if (Row <= max_row) 
                {
                  REQ_DoCreate (Row, True) ;
                  REQ_FillInLeaf (Row, LeafLabel, LeafDef) ;
                }
            
            }
   
          // Need to do a Refine
          else if (ParentCol == REQ_NeedRefine)
            {
   
              if (ParentLabel == gte_get_cell_label (Row, leaf_col))
                {
                  REQ_DoRefine (Row, leaf_col, False) ;
                  REQ_FillInLeaf (Row, LeafLabel, LeafDef) ;
                }
              else
                {
                  gte_print_error 
                    ("Cannot Undo: Unrecoverable change occurred to table since last delete.") ;
   
                  break ;
                }
            }
   
          // Deleted a leaf of an existing Parent
          else 
            {
              if (  
                  (ParentLabel == gte_get_cell_label (Row, ParentCol))
                  ||
                  (ParentLabel == gte_get_cell_label (Row-1, ParentCol))
                  ||
                  (ParentLabel == gte_get_cell_label (Row+1, ParentCol))
                  )
                {
                  if (Row > max_row)
                    {
                      RowTag = "Append" ;
                    }
                  else
                    {
                      REQ_AddReqRow (Row, 0) ;
                      RowTag = to_string (Row- min_row + 1) ;
                    }
   
   
                  FillTable = 
                    string_search_and_replace (FillTable, REQ_RowTag, RowTag) ;

                  gte_filltable_string (FillTable) ;
                }
              else
                {
                  gte_print_error 
                    ("Cannot Undo: Unrecoverable change occurred to table since last delete.") ;
   
                  break ;
                }
            }
      
          REQ_RespanHierarchyRow (Row) ;
        }

      int first_row = list_get (REQ_DeletedRowList, Count-1) ;
      int last_row = list_get (REQ_DeletedRowList, 0) ;
      max_row = gte_get_last_row (REQ_RequirementsHsect()) ;
   
      if (first_row > max_row)
        {
          first_row = max_row ;
        }
   
      if (last_row > max_row)
        {
          last_row = max_row ;
        }
   
   
      leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
   
      REQ_DeleteUndoInit () ;
      gte_set_selection (first_row, leaf_col, last_row, leaf_col, 
                  first_row, leaf_col) ;
   
      gte_goto (first_row, leaf_col) ;

    }
   
  gte_enable_refresh () ;
  gte_refresh_table() ;
  gte_enable_action_completed();
}
   

void
request_requirement_subsystem_cb ()
{
  list result = editor_selector_selected_names () ;
  int i ;
  int count = list_count (result) ;
  string Subsystem = list_get (result, 0)  ;

  TableInitialize (    REQ_SatisfactionId, REQ_LinkOrNodeOrCntx, 
                       REQ_SatisfactionNode, REQ_SatisfactionLink, 
                       REQ_SatisfactionCntx,
                       Subsystem, REQ_PhaseString) ;
  gte_enable_refresh () ;
  gte_refresh_table() ;
  REQ_ResetTableDirty () ;
  gte_enable_action_completed();
}


list // of file
REQ_CurrentTables (int Id)
{
  const string ItemQuery = "item [${REQ_AssignmentItem} && obj_id==${Id}]" ;

  const string NodeQuery = "node[REQRequirement && name=='${Item.value}' &&"
    + "in_links[REQCurrentRequirementIdentifier]]" ;

  const string NodeQueryIdList = "NodeQueryIdList" ;

  const string RefQuery = "node_ref [node[NodeQueryIdList]] " ;
  const string FileQuery = "file [REQTable && ${Ref.file_id}]" ;

  set result = set_create ("file") ;
  list Result = list_create ("file", 0) ;
  list RefList = list_create ("node_ref", 0) ;
  list ItemList = list_create ("item", 0) ;

  ItemList = list_select (ItemQuery) ;

  int i ;
  int j ;
  int ItemCount = list_count (ItemList) ;
  item Item ;
  file File ;
  node_ref Ref ;
  int RefCount ;

  for (i=0; i<ItemCount; i++)
    {
      Item = list_get (ItemList, i) ;

      id_list_create (NodeQuery, NodeQueryIdList) ;
      RefList = list_select (RefQuery) ;
      RefCount = list_count (RefList) ;

      for (j=0; j<RefCount; j++)
        {
          Ref = list_get (RefList, j) ;
          File = find_by_query (FileQuery) ;
          set_add (result, File) ;
        }

      id_list_free (NodeQueryIdList) ;
    }

  if (set_count (result) > 0) Result = set_to_list (result) ;

  return (Result) ;
}




boolean
REQ_RequirementSubsystemMenu (int Id, string CallbackFunc)
{
  list SelectionList = REQ_CurrentTables (Id) ;
  boolean SubsystemsExist = False ;
  file f;

  if (list_count (SelectionList) != 0)
    {
      if (list_count(SelectionList) == 1)
        {
          f = list_get(SelectionList, 0);
          RequirementTableInitialize_subsys_no_cb(f.name);
        }
      else
        editor_item_selector (
                              SelectionList,                         // list of possibilities 
                              CallbackFunc,                          // callback
                              "Choose from tables where object is currently allocated.", // label
                              True);

      SubsystemsExist = True ;
    }
  else
    {
      const string SubsystemQuery = "file [REQTable]" ;
      SelectionList = list_select (SubsystemQuery) ;

      if (list_count (SelectionList) > 0)
        {
          if (list_count(SelectionList) == 1)
            {
              f = list_get(SelectionList, 0);
              RequirementTableInitialize_subsys_no_cb(f.name);
            }
          else
            editor_item_selector(SelectionList, CallbackFunc, 
                                 "Object has no allocated requirements. Choose a Requirement Table.", 
                                 True);

          SubsystemsExist = True ;
        }
    }

  if (!SubsystemsExist)
    {
      print_error("No Requirements Tables found.");
    }

  return (SubsystemsExist) ;
}


void
REQ_RequestRequirementSubsystem ()
{
  gte_disable_refresh () ;
  gte_disable_action_completed();
  REQ_PreserveTableDirty () ;
  REQ_RequirementSubsystemMenu (-1, "request_requirement_subsystem_cb();") ;
}




void
request_requirement_phase_cb ()
{
  list result = editor_selector_selected_labels () ;
  int i ;
  string Phase = list_get (result, 0)  ;

  gte_disable_refresh () ;
  gte_disable_action_completed();

  TableInitialize (    REQ_SatisfactionId, REQ_LinkOrNodeOrCntx, 
                       REQ_SatisfactionNode, REQ_SatisfactionLink, 
                       REQ_SatisfactionCntx,
                       REQ_CurrentFileName(0,0,0,0), Phase) ;

  REQ_SetUserAwareOfPhases (True) ;

  REQ_ResetTableDirty () ;
  gte_enable_refresh () ;
  gte_refresh_table() ;
  gte_enable_action_completed();
}


int
REQ_RequestRequirementPhase_IsActive ()
{
  int result ;
  result = ACTIVE_FUNC_IS_ACTIVE ;
  return (result) ;
}


void
REQ_RequestRequirementPhaseMenu (string CallbackFunc)
{
  list Phases = list_create ("string", 0) ;
  list_append (Phases, "Analysis") ;
  list_append (Phases, "Design") ;
  list_append (Phases, "Implementation") ;
  list_append (Phases, "Test") ;

  int index = editor_item_selector (
                                    Phases,                            // list of possibilities 
                                    CallbackFunc,                      // callback
                                    "Set Requirement Project Phase",   // label
                                    True
                                    ) ;
}

void
REQ_RequestRequirementPhase ()
{
  gte_disable_refresh () ;
  REQ_PreserveTableDirty () ;
  gte_disable_action_completed();
  REQ_RequestRequirementPhaseMenu ("request_requirement_phase_cb();") ;

  // SPR 2723 - table doesn't refresh if cancel is button is selected
  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}

int REQ_SelectedRow ;
int REQ_SelectedCol ;

int REQ_LowRow ;
int REQ_HighRow ;

int REQ_LowCol ;
int REQ_HighCol ;

void
REQ_PreserveCurrentSettings ()
{
  REQ_SelectedRow = gte_get_current_cell_row() ;
  REQ_SelectedCol = gte_get_current_cell_col() ;
  REQ_LowRow      = gte_get_first_row_in_selected () ;
  REQ_HighRow     = gte_get_last_row_in_selected () ;
  REQ_LowCol      = gte_get_first_col_in_selected () ; 
  REQ_HighCol     = gte_get_last_col_in_selected () ;  

}

void
REQ_GoBackToSettingsSaved ()
{
  gte_set_selection (REQ_LowRow,  REQ_LowCol,
              REQ_HighRow, REQ_HighCol,
              REQ_SelectedRow, REQ_SelectedCol) ;

}

int REQ_ForMappingSelectedRow ;
int REQ_ForMappingSelectedCol ;

int REQ_ForMappingLowRow ;
int REQ_ForMappingHighRow ;

int REQ_ForMappingLowCol ;
int REQ_ForMappingHighCol ;

void
REQ_ForMappingPreserveCurrentSettings ()
{
  REQ_ForMappingSelectedRow = gte_get_current_cell_row() ;
  REQ_ForMappingSelectedCol = gte_get_current_cell_col() ;
  REQ_ForMappingLowRow      = gte_get_first_row_in_selected () ;
  REQ_ForMappingHighRow     = gte_get_last_row_in_selected () ;
  REQ_ForMappingLowCol      = gte_get_first_col_in_selected () ; 
  REQ_ForMappingHighCol     = gte_get_last_col_in_selected () ;  

}

void
REQ_ForMappingGoBackToSettingsSaved ()
{
  gte_set_selection (REQ_ForMappingLowRow,  REQ_ForMappingLowCol,
              REQ_ForMappingHighRow, REQ_ForMappingHighCol,
              REQ_ForMappingSelectedRow, REQ_ForMappingSelectedCol) ;

}

void
REQ_ToggleSupersededRqmts ()
{
  gte_disable_refresh () ;
  gte_disable_action_completed();

  gte_set_vsect_visibility (REQ_ParentReqVsect(), 
                            !gte_get_vsect_visibility (REQ_ParentReqVsect())) ;

  if (!gte_get_vsect_visibility (REQ_ParentReqVsect()))
    {
      // Hide Superseded Requirement Definitions hsect
      gte_set_hsect_visibility (REQ_ParentDefinitionHsect(), False) ;
      gte_set_hsect_visibility (REQ_ParentDefinitionTitleHsect(), False) ;
    }

  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}

int
REQ_ShowSupersededDefinition_IsActive ()
{
  int Result ;

  int row_selected = gte_get_current_cell_row() ;
  int col_selected = gte_get_current_cell_col() ;

  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_col = gte_get_last_col  (REQ_ParentReqVsect()) ;

  if (row_selected >= min_row && row_selected <= max_row &&
      col_selected >= min_col && col_selected <= max_col &&
      !NoLabel (row_selected, col_selected)
      )
    {
      Result = ACTIVE_FUNC_IS_ACTIVE ;
    }
  else
    {
      Result = ACTIVE_FUNC_IS_INACTIVE ;
    }

  return (Result) ;
}

void
REQ_ShowSupersededDefinition ()
{
  REQ_PreserveCurrentSettings () ;

  int min_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;

  int col = gte_get_first_col (REQ_ParentDefinitionNameVsect()) ;
  int text_col = gte_get_first_col (REQ_ParentDefinitionTextVsect()) ;

  gte_disable_refresh () ;
  gte_disable_action_completed();

  int row_selected = gte_get_current_cell_row() ;
  int col_selected = gte_get_current_cell_col() ;

  if (REQ_ShowSupersededDefinition_IsActive() == ACTIVE_FUNC_IS_ACTIVE)
    {

      REQ_LabelType Label = REQ_ParsedLabel (row_selected, col_selected) ;


      REQ_CellType  Cell = REQ_FindUniqueId (Label.unique_id,
                                             min_row, col, max_row, col) ;

      if (Cell.row != -1)
        {
          gte_set_hsect_visibility (REQ_ParentDefinitionTitleHsect (), True) ;
          gte_set_hsect_visibility (REQ_ParentDefinitionHsect(), True) ;
          gte_goto (Cell.row, Cell.col) ;
          gte_set_selection (Cell.row, text_col, Cell.row, text_col, 
                      Cell.row, text_col) ;
        }
      else
        {
          gte_print_error ("RQTBL: Cannot find superseded requirement text.") ;
          REQ_GoBackToSettingsSaved () ;
        }
    }

  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}

void
REQ_NOOP ()
{
  gte_print_error ("This feature not implemented yet.") ;
}


void
REQ_Load ()
{
  gte_disable_refresh () ;
  gte_disable_action_completed();
  //REQ_CleanFile () ;
  gte_stpem ("LoadDialogShow") ;
  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}

int
REQ_PasteCellText_IsActive ()
{
  int row = gte_get_current_cell_row() ;
  int col = gte_get_current_cell_col() ;

  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int Result = ACTIVE_FUNC_IS_INACTIVE ;

  if (row >= min_row && row <= max_row && (col == leaf_col || col == def_col))
    {
      Result = ACTIVE_FUNC_IS_ACTIVE ;
    }

  return (Result) ;
}

void
REQ_PasteCellText ()
{

  int row = gte_get_current_cell_row() ;
  int col = gte_get_current_cell_col() ;

  if (REQ_PasteCellText_IsActive() == ACTIVE_FUNC_IS_ACTIVE)
    {
      gte_set_selection (row,col,row,col,row,col) ;
      gte_stpem ("TableElementPaste") ;
    }
}

int
REQ_CopyCellText_IsActive ()
{
  int row = gte_get_current_cell_row() ;
  int col = gte_get_current_cell_col() ;

  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int min_parent_def_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_parent_def_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;

  int Result = ACTIVE_FUNC_IS_INACTIVE ;

  if ((row >= min_row && row <= max_row) || 
      (row >= min_parent_def_row && row <= max_parent_def_row))
    {
      Result = ACTIVE_FUNC_IS_ACTIVE ;
    }

  return (Result) ;
}


void
REQ_CopyCellText ()
{
  // JED - what's all the hoopla about? 
  // Just copy the current selection and return
  gte_stpem ("TableElementCopy") ;
  return;

//  gte_disable_refresh () ;
//  gte_disable_action_completed();
//
//  int row = gte_get_current_cell_row() ;
//  int col = gte_get_current_cell_col() ;
//
//  if (REQ_CopyCellText_IsActive() == ACTIVE_FUNC_IS_ACTIVE)
//    {
//      RowSpanType RowSpan = REQ_RowSpanRange (row, col) ;
//      ColSpanType ColSpan= REQ_ColSpanRange (row, col) ;
//
//      gte_set_selection (RowSpan.start_row, ColSpan.start_col, 
//                  RowSpan.end_row, ColSpan.end_col,
//                  RowSpan.start_row, ColSpan.start_col) ;
//
//      gte_unspan () ;
//
//      gte_set_selection (row,col,row,col,row,col) ;
//      gte_stpem ("TableElementCopy") ;
//
//      gte_set_selection (RowSpan.start_row, ColSpan.start_col, 
//                  RowSpan.end_row, ColSpan.end_col,
//                  RowSpan.start_row, ColSpan.start_col) ;
//
//      gte_span () ;
//    }
//
//  gte_enable_refresh () ;
//  gte_refresh_table () ;
//  gte_enable_action_completed();
}


list REQ_DragList = list_create ("string", 0) ;
list REQ_LeafDragList = list_create ("string", 0) ;
string REQ_DropType = NULL ;
string REQ_DropName = NULL ;
string REQ_DropEditor = NULL ;
int REQ_DropStpmHandle = -1 ;
int REQ_DropOid = -1 ;
boolean REQ_DoingDropAck = False ;


string
rqtbl_get_builtin_drag_data()
{
  string Result = NULL ;

  if (!REQ_DoingDropAck)
    {
      REQ_DragList = REQ_SelectedUniqueIdsList() ;   

      if (list_count (REQ_DragList) > 0)
        {
          Result = CreateDragMessage ("gte") ;
        }
    }
  return (Result) ;
}

void 
REQ_AllocateRqmtsToDropOid 
(string type, string name, int oid, 
 string drop_editor, int drop_handle, list RqmtList)
{

  int leaf_count = list_count (RqmtList) ; 
  if (leaf_count > 0)
    {
      REQ_AssignRqmtListToOid (RqmtList, oid, REQ_Phase) ;
      int i ;
      string req_id ;
      string msg ;

      for (i=0; i<leaf_count; i++)
        {
          req_id = list_get (RqmtList, i) ;

          //if (REQ_SatisfactionId == oid)
          //{
          //REQ_MarkListAsSatisfied (REQ_GetLeavesWithId (req_id)) ;
          //}

          msg =
            "Allocating "+ REQ_PhaseString + " requirement \"" +
            req_id + "\" to the "+
            type + " \"" +name+ "\" ("+oid+").";

          SendToRemoteMessageLog (msg, drop_editor, drop_handle) ;
          print_message (msg) ;
        }
    }

  REQ_DoingDropAck = False ;

  list_clear (REQ_DragList) ;
  list_clear (REQ_LeafDragList) ;
}


void
RQTBL_ReceiveDropAcknowledge (
                              string dropEditor, string dropEditorClass, int dropStpmHandle,
                              string projdir, string system,
                              string omsName, string omsType, string omsClass, int oid, 
                              int xpos, int ypos,
                              string info)
{
  // SPR 2306 - drag and drop projdir trailing backslash problem
  if ((!REQ_DoingDropAck ) && 
      system == current_system() && projdir == string_strip(current_projdir(), "T", "\\"))
    {
      if (dropEditorClass == "gde")
        {
          if (oid != -1)
            {
              REQ_LeafDragList = REQ_SelectedLeavesUniqueIdsList() ;

              int leaf_count = list_count (REQ_LeafDragList) ; 
              if (leaf_count > 0)
                {
                  REQ_AllocateRqmtsToDropOid 
                    (omsType, omsName, oid, 
                     dropEditor, dropStpmHandle, 
                     REQ_LeafDragList) ;
                }
              else
                {
                  string msg = "You cannot allocate a superseded requirement." ;
                  print_message (msg) ;
                  SendToRemoteMessageLog (msg, dropEditor, dropStpmHandle) ;
                }
            }
          else
            {
              string msg = "You did not drop upon a legitimate object." ;
              print_message (msg) ;
              SendToRemoteMessageLog (msg, dropEditor, dropStpmHandle) ;
            }
        }
      else if (dropEditorClass == "gte")
        {
          if (dropEditor == "rqtbl")
            {
              REQ_DragAndDropCopy (
                                   dropEditor, dropEditorClass, dropStpmHandle,
                                   projdir, system,
                                   omsName, omsType, omsClass, oid, 
                                   xpos, ypos,
                                   info) ;
            }
          else
            {
            }
        }
    }
}





void
RQTBL_AcknowledgeDrop (string dragEditor, string dragEditorClass,
                       string projdir, string system,
                       int dragStpmHandle, int col, int row)   
{

   // SPR 2306 - drag and drop projdir trailing backslash problem
  if (system == current_system() && projdir == string_strip(current_projdir(), "T", "\\"))
    {
      ObjectInfoType DropInfo ;
      DropInfo.omsType = "" ;
      DropInfo.omsName = "" ;
      DropInfo.omsClass = "node" ;
      DropInfo.oid = 0 ;
      string info = REQ_PhaseString ;

      if (dragEditorClass == "gde")
        {
          int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
          int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

          int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
          int def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

          if (row >= min_row && row <= max_row && 
              (col == leaf_col || col == def_col))
            {
              REQ_LabelType Label = REQ_ParsedLabel (row, leaf_col) ;
              DropInfo.omsName = Label.unique_id ;

              if (!IsBlank (Label.unique_id))
                {
                  SendDropAcknowledgment (dragEditor, dragStpmHandle,
                                          projdir, system, current_editor(), "gte",
                                          DropInfo, col, row, info) ;
                }
              else
                {
                  string msg = "Requirement name is blank." ;
                  print_message (msg) ;
                  SendToRemoteMessageLog (msg, dragEditor, dragStpmHandle) ;
                }
            }
          else if (row >= min_row && row <= max_row && col > 0 && col < leaf_col)
            {
              string msg = "You cannot allocate a superseded requirement." ;
              print_message (msg) ;
              SendToRemoteMessageLog (msg, dragEditor, dragStpmHandle) ;
            }
          else
            {

              // This will signal a reset of satisfaction object because 
              // omsName is blank .
              SendDropAcknowledgment (dragEditor, dragStpmHandle,
                                      projdir, system, current_editor(), "gte",
                                      DropInfo, col, row, info) ;

            }
        }

      else if (dragEditorClass == "gte")
        {
          if (dragEditor == "rqtbl")
            {
              SendDropAcknowledgment (dragEditor, dragStpmHandle,
                                      projdir, system, current_editor(), "gte",
                                      DropInfo, col, row, info) ;

            }
          else
            {
              SendCannotDropMsg (dragEditor, dragStpmHandle, current_editor(),
                                 editor_get_msgd_handle()) ;
            }
        }
    }
}


void
REQ_SetCurrentObject (string omsType, int oid)
{
  gte_disable_refresh () ;
  REQ_PreserveTableDirty () ;
  gte_disable_action_completed();

  REQ_LinkOrNodeOrCntxSave = omsType ;
  string FileName = REQ_CurrentFileName(0,0,0,0); 
  FinishInitialization (oid, FileName, REQ_PhaseString);
}


void
REQ_NotifyOfAllocations (int oid, string req_id)
{
  if (REQ_SatisfactionId == oid)
    {
      //REQ_MarkListAsSatisfied (REQ_GetLeavesWithId (req_id)) ;
    }
}

set // of strings
REQ_GetAllParents (int row, int col)
{
  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_col =  gte_get_last_col (REQ_ParentReqVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  if (col >= leaf_col) col = max_col;

  set Result = set_create ("string") ;

  if (row >= min_row && col >= min_col &&
      row <= max_row && col <= max_col)
    {
      int i ;
      REQ_LabelType label ;

      for (i=col; i >= min_col ; i--)
        {
          label = REQ_ParsedLabel (row, i) ;
      
          if (!IsBlank (label.unique_id))
            {
              set_add (Result, label.unique_id) ;
            }
        }
    }
  return (Result) ;
}

struct CopyRowType
{
  int row ;
  string FillTable ;
} ;

void
REQ_DragAndDropCopy (
                     string dropEditor, string dropEditorClass, int dropStpmHandle,
                     string projdir, string system,
                     string omsName, string omsType, string omsClass, int oid, 
                     int drop_col, int drop_row, string info)
{
  gte_disable_refresh () ;

  int min_sel_row = gte_get_first_row_in_selected() ;
  int min_sel_col = gte_get_first_col_in_selected() ;
  int max_sel_row = gte_get_last_row_in_selected() ;
  int max_sel_col = gte_get_last_col_in_selected() ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int def_col =  gte_get_first_col (REQ_LeafDefinitionVsect()) ;

  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  int min_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int max_col =  def_col ;

  if (min_sel_col == def_col) min_sel_col = leaf_col ;
  if (max_sel_col == leaf_col) max_sel_col = def_col ;

  string FillTable ;
  string cmd ;
  string msg ;

  if (min_sel_row >= min_row && min_sel_col >= min_col &&
      max_sel_row <= max_row && max_sel_col <= max_col)
    {
      int row ;
      set parentSet = set_create ("string") ;

      int insertion_row = drop_row ;
      int handle ;

      string leafLabel = "" ;


      list FillTableList = list_create ("CopyRowType", 0) ;
      CopyRowType CopyRow ;



      for (row = min_sel_row; row <= max_sel_row; row++)
        {
          set_union (parentSet, REQ_GetAllParents (row, max_sel_col)) ;

          FillTable = 
            REQ_FillTableStringForRow 
            (row, REQ_ParentReqVsect(), REQ_LeafDefinitionVsect(),
             max_sel_col) ;

          FillTable = string_escape (FillTable, "\"") ;
          FillTable = string_escape (FillTable, "\\") ;

          CopyRow.row = insertion_row ;
          CopyRow.FillTable = FillTable ;
          list_append (FillTableList, CopyRow) ;

          insertion_row++ ;
             
        }

      // Send Parents first to avoid errors with correspondence with leaves.
      //
      int ParentCount = set_count (parentSet) ;
      int i ;
      string parentName ;

      int min_parent_row ;
      int max_parent_row ;

      int parent_col ;
      int parent_text_col ; 

      REQ_CellType  Cell ;

      for (i=0 ; i<ParentCount; i++)
        {
          parentName = set_get_element (parentSet, i) ;

          min_parent_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
          max_parent_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
          parent_col = gte_get_first_col (REQ_ParentDefinitionNameVsect()) ;
          parent_text_col = gte_get_first_col (REQ_ParentDefinitionTextVsect()) ;

          Cell = REQ_FindUniqueId (parentName,
                                   min_parent_row, parent_col, 
                                   max_parent_row, parent_col) ;



          if (Cell.row != -1)
            {
              FillTable = 
                REQ_FillTableStringForRow 
                (Cell.row, REQ_ParentDefinitionNameVsect(), 
                 REQ_ParentDefinitionTextVsect(),
                 parent_text_col) ;

              FillTable = string_escape (FillTable, "\"") ;
              FillTable = string_escape (FillTable, "\\") ;

              cmd = 
                "EditorQrlEvalNoSave \"ReceiveParentHsectFillTableRequest (" + 
                "\\\"" + parentName + "\\\"" + "," +
                "\\\"" + FillTable + "\\\"" +
                ");\"" ;

              handle = editor_send_msg (dropEditor, cmd, dropStpmHandle) ;
            }
        }

      // Then send the "proper" table.
      int CopyRowCount = list_count (FillTableList) ;

      for (i=0 ; i<CopyRowCount; i++)
        {
          CopyRow = list_get (FillTableList, i) ;

          cmd = "EditorQrlEvalNoSave \"REQ_ReceiveFillTableRequest (" + 
            CopyRow.row + "," +
            "\\\"" + CopyRow.FillTable + "\\\"" +
            ");\"" ;

          handle = editor_send_msg (dropEditor, cmd, dropStpmHandle) ;
        }
    }
  else
    {
      msg = "Can only drag from Requirement cells." ;
      print_message (msg) ;
    }

  gte_enable_refresh () ;
  gte_refresh_table () ;
}

void
REQ_ReceiveFillTableRequest (int row, string FillTable)
{
  gte_disable_refresh () ;
  gte_disable_action_completed();

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  int def_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
  int last_parent_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int min_col = gte_get_first_col (REQ_ParentReqVsect()) ;
  int min_row = gte_get_first_row (REQ_RequirementsHsect()) ;
  int max_row = gte_get_last_row (REQ_RequirementsHsect()) ;

  if (row < min_row) row = min_row ;

  string RowTag ;
  boolean deleteFlag = False ;

  // if table is empty no need to create new row
  if ((row == min_row) && (row == max_row) && 
      (0 == REQ_GetParentColumn (row) && NoLabel (row,leaf_col)))
    {
      RowTag = to_string (1) ;
    }
  else if (row > max_row)
    {
      row = max_row + 1 ;
      RowTag = "Append" ;
    }
  else
    {
      RowTag = to_string (row-min_row+1) ;
      REQ_DoCreate (row, False);
    }

  FillTable = string_search_and_replace (FillTable, REQ_RowTag, RowTag) ;

  gte_filltable_string (FillTable) ;

  REQ_RespanHierarchyRow (row) ;

  leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  REQ_LabelType label = REQ_ParsedLabel (row, leaf_col) ;
  //if (!IsBlank (label.unique_id)) 
  //{
  //REQ_TestAndMarkAsSatisfied (label.unique_id) ;
  //}


  leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;
  def_col = gte_get_first_col (REQ_LeafDefinitionVsect()) ;
  min_col = gte_get_first_col (REQ_ParentReqVsect()) ;

  // if no leaf, must have copied a parent.
  if (NoLabel (row, leaf_col))
    {
      gte_set_vsect_visibility (REQ_ParentReqVsect(), True) ;
    }

  gte_goto (row, min_col) ;
  gte_set_selection (row, min_col, 
              row, def_col,
              row, def_col) ;

  gte_enable_refresh () ;
  gte_refresh_table () ;
  gte_enable_action_completed();
}

void
ReceiveParentHsectFillTableRequest (string parentName, string FillTable)
{

  int min_parent_row = gte_get_first_row (REQ_ParentDefinitionHsect()) ;
  int max_parent_row = gte_get_last_row (REQ_ParentDefinitionHsect()) ;
  int parent_col = gte_get_first_col (REQ_ParentDefinitionNameVsect()) ;

  int leaf_col = gte_get_first_col (REQ_LeafReqVsect()) ;

  REQ_CellType  Cell ;

  Cell = REQ_FindUniqueId (parentName,
                           min_parent_row, parent_col, 
                           max_parent_row, parent_col) ;
  if (Cell.row == -1)
    {
      FillTable = string_search_and_replace (FillTable, REQ_RowTag, "Append") ;

      gte_filltable_string (FillTable) ;
    }
}

void
setTableSubsystem()
{
    list labels = list_create("string", 0);
    node N;

    string tableName = gte_table_name();
    string tableType = gte_get_table_type();

    if(selection_count("file[${tableType} & name = '${tableName}']") == 0) {
        print_error("Table must be saved before assigning it to a subsystem"); // ECR 7571
        return;
    }

    list_append(labels, "unassigned");
    for_each_in_select("node[UmlPackage & node_refs & items[UmlStereotype & value = 'subsystem']] sort by name", N)
        list_append(labels, N.name);
        editor_item_selector(labels, "setTableSubsystemCallback();",
                                     "Assign Table to Subsystem...",
                                     True);
}

void
setTableSubsystemCallback()
{
    string subsystem = list_get(editor_selector_selected_labels(), 0);
    string tableName = gte_table_name();
    string tableType = gte_get_table_type();

    file F = find_by_query("file[${tableType} & name = '${tableName}']");

    // ECR 5076 start
    item I = find_by_query("item[UmlSubsystemName & obj_id = ${F.id}]");

    if(subsystem == "unassigned") {
	if(I == NULL)
	    return;
    }
    else {
	if(I != NULL && I.value == subsystem)
	    return;

        if(selection_count( "node[UmlPackage & name = '${subsystem}' & items[UmlSubsystemIsLocked & value = 'True']]" ) > 0) {
            print_error("The subsystem " + subsystem + " is locked, you cannot assign a table to it");
            return;
        }
    }

    if(I != NULL) {
        if(selection_count( "node[UmlPackage & name = '${I.value}' & items[UmlSubsystemIsLocked & value = 'True']]" ) > 0) {
            print_error("The table is assigned to the locked subsystem " + I.value + ", you cannot reassign this table");
            return;
        }
    }
    // ECR 5076 end

    int stpemHandle = editor_send_msg("ngoae", "EditorStart " + to_string(editor_get_msgd_name()) + " "
		    + to_string(editor_get_msgd_handle()), -1);
    // ECR 5009
    if( subsystem != "unassigned" )
        editor_send_msg("ngoae",
		    "EditorQrlEval setNoteAndItem(" + F.id + ",\"UmlSubsystem\",\"UmlSubsystemName\",\"" + 
		    subsystem + "\",False);", stpemHandle);
    else
        editor_send_msg("ngoae","EditorQrlEval removeNote(" + F.id + ",\"UmlSubsystem\",False);", stpemHandle);
}


//  Add any user customizations to the file included below:
#include_if_exists "user/ct/rules/qrl/user_rqtbl.qrl"
