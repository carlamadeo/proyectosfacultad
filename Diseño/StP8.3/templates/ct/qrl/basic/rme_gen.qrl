//////////////////////////////////////////////////////////////////////////////
//
//      sccsid[] = @(#)rme_gen.qrl
//      StP/Core
//      Confidential property of Aonix.
//      Copyright (c) 1996
//      All rights reserved
//
//      Description: Provide a meta report script that produces executable QRL.
//
//////////////////////////////////////////////////////////////////////////////

#include "qrl/check/rme_check.inc"
#include "qrl/include/files.inc"

// GLOBALS
external string DIAGNAME = "";
external_help = "The name of the rme file to generate a QRL script for.";
int NUM = 0;
string query = "";
string ASCII_TITLE="center";
string ASCII_AUTHOR="center";
string MIF_TITLE="Title";
string MIF_AUTHOR="Author";
string ILEAF_TITLE="title";
string ILEAF_AUTHOR="subtitle";
string RTF_TITLE="Title";
string RTF_AUTHOR="Author";

string DIAG_ORIENTATION = "Portrait";
string DIAG_CAP_ORIENTATION = "Portrait";
string DIAG_CAPTION = "Diagram: ";
string TBL_ORIENTATION = "PortraitTable";
string TBL_CAPTION = "Table: ";
string TBL_SHOW_ROW_INDICES = "False";
string TBL_SHOW_COL_INDICES = "False";
float DIAG_HEIGHT = 8.0;
float DIAG_WIDTH = 16.0;
float TBL_WIDTH = 16.0;
string RPT_FORMAT_FILE = "rme_report";

int space = 0;
boolean eject_page = False;

void main()
{
    file rme_file;
    node rme_node;
    list filelist = file_list("RmeDiagram", DIAGNAME);
    item rpt_format_file;

    message("Starting QRL report generation...");
   
    if(RmeCheckSemanticsFromQrl(filelist) != 0)
    {
        message("Aborting QRL report generation.");
        return;
    }

    comment(DIAGNAME + ".qrl");
    comment("This file was automatically generated by StP's Report Maker");
    comment(time_to_string(time_now(), NULL));
    ws();

    comment(" GLOBALS");
    out("string query = \"\";");
    ws();

    out("void main()");
    open_brace();
    indent();
    out("file file_var;");
    out("string inc_file = \"\";");
    ws();
    out("target_enum target = target();");
    out("message(\"Starting report processing...\");");
    ws();

    query = "file[RmeDiagram && name = '" + DIAGNAME + "']";
    rme_file = find_by_query(query);

    // set the default format file if none is specified.
    query = "item[FormatFileName && file[RmeDiagram && name = '" + DIAGNAME + "']]";
    rpt_format_file = find_by_query(query);
    if(rpt_format_file != NULL) {
        if(rpt_format_file.value != "") {
        RPT_FORMAT_FILE = rpt_format_file.value;
        }
    }
    out("if (target == Ascii) format(\"" + RPT_FORMAT_FILE + ".asc\");");
    out("if (target == Framemaker) format(\"" + RPT_FORMAT_FILE + ".mif\");");
    // out("if (target == Interleaf) format(\"" + RPT_FORMAT_FILE + ".doc\");");
    out("if (target == RTF) format(\"" + RPT_FORMAT_FILE + ".rtf\");");
    ws();

    // Find starting node (node with outlinks only)
    query = "node[node_refs[file_id = " + rme_file.id + " && !in_link_refs]]";
    rme_node = find_by_query(query);

    process_nodes(rme_node);

    // Process nodes in order of linkage
    while((rme_node = get_next(rme_node, rme_file.id)) != NULL)
    {
        process_nodes(rme_node);
    }

    out("message(\"Finished report processing.\");");
    outdent();
    close_brace();

    message("Finished QRL generation.");
}

void do_space()
{
    int i;
    for(i=0; i < space; i=i+1)
        print(" ");
}

void type_error(string name)
{
    comment("Warning: Type is required for object labeled \"" + name + "\"");
}

void out(string text)
{ do_space(); print_line(text); }

void pl(string text) // Print Line
{ do_space(); print_line("print_line(\"" + text + "\");"); }

void ws() // White Space
{ print_line(); }

void para(string text)
{ do_space(); print_line("paragraph(\"" + text + "\");"); }

void open_brace()
{ do_space(); print_line("{"); }

void close_brace()
{ do_space(); print_line("}"); }

void indent()
{ space = space + 4; }
 
void outdent()
{ space = space - 4; }

void comment(string text)
{ do_space(); print_line("// " + text); }

// Process nodes based upon their type
void process_nodes(node rme_node)
{

    if(rme_node != NULL)
        comment(rme_node.name);
    else
        return;

    message("--Creating QRL for section " + rme_node.name + " ...");

    if(rme_node.type == "CoverPageSection")
    {
        comment("CoverPageSection");
        out("message(\"-- Processing " + rme_node.name + "...\");");
        process_coverpage(rme_node, eject_page);
        eject_page = True;
        ws();
    }

    if(rme_node.type == "SingleDiagSection")
    {
        comment("SingleDiagSection");
        out("message(\"-- Processing " + rme_node.name + "...\");");
        process_singlediag(rme_node, eject_page);
        eject_page = False;
        ws();
    }

    if(rme_node.type == "MultiDiagSection")
    {
        comment("MultiDiagSection");
        out("message(\"-- Processing " + rme_node.name + "...\");");
        process_multidiag(rme_node, eject_page);
        eject_page = False;
        ws();
    }

    if(rme_node.type == "SingleTableSection")
    {
        comment("SingleTableSection");
        out("message(\"-- Processing " + rme_node.name + "...\");");
        process_singletable(rme_node, eject_page);
        eject_page = False;
        ws();
    }

    if(rme_node.type == "MultiTableSection")
    {
        comment("MultiTableSection");
        out("message(\"-- Processing " + rme_node.name + "...\");");
        process_multitable(rme_node, eject_page);
        eject_page = False;
        ws();
    }

    if(rme_node.type == "MultiObjectSection")
    {
        comment("MultiObjectSection");
        out("message(\"-- Processing " + rme_node.name + "...\");");
        process_multiobject(rme_node, eject_page);
        eject_page = False;
        ws();
    }

    if(rme_node.type == "TextSection")
    {
        comment("TextSection");
        out("message(\"-- Processing " + rme_node.name + "...\");");
        process_text(rme_node, eject_page);
        eject_page = False;
        ws();
    }
}
 
node get_next(node rme_node, int file_id)
{
    link rme_link;
 
    if(rme_node == NULL) return NULL;

    // Get next node in the chain
    query = "link[link_refs[file_id = " + file_id + "] && from_node_id = " + rme_node.id + "]";
    rme_link = find_by_query(query);
 
    if(rme_link == NULL) return NULL;
 
    query = "node[node_refs && id = " + rme_link.to_node_id + "]";
    rme_node = find_by_query(query);
 
    return rme_node;
}

item get_item(node rme_node, string item_type, string node_type)
{
    string query;
    query = "item[" + item_type + " && node[node_refs && " + node_type + " && id == " +
            rme_node.id + "]]";
    return(find_by_query(query));
}
void set_diag_parms(item diag_orient, item diag_cap_orient, item diag_height, item diag_width)
{
    string diagram_cap_orient, diagram_orient;
    float diagram_height, diagram_width;

    diagram_orient = DIAG_ORIENTATION;
    if(diag_orient != NULL) if(diag_orient.value != "")
        diagram_orient = diag_orient.value;

    out("diagram_orientation_scale_set(" + diagram_orient +");");

    diagram_cap_orient = DIAG_CAP_ORIENTATION;
    if(diag_cap_orient != NULL) if(diag_cap_orient.value != "")
        diagram_cap_orient = diag_cap_orient.value;

    out("diagram_caption_orientation_set(" + diagram_cap_orient +");");
    out( "diagram_caption_paragraph_format_set(\"Figure\");");

    diagram_height = DIAG_HEIGHT;
    if(diag_height != NULL)
        diagram_height = to_float(diag_height.value);

    out("diagram_frame_height_set(" + diagram_height +");");

    diagram_width = DIAG_WIDTH;
    if(diag_width != NULL)
        diagram_width = to_float(diag_width.value);

    out("diagram_frame_width_set(" + diagram_width +");");
}

void set_tbl_parms(item tbl_orient, item tbl_row_range, item tbl_col_range, item tbl_hdr_row_range, item tbl_show_row_indices, item tbl_show_col_indices, item tbl_width)
{

    string table_row_range, table_col_range, table_hdr_row_range;
    string table_orient, table_show_row_indices, table_show_col_indices;
    float table_width;

    table_orient = TBL_ORIENTATION;
    if(tbl_orient != NULL) if(tbl_orient.value != "")
    {
        table_orient = tbl_orient.value;
        out("table_orientation_set(" + table_orient + ");");
    }

    if(tbl_row_range != NULL) if(tbl_row_range.value != "")
    {
        table_row_range = tbl_row_range.value;
        out("table_row_range_set(\"" + table_row_range + "\");");
    }

    if(tbl_col_range != NULL) if(tbl_col_range.value != "")
    {
        table_col_range = tbl_col_range.value;
        out("table_column_range_set(\"" + table_col_range + "\");");
    }

    if(tbl_hdr_row_range != NULL) if(tbl_hdr_row_range.value != "")
    {
        table_hdr_row_range = tbl_hdr_row_range.value;
        out("table_header_row_range_set(\"" + table_hdr_row_range + "\");");
    }

    table_show_row_indices = TBL_SHOW_ROW_INDICES;
    if(tbl_show_row_indices != NULL) if(tbl_show_row_indices.value != "")
        table_show_row_indices = tbl_show_row_indices.value;
    out("table_print_row_indices_set(" + table_show_row_indices + ");");
 
    table_show_col_indices = TBL_SHOW_COL_INDICES;
    if(tbl_show_col_indices != NULL) if(tbl_show_col_indices.value != "")
        table_show_col_indices = tbl_show_col_indices.value;
    out("table_print_column_indices_set(" + table_show_col_indices + ");");

    table_width = TBL_WIDTH;
    if(tbl_width != NULL)
        table_width = to_float(tbl_width.value);
 
    out("table_width_set(" + table_width +");");
}

void reset_tbl_parms()
{
    // Reset all stuff that we changed so next table will be virgin
        out("table_override_clear_all();");
}

void loop_thru_text_notes(node rme_node, string obj_type)
{
    string temp = "";
    note text_note;
    item default_style, ascii_style, mif_style, ileaf_style, rtf_style;
    item include_file;

    for_each_in_select("note[TextRptOptions && node[" + obj_type + " && id == "
+ rme_node.id + "]] sort by name", text_note)
    {
 
        default_style = find_by_query("item[ParagraphStyle && node[" + obj_type + " && id == " + rme_node.id + "] && note[name == '" + text_note.name + "']]");
        ascii_style = find_by_query("item[AsciiParagraphStyle && node[" + obj_type + " && id == " + rme_node.id + "] && note[name == '" + text_note.name + "']]");
        mif_style = find_by_query("item[MifParagraphStyle && node[" + obj_type + " && id == " + rme_node.id + "] && note[name == '" + text_note.name + "']]");
        ileaf_style = find_by_query("item[IleafParagraphStyle && node[" + obj_type + " && id == " + rme_node.id + "] && note[name == '" + text_note.name + "']]");
        rtf_style = find_by_query("item[RtfParagraphStyle && node[" + obj_type + " && id == " + rme_node.id + "] && note[name == '" + text_note.name + "']]");

        include_file = find_by_query("item[RmeIncludeFile && node[" + obj_type + " && id == " + rme_node.id + "] && note[name == '" + text_note.name + "']]");
 
        process_paragraphs(default_style, ascii_style, mif_style, ileaf_style, rtf_style);
 
        temp = string_escape(text_note.desc, "\"");
        pl(temp);

        // Add included file text after the note description text
        if(include_file != NULL) if (include_file.value != "")
        {
            ws();
            out("inc_file = read_file(\"" + include_file.value + "\");");
            out("print_line(inc_file);");

            // Alternate way. This embeds the text in the QRL output
	    //    temp = string_escape(read_file(include_file.value), "\"");
            //    pl(temp);
        }

        ws();
    }
}

void loop_thru_item_values(node rme_node, string obj_type, int num)
{
    item selected_item;
    string temp = "";
    string item_type;

    for_each_in_select("item[" + obj_type + " && node[id == " + rme_node.id + "]]", selected_item)
    {
        item_type = selected_item.value;

        comment("Show Item Value: " + item_type);

        temp = "item_val_var" + num + " = find_by_query(\"item[" + item_type + " && node[id = \" + node_var" + num + ".id + \" && node_refs]]\");";

        ws();
        out("print_line(\"  Item : " + item_type + "\");");
        out(temp);

        out("if(item_val_var" + num  + " != NULL) print_line(\"    \" + item_val_var" + num + ".value);");
        pl("");
        ws();
        
    }
}

void loop_thru_note_descs(node rme_node, string obj_type, int num)
{
    item selected_item;
    string temp = "";
    string item_type;

    for_each_in_select("item[" + obj_type + " && node[id == " + rme_node.id + "]]", selected_item)
    {
        item_type = selected_item.value;

        comment("Show Note Description: " + item_type);

        ws();
        out("print_line(\"  Note Description for " + item_type + " :\");");
        out("note_desc_var" + num + " = find_by_query(\"note[" + item_type + " && node[id = \" + node_var" + num + ".id + \" && node_refs]]\");");

        out("if(note_desc_var" + num  + " != NULL) print_line(note_desc_var" + num + ".desc);");
        pl("");
        ws();
    }
}

void process_coverpage(node rme_node, boolean eject_page)
{
    string doc_title = rme_node.name;
    string temp = "";
    item title, author, show_date;
    item start_new_page;

    title = get_item(rme_node, "Title", "CoverPageSection");
    author = get_item(rme_node, "Author", "CoverPageSection");
    show_date = get_item(rme_node, "ShowReportDate", "CoverPageSection");
    start_new_page = get_item(rme_node, "StartNewPage", "CoverPageSection");
 
    ws();
    if(start_new_page != NULL) if (start_new_page.value == "True")
        out("page();");

    temp = "if (target == Ascii) paragraph(\"" + ASCII_TITLE + "\");";
    out(temp);

    temp = "if (target == Framemaker) paragraph(\""+ MIF_TITLE + "\");"; 
    out(temp);

//    temp = "if (target == Interleaf) paragraph(\""+ ILEAF_TITLE + "\");"; 
//    out(temp);

    temp = "if (target == RTF) paragraph(\""+ RTF_TITLE + "\");";
    out(temp);
    ws();

    pl("");

    if(title != NULL) if (title.value != "")
        doc_title = title.value;
    pl(doc_title);
    pl("");

    ws();
    temp = "if (target == Ascii) paragraph(\"" + ASCII_AUTHOR + "\");";  
    out(temp); 

    temp = "if (target == Framemaker) paragraph(\"" + MIF_AUTHOR + "\");";  
    out(temp); 

//    temp = "if (target == Interleaf) paragraph(\"" + ILEAF_AUTHOR + "\");";  
//    out(temp); 

    temp = "if (target == RTF) paragraph(\"" + RTF_AUTHOR + "\");";  
    out(temp); 
    
    ws();

    temp = string_search_and_replace(current_projdir(),"\\","/");
    
    pl("Project Directory : " + temp);
    pl("System Name : " + current_system());

    // Author extraction
    if(author != NULL) if (author.value != "")
        pl("Prepared by : " + author.value);

    if(show_date != NULL) if (show_date.value == "True")
        pl(time_to_string(time_now(),NULL));

    loop_thru_text_notes(rme_node, "CoverPageSection");

    out("page();");
}

void process_singlediag(node rme_node, boolean eject_page)
{
    string temp = "", diagram_name, diagram_caption, diagram_print_settings;
    item diag_type, diag_name, diag_orient;
    item diag_caption, diag_cap_orient;
    item diag_height, diag_width;
    item diag_print_settings;
    item start_new_page;

    diag_type = get_item(rme_node, "DiagramType", "SingleDiagSection");
    diag_name = get_item(rme_node, "DiagramName", "SingleDiagSection");
    diag_orient = get_item(rme_node, "Orientation", "SingleDiagSection");
    diag_caption = get_item(rme_node, "Caption", "SingleDiagSection");
    diag_cap_orient = get_item(rme_node, "CaptionOrientation", "SingleDiagSection");
    diag_height = get_item(rme_node, "DiagramFrameHeight", "SingleDiagSection");
    diag_width = get_item(rme_node, "DiagramFrameWidth", "SingleDiagSection");
    diag_print_settings = get_item(rme_node, "PrintSetting", "SingleDiagSection");
    start_new_page = get_item(rme_node, "StartNewPage", "SingleDiagSection");
 
    ws();

    if(eject_page == False)
        if(start_new_page != NULL) if (start_new_page.value == "True")
            out("page();");


    if(diag_type == NULL)
    {
        type_error(rme_node.name);
        return;
    }

    set_diag_parms(diag_orient, diag_cap_orient, diag_height, diag_width);

    diagram_name = rme_node.name;
    if(diag_name != NULL) if(diag_name.value != "")
        diagram_name = diag_name.value;

    if(diag_type != NULL) if (diag_type.value != "")
        temp = "query = \"file[" + diag_type.value + " && name == '" +
               diagram_name + "']\";";

    out(temp);
    out("for_each_in_select(query, file_var)");
    open_brace();
    indent();

    temp = "file_print(file_var, \"";

    diagram_caption = DIAG_CAPTION;
    if(diag_caption != NULL) if (diag_caption.value != "")
        diagram_caption = diag_caption.value;

    temp = temp + diagram_caption + " \" + " + "file_var.name";

    if(diag_print_settings != NULL) if (diag_print_settings.value != "")
    {
        diagram_print_settings = diag_print_settings.value;
        temp = temp + ", \"" + diagram_print_setting + "\"";
    }

    temp = temp + ");";
    out(temp);

    outdent();
    close_brace();
}
void process_multidiag(node rme_node, boolean eject_page)
{
    string temp = "", diagram_caption, diagram_cap_orient, diagram_orient;
    string diagram_print_setting;
    item diag_type, diag_omit, diag_orient, diag_sort;
    item diag_caption, diag_cap_orient;
    item diag_height, diag_width;
    item start_new_page, start_each_new_page;
    item diag_print_setting;

    diag_type = get_item(rme_node, "DiagramType", "MultiDiagSection");
    diag_orient = get_item(rme_node, "Orientation", "MultiDiagSection");
    diag_caption = get_item(rme_node, "Caption", "MultiDiagSection");
    diag_cap_orient = get_item(rme_node, "CaptionOrientation", "MultiDiagSection");
    diag_height = get_item(rme_node, "DiagramFrameHeight", "MultiDiagSection");
    diag_width = get_item(rme_node, "DiagramFrameWidth", "MultiDiagSection");
    diag_omit = get_item(rme_node, "OmitDiagCalled", "MultiDiagSection");
    diag_sort = get_item(rme_node, "SortBy", "MultiDiagSection");
    diag_print_setting = get_item(rme_node, "PrintSetting", "MultiDiagSection");
    start_new_page = get_item(rme_node, "StartNewPage", "MultiDiagSection");
    start_each_new_page = get_item(rme_node, "StartEachNewPage", "MultiDiagSection");
 
    ws();

    if(eject_page == False)
        if(start_new_page != NULL) if (start_new_page.value == "True")
            out("page();");

    if(diag_type == NULL)
    {
        type_error(rme_node.name);
        return;
    }

    set_diag_parms(diag_orient, diag_cap_orient, diag_height, diag_width);

    if(diag_type != NULL) if (diag_type.value != "")
        temp = "query = \"file[" + diag_type.value;

    if(diag_omit != NULL) if (diag_omit.value != "")
        temp = temp + " && name != '" + diag_omit.value + "'";
    temp = temp + "]";
    if(diag_sort != NULL) if (diag_sort.value != "")
        temp = temp + " sort by " + diag_sort.value;
    temp = temp + "\";";
    out(temp);


    out("for_each_in_select(query, file_var)");
    open_brace();
    indent();

    if(start_each_new_page != NULL) if (start_each_new_page.value == "True")
        out("page();");

    temp = "file_print(file_var, \"";

    diagram_caption = DIAG_CAPTION;
    if(diag_caption != NULL) if (diag_caption.value != "")
        diagram_caption = diag_caption.value;

    temp = temp + diagram_caption + " \" + " + "file_var.name";
 
    if(diag_print_setting != NULL) if (diag_print_setting.value != "")
    {
        diagram_print_setting = diag_print_setting.value;
        temp = temp + ", \"" + diagram_print_setting + "\"";
    }
 
    temp = temp + ");";
    out(temp);

    outdent();
    close_brace();
}

void process_singletable(node rme_node, boolean eject_page)
{
    string table_name, temp = "";
    string table_caption, table_show_row_indices, table_show_col_indices;
    string table_row_range, table_col_range, table_hdr_row_range;
    string table_print_setting;
    item tbl_type, tbl_name, tbl_caption, tbl_orient;
    item tbl_row_range, tbl_col_range, tbl_hdr_row_range;
    item tbl_show_row_indices, tbl_show_col_indices, tbl_width;
    item tbl_print_setting;
    item start_new_page;
 
    tbl_type = get_item(rme_node, "TableType", "SingleTableSection");
    tbl_name = get_item(rme_node, "TableName", "SingleTableSection");
    tbl_caption = get_item(rme_node, "Caption", "SingleTableSection");
    tbl_orient = get_item(rme_node, "TableOrientation", "SingleTableSection");
    tbl_row_range = get_item(rme_node, "RowRange", "SingleTableSection");
    tbl_col_range = get_item(rme_node, "ColumnRange", "SingleTableSection");
    tbl_hdr_row_range = get_item(rme_node, "HeaderRowRange", "SingleTableSection");
    tbl_show_row_indices = get_item(rme_node, "ShowRowIndices", "SingleTableSection");
    tbl_show_col_indices = get_item(rme_node, "ShowColumnIndices", "SingleTableSection");
    tbl_width = get_item(rme_node, "TableWidth", "SingleTableSection");
    tbl_print_setting = get_item(rme_node, "PrintSetting", "SingleTableSection");
    start_new_page = get_item(rme_node, "StartNewPage", "SingleTableSection");

    ws();

    if(eject_page == False)
        if(start_new_page != NULL) if (start_new_page.value == "True")
            out("page();");
 

    if(tbl_type == NULL)
    {
        type_error(rme_node.name);
        return;
    }

    table_name = rme_node.name;
    if(tbl_name != NULL) if(tbl_name.value != "")
        table_name = tbl_name.value;
 
    set_tbl_parms(tbl_orient, tbl_row_range, tbl_col_range, tbl_hdr_row_range, tbl_show_row_indices, tbl_show_col_indices, tbl_width);
 
    if(tbl_type != NULL) if(tbl_type.value != "")
        temp = "query = \"file[" + tbl_type.value + " && name == '" +
               table_name + "']\";";
 
    out(temp);
    out("for_each_in_select(query, file_var)");
    open_brace();
    indent();
 
    temp = "file_print(file_var, \"";
 
    table_caption = TBL_CAPTION;
    if(tbl_caption != NULL) if (tbl_caption.value != "")
        table_caption = tbl_caption.value;
 
    temp = temp + table_caption;
    temp = temp + " \" + " + "file_var.name";
 
    if(tbl_print_setting != NULL) if (tbl_print_setting.value != "")
    {
        table_print_setting = tbl_print_setting.value;
        temp = temp + ", \"" + table_print_setting + "\"";
    }
 
    temp = temp + ");";
    out(temp);
    outdent();
    close_brace();

    reset_tbl_parms();
}

void process_multitable(node rme_node, boolean eject_page)
{
    string temp = "";
    string table_caption, table_show_row_indices, table_show_col_indices;
    string table_row_range, table_col_range, table_hdr_row_range;
    string table_print_setting;
    item tbl_type, tbl_omit, tbl_sort, tbl_caption, tbl_orient;
    item tbl_row_range, tbl_col_range, tbl_hdr_row_range;
    item tbl_show_row_indices, tbl_show_col_indices, tbl_width;
    item tbl_print_setting;
    item start_new_page, start_each_new_page; 
 
    tbl_type = get_item(rme_node, "TableType", "MultiTableSection");
    tbl_omit = get_item(rme_node, "OmitTableCalled", "MultiTableSection");
    tbl_sort = get_item(rme_node, "SortBy", "MultiTableSection");
    tbl_caption = get_item(rme_node, "Caption", "MultiTableSection");
    tbl_orient = get_item(rme_node, "TableOrientation", "MultiTableSection");
    tbl_row_range = get_item(rme_node, "RowRange", "MultiTableSection");
    tbl_col_range = get_item(rme_node, "ColumnRange", "MultiTableSection");
    tbl_hdr_row_range = get_item(rme_node, "HeaderRowRange", "MultiTableSection");
    tbl_show_row_indices = get_item(rme_node, "ShowRowIndices", "MultiTableSection");
    tbl_show_col_indices = get_item(rme_node, "ShowColumnIndices", "MultiTableSection");
    tbl_width = get_item(rme_node, "TableWidth", "MultiTableSection");
    tbl_print_setting = get_item(rme_node, "PrintSetting", "MultiTableSection");
    start_new_page = get_item(rme_node, "StartNewPage", "MultiTableSection");
    start_each_new_page = get_item(rme_node, "StartEachNewPage", "MultiTableSection");
 
    ws();

    if(eject_page == False)
        if(start_new_page != NULL) if (start_new_page.value == "True") 
            out("page();");
 

    if(tbl_type == NULL)
    {
        type_error(rme_node.name);
        return;
    }
 
    set_tbl_parms(tbl_orient, tbl_row_range, tbl_col_range, tbl_hdr_row_range, tbl_show_row_indices, tbl_show_col_indices, tbl_width);
 
    if(tbl_type != NULL) if (tbl_type.value != "")
        temp = "query = \"file[" + tbl_type.value;
 
    if(tbl_omit != NULL) if (tbl_omit.value != "")
        temp = temp + " && name != '" + tbl_omit.value + "'";
    temp = temp + "]";
    if(tbl_sort != NULL) if (tbl_sort.value != "")
        temp = temp + " sort by " + tbl_sort.value;
    temp = temp + "\";";
    out(temp);
 
 
    out("for_each_in_select(query, file_var)");
    open_brace();
    indent();

    if(start_each_new_page != NULL) if (start_each_new_page.value == "True")
        out("page();");

    temp = "file_print(file_var, \"";
 
    table_caption = TBL_CAPTION;
    if(tbl_caption != NULL) if (tbl_caption.value != "")
        table_caption = tbl_caption.value;
 
    temp = temp + table_caption;
    temp = temp + " \" + " + "file_var.name";
 
    if(tbl_print_setting != NULL) if (tbl_print_setting.value != "")
    { 
        table_print_setting = tbl_print_setting.value; 
        temp = temp + ", \"" + table_print_setting + "\""; 
    } 
  
    temp = temp + ");";
    out(temp);

    outdent();
    close_brace();

    reset_tbl_parms();
}

void process_text(node rme_node, boolean eject_page)
{
    item start_new_page;

    start_new_page = get_item(rme_node, "StartNewPage", "TextSection");

    ws();

    if(eject_page == False)
        if(start_new_page != NULL) if (start_new_page.value == "True")
            out("page();");

    loop_thru_text_notes(rme_node, "TextSection");

}

void process_paragraphs(item default_style, item ascii_style, item mif_style, item ileaf_style, item rtf_style)
{
    string temp = "", paragraph_style = "";

 
    if(ascii_style != NULL) if (ascii_style.value != "")
    {
        paragraph_style = ascii_style.value;
        temp = "if (target == Ascii) paragraph(\"" + paragraph_style + "\");";
        out(temp);
    }
             
    if(mif_style != NULL) if (mif_style.value != "")
    {
        paragraph_style = mif_style.value;
        temp = "if (target == Framemaker) paragraph(\"" + paragraph_style + "\");";
        out(temp);
    }
             
//    if(ileaf_style != NULL) if (ileaf_style.value != "")
//    {
//        paragraph_style = ileaf_style.value;
//        temp = "if (target == Interleaf) paragraph(\"" + paragraph_style + "\");"; 
//        out(temp); 
//    }

    if(rtf_style != NULL) if (rtf_style.value != "")
    {  
        paragraph_style = rtf_style.value;
        temp = "if (target == RTF) paragraph(\"" + paragraph_style + "\");";
        out(temp);
    }

    // default paragraph style overrides all others for flexibility
    if(default_style != NULL) if (default_style.value != "")
    {
        paragraph_style = default_style.value;
        para(paragraph_style);
    }
}

item get_obj_item(node rme_node, note obj_note, string obj_type)
{
    string query = "item[" + obj_type +" && node[MultiObjectSection && id == " + rme_node.id + "] && note[name == '" + obj_note.name + "']]";
    return(find_by_query(query));
}

void process_multiobject(node rme_node, boolean eject_page)
{
    string temp = "";
    int num;
    note obj_note;
    node node_var;
    item obj_type, obj_name, obj_list_attrs, obj_list_ops;
    item obj_list_inlinks, obj_list_outlinks;
    item default_style, ascii_style, mif_style, ileaf_style, rtf_style;
    item start_new_page, start_each_new_page;

    start_new_page = get_item(rme_node, "StartNewPage", "MultiObjectSection");
    start_each_new_page = get_item(rme_node, "StartEachNewPage", "MultiObjectSection");
    default_style = get_item(rme_node, "ParagraphStyle", "MultiObjectSection");
    ascii_style = get_item(rme_node, "AsciiParagraphStyle", "MultiObjectSection");
    mif_style = get_item(rme_node, "MifParagraphStyle", "MultiObjectSection");
    ileaf_style = get_item(rme_node, "IleafParagraphStyle", "MultiObjectSection");
    rtf_style = get_item(rme_node, "RtfParagraphStyle", "MultiObjectSection");

    ws();

    if(eject_page == False)
        if(start_new_page != NULL) if (start_new_page.value == "True")
            out("page();");

    process_paragraphs(default_style, ascii_style, mif_style, ileaf_style, rtf_style);

    for_each_in_select("note[DBObjectRptOptions && node[MultiObjectSection && id == " + rme_node.id + " && node_refs]] sort by name", obj_note)
    {
        obj_type = get_obj_item(rme_node, obj_note, "DBObjectType");
        obj_name = get_obj_item(rme_node, obj_note, "DBObjectName");
        obj_list_attrs = get_obj_item(rme_node, obj_note, "ListAttributes");
        obj_list_ops = get_obj_item(rme_node, obj_note, "ListOperations");
        obj_list_inlinks = get_obj_item(rme_node, obj_note, "ListInLinks");
        obj_list_outlinks = get_obj_item(rme_node, obj_note, "ListOutLinks");

        if(obj_type == NULL)
        {
            type_error(rme_node.name);
            return;
        }

        // Since we may loop through this more than once, we need to
        // create unique names and declare them up front

        num = uniq_num();

        ws();
        comment("Declare a set of uniquely named variables each time.");
        ws();
        out("node node_var" + num + ";");
        out("node node_ops_var" + num + ";");
        out("node node_attr_var" + num + ";");
        out("link in_link_var" + num + ";");
        out("link out_link_var" + num + ";");
        out("note note_desc_var" + num + ";");
        out("item item_val_var" + num + ";");
        ws();

        pl("--- Database report on type : " + obj_type.value + " ---");

        temp = "query = \"node[" + obj_type.value;
        if(obj_name != NULL) if (obj_name.value != NULL)
            temp = temp + " && name == '" + obj_name.value + "'";
        temp = temp + "]\";";

        out(temp);
        out("for_each_in_select(query, node_var" + num + ")");
        open_brace();
        indent();

        if(start_each_new_page != NULL) if (start_each_new_page.value == "True")
        out("page();");

        out("print_line(node_var" + num + ".name);");
        ws();

        if(obj_list_attrs != NULL) if(obj_list_attrs.value == "True")
            list_attrs(obj_type.value, num);
        if(obj_list_ops != NULL) if(obj_list_ops.value == "True")
            list_ops(obj_type.value, num);
        if(obj_list_inlinks != NULL) if(obj_list_inlinks.value == "True")
            list_inlinks(num);
        if(obj_list_outlinks != NULL) if(obj_list_outlinks.value == "True")
            list_outlinks(num);

        loop_thru_item_values(rme_node, "ShowItemValueFor", num);

        loop_thru_note_descs(rme_node, "ShowNoteDescFor", num);

        outdent();
        close_brace();
        ws();
    }
}

void list_attrs(string obj_type, int num)
{
    string temp = "";

    comment("List Attributes");

    if(to_lower(obj_type) == "omtclass")
        temp = "for_each_in_select(\"node[OMTAttribute && scope_node_id == \" + node_var" + num + ".id + \" && node_refs]\", node_attr_var" + num + ")";
    else if(to_lower(obj_type) == "entity")
        temp = "for_each_in_select(\"node[Attribute && scope_node_id == \" + node_var" + num + ".id + \" && node_refs]\", node_attr_var" + num + ")";
    else if(to_lower(obj_type) == "umlclass")
        temp = "for_each_in_select(\"node[UmlAttribute && scope_node_id == \" + node_var" + num + ".id + \" && node_refs]\", node_attr_var" + num + ")";
    else
    {
        comment("Warning: Object type must be OMTClass, UmlClass or Entity.");
        return;
    }

    ws();
    out("print_line(\"  Attributes :\");");
    out(temp);

    open_brace();
    indent();
    out("print_line(\"    \" + node_attr_var" + num + ".name);");
    outdent();
    close_brace();
    pl("");
    ws();

}
void list_ops(string obj_type, int num)
{
    string temp = "";

    comment("List Operations");
 
    if(to_lower(obj_type) == "omtclass")
        temp = "for_each_in_select(\"node[OMTOperation && scope_node_id == \" + node_var" + num + ".id + \" && node_refs]\", node_ops_var" + num + ")";
    else if(to_lower(obj_type) == "umlclass")
        temp = "for_each_in_select(\"node[UmlOperation && scope_node_id == \" + node_var" + num + ".id + \" && node_refs]\", node_ops_var" + num + ")";
    else
    {
        comment("Warning: Object type must be OMTClass or UmlClass.");
        return;
    }

    ws();
    out("print_line(\"  Operations :\");");
    out(temp);
 
    open_brace();
    indent();
    out("print_line(\"    \" + node_ops_var" + num + ".name);");
    outdent();
    close_brace();
    pl("");
    ws();
}
void list_inlinks(int num)
{
    string temp = "";

    comment("List In Links");
    temp = "for_each_in_select(\"link[to_node[id = \" + node_var" + num + ".id + \" && node_refs]] sort by type\", in_link_var" + num + ")";
 
    ws();
    out("print_line(\"  In Link(s) :\");");
    out(temp);

    open_brace();
    indent();
    out("print_line(\"    \" + in_link_var" + num + ".type + \" : \" + in_link_var" + num + ".name);");
    outdent();
    close_brace();
    pl("");
    ws();
}

void list_outlinks(int num)
{
    string temp = "";

    comment("List Out Links");
    temp = "for_each_in_select(\"link[from_node[id = \" + node_var" + num + ".id + \" && node_refs]] sort by type\", out_link_var" + num + ")";
 
    ws();
    out("print_line(\"  Out Link(s) :\");");
    out(temp);
 
    open_brace();
    indent();   
    out("print_line(\"    \" + out_link_var" + num + ".type + \" : \" + out_link_var" + num + ".name);"); 
    outdent(); 
    close_brace(); 
    pl(""); 
    ws();
}

void show_note(string note_type, int num)
{
    comment("Show Note Description");
 
    ws();
    out("print_line(\"  Note Description for " + note_type + " :\");");
    out("note_desc_var" + num + "  = find_by_query(\"note[" + note_type + " && node[id = \" + node_var" + num + ".id + \" && node_refs]]\"));");
 
    out("print_line(note_desc_var" + num + ".desc);");
    pl("");
    ws();
}

int uniq_num()
{
    NUM = NUM + 1;
    return(NUM);
}

// This function is defined here to use the standard message function.
void out_error(string text)
{
    message(text);
}

// This function is defined here to use the standard message function.
void out_message(string text)
{
    message(text);
}
