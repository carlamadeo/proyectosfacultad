//////////////////////////////////////////////////////////////////////////////
//
//      sccsid[] = %W% %Y% %D%
//	StP Core
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1994
//      All rights reserved
//
//////////////////////////////////////////////////////////////////////////////


external	string	sql_command_file = "";
external	boolean	dryrun = False;
external	boolean delete_all_except_last = False;
external	string	repository_name = "";

#include "qrl/include/user_input.inc"


struct	id_ind_tp
{
    int	id;
    int	ind;
};

list
hists_to_ids(list l)
{
    list	res;
    int		i, id, cnt = list_count(l);
    id_ind_tp	el;
    file_hist   h;

    res = list_create("id_ind_tp", 0);
    for(i = 0; i < cnt; i = i + 1)
    {
	el.ind = i;
	h = list_get(l, i);
	el.id = h.id;
	list_append(res, el);
    }
    return(list_sort_by_field(res, "id"));
}

void
print_hev_list(list l, int lim)
{
    int		i;
    int		cnt;
    file_hist	h;

    cnt = list_count(l);
    if (lim < cnt)
	cnt = lim;
    for(i = 0; i < cnt; i = i + 1)
    {
	h = list_get(l, i);
	message(i + ": " + h.id + ": " + h.type + " " + h.file_id + " " + h.user + " " + h.time);
    }
}


void
print_id_list(list l, int lim)
{
    int		i;
    int		cnt;
    id_ind_tp	ind;

    cnt = list_count(l);
    if (lim < cnt)
	cnt = lim;
    for(i = 0; i < cnt; i = i + 1)
    {
	ind = list_get(l, i);
	message(i + ": ind: " + ind.ind + ", id: " + ind.id);
    }
}


const	int	SYBASE_IN_LIM =  100;

// binary search .....

int
ind_from_id(list li, int id)
{
    int		l = 0, r = list_count(li) - 1;
    int		k, lid, res;
    id_ind_tp	el;


    while(True)
    {
	k = (l+r)/2;
	el = list_get(li, k);
	lid = el.id;
	if (lid == id)
	{
	    res = el.ind;
	    list_delete(li, k);
	    return(res);
	}
	if (id < lid)
	    r = k-1;
	else
	    l = k+1;
	if (l > r)
	    break;
    }
    return(list_count(li));
}

void
print_hevent(file_hist h)
{
    message(h.id + ": " + h.type + " " + h.file_id + " " + h.user + " " + h.time);
}

boolean
check_event(int id, list l, int ind)
{
    file_hist h;

    h = list_get(l, ind);

    if (h.id != id)
    {
	message("Expected id: " + id + ", at ind: " + ind);
	print_hevent(h);
	return(False);
    }
    return(True);
}

void
main()
{
    list	files, hists, histid, keep, delete, dids, il;
    int		i, j, k;
    file_hist	h, h1;
    file	f;
    int		fcount, ind, hcount;
    string	sql_string, ts;
    string	syb_rep_name;


    syb_rep_name = repository_name;
    if (syb_rep_name == "")
    {
	syb_rep_name = repinfo_var("repname");
	if (syb_rep_name == NULL || syb_rep_name == "")
	{
	    syb_rep_name = current_system();
	}
    }

    message("Truncate File Object History for System: " + current_system());
    if (delete_all_except_last == False)
    {
	message("    Keep Last File History Object per User");
    } else {
	message("    Keep Used File History Object only");
    }
    if (sql_command_file == "")
    {
	sql_command_file = temp_file("hst", "sql");
    }

    files = list_select("file");
    message("\tFound " + list_count(files) + " File Objects");
    hists = list_select("file_hist[file_id > 0] sort by file_id, type, user, time");
    hcount = list_count(hists);
    message("\tFound " + list_count(hists) + " File History Objects");

    // message("hists (sorted): " + list_count(hists));
    hcount = list_count(hists);

    histid = hists_to_ids(hists);
    // print_id_list(histid, list_count(histid));
    // print_hev_list(hists, list_count(hists));
    keep = list_create("file_hist", 0);

    fcount = list_count(files);
    hcount = list_count(histid);
    message("    Find used File History Objects");
    delete = list_create("int", 0);
    show_meter(fcount, 50);
    for(k = 0, i = 0; i < fcount; i = i + 1)
    {
	if (k == 50)
	{
	    update_meter();
	    k = 0;
	}
	k = k + 1;
	f = list_get(files, i);
	if (f.lview_id > 0)
	{
	    ind = ind_from_id(histid, f.lview_id);
	    if (ind < hcount)
	    {
		// check_event(f.lview_id, hists, ind);
		list_append(keep, list_get(hists, ind));
		list_append(delete, ind);
	    } else {
		message("Not found: last view history event: " + f.lview_id);
	    }
	}
	if (f.lmdfy_id > 0)
	{
	    ind = ind_from_id(histid, f.lmdfy_id);
	    if (ind < hcount)
	    {
		// check_event(f.lmdfy_id, hists, ind);
		list_append(keep, list_get(hists, ind));
		list_append(delete, ind);
	    } else {
		message("Not found: last mod history event: " + f.lmdfy_id);
	    }
	}
	if (f.lsync_id > 0)
	{
	    ind = ind_from_id(histid, f.lsync_id);
	    if (ind < hcount)
	    {
		// check_event(f.lsync_id, hists, ind);
		list_append(keep, list_get(hists, ind));
		list_append(delete, ind);
	    } else {
		message("Not found: last sync history event: " + f.lsync_id);
	    }
	}
    }
    if (fcount > 0)
    {
	update_meter();                  
    }
    finish_meter();
    // message("Eliminate events except last\n");
    delete = list_sort(delete);
    for(i = list_count(delete) - 1; i >= 0; i = i - 1)
    {
	ind = list_get(delete, i);
	list_delete(hists, ind);
    }

    hcount = list_count(hists);

    if (delete_all_except_last == False)
    {
	message("    Find last File History Object per user");
	h1 = NULL;
	delete = list_create("file_hist", 0);
	for(i = 0; i < hcount; i = i + 1)
	{
	    h = list_get(hists, i);
	    if (h1 != NULL)
	    {
		if (h.type != h1.type ||
		    h.file_id != h1.file_id ||
		    h.user != h1.user)
		{
		    list_append(keep, h1);
		} else {
		    list_append(delete, h1);
		}
	    }
	    h1 = h;
	}
	if (h1 != NULL)
	{
	    list_append(keep, h1);
	}
    } else
    {
	delete = hists;
    }
    /****************************
    message("Keep: " + list_count(keep) + " File History Objects");
    for(i = 0; i < list_count(keep); i = i + 1)
    {
	h = list_get(keep, i);
	message(h.type + " " + h.file_id + " " + h.user + " " + h.time);
    }
    message("Delete: " + list_count(delete) + " File History Objects");
    ****************************/
    if (list_count(delete) == 0)
    {
	message("No File History Objects to delete");
	return;
    }
    sql_string = "use " + syb_rep_name + " \ngo\n" ;
    ts = "";
    k = 0;
    dids = list_create("int", 0);
    for(i = 0; i < list_count(delete); i = i + 1)
    {
	h = list_get(delete, i);
	if (k == SYBASE_IN_LIM)
	{
	    sql_string = sql_string + make_sql_delete_stmt(dids);
	    dids = list_create("int", 0);
	    k = 0;
	}
	list_append(dids, h.id);
	k = k + 1;
	// print_hevent(h);
    }
    if (k > 0)
    {
	sql_string = sql_string + make_sql_delete_stmt(dids);
    }
    if (dryrun == True)
    {
	message("Exec sql in: " + sql_command_file);
    }
    message("Keep  : " + list_count(keep) + " File History Objects");
    message("Delete: " + list_count(delete) + " File History Objects");
    write_file(sql_command_file, sql_string);
}

string
make_sql_delete_stmt(list ids)
{
    string	clause = "delete from xx_file_hist\twhere xx_id in (\t    ";
    string	t = list_to_string(ids, ",\t    ");
    string	stmt;


    stmt = clause + t + ")\ngo\n";
    return(stmt);
}

string
repinfo_var(string vn)
{
    string	fn = path_compose(current_projdir(), "/", current_system(),
				  "/.repinfo");
    string	c, v, val;
    list	l;
    int		i, j, k;

    if (read_file_access(fn) == False)
    {
	return("");
    }
    c = read_file(fn);
    l = string_to_list(c, "\n");
    j = string_length(vn) + 1;
    vn = vn + "=";
    for(i = 0; i < list_count(l); i = i + 1)
    {
	c = list_get(l, i);
	k = string_length(c);
	if (k >= j)
	{
	    val = string_extract(c, 0, j);
	    if (val == vn)
	    {
		val = string_extract(c, j, k - j);
		return(val);
	    }
	}
    }
    return(NULL);
}
