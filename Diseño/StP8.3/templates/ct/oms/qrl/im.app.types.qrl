//
//      sccsid[] = %W% %Y% %D%
//      StP/Core
//      StP/IM
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1992-1995
//      All rights reserved
//

string ere_editor = "";

// An Association depends on the Entities it connects for its signature.
// In Chen, an Intersection depends on its "child" Entities for its 
// signature.

update_dependents entity_dependents(node the_entity)
{
    update_dependents dependents;
    file ere_file, dependent_file;
    node dependent_node;
    string correct_name;

    dependents = update_dependents_create();

    // find referential integrity dependents

    // InheritedKeyFile objects are dependent on entities

    for_each_in_select("file[InheritedKeyFile && name = '${the_entity.name}']", dependent_file)
        update_dependents_append(dependents, dependent_file, 
			         "Name");

    // Association is always dependent on entity 

    for_each_in_select("node[Association && in_links[from_node_id == ${the_entity.id}]]", dependent_node)
        update_dependents_append(dependents, dependent_node, 
			         "EntityAssociation");

    // if the global variable ere_editor hasn't been set, set it.
    if( ere_editor == "" )
    {
        ere_file = find_by_query("file[(BachDiagram || ChenDiagram) && node_refs[node[Entity && id == ${the_entity.id}]]]");
	// if you haven't saved this diagram yet, ere_file is NULL
	if( ere_file == NULL )
	{
	    // go find any diagram in the system; they should all be
	    // Bachman or all be Chen (not mixed)
	    ere_file = find_by_query("file[(BachDiagram || ChenDiagram)]");
	    // if there are no diagrams in the system at all...
	    if (ere_file != NULL)
	    {
		if( ere_file.type == "BachDiagram" )
		    ere_editor = "bach";
		else if ( ere_file.type == "ChenDiagram" )
		    ere_editor = "chen";
	    }
        }
	else if( ere_file.type == "BachDiagram" )
	    ere_editor = "bach";
	else if ( ere_file.type == "ChenDiagram" )
	    ere_editor = "chen";
    }
    // if you are using Chen, there is a dependency of an intersection
    // relationship on the names of the participating child entities.
    if(ere_editor == "chen") 
    {
        for_each_in_select("node[Intersection && in_links[from_node_id == ${the_entity.id}]]", dependent_node)
	    update_dependents_append(dependents, dependent_node,
				     "EntityIntersection");
    }

    // find optional dependents

    if( rename_attribute_table )
    {
        correct_name = white_space_replace(the_entity.name);
        dependent_file = 
	 find_by_query("file[AttributeTable && name == '${correct_name}']");
	if( dependent_file != NULL )
	    update_dependents_append(dependents, dependent_file, "EntityAttributeTable");
    }

    if( rename_class )
    {
        dependent_node = find_by_query("node[OMTClass && name == '${the_entity.name}' && items[(OMTClassIsPersistent && value == 'True') || (ClassPersistence && value = 'Persistent')]]");
	if( dependent_node != NULL )
	    update_dependents_append(dependents, dependent_node, "Name");
    }
    return dependents;

}

// In Bachman, an Association relationship depends on its incoming
// AssociationChild links' names for its name.

update_dependents association_child_dependents(link the_link)
{
    update_dependents dependents;
    file ere_file;
    node dependent_node;
    
        dependents = update_dependents_create();

    // check the global variable to see if this is Bachman or Chen.
    // If it is blank, set the global variable.
    if( ere_editor == "" )
    {
	// if you haven't saved this diagram yet, ere_file is NULL
        ere_file = find_by_query("file[(BachDiagram || ChenDiagram) && link_refs[link[id == ${the_link.id}]]]");
	if( ere_file == NULL ) 
	{
	    // go find any diagram in the system; they should all be
	    // Bachman or all be Chen (not mixed)
	    ere_file = find_by_query("file[(BachDiagram || ChenDiagram)]");
	    // if there are no diagrams in the system at all...
	    if (ere_file != NULL)
	    {
		if( ere_file.type == "BachDiagram" )
		    ere_editor = "bach";
		else if ( ere_file.type == "ChenDiagram" )
		    ere_editor = "chen";
	    }
        }
	else if( ere_file.type == "BachDiagram" )
	    ere_editor = "bach";
	else if ( ere_file.type == "ChenDiagram" )
	    ere_editor = "chen";
    }

    if( ere_editor == "bach" )
    {
        dependent_node = find_by_query("node[Association && in_links[id == ${the_link.id}]]");
        if( dependent_node != NULL )
            update_dependents_append(dependents, dependent_node,
				     "AssocChildAssocRel");
    }

    return dependents;
}

update_dependents data_element_dependents(node the_data_element)
{
    update_dependents dependents;
    string correct_name;
    file dependent_file;

    dependents = update_dependents_create();

    // no referential integrity dependents

    // find optional dependents

    correct_name = white_space_replace(the_data_element.name);
    dependent_file = find_by_query("file[DataElementTable && name == '${correct_name}']");
    if( dependent_file != NULL )
        update_dependents_append(dependents, dependent_file, "DataElement");

    return dependents;
}

update_dependents domain_dependents(node the_domain)
{
    update_dependents dependents;
    string correct_name;
    file dependent_file;

    dependents = update_dependents_create();

    // no referential integrity dependents

    // find optional dependents

    correct_name = white_space_replace(the_domain.name);

    dependent_file = find_by_query("file[DomainTable && name == '${correct_name}']");
    if( dependent_file != NULL )
        update_dependents_append(dependents, dependent_file, "Domain");

    return dependents;

}


// An Association depends on Entities for its signature.

node assoc_derive_attrs(node the_association, node old_entity,
			node new_entity)
{
    //    string this_entity_name;
    string partial_sig;
    string full_sig = "";
    int pos, starting_pos;
    //    boolean end_of_string = False;

//     starting_pos = 0;
//     while(!end_of_string)
//     {
//         // get the next entity name in the signature - 
// 	// entity names separated by spaces
//         pos = string_find(the_association.sig, starting_pos, " ");
//         partial_sig = string_extract(the_association.sig, starting_pos, 
// 				     pos-starting_pos);

// 	// if this is the old entity name, use the new one instead
//         if( partial_sig == white_space_replace(old_entity.name) )
// 	    full_sig = full_sig + white_space_replace(new_entity.name);
// 	else
// 	    full_sig = full_sig + partial_sig;
// 	if( pos >= string_length(the_association.sig) )
// 	    end_of_string = True;
// 	else
// 	{
// 	    full_sig = full_sig + " ";
// 	    starting_pos = pos+1;
// 	}
//     }

    // code inserted to generate the sig in the ascending order
    list l = list_create("string", 0);
    int len = string_length(the_association.sig);
    for(pos = 0; pos < len; pos = starting_pos+1)
    {
        starting_pos = string_find(the_association.sig, pos, " ");
        partial_sig = string_extract(the_association.sig, pos, starting_pos-pos);
        if (partial_sig == white_space_replace(old_entity.name))
            partial_sig = white_space_replace(new_entity.name);
        list_append(l, partial_sig);
    }
    l = list_sort(l);
    full_sig = list_to_string(l, " ");
    return node_sig_set(the_association, full_sig);
}

// In Bachman, an Association depends on incoming AssociationChild link
// names for its name

node assoc_derive_name(node the_association, link old_link, link new_link)
{
    node new_association;
    file ere_file;
    link link1, link2;
    string partial_name;
    string full_name;
    int pos;

    // check the global variable to see if this is Bachman or Chen.
    // If it is blank, set the global variable.
    if( ere_editor == "" )
    {
        ere_file = find_by_query("file[(BachDiagram || ChenDiagram) && node_refs[node[Association && id == ${the_association.id}]]]");
	// if you haven't saved this diagram yet, ere_file is NULL
	if( ere_file == NULL ) 
	{
	    // go find any diagram in the system; they should all be
	    // Bachman or all be Chen (not mixed)
	    ere_file = find_by_query("file[(BachDiagram || ChenDiagram)]");
	    // if there are no diagrams in the system at all...
	    if( ere_file != NULL ) 
	    {
		if( ere_file.type == "BachDiagram" )
		    ere_editor = "bach";
		else if ( ere_file.type == "ChenDiagram" )
		    ere_editor = "chen";
	    }
        }
	else if( ere_file.type == "BachDiagram" )
	    ere_editor = "bach";
	else if ( ere_file.type == "ChenDiagram" )
	    ere_editor = "chen";
    }
    // If Bachman, set the association name to the concatenation of
    // the link names.  If Chen, the association does not depend on
    // the link names so no change is needed.
    if( ere_editor == "bach" )
    {
        // set link names to assoc name...
	link1 = new_link;
	link2 = find_by_query("link[to_node_id == ${the_association.id} && id != ${link1.id}]");

	pos = string_find(the_association.name, 0, " ");
	partial_name = string_extract(the_association.name, 0, pos);

	if( partial_name == old_link.name )
	    full_name = link1.name + " " + link2.name;
	else
	    full_name = link2.name + " " + link1.name;

	new_association = node_name_set(new_association, full_name);
    } 
    return new_association;
}

// In Chen, an Intersection gets its signature from the names of its
// participating child Entities.

node intersection_derive_attrs(node the_intersection, node old_entity, 
			       node new_entity)
{
    node new_intersection = the_intersection;
    string this_entity_name;
    string partial_sig, full_sig = "";
    file ere_file;
    //    boolean end_of_string = False;
    int pos, starting_pos;

    // if the global variable ere_editor hasn't been set, set it.
    if( ere_editor == "" )
    {
        ere_file = find_by_query("file[(BachDiagram || ChenDiagram) && node_refs[node[Intersection && id == ${the_intersection.id}]]]");
	// if you haven't saved this diagram yet, ere_file is NULL
	if( ere_file == NULL ) 
	{
	    // go find any diagram in the system; they should all be
	    // Bachman or all be Chen (not mixed)
	    ere_file = find_by_query("file[(BachDiagram || ChenDiagram)]");
	    // if there are no diagrams in the system at all...
	    if (ere_file != NULL)
	    {
		if( ere_file.type == "BachDiagram" )
		    ere_editor = "bach";
		else if ( ere_file.type == "ChenDiagram" )
		    ere_editor = "chen";
	    }
        }
	else if( ere_file.type == "BachDiagram" )
	    ere_editor = "bach";
	else if ( ere_file.type == "ChenDiagram" )
	    ere_editor = "chen";
    }

    // This dependency only exists in the Chen editor.
    // In Bachman, the Intersection relationship depends on its parent
    // entity, not on the set of child entities.
    if( ere_editor == "chen" )
    {
//         starting_pos = 0;
//         // must check every single entity name in the signature, as the
// 	// old name may be in there more than once
//         while(!end_of_string)
// 	{
// 	    // get the next entity name in the signature - entity names
// 	    // are separated by spaces
//             pos = string_find(the_intersection.sig, starting_pos, " ");
// 	    partial_sig = string_extract(the_intersection.sig, starting_pos, 
// 					 pos-starting_pos);

// 	    // if this is the old entity name, use the new name instead
// 	    if( partial_sig == white_space_replace(old_entity.name) )
// 	        full_sig = full_sig + white_space_replace(new_entity.name);

// 	    // if it's not the old entity name, put it in the sig
// 	    else
// 	        full_sig = full_sig + partial_sig;

// 	    if( pos >= string_length(the_intersection.sig) )
// 	        end_of_string = True;
// 	    else
// 	    {
// 	        full_sig = full_sig + " ";
// 		starting_pos = pos+1;
// 	    }
//         }

        // generate the signature in the ascending order

        list l = list_create("string", 0);
        int len = string_length(the_intersection.sig);
        for(pos = 0; pos < len; pos = starting_pos+1)
        {
            starting_pos = string_find(the_intersection.sig, pos, " ");
            partial_sig = string_extract(the_intersection.sig, pos, starting_pos-pos);
            if (partial_sig == white_space_replace(old_entity.name))
                partial_sig = white_space_replace(new_entity.name);
            list_append(l, partial_sig);
        }
        l = list_sort(l);
        full_sig = list_to_string(l, " ");
        new_intersection = node_sig_set(new_intersection, full_sig);
    }
    return new_intersection;
}

file attribute_table_derive_wsname(file the_ate_file, node old_entity,
				 node new_entity)
{

    return file_name_set(the_ate_file, white_space_replace(new_entity.name));
}

file data_elem_table_derive_name(file the_de_file, node old_data_element,
				 node new_data_element)
{
    return file_name_set(the_de_file, 
			 white_space_replace(new_data_element.name));
}

file domain_table_derive_name(file the_domain_file, node old_domain, 
			      node new_domain)
{
    return file_name_set(the_domain_file, white_space_replace(new_domain.name));
}

//
// Replace all whitespace in source with underscores unless source 
// is a doubly quoted string.
//
string white_space_replace(string source)
{
    string temp;

    // don't replace a empty or quoted string
    if (source == NULL || source == "" 
    	|| string_extract(source, 0, 1) == "\"") 
        return source;

    // replace blanks, linefeeds, and tabs.
    temp = string_search_and_replace(source, " ", "_");
    temp = string_search_and_replace(temp, "\\n", "_");
    temp = string_search_and_replace(temp, "\\t", "_");
    return temp;
}
