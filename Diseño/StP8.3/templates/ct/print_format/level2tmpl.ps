% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright Aonix Corporation 2001
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/font1 /Helvetica findfont 12.000000 scalefont def
/allign_center	0 def
/allign_left	1 def
/allign_right	2 def
/allign_top	1 def
/allign_bottom	2 def
/CellTemplates <<
	/ColumIndex 
		<< /LLy 0 /URy 0 /Fg [0] /Bg [255]  /Bl 0 /Br 0 /Bu 0 /Bb 1 /Ml 5 /Mr 5 /Mu 1 /Mb 1  /Ax 0 /Ay 0 /Font font1 /Ls 0 >>
	/RowIndex
		<< /LLx 0 /URx 0 /Fg [0] /Bg [255]  /Bl 0 /Br 1 /Bu 0 /Bb 0 /Ml 1 /Mr 1 /Mu 5 /Mb 5  /Ax 0 /Ay 0 /Font font1 /Ls 0 >>
	/HeaderCell
		<< /Fg [0] /Bg [16#c0 16#d9 16#d9]  /Bl 1 /Br 1 /Bu 1 /Bb 1 /Ml 5 /Mr 5 /Mu 5 /Mb 5  /Ax 0 /Ay 0 /Font font1 /Ls 2 >>
	/BodyCell
		<< /Fg [0] /Bg [255] /Bl 1 /Br 1 /Bu 1 /Bb 1 /Ml 5 /Mr 5 /Mu 5 /Mb 5  /Ax 0 /Ay 0 /Font font1 /Ls 2 >>
	/Default
		<< /LLx 0 /LLy 0 /URx 1 /URy 1  /MLabel [ () ] /Fg [0] /Bg [255]  /Bl 1 /Br 1 /Bu 1 /Bb 1 /Ml 1 /Mr 1 /Mu 1 /Mb 1  /Ax 0 /Ay 0 /Font font1 /Ls 1 >>
>> def
/GteColorSet {
	1 dict begin
	/acolor exch def
	acolor length 1 eq {
		
		acolor 0 get 255 div dup dup setrgbcolor
	} { 
		
		0 1 2 { acolor exch get 255 div } for setrgbcolor
	} ifelse
	end
} def
/GteColorEq {
	5 dict begin
	/ac2 exch def
	/ac1 exch def
	
	/i 0 def
	/res true def
	ac2 length ac1 length eq {
		0 1 ac2 length 1 sub {
			/i exh store 
			ac1 i get ac2 i get eq not { 
				res false store
			} if
		} for
	}
	{ 
		ac1 length 1 eq { 
			/i ac1 0 get store
			ac2 { i eq not { /res false store } if } forall
		} { 
			ac2 0 get 
			ac1 { i eq not { /res false store } if } forall
		} ifelse
	} ifelse
	res
	end
} def
/GetLabelWidthAndHeight { 
	gsave 
	setfont 
	0 0 moveto 
	true charpath pathbbox 
	exch		
	4 1 roll	
	exch		
	sub		
	3 1 roll	
	sub		
	exch		
	grestore	
} def
/drawLabel { 
	10 dict begin	
	gsave		
	/Ay exch def	
	/Ax exch def	
	/Y exch def	
	/X exch def	
	/Font exch def	
	/Label exch def	
	Label Font GetLabelWidthAndHeight
	/LabelHeight exch def
	/LabelWidth exch def
	Ax allign_right eq { /X X LabelWidth sub store } if
	Ax allign_center eq { /X X LabelWidth 2 div sub store } if
	
	Ay allign_center eq { /Y Y LabelHeight 2 div sub store } if
	Ay allign_top eq { /Y Y LabelHeight sub store } if
	X Y moveto	
	Font setfont	
	Label show	
	grestore	
	end		
} def 
		
/WrapLabel { 
	10 dict begin 
	gsave
	/Width exch def
	/Font exch def
	/Label exch def
	/labelLength Label length def
	/labelCurrentCharID 0 def
	/lineStartCharID 0 def
	/labelLines labelLength array def
	/lineID 0 def
	/lineLabel null def
	Font setfont
	{
		labelCurrentCharID labelLength ge {
			exit
		} if
		/lineStartCharID labelCurrentCharID store
		{
			/labelCurrentCharID labelCurrentCharID 1 add store
			labelCurrentCharID labelLength ge {
				labelLines lineID   Label lineStartCharID  dup labelLength exch sub   getinterval   put 
				exit
			} if
			/lineLabel Label lineStartCharID dup labelCurrentCharID exch sub getinterval store
			
			lineLabel stringwidth pop Width gt 
			{ 
				labelLines lineID   Label lineStartCharID   dup labelCurrentCharID exch sub   getinterval  put 
				exit 
			} if
		} loop
		/lineID lineID 1 add store
	} loop
	labelLines 0 lineID getinterval
	
	grestore
	end
} def 
/WrapMultilineLabel {
	10 dict begin
	
	/Width	exch def
	/Font	exch def
	/MLabel exch def
	/i 0 def MLabel { length i add /i exch store } forall 
	/resMLabel i array def
	/i 0 store
	MLabel {
		Font Width WrapLabel { 
			resMLabel i 3 -1 roll put
			/i i 1 add store
		} forall
	} forall
	resMLabel 0 i getinterval 
	end
} def
/getMiltilineLabelCaps {
	10 dict begin
	/Linespace exch def
	/Font	exch def
	/Label	exch def
	
	/width	0 def
	/heigth	0 def
	Label {	     
		Font GetLabelWidthAndHeight
		dup heigth gt { /heigth exch store } { pop } ifelse
		dup width gt  { /width exch store } { pop } ifelse
	} forall
	width
	
	/labelNumLines Label length def
	heigth labelNumLines mul  Linespace labelNumLines 1 sub mul  add
	end
} def 
/drawMultilineLabel {
	10 dict begin
	/Ay exch def
	/Ax exch def
	/Yo exch def
	/Xo exch def
	/Linespace exch def
	/Font exch def
	/Label exch def
	
	Label Font Linespace getMiltilineLabelCaps /y exch def  /x exch def
	
	/lineHeight  y Linespace add  Label length  div  def 
	/y
	Ay 0 eq { Yo y 2 div add } if
	Ay 1 eq { Yo } if
	Ay 2 eq { Yo y add } if
	def
	Label {
		Font Xo y Ax 1 drawLabel
		/y y lineHeight sub store
	} forall
	end
} def 
/drawMultilineCell {
	20 dict begin
	gsave
	/Font	exch def
	/MLabel	exch def
	/Bg	exch def
	/Fg	exch def
	/Ls	exch def
	/Ay	exch def
	/Ax	exch def
	/Mb	exch def
	/Mu	exch def
	/Mr	exch def
	/Ml	exch def
	/Bb	exch def
	/Bu	exch def
	/Br	exch def
	/Bl	exch def
	/URy	exch def
	/URx	exch def
	/LLy	exch def
	/LLx	exch def
	
	Bg GteColorSet
	LLx LLy  URx LLx sub  URy LLy sub rectfill
	
	Fg GteColorSet
	/Clw currentlinewidth def
	Bl 0 gt { Bl setlinewidth LLx LLy moveto  LLx URy lineto stroke } if
	Bu 0 gt { Bu setlinewidth LLx URy moveto  URx URy lineto stroke } if
	Br 0 gt { Br setlinewidth URx URy moveto  URx LLy lineto stroke } if
	Bb 0 gt { Bb setlinewidth URx LLy moveto  LLx LLy lineto stroke } if
	Clw setlinewidth
	
	
	/W URx LLx sub  Ml Mr add  sub  def 
	/H URy LLy sub  Mu Mb add  sub  def 
	LLx Ml add
	LLy Mb add
	W H rectclip
	
	/Xo
	Ax 0 eq { LLx Ml add W 2 div add } if
	Ax 1 eq { LLx Ml add } if 
	Ax 2 eq { URx Mr sub } if
	def
	/Yo
	Ay 0 eq { LLy Mb add H 2 div add } if
	Ay 1 eq { URy Mu sub } if
	Ay 2 eq { LLy Mb add } if
	def
	MLabel Font Ls  Xo Yo  Ax Ay  drawMultilineLabel 
	grestore
	end
} def 
/EvaluateColumnWidths {
	10 dict begin
	
	/TableWidth	exch def
	/ColumnWidths	exch def
	/sumWidths	0 def
	/numUnspecified 0 def
	
	/i 0 def
	ColumnWidths {
		dup
		0 eq { 
			pop /numUnspecified numUnspecified 1 add store
		} 
		{ 
			sumWidths add /sumWidths exch store
			sumWidths TableWidth gt { 
				ColumnWidths i -1 put
			} if
		} ifelse			
		/i i 1 add store
	} forall
	/colWidth 0 def 
	sumWidths TableWidth lt { 
		/averageWidth TableWidth sumWidths sub numUnspecified div floor def
		/i 0 store
		ColumnWidths { 
			/colWidth exch store
			colWidth 0 eq { 
				ColumnWidths i averageWidth put
			} if
			colWidth -1 eq { 
				ColumnWidths i 0 put
			} if
			/i i 1 add store
		} forall
	} if 
	
	ColumnWidths
	end
} def 
/EvaluateRowHeight {
	10 dict begin
	/RowIndex	exch def
	/RowWidth	exch def
	/ColumnWidths	exch def
	/RowCells	exch def
	
	/cell		null def 
	/width		0 def 
	/rowHeight	0 def 
	/i		0 def
	RowCells {
		/cell exch store
		cell /LLy get  RowIndex eq {
			
			cell /MLabel get   
			cell /Font get	
				
				/width 0 store
				cell /LLx get  1  cell /URx get {
					ColumnWidths exch get width add /width exch store
				} for
				width  cell /Ml get  cell /Mr get add   sub 
			WrapMultilineLabel
			cell /MLabel 3 -1 roll put
			
			cell /MLabel	get 
			cell /Font	get	
			cell /Ls	get	
			getMiltilineLabelCaps 
			exch pop
			cell /Mu get add
			cell /Mb get add
			
			dup rowHeight gt { 
				/rowHeight exch store
			} { pop } ifelse
			
			RowCells i cell put 
		} if
		/i i 1 add store
	} forall 
	rowHeight
	end
} def 
/drawRow {
	10 dict begin
	
	/ULy		exch def
	/ULx		exch def
	/RowIndex	exch def
	/RowHeights	exch def
	/CellWidths	exch def
	/RowCells	exch def
	
	/LLx ULx def
	/LLy ULy RowHeights RowIndex get sub def
	/rowHeight RowHeights RowIndex get def
	/cell		null def  
	/cellWidth	0 def  
	/cellHeight	0 def  
	
	/llx		0 def  
	/lly		0 def  
	/urx		0 def  
	/ury		0 def  
	RowCells {
		/cell exch store
		cell /LLy get RowIndex eq {
			
			/cellWidth  0 store
			cell /LLx get 1 cell /URx get {
				CellWidths exch get cellWidth add /cellWidth exch store
			} for
			/cellHeight 0 store
			cell /URy get 1 cell /LLy get {
				RowHeights exch get cellHeight add /cellHeight exch store
			} for
			
			cellWidth 0 gt 
			cellHeight 0 gt and {
				
				
				/llx LLx store
				0 1  cell /LLx get 1 sub {
					CellWidths exch get  llx add  /llx exch store
				} for
				
				/lly LLy store
				
				/urx llx cellWidth add store
				
				/ury lly cellHeight add store
				llx lly urx ury
				cell /Bl get
				cell /Br get
				cell /Bu get
				cell /Bb get
				cell /Ml get 
				cell /Mr get 
				cell /Mu get 
				cell /Mb get
				cell /Ax get 
				cell /Ay get 
				cell /Ls get
				
				cell /Fg get
				cell /Bg get
				cell /MLabel get 
				cell /Font get
				drawMultilineCell
			} if
		} if
	} forall
	LLx LLy
	end
} def
/getNextPageBreak {
	20 dict begin
	/StartPageRowIdx	exch def
	/PageHeight		exch def
	/HrLen			exch def
	/CanBreakPage		exch def
	/RowHeights		exch def
	
	/endPageRowIdx	0 def
	/brokenCell	true def
	/headerHeight	0 def
	/currentRowIdx	0 def
	/currentHeight  0 def
	0 1 HrLen 1 sub {
		RowHeights exch get headerHeight add /headerHeight exch store
	} for
	
	/PageHeight PageHeight headerHeight sub store
	PageHeight 0 gt {
		StartPageRowIdx HrLen lt { /StartPageRowIdx HrLen store } if
		StartPageRowIdx 1 RowHeights length 1 sub {
			/currentRowIdx exch store
			/currentHeight RowHeights currentRowIdx get currentHeight add store
			
			currentHeight PageHeight gt {
				currentRowIdx StartPageRowIdx gt {
					currentRowIdx 1 sub -1 StartPageRowIdx {
						/i exch store
						CanBreakPage i get {
							/endPageRowIdx i store
							/brokenCell false store
							exit
						} if
					} for
				} if
				endPageRowIdx 0 eq { 
					/endPageRowIdx currentRowIdx 1 sub store
					/brokenCell true store
				} if
				exit
			} if
		} for
			
		currentRowIdx RowHeights length 1 sub eq { 
			/endPageRowIdx currentRowIdx store
			/brokenCell false store
		} if
	} if
	endPageRowIdx
	brokenCell
	end
} def
/getPageUserCaps {
	5 dict begin
	/PageDict exch def
	/drawableHeight PageDict /PageHeight get  PageDict /Mu get PageDict /Mb get add  sub def
	/drawableWidth  PageDict /PageWidth get  PageDict /Ml get PageDict /Mr get add  sub def
	
	/userPageHeight drawableHeight	def
	/userPageWidth  drawableWidth	def
	
	PageDict /isLandscape get {
		/userPageHeight drawableWidth	store
		/userPageWidth  drawableHeight	store
	} if
	
	userPageWidth
	userPageHeight
	end
} def
/drawPageFrame {
	10 dict begin 
	
	10 string cvs /NumPages		exch def
	10 string cvs /CurentPage	exch def
	/PageDict	exch def
	
	
	PageDict /Ml get
	PageDict /Mb get
		translate
	/drawableHeight PageDict /PageHeight get  PageDict /Mu get PageDict /Mb get add  sub def
	/drawableWidth  PageDict /PageWidth get  PageDict /Ml get PageDict /Mr get add  sub def
	
	/userPageHeight drawableHeight def
	/userPageWidth  drawableWidth def
	
	PageDict /isLandscape get {
		-90 rotate
		drawableHeight neg 0 translate
		/userPageHeight drawableWidth def
		/userPageWidth  drawableHeight def
	} if
	
	/len PageDict /CaptionLabel get length def
	/i 0 def 
	PageDict /CaptionLabel get {
		(#P) search { pop pop /i i 1 add store } { pop exit } ifelse
	} loop
	/j 0 def 
	PageDict /CaptionLabel get {
		(#p) search { pop pop /j j 1 add store } { pop exit } ifelse
	} loop
	/expandedCaptionLabel len i NumPages length mul add  j CurentPage length mul add string def
	/c 0 def	
	/j 0 store	
	/ec false store 
	0 1 len 1 sub {
		/i exch def
		/c PageDict /CaptionLabel get i get store
		c (#) 0 get eq  ec not  and {
			/ec true store
		}
		{
			ec  c (P) 0 get eq  c (p) 0 get eq  or and {
				c (P) 0 get eq { 
					
					expandedCaptionLabel j NumPages putinterval
					/j j NumPages length add store
				}
				{
					
					expandedCaptionLabel j CurentPage putinterval
					/j j CurentPage length add store
				} ifelse 
			}
			{
				expandedCaptionLabel j c put
				/j j 1 add store
			} ifelse
			/ec false store
		} ifelse
	} for
	/expandedCaptionLabel expandedCaptionLabel 0 j getinterval store
	
	/Xo userPageWidth def /Ax 2 def
	PageDict /CAx get 0 eq { /Xo userPageWidth 2 div store  /Ax 0 store } if
	PageDict /CAx get 1 eq { /Xo 0 store  /Ax 1 store } if
	/Yo userPageHeight 5 add def  /Ay 2 def 
	PageDict /CAy get 2 eq { /Yo 0 store  /Ay 1 store } if
	
	0 setgray
	1 array dup 0 expandedCaptionLabel put
	PageDict /CFont get 0 Xo Yo Ax Ay drawMultilineLabel
	userPageWidth 
	userPageHeight 
	end
} def 
/drawTable {
	20 dict begin
	
	/Yo  exch def
	/Xo  exch def
	/URy exch def
	/URx exch def
	/LLy exch def
	/LLx exch def
	/TableDict  exch def
	/PageDict   exch def
	/pageHeight URy LLy sub def
	
	TableDict /puTableWidth get 0 eq {
		TableDict /puTableWidth URx LLx sub put
	} if
	
	TableDict /apuColumnSizes get
	TableDict /puTableWidth get
		EvaluateColumnWidths
		TableDict /apuColumnSizes 3 -1 roll put
	/i 0 def
	0 1 TableDict /aaclRows get length 1 sub { 
		/i exch store
		TableDict /apuRowSizes get i get 0 eq {
			
			TableDict /aaclRows get i get
			TableDict /apuColumnSizes get
			TableDict /puTableWidth get
			i
				EvaluateRowHeight
				TableDict /apuRowSizes get i 3 -1 roll put
		} if
	} for
	
	
	/afCanBreakPage TableDict /aaclRows get length array def
	/afCanBreak TableDict /apuColumnSizes get length array def
	/cell null def 
	/i 0 store
	TableDict /aaclRows get { 
		0 1 afCanBreak length 1 sub { afCanBreak exch false put } for 
		{ 
			/cell exch store
			cell /LLy get i eq {
				cell /LLx get 1 cell /URx get { afCanBreak exch true put } for
			} if
		} forall
		afCanBreakPage i   true afCanBreak { and } forall put
		/i i 1 add store
	} forall
	
	
	/pageBreaks  TableDict /apuRowSizes get length  array def
	/pageHeight	 Yo LLy sub def 
	/currentPageIdx	 0 def
	/pageStartRowIdx 0 def
	{
		
		TableDict /apuRowSizes get
		afCanBreakPage
		TableDict /hrLen get
		pageHeight 
		pageStartRowIdx
			getNextPageBreak
			pageHeight URy LLy sub lt and not {
				/pageStartRowIdx exch store 
				pageBreaks currentPageIdx pageStartRowIdx put 
				/currentPageIdx currentPageIdx 1 add store
				/pageStartRowIdx pageStartRowIdx 1 add store 
			} if
			pageStartRowIdx TableDict /apuRowSizes get length ge {
				exit
			} if
			/pageHeight URy LLy sub store
	} loop
	/pageBreaks pageBreaks 0 currentPageIdx getinterval store
	
	/startPageRowIdx TableDict /hrLen get  def  
	/rows TableDict /aaclRows get def	
	/columnWidths TableDict /apuColumnSizes get def 
	/rowHeights TableDict /apuRowSizes get def 
	/ulx	Xo	def 
	/uly	Yo	def 
	/currentPageIdx 0 store
	pageBreaks {
		/endPageRowIdx exch def
		/currentPageIdx currentPageIdx 1 add store
		PageDict currentPageIdx pageBreaks length drawPageFrame pop pop
		uly Yo ne { /uly URy store } if
		
		0 1 TableDict /hrLen get 1 sub { 
			/i exch store
			
			rows i get 
			columnWidths
			rowHeights
			i 
			ulx uly
				drawRow pop pop
			/uly uly rowHeights i get sub store
		} for
		
		startPageRowIdx 1 endPageRowIdx {
			/i exch store
			
			rows i get
			columnWidths
			rowHeights
			i
			ulx uly
				drawRow pop pop
			/uly uly rowHeights i get sub store
		} for
		/startPageRowIdx endPageRowIdx 1 add store
		showpage
	} forall
	ulx uly
	end
} def
/drawTableSet {
	10 dict begin
	/TablesArray	exch def
	/PageDict	exch def
	
	/drawableHeight PageDict /PageHeight get  PageDict /Mu get PageDict /Mb get add  sub def
	/drawableWidth  PageDict /PageWidth get  PageDict /Ml get PageDict /Mr get add  sub def
	
	/userPageHeight drawableHeight def
	/userPageWidth  drawableWidth def
	PageDict /isLandscape get {
		/userPageHeight drawableWidth def
		/userPageWidth  drawableHeight def
	} if
	/Xo 0 def
	/Yo userPageHeight def
	TablesArray {
		 PageDict exch 0 0  userPageWidth userPageHeight  0 userPageHeight  drawTable  pop pop 
		 
		 
	} forall
	end
} def
/ExpandCellParams {
	10 dict begin
	
	/Templates	exch def
	/Cell		exch def
	/resCell 20 dict def
	Templates /Default known { Templates /Default get resCell copy pop } if
	Cell /Template known { 
		/theTemplate Cell /Template get def
		Templates theTemplate known { 
			Templates theTemplate get resCell copy pop 
		} if 
	} if
	Cell resCell copy
	end
} def
/ExpandTableCellParams {
	10 dict begin
	/CellTemplates	exch def
	/Table		exch def
	/i 0 def
	Table /aaclRows get { 
		/theRow exch store
		/j 0 store theRow { 
			CellTemplates ExpandCellParams theRow j 3 -1 roll put
			/j j 1 add store
		} forall
		/i i 1 add store
	} forall
	end
} def
