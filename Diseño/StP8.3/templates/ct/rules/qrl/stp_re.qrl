//      StP/SE and OO
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1992-1993
//      All rights reserved
//


#include "qrl/include/general.inc"

// this is needed by SE as the parser_sh can send a 'execute_chooser'
// message
#include "rules/qrl/re_navigate.inc"

const string Parent = "Parent Directory";
ui_image_tp FileImage = to_ui_image("new_file"); 
ui_image_tp DirImage = to_ui_image("closed_folder");
ui_image_tp UpArrowImage = to_ui_image("parent_dir");

// Sync and Parse share the file selector, so we always need to be careful of which one we are using.

ui_prop
proper_master(string field)
{
    ui_prop prop;

    if ((prop = to_ui_prop("REParse", field)) != NULL)
	return prop;

    return to_ui_prop("RESynchronizer", field);
} 


int
SetFilterDefault_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop button = proper_master("ChooserDirectoryButton");
    ui_button_set_as_default(button, True);
    return 0;
}


int
DirChooserFill_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop chooser_prop;
    string dir;
    int i;
   
    chooser_prop = proper_master("ChooserDirectory");
    dir = ui_text_value(chooser_prop);

    if (str_no_val(dir))
    {
	print_error("A pattern or directory is required.");
	return 0;
    }

    dir = expand_directory_filter(dir);

    fill_chooser(dir, False);

    // put the dir, which might be modified, in directory window
    ui_text_set_value(chooser_prop, dir);

    return 0;
}

int 
fill_chooser(string dir, boolean right_justify)
{
    ui_prop dir_prop;
    list dlist;
    int i, cnt;
    list l = list_create("ui_list_item_tp", 0);
    ui_list_item_tp item;

    dir_prop = proper_master("DirSelector");

    ui_footer_set_value(to_ui_prop("REParse", "Status"), "");
    ui_busy(to_ui_owner(dir_prop), True);
    dlist = get_dir_list(dir);
    if (dlist == NULL)
    {
        ui_busy(to_ui_owner(dir_prop), False);
	return 0;
    }

    ui_list_clear(dir_prop);

    if (root_part(dir) != dir)
    {
	item.image = UpArrowImage;
	item.label = Parent;
        ui_list_append(dir_prop, item);
    }

    cnt = list_count(dlist);

    if (cnt > 0 && cnt < 1000)
        ui_footer_set_value(to_ui_prop("REParse", "Status"), "Processing " + cnt + " items.");
    else if (cnt > 1000 && cnt < 5000)
        ui_footer_set_value(to_ui_prop("REParse", "Status"), "Processing " + cnt + " items. This takes a few moments.");
    else
        ui_footer_set_value(to_ui_prop("REParse", "Status"), "Processing " + cnt + " items. This can take several minutes.");

    // the list contains directories followed by files, so the counting
    // of directories means we do not need to call read_dir_access() once
    // it has failed - it is a relative slowbie, so this is a good thing.
    int directory_count = 0;
    for (i = 0; i < cnt; i++)
    {
        item.label = list_get(dlist, i);
        if (directory_count == 0 && read_dir_access(item.label))
	    item.image = DirImage;
	else
        {
            if (directory_count == 0)
                directory_count = i;
	    item.image = FileImage;
        }

	list_append(l, item);
    }

    if (cnt > 0)
        ui_list_append(dir_prop, l);

    if ( right_justify )
	ui_list_set_hscroll_pos( dir_prop, 200 );

    ui_busy(to_ui_owner(dir_prop), False);
    return 0;
}


int 
REFileChooserDoubleClick_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop prop, chooser_prop;
    int row, i, indent = 0;
    string val;
    list l;
    boolean add_slash = False;

    prop = proper_master("DirSelector");
    chooser_prop = proper_master("ChooserDirectory");
    row = ui_list_selected_row(prop);

    if (row >= 0)
        val = ui_list_row_label(prop, row);	// LastValue does not work here
    else
        return 0;

    if (row == 0) //Parent Directory
    {
	int orig_len = string_length( ui_text_value(chooser_prop) );
	if (ui_list_num_items(prop) > 1)
	    val = ui_list_row_label(prop, 1);
	else
	    val = ui_text_value(chooser_prop);

	if(path_part(val) == root_part(val))
	    val = root_part(val);
	else
	    val = parent_directory(parent_directory(val));
	indent = string_length( val ) - orig_len;
    }
    else
    {
        if (! read_dir_access(val))
        {
	    print_message(val + " is not a directory.");
	    return 0;
	}
	indent = string_length( val ) -
	         string_length( ui_text_value(chooser_prop));
    }

    val = expand_directory_filter(val);
    fill_chooser(val, True);

    // put the dir in directory window
    prop = proper_master("ChooserDirectory");
    ui_text_set_value(prop, val);
    return 0;

}





// Delete functions

int
scrolling_list_delete(ui_prop prop)
{
    int row, i;
    list rows;

    rows = ui_list_selected(prop);

    for (i = 0; i < list_count(rows); i++)
    {
	row = list_get(rows, i);
        ui_list_delete(prop, row - i);
    }

    return 0;
}


int
RERemoveFile(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop prop = proper_master("Files");
    return scrolling_list_delete(prop);
}



int
REFileAdd(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop dir_prop, file_prop;
    list l, l_with_image = list_create("ui_list_item_tp", 0), existingl;
    string item;
    ui_list_item_tp ui_item;
    int i, j;
    boolean dup;

    dir_prop = proper_master("DirSelector");
    file_prop = proper_master("Files");

    // get the selected files from dir_prop and stuff them in file_prop, if they 
    // are not already in the list.

    l = ui_list_selected_items(dir_prop);
 
    existingl = ui_list_value(file_prop);
    ui_item.image = FileImage;

    for (i = 0; i < list_count(l); i++)
    {
        item = list_get(l, i);
	
        // disallow selection of parent or directories
	if (item == Parent || read_dir_access(item)) 
	    continue;

	dup = False;
	for (j = 0; j < list_count(existingl); j++)
	{
	    if (item == list_get(existingl, j))
	    {
   		dup = True;
		break;
	    }
	}
 
	if (!dup)
        {
            ui_item.label = item;
	    list_append(l_with_image, ui_item);
        }
    }
    ui_list_append(file_prop, l_with_image);
 
    return 0;
}

string REParseExtra_Includes = "";

string
ExtraIncludeValue( string new_val )
{
    ui_prop myProp = to_ui_prop( "REParseExtra", "UserIncludes" );
    if ( myProp != NULL )
      {
	REParseExtra_Includes = "";
	if ( new_val != NULL )
	  {
	    ui_text_set_value( myProp, new_val );
	    return "";
	  }
	else
	  return ui_text_value( myProp );
      }
    else
      if ( new_val != NULL )
	{
	  REParseExtra_Includes = new_val;
	  return "";
	}
      return REParseExtra_Includes;
}

string REParseExtra_SysIncludes = "";

string
ExtraSysIncludeValue( string new_val )
{
    ui_prop myProp = to_ui_prop( "REParseExtra", "SysIncludes" );
    if ( myProp != NULL )
      {
	REParseExtra_SysIncludes = "";
	if ( new_val != NULL )
	  {
	    ui_text_set_value( myProp, new_val );
	    return "";
	  }
	else
	  return ui_text_value( myProp );
      }
    else
      if ( new_val != NULL )
	{
	  REParseExtra_SysIncludes = new_val;
	  return "";
	}
      return REParseExtra_SysIncludes;
}

string REParseExtra_Defines = "";

string
ExtraDefineValue( string new_val )
{
    ui_prop myProp = to_ui_prop( "REParseExtra", "Defines" );
    if ( myProp != NULL )
      {
	REParseExtra_Defines = "";
	if ( new_val != NULL )
	  {
	    ui_text_set_value( myProp, new_val );
	    return "";
	  }
	else
	  return ui_text_value( myProp );
      }
    else
      if ( new_val != NULL )
	{
	  REParseExtra_Defines = new_val;
	  return "";
	}
      return REParseExtra_Defines;
}

string REParseExtra_Specifiers = "";

string
ExtraSpecifierValue( string new_val )
{
    ui_prop myProp = to_ui_prop( "REParseExtra", "Specifiers" );
    if ( myProp != NULL )
      {
	REParseExtra_Specifiers = "";
	if ( new_val != NULL )
	  {
	    ui_text_set_value( myProp, new_val );
	    return "";
	  }
	else
	  return ui_text_value( myProp );
      }
    else
      if ( new_val != NULL )
	{
	  REParseExtra_Specifiers = new_val;
	  return "";
	}
      return REParseExtra_Specifiers;
}

int REParseExtra_MakeType = 0;

int
ExtraMakeTypeValue( int new_val )
{
    ui_prop myProp = to_ui_prop( "REMakeOptions", "MakefileType" );
    if ( myProp != NULL )
      {
	REParseExtra_MakeType = 0;
	if ( new_val != -1 )
	  {
	    ui_choice_set_value( myProp, new_val );
	    return 0;
	  }
	else
	  return ui_choice_value( myProp );
      }
    else
      if ( new_val != -1 )
	{
	  REParseExtra_MakeType = new_val;
	  return 0;
	}
      return REParseExtra_MakeType;
}

int REParseExtra_MakeKeep = 0;

int
ExtraMakeKeepValue( int new_val )
{
    ui_prop myProp = to_ui_prop( "REMakeOptions", "MakefileKeep" );
    if ( myProp != NULL )
      {
	REParseExtra_MakeKeep = 0;
	if ( new_val != -1 )
	  {
	    ui_choice_set_value( myProp, new_val );
	    return 0;
	  }
	else
	  return ui_choice_value( myProp );
      }
    else
      if ( new_val != -1 )
	{
	  REParseExtra_MakeKeep = new_val;
	  return 0;
	}
      return REParseExtra_MakeKeep;
}

string REParseExtra_MakeTarget = "";

string
ExtraMakeTargetValue( string new_val )
{
    ui_prop myProp = to_ui_prop( "REMakeOptions", "MakefileTargets" );
    if ( myProp != NULL )
      {
	REParseExtra_MakeTarget = "";
	if ( new_val != NULL )
	  {
	    ui_text_set_value( myProp, new_val );
	    return "";
	  }
	else
	  return ui_text_value( myProp );
      }
    else
      if ( new_val != NULL )
	{
	  REParseExtra_MakeTarget = new_val;
	  return "";
	}
      return REParseExtra_MakeTarget;
}


string REParseExtra_AdaLibFolder = "";

string
ExtraAdaLibFolder( string new_val )
{
    ui_prop myProp = to_ui_prop( "REObjectAdaLibDir", "ObjectAdaLibDir" );
    if ( myProp != NULL )
      {
	REParseExtra_AdaLibFolder = "";
	if ( new_val != NULL )
	  {
	    ui_text_set_value( myProp, new_val );
	    return "";
	  }
	else
	  return ui_text_value( myProp );
      }
    else
      if ( new_val != NULL )
	{
	  REParseExtra_AdaLibFolder = new_val;
	  return "";
	}
      return REParseExtra_AdaLibFolder;
}


int REParseExtra_MakeDepth = 0;

int
ExtraMakeDepthValue( int new_val )
{
    ui_prop myProp = to_ui_prop( "REMakeOptions", "MakefileDepth" );
    if ( myProp != NULL )
      {
	REParseExtra_MakeDepth = 0;
	if ( new_val != -1 )
	  {
	    ui_choice_set_value( myProp, new_val );
	    return 0;
	  }
	else
	  return ui_choice_value( myProp );
      }
    else
      if ( new_val != -1 )
	{
	  REParseExtra_MakeDepth = new_val;
	  return 0;
	}
      return REParseExtra_MakeDepth;
}

int REParseExtra_Preprocessor = 0;

int
ExtraPreprocessorValue( int new_val )
{
    ui_prop myProp = to_ui_prop( "REParseExtra", "NoPreprocessor" );
    if ( myProp != NULL )
      {
	REParseExtra_Preprocessor = 0;
	if ( new_val != -1 )
	  {
	    ui_choice_set_value( myProp, new_val );
	    return 0;
	  }
	else
	  return ui_choice_value( myProp );
      }
    else
      if ( new_val != -1 )
	{
	  REParseExtra_Preprocessor = new_val;
	  return 0;
	}
      return REParseExtra_Preprocessor;
}


int REParseExtra_Undefines = 0;

int
ExtraUndefinesValue( int new_val )
{
    ui_prop myProp = to_ui_prop( "REParseExtra", "NoPredefinedDirectives" );
    if ( myProp != NULL )
      {
	REParseExtra_Undefines = 0;
	if ( new_val != -1 )
	  {
	    ui_choice_set_value( myProp, new_val );
	    return 0;
	  }
	else
	  return ui_choice_value( myProp );
      }
    else
      if ( new_val != -1 )
	{
	  REParseExtra_Undefines = new_val;
	  return 0;
	}
      return REParseExtra_Undefines;
}

const int PatternCount = 6;
list REParseExtra_MakePattern = string_to_list( "*.c *.C *.cpp *.cxx,*cl *cl.exe *cc *g++,/I* -I*,/I* -I* -Y*,/D* -D*, ", "," );

string
ExtraMakePattern( int no, string new_val )
{
    ui_prop myProp = to_ui_prop( "REMakeOptions", "Pattern" + no );
    if ( myProp != NULL )
      {
	list_set( REParseExtra_MakePattern, no, "" );
	if ( new_val != NULL )
	  {
	    ui_text_set_value( myProp, new_val );
	    return "";
	  }
	else
	  return ui_text_value( myProp );
      }
    else
      if ( new_val != NULL )
	{
	  list_set( REParseExtra_MakePattern, no, new_val );
	  return "";
	}
      return list_get( REParseExtra_MakePattern, no );
}


int
REReadMakefile(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop dir_prop;
    list l, existingl;
    string item;
    int i, j;
    boolean dup;

    dir_prop = proper_master( "DirSelector" );

    l = ui_list_selected_items(dir_prop);

    if ( list_count(l) == 0 || ui_list_selected_row(dir_prop) == 0 )
    {
	print_error( "Select the Makefile to use in the Directory list first." ); 
	return 1;
    }
    if ( list_count(l) > 1 )
    {
	print_error( "Select a single Makefile to use." ); 
	return 1;
    }

    string filename = list_get(l,0);

    if ( read_dir_access( filename ))
    {
	print_error( "Select a Makefile - not a directory." ); 
	return 1;
    }

    string makefile = file_part(filename);
    string dir = path_part(filename);
    string keep_flag = "";
    string depth_setting = "";

    int     maketype = ExtraMakeTypeValue( -1 );
    string targets = ExtraMakeTargetValue( NULL );

    string maketype_arg = "";
    if ( maketype == 1 )
      maketype_arg = " -nmake";
    else if ( maketype == 2 )
      maketype_arg = " -gmake";

    string source_pattern = " -source \"" + ExtraMakePattern( 0, NULL ) +
      "\"";
    string compiler_pattern = " -compiler \"" + ExtraMakePattern( 1, NULL ) +
      "\"";
    string include_pattern = " -include \"" + ExtraMakePattern( 2, NULL ) +
      "\"";
    string sysinclude_pattern = " -sysinclude \"" +
      ExtraMakePattern( 3, NULL ) + "\"";
    string define_pattern = " -define \"" + ExtraMakePattern( 4, NULL ) +
      "\"";
    string exclude_pattern = " -exclude \"" + ExtraMakePattern( 5, NULL ) +
      "\"";

    if ( ExtraMakeKeepValue( -1 ) != 1 )
    {
	REParseSaveOptions( ".re_make." );
	keep_flag = " -keep ";
    }

    if ( ExtraMakeDepthValue( -1 ) != 0 )
	depth_setting = " -depth " + (ExtraMakeDepthValue( -1 ) - 1) + " ";

    ui_busy(to_ui_owner(dir_prop), True);
    string make_command = "re_make -forward_messages " +
      editor_get_msgd_handle() + " -p " +
      current_projdir() + " -s " +
      // ECR4211: Removed "" for option -cd
      current_system() + keep_flag + depth_setting + " -cd " + dir +
      " -f " + makefile + maketype_arg + source_pattern + compiler_pattern +
      include_pattern + sysinclude_pattern + define_pattern +
      exclude_pattern + " " + targets;

     // print_message( "Executing " + make_command );

    if ( system( make_command  ) == 0)
    {
	REParseReadFiles( path_compose(current_projdir(),
				       current_system(),
				       "revc_files"),
				       ".re_make." );
	// may as well delete the files that have been read in
        list files = directory_files(path_compose(current_projdir(),
						  current_system(),
						  "revc_files"),
				     ".re_make.*" );

        for(i = 0;i < list_count(files); i++)
	    delete_file(list_get(files,i));

	ui_busy(to_ui_owner(dir_prop), False);
	return 0;
    }

    ui_busy(to_ui_owner(dir_prop), False);
    print_error( "Makefile could not be read." );
    return 1;
}

int 
RECommentsInit_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    RECommentsReset_cb(event, theprop, id, v);
    return 0;
}

int 
REParseInit_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    REParseReset_cb(event, theprop, id, v);
    return 0;
}


// read in the files - the makefile reader writes the files with a "."
// in front, so specify the dot when loading auto-genned versions
//
void
REParseReadFiles( string dirname, string prefix )
{
    ui_prop prop;
    int i;
    string s, fname, suffix;
    list l;

    if ( is_product_se() )
	suffix = "";
    else
	suffix = ".cc";

    // first the files

    fname = path_compose(dirname, prefix + "Files" + suffix);
    if (! read_file_access(fname))
	s = "";
    else
	s = read_file(fname);
    l = string_to_list(s, "\n");
    list l_with_image = list_create("ui_list_item_tp", 0);
    int i2, len = list_count(l);
    ui_list_item_tp ui_item;
    ui_item.image = FileImage;
    
    for(i2 = 0; i2 < len; i2++)
    {
        ui_item.label = list_get(l, i2);
        list_append(l_with_image, ui_item);
    }

    prop = proper_master("Files");
    ui_list_clear(prop);

    ui_list_append( prop, l_with_image );

    // Now user includes

    fname = path_compose( dirname, prefix + "UserIncludes" + suffix);
    if (! read_file_access(fname))
	s = "";
    else
    	s = read_file(fname);

    ExtraIncludeValue( s );

    // Now system includes

    fname = path_compose( dirname, prefix + "SystemIncludes" + suffix );
    if (! read_file_access(fname))
	s = "";
    else
        s = read_file(fname);

    ExtraSysIncludeValue( s );

    // Now the defines

    fname = path_compose( dirname, prefix + "Defines" + suffix);
    if (! read_file_access(fname))
	s = "";
    else
        s = read_file(fname);
    s = list_to_string(string_to_list(s, "\n"), " ");
    ExtraDefineValue( s );

    // Now the specifiers

    fname = path_compose( dirname, "Specifiers" );
    if (! read_file_access(fname))
	s = "";
    else
        s = read_file(fname);
    s = list_to_string(string_to_list(s, "\n"), " ");
    ExtraSpecifierValue( s );

    return;
}


int
NoPPset( ui_event_tp event, ui_prop theprop, int id, string v )
{
    // deactivate/activate the Undef setting
    if ( v == "1" )
      {
	ui_activate( to_ui_prop("REParseExtra", "NoPredefinedDirectives"),
		     False );
	ui_activate( to_ui_prop("REParseExtra", "UserIncludes"), False );
	ui_activate( to_ui_prop("REParseExtra", "SysIncludes"), False );
	ui_activate( to_ui_prop("REParseExtra", "Defines"), False );
      }
    else
      {
	ui_activate( to_ui_prop("REParseExtra", "NoPredefinedDirectives"),
		     True );
	ui_activate( to_ui_prop("REParseExtra", "UserIncludes"), True );
	ui_activate( to_ui_prop("REParseExtra", "SysIncludes"), True );
	ui_activate( to_ui_prop("REParseExtra", "Defines"), True );
      }
    return 0;
}


int 
REPCset(ui_event_tp event, ui_prop theprop, int id, string v)
{
    // add cdecl= far= fortran= huge= interrupt= near= pascal=
    string flags = "__cdecl= __far= __fortran= __huge= __interrupt= __near= __pascal= ";
    string val = ExtraDefineValue( NULL );

    if ( v == "1" )
      {
	//SPR000034
	val = string_search_and_replace( val, "__cdecl=", "" );
	val = string_search_and_replace( val, "__far=", "" );
	val = string_search_and_replace( val, "__fortran=", "" );
	val = string_search_and_replace( val, "__huge=", "" );
	val = string_search_and_replace( val, "__interrupt=", "" );
	val = string_search_and_replace( val, "__near=", "" );
	val = string_search_and_replace( val, "__pascal=", "" );
	if ( string_length( val ) > 0 )
	  {
	    val += " " + flags;
	    val = string_search_and_replace( val, "  ", " " );
	  }
	else
	  val = flags;
      }
    else
      {
	if ( string_length( val ) > 0 )
	  {
	    int pos = string_find( val, 0, flags );
	    if ( pos < string_length( val ))
	      val = string_search_and_replace( val, flags, "" );
	  }
      }
    ExtraDefineValue( val );
    return 0;
}


int 
REParseReset_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    string s, str, dirname, fname, suffix;
    list l;

    if ( is_product_se() )
	suffix = "";
    else
	suffix = ".cc";

    dirname = path_compose(current_projdir(),
			   current_system(),
			   "revc_files");

    REParseReadFiles( dirname, "" );

    // and the misc. things

    fname = path_compose( dirname, "ParserExtras" + suffix );
    if (! read_file_access(fname))
      {
	s = "";
      }
    else
        s = read_file(fname);

    if (str_has_val(s))
    {
	l = string_to_list(s, "\n");

	// format is very specific here.  This file should not be hand modified
	str = list_get(l, 1);
	ui_choice_set_value(to_ui_prop("REParse", "Incremental"), to_int(string_extract(str, 4, 1)));
	str = list_get(l, 2);
	ui_choice_set_value(to_ui_prop("REParse", "PCStyle"), to_int(string_extract(str, 4, 1)));
	str = list_get(l, 3);
	str = string_extract(str, 4, string_length(str) - 4);
	if (str != "NULL")
	{
	    ui_text_set_value(to_ui_prop("REParse", "ChooserDirectory"), str);
	    DirChooserFill_cb(NULL, NULL, 0, NULL);
	}
	// old sets of files from SE6.0 will not have this dude
	if (list_count(l) > 4 )
	{
	    str = list_get(l, 4);
	    ExtraUndefinesValue( to_int(string_extract(str, 6, 1)));
	}
	// files saved by SE6.1 will not have these chappies
	if (list_count(l) > 5 )
	{
	    str = list_get(l, 5);
	    ExtraMakeKeepValue( to_int(string_extract(str,10,1)) );
	    str = list_get(l,6);
	    ExtraMakeDepthValue( to_int(string_extract(str,10,1)) );
	    str = list_get(l,7);
	    str = string_extract( str,12,string_length(str) - 12);
	    if ( str != "NULL" )
	      ExtraMakeTargetValue( str );
	    else
	      ExtraMakeTargetValue( "" );
	}
	// files saved with SE6.3 will not have these chappies
	if (list_count(l) > 8)
	{
	    str = list_get(l,8);
	    ui_choice_set_value(to_ui_prop("REParse", "MSExtensions"), to_int(string_extract(str,6,1)));
	    str = list_get(l,9);
	    int val = to_int(string_extract(str,5,1));
	    ExtraPreprocessorValue( val );

	    // enable/disable the preprocessor options depending upon the
	    // last result
	    if ( val == 1 )
	      NoPPset( NULL, NULL, 1, "1" );
	    else
	      NoPPset( NULL, NULL, 0, "0" );

	    int base = 10;
	    int loop = 0;
	    for( loop = 0; loop < PatternCount; loop++ )
	      {
		str = list_get( l, base + loop );
		str = string_extract( str, 13, string_length( str ) - 13 );
		ExtraMakePattern( loop, str );
	      }

	    str = list_get(l,10 + PatternCount);
	    ExtraMakeTypeValue( to_int( string_extract( str, 9, 1 )));
	}
    }
    else // there are no saved values
      {
	if ( is_product_se() && is_windows_platform() )
	  {
	    // for some reason this doesn't work, so I'll put the init
	    // value into the rules files
	    ui_choice_set_value( to_ui_prop("REParse", "PCStyle"), 1 );
	    REPCset( NULL, NULL, 0, "1" );
	  }
      }
   
    return 1;
}



// save the current option settings - return -1 if it fails, 0 if all
// is well and incremental was not set, 1 if all was well and incremental
// was set - the prefix allows us to write a special copy of the files
// that will be merged with the stuff from the makefile reader
//
int
REParseSaveOptions( string prefix )
{
    int i, rc = 0, llen;
    ui_prop prop;
    string s, str, dirname, fname, suffix;

    if ( is_product_se() )
	suffix = "";
    else
	suffix = ".cc";

    // first the files
    prop = proper_master("Files");
    s = "";

    llen = ui_list_num_items(prop);
    for (i = 0; i < llen; i++) 
	s = s + ui_list_row_label(prop, i ) + "\n";

    dirname = path_compose(current_projdir(),
			   current_system(),
			   "revc_files");

    fname = path_compose( dirname, prefix + "Files" + suffix );
    if (file_exists(fname) && (! write_file_access(fname)))
    {
	print_error("Cannot write parser state (Files).");
	rc = -1;
    }	
    else
        write_file(fname, s);

    // Now user includes
    s = ExtraIncludeValue( NULL );

    fname = path_compose( dirname, prefix + "UserIncludes" + suffix );
    if (file_exists(fname) && (! write_file_access(fname)))
    {
	print_error("Cannot write parser state (UserIncludes).");
	rc = -1;
    }	
    else
        write_file(fname, s);

    // Now system includes

    s = ExtraSysIncludeValue( NULL );

    fname = path_compose( dirname, prefix + "SystemIncludes" + suffix );
    if (file_exists(fname) && (! write_file_access(fname)))
    {
	print_error("Cannot write parser state (SystemIncludes).");
	rc = -1;
    }	
    else
	write_file(fname, s);

    // Now the defines

    s = ExtraDefineValue( NULL );
    if (str_has_val(s))
        s = list_to_string(string_to_list(s, " "), "\n") + "\n";

    fname = path_compose( dirname, prefix + "Defines" + suffix );
    if (file_exists(fname) && (! write_file_access(fname)))
    {
	print_error("Cannot write parser state (Defines).");
	rc = -1;
    }	
    else
	write_file(fname, s);

    // if the prefix was set, then we are writing the files for the 
    // makefile reader to pick, up. It has all the files it now needs,
    // so we can return
    if ( prefix != NULL && prefix != "" )
	return 0;

    // Now the specifiers

    s = ExtraSpecifierValue( NULL );
    if (str_has_val(s))
      s = list_to_string(string_to_list(s, " "), "\n") + "\n";
    else
      s = "";

    fname = path_compose( dirname, "Specifiers" );
    if (file_exists(fname) && (! write_file_access(fname)))
    {
	print_error("Cannot write parser state (Specifiers).");
	rc = -1;
    }	
    else
	write_file(fname, s);

    // now write the rest of the info, for future resetting, and for sending messages
    // back to the desktop 

    s = editor_get_msgd_handle() + "=Handle";

    int incremental = 0;
    prop = to_ui_prop("REParse", "Incremental");
    if (ui_choice_value(prop) == 0)
	s += "\nInc=0";
    else
    {
	s += "\nInc=1";
	incremental = 1;
    }

    prop = to_ui_prop("REParse", "PCStyle");
    if (ui_choice_value(prop) == 0)
	s += "\nPCS=0";
    else
	s += "\nPCS=1";

    prop = to_ui_prop("REParse", "ChooserDirectory");
    str = ui_text_value(prop);
    if (str_has_val(str))
	s += "\nChD=" + str;
    else
	s += "\nChD=NULL";
    
    if (ExtraUndefinesValue(-1) == 0)
	s += "\nUndef=0";
    else
	s += "\nUndef=1";

    if (ExtraMakeKeepValue(-1) == 0)
	s += "\nMakeClear=0";
    else
	s += "\nMakeClear=1";

    s += "\nMakeDepth=" + ExtraMakeDepthValue(-1);

    str = ExtraMakeTargetValue(NULL);
    if (str_has_val(str))
	s += "\nMakeTargets=" + str;
    else
	s += "\nMakeTargets=NULL";

    prop = to_ui_prop("REParse", "MSExtensions");
    if (ui_choice_value(prop) == 0)
	s += "\nMSExt=0";
    else
	s += "\nMSExt=1";

    if (ExtraPreprocessorValue(-1) == 0)
	s += "\nNoPP=0";
    else
	s += "\nNoPP=1";

    int loop = 0;
    for( loop = 0; loop < PatternCount; loop++ )
      {
	str = ExtraMakePattern( loop, NULL );
	if ( !str_has_val( str ))
	  str = "";
	s += "\nMakePattern" + loop + "=" + str;
      }

    s+= "\nMakeType=" + ExtraMakeTypeValue(-1);

    fname = path_compose( dirname, "ParserExtras" + suffix );
    if (file_exists(fname) && (! write_file_access(fname)))
    {
	print_error("Cannot write parser state (ParserExtras).");
	rc = -1;
    }	
    else
	write_file(fname, s);



    // Now write the language specific info, like ADA Lib info, etcc

    prop = to_ui_prop("REObjectAdaLibDir", "ObjectAdaLibDir");
    str = ui_text_value(prop);
    if (str_has_val(str))
	s = "\nObjectAdaLibDir=" + str;
    else
	s = "\nObjectAdaLibDir=NULL";

    fname = path_compose( dirname, "LangSpecific" + suffix );
    if (file_exists(fname) && (! write_file_access(fname)))
    {
	print_error("Cannot write parser state (LangSpecific).");
	rc = -1;
    }	
    else
	write_file(fname, s);



    if ( rc == 0 && incremental == 1 )
	return 1;
    return rc;
}


int
RESelectMakeOptions(ui_event_tp event, ui_prop theprop, int id, string v)
{
    int new_window = 0;
    if ( to_ui_prop( "REMakeOptions", "MakefileKeep" ) == NULL )
      new_window = 1;

    ui_prop_sheet_pop_up( "REMakeOptions" );

    if ( new_window == 1 )
      {
	ExtraMakeKeepValue( REParseExtra_MakeKeep );
	ExtraMakeTargetValue( REParseExtra_MakeTarget );
	ExtraMakeDepthValue( REParseExtra_MakeDepth );
	ExtraMakeTypeValue( REParseExtra_MakeType );
	int loop;
	for( loop = 0; loop < PatternCount; loop++ )
	  ExtraMakePattern( loop, list_get( REParseExtra_MakePattern, loop ));
      }
    return 0;
}

int REObjectAdaLibrary(ui_event_tp event, ui_prop theprop, int id, string v)
{
    int new_window = 0;
    if ( to_ui_prop( "REObjectAdaLibDir", "ObjectAdaLibDir" ) == NULL )
	new_window = 1;

    ui_prop_sheet_pop_up( "REObjectAdaLibDir" );



    if ( new_window == 1 ) 
      {

         ui_prop myProp = to_ui_prop( "REObjectAdaLibDir", "ObjectAdaLibDir" );
         string str = ui_text_value(myProp);
         if (str == "")
           {

             ui_prop prop = to_ui_prop("REParse", "ChooserDirectory");
             str = ui_text_value(prop);
             ui_text_set_value( myProp, str );
           }

      }
    
    return 0;
}



// pop up the extra parser options
int
RESelectAdvanced(ui_event_tp event, ui_prop theprop, int id, string v)
{
    int new_window = 0;
    if ( to_ui_prop( "REParseExtra", "UserIncludes" ) == NULL )
      new_window = 1;

    ui_prop_sheet_pop_up( "REParseExtra" );

    if ( new_window == 1 )
      {
	ExtraIncludeValue( REParseExtra_Includes );
	ExtraSysIncludeValue( REParseExtra_SysIncludes );
	ExtraDefineValue( REParseExtra_Defines );
	ExtraSpecifierValue( REParseExtra_Specifiers );
	ExtraPreprocessorValue( REParseExtra_Preprocessor );
	ExtraUndefinesValue( REParseExtra_Undefines );
      }
    return 0;
}


int
REParseApply_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    int incremental = 0;
    ui_prop prop;
    string s, dirname;

    // if the OK button is hit, and the extra prop sheet is on show, then
    // take it doen too - I don't think QRL lets us take another property
    // sheet down, so this can't be done without core changes - and there
    // ain't time for that
    // And I've tried ui_show and that doesn't seem to work

    dirname = path_compose(current_projdir(),
			   current_system(),
			   "revc_files");

    prop = proper_master("Files");

    if (ui_list_num_items(prop) < 1)
    {
	print_error("No files to parse.");
	return 0;
    }

    if ( (incremental = REParseSaveOptions( "" )) == -1 )
    {
	print_error("Unable to save the current options.");
	return 0;
    }

    if ( toolinfo_variable( "ide_qa_force" ) == NULL &&
	 incremental == 0 && file_exists( path_compose(dirname,
						       "db_dir",
						       "files.nix") ))
    {
	if ( editor_confirm( "Parsing will remove all information\n" +
			     "in the existing Semantic Model.\n\n" +
			     "Are you sure you want to proceed?",
			     "Continue", "Cancel" ) == False )
	    return 0;
    }

    return 1;
}


int
REParseExtraApply_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
  // must copy everything over into safe variables
    REParseExtra_Includes = ExtraIncludeValue( NULL );
    REParseExtra_SysIncludes = ExtraSysIncludeValue( NULL );
    REParseExtra_Defines = ExtraDefineValue( NULL );
    REParseExtra_Specifiers = ExtraSpecifierValue( NULL );
    REParseExtra_Preprocessor = ExtraPreprocessorValue( -1 );
    REParseExtra_Undefines = ExtraUndefinesValue( -1 );

    return 1; // return 1 to remove the property sheet
}

int
RECommentsApply_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    string cookie, fname, params;
    ui_prop prop;
    int val;

    params = "";
    fname = path_compose(current_projdir(),
			 current_system(),
			 "revc_files",
			 "Comments");

    // functions
    prop = to_ui_prop("RECommentGather", "FunctionCommentLocation");
    if (ui_choice_isset(prop, 0))
	params = params + "function_above=1\n";
    else  
	params = params + "function_above=0\n";
    if (ui_choice_isset(prop, 1))
	params = params + "function_below=1\n";
    else  
	params = params + "function_below=0\n";

    prop = to_ui_prop("RECommentGather", "FunctionGapSetting");
    params = params + "function_gap=" + ui_choice_value(prop) + "\n";

    // structures
    if ( is_product_se() )
      prop = to_ui_prop("RECommentGather", "StructureCommentLocation");
    else
      prop = to_ui_prop("RECommentGather", "ClassCommentLocation");
    if (ui_choice_isset(prop, 0))
	params = params + "structure_above=1\n";
    else  
	params = params + "structure_above=0\n";
    if (ui_choice_isset(prop, 1))
	params = params + "structure_below=1\n";
    else  
	params = params + "structure_below=0\n";
    if (ui_choice_isset(prop, 2))
	params = params + "structure_side=1\n";
    else  
	params = params + "structure_side=0\n";

    if ( is_product_se() )
      prop = to_ui_prop("RECommentGather", "StructureGapSetting");
    else
      prop = to_ui_prop("RECommentGather", "ClassGapSetting");
    params = params + "structure_gap=" + ui_choice_value(prop) + "\n";

    // globals
    prop = to_ui_prop("RECommentGather", "GlobalCommentLocation");
    if (ui_choice_isset(prop, 0))
      params = params + "global_above=1\n";
    else  
      params = params + "global_above=0\n";
    if (ui_choice_isset(prop, 1))
      params = params + "global_side=1\n";
    else  
      params = params + "global_side=0\n";
    
    prop = to_ui_prop("RECommentGather", "GlobalGapSetting");
    val = ui_choice_value(prop);
    if ( val == NULL )
      val = 1;
    params = params + "global_gap=" + val + "\n";

    // members
    prop = to_ui_prop("RECommentGather", "MemberCommentLocation");

    if (ui_choice_isset(prop, 0))
      params = params + "member_above=1\n";
    else  
      params = params + "member_above=0\n";
    if (ui_choice_isset(prop, 1))
      params = params + "member_side=1\n";
    else  
      params = params + "member_side=0\n";
	
    prop = to_ui_prop("RECommentGather", "MemberGapSetting");
    val = ui_choice_value(prop);
    if ( val == NULL )
      val = 1;
    params = params + "member_gap=" + val + "\n";

    // start and end comment delimiters
    prop = to_ui_prop("RECommentGather", "UseCommentDelimiters" );
    if ( ui_choice_isset( prop, 0 ))
    {
	prop = to_ui_prop("RECommentGather", "StartCommentDelimiter");
	cookie = ui_text_value(prop);
	if (cookie == NULL || cookie == "")
	    params = params + "startdelimiter=NULL\n";
	else 
	    params = params + "startdelimiter=" + cookie + "\n";
    
	prop = to_ui_prop("RECommentGather", "EndCommentDelimiter");
	cookie = ui_text_value(prop);
	if (cookie == NULL || cookie == "")
	    params = params + "enddelimiter=NULL\n";
	else 
	    params = params + "enddelimiter=" + cookie + "\n";
    }
    else
    {
	params = params + "startdelimiter=NULL\n";
	params = params + "enddelimiter=NULL\n";
    }

    if (file_exists(fname) && (! write_file_access(fname)))
        print_error("Cannot write file " + fname + " (check permissions).  Comment generation will not
be correct.");
    else
        write_file(fname, params);

    // write the extras
    prop = to_ui_prop("RECommentGather", "UseCommentDelimiters");
    params = ui_choice_value(prop) + " ";

    prop = to_ui_prop("RECommentGather", "PrintStyle");
    params += ui_choice_value(prop) + " ";

    prop = to_ui_prop("RECommentGather", "AnnotationLength");
    params += ui_choice_value(prop) + " ";

    fname = path_compose(current_projdir(),
			 current_system(),
			 "revc_files",
			 "CommentsExtras");
    if (file_exists(fname) && (! write_file_access(fname)))
        print_error("Cannot write file " + fname + " (check permissions).");
    else
        write_file(fname, params);
    
    return 1;
}


int
RECommentsReset_cb(ui_event_tp event, ui_prop theprop, int id, string v)

{
    string fname, params = "", valstr, param;
    ui_prop prop;
    list paraml, littlel;
    int i;

    // Reset the templates to the values in the template if exists, or 
    // otherwise to system defaults.

    fname = path_compose(current_projdir(),
			 current_system(),
			 "revc_files",
			 "Comments");
    if (read_file_access(fname))
         params = read_file(fname);

    if (params != "")
    {
	paraml = string_to_list(params, "\n");

	for (i = 0; i < list_count(paraml); i++)
	{
	    param = list_get(paraml, i);
	    littlel = string_to_list(param, "=");
	    valstr = list_get(littlel, 1);
	    
	    if (i == 2)		
	    {
		prop = to_ui_prop("RECommentGather", "FunctionGapSetting");
	        ui_choice_set_value(prop, to_int(valstr));
	    }
	    else if (i == 6)		
	    {
	      if ( is_product_se())
		prop = to_ui_prop("RECommentGather", "StructureGapSetting");
	      else
		prop = to_ui_prop("RECommentGather", "ClassGapSetting");
	      ui_choice_set_value(prop, to_int(valstr));
	    }
	    else if (i == 9)		
	    {		
		prop = to_ui_prop("RECommentGather", "GlobalGapSetting");
	        ui_choice_set_value(prop, to_int(valstr));
	    }
	    else if (i == 12)		
	    {		
		prop = to_ui_prop("RECommentGather", "MemberGapSetting");
	        ui_choice_set_value(prop, to_int(valstr));
	    }
	    else if (i == 13)		
	    {
		prop = to_ui_prop("RECommentGather", "StartCommentDelimiter");
		if (valstr == "NULL")
		    valstr = toolinfo_variable("RE_start_comment_delimiter");
		if (valstr == NULL || valstr == "")
		    valstr = "";
	        ui_text_set_value(prop, valstr);
	    }
	    else if (i == 14)		
	    {
		prop = to_ui_prop("RECommentGather", "EndCommentDelimiter");
		if (valstr == "NULL")
		    valstr = toolinfo_variable("RE_end_comment_delimiter");
		if (valstr == NULL || valstr == "")
		    valstr = "";
	        ui_text_set_value(prop, valstr);
	    }
	    else if (i >= 0 && i <= 1)
	    {
		prop = to_ui_prop("RECommentGather", "FunctionCommentLocation");
		if (to_int(valstr) == 0)
		    ui_choice_set(prop, i, False);
		else
		    ui_choice_set(prop, i, True);
	    }
	    else if (i >= 3 && i <= 5)
	    {
	      if ( is_product_se() )
		prop = to_ui_prop("RECommentGather", "StructureCommentLocation");
	      else
		prop = to_ui_prop("RECommentGather", "ClassCommentLocation");
	      if (to_int(valstr) == 0)
		ui_choice_set(prop, i - 3, False);
	      else
		ui_choice_set(prop, i - 3, True);
	    }
	    else if (i >= 7 && i <= 8)
	    {
		prop = to_ui_prop("RECommentGather", "GlobalCommentLocation");
		if (to_int(valstr) == 0)
		    ui_choice_set(prop, i - 7, False);
		else
		    ui_choice_set(prop, i - 7, True);
	    }
	    else if (i >= 10 && i <= 11)
	      {
		prop = to_ui_prop("RECommentGather", "MemberCommentLocation");
		if (to_int(valstr) == 0)
		    ui_choice_set(prop, i - 10, False);
		else
		    ui_choice_set(prop, i - 10, True);
	      }
	}
    }

    // get the extras
    params = "";
    fname = path_compose(current_projdir(),
			 current_system(),
			 "revc_files",
			 "CommentsExtras");
    if (read_file_access(fname))
         params = read_file(fname);

    if (params != "")
    {
	paraml = string_to_list(params, " ");

	if (list_count(paraml) >= 3)
	{
	    param = list_get(paraml, 0);
            prop = to_ui_prop("RECommentGather", "UseCommentDelimiters");
	    ui_choice_set_value(prop, to_int(param));

	    param = list_get(paraml, 1);
	    prop = to_ui_prop("RECommentGather", "PrintStyle");
	    ui_choice_set_value(prop, to_int(param));

	    param = list_get(paraml, 2);
	    prop = to_ui_prop("RECommentGather", "AnnotationLength");
	    ui_choice_set_value(prop, to_int(param));
	}
    }


    return 0;
}


// file system stuff

list
get_dir_list(string dir)

{
    list dlist;
    
    dlist = directory_files(path_part(dir),file_part(dir));

    if (list_count(dlist) == 0)//
    {
        print_error("No files found matching `" + dir + "'.");
	return NULL;
    }

    return dlist;
}



/////////////////////////// routines for the filtering of information

struct REFilterFile
{
    string myPath;        // the directory with the filename on the end
    boolean isUser;
    boolean isInFilter;
    list   myClasses;     // the positions in the allREFilterClasses
};

struct REFilterClass
{
    string myName;
    string myType;
    REFilterFile myFile;
    boolean isInFilter;
};

list allREFilterFiles = NULL;
list allREFilterClasses = NULL;


void update_ui_filter_lists()
{
    //print_error("update_ui_filter_lists.");

    int loop;
    REFilterFile reff;
    REFilterClass refc;
    ui_prop ignorelist = to_ui_prop( "REFilterModel", "IgnoreList" );
    ui_prop includelist = to_ui_prop( "REFilterModel", "IncludeList" );
    ui_list_item_tp ui_item;

    ui_list_clear( ignorelist );
    ui_list_clear( includelist );

    if ( allREFilterFiles == NULL )
      return;

    list ui_list_ignore = list_create("ui_list_item_tp", 0);
    list ui_list_include = list_create("ui_list_item_tp", 0);

    if ( REFilterCategory == FileCategory )
    {
        ui_item.image = to_ui_image("new_file");
	for( loop = 0; loop < list_count( allREFilterFiles ); loop++ )
	  {
	    reff = list_get( allREFilterFiles, loop );
            ui_item.label = reff.myPath;
	    if ( reff.isInFilter )
	      list_append( ui_list_include, ui_item );
	    else
	      list_append( ui_list_ignore, ui_item );
	  }
      }
    else
      {
          ui_item.image = to_ui_image("class");
	for( loop = 0; loop < list_count( allREFilterClasses ); loop++ )
	  {
	    refc = list_get( allREFilterClasses, loop );
            ui_item.label = refc.myName;
	    if ( refc.isInFilter )
	      list_append( ui_list_include, ui_item );
	    else
	      list_append( ui_list_ignore, ui_item );
	  }
      }
    ui_list_append(includelist, ui_list_include);
    ui_list_append(ignorelist, ui_list_ignore);
}

// pop up the filter dialog and call its reset function to fill in the
// details
//
int REFilterShow_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    //print_error("FilterShow_cb.");

    allREFilterFiles = NULL;
    allREFilterClasses = NULL;

    ui_prop_sheet_pop_up("REFilterModel");

    // if there is a user defined file there, then set it to that, otherwise
    // set it to the system by default
    ui_choice_set_value(to_ui_prop("REFilterModel", "PersonalChoice"), 1);
    string stored_filename = REFilterPersistentFile();
    if ( !read_file_access(stored_filename) )
      ui_choice_set_value(to_ui_prop("REFilterModel", "PersonalChoice"), 0);

    // populate the lists
    REFilterReset_cb(event, theprop, id, v);

    return 0;
}

// fill in the details - get the list of files and classes from the SMDB,
// build the internal data structure, then see if an existing filter file
// exists, and if it does apply that filter and display it
//
int REFilterReset_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    //print_error("FilterReset_cb.");

    ui_busy(to_ui_owner(to_ui_prop("REFilterModel", "PersonalChoice")), True);
    // create a temporary file for the output from the call to get the
    // info from the SMDB
    string fname = temp_file( "OOFilter", "oo" );

    if ( system( "xrb_get_files -forward_messages " + 
		 editor_get_msgd_handle() +
		 " -p ${projdir} -s ${system} -classes -of ${fname}" ) == 0 )
      {
	if (read_file_access(fname))
	  {
	    string fc = read_file(fname);
	    build_files_and_classes(fc);
	    string stored_data_file = REFilterPersistentFile();
	    string stored_settings = "";
	    if (read_file_access(stored_data_file))
	      {
		stored_settings = read_file(stored_data_file);
		mark_files_and_classes(stored_settings);
	      }
	    else
	      reset_filter_to_default();
	  }
	else
	  print_error( "No Files or Classes in SMDB." );
      }
    else
      print_error( "Failed to populate list with classnames from SMDB." );
    delete_file( fname );

    update_ui_filter_lists();
    ui_busy(to_ui_owner(to_ui_prop("REFilterModel", "PersonalChoice")), False);

    return 0;
}

// format of incoming file is FILE <fullfilepath> User|System
//                            CLASS <fullname>
// format of other file can be the same.

const string FileCategory = "0";
const string ClassCategory = "1";
string REFilterCategory = FileCategory;
const string FilterFileName = "OOFilter";

// this is called when either "Files" or "Classes" is picked as a category
// If it is the same value as now, then do nothing. Otherwise empty the lists
// and reload them with the data from the other set
//
int REFilterCategoryChanged_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    //print_error("Changing Category.");

    if ( v == REFilterCategory )
      return 0;

    // load up the new values
    REFilterCategory = v;
    update_ui_filter_lists();

    return 0;
}


// called when the arrow button is pressed to move files from the left list
// to the right list - need to see whether we are working with files or
// classes to determine exact behaviour.
// The objects internal rep needs to be marked, and visually they must be
// remove from the first list and added to the second
//
int REFilterAdd_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
  // foreach selected one, copy it across to the other side
  // if it is a file, then mark its contents as all being included
    ui_prop fromlist, ignorelist = to_ui_prop( "REFilterModel", "IgnoreList" );
    ui_prop tolist, includelist = to_ui_prop( "REFilterModel", "IncludeList" );
    boolean mark = True;

    if ( ui_prop_name(theprop) == "Add" )
      {
	fromlist = ignorelist;
	tolist = includelist;
	mark = True;
      }
    else
      {
	fromlist = includelist;
	tolist = ignorelist;
	mark = False;
      }

    list row_numbers = ui_list_selected( fromlist );
    list row_names = ui_list_selected_items( fromlist );
    int loop, pos, selected_count = 0, last_pos = 0, last_selected_count = -99;
    REFilterFile reff;
    REFilterClass refc;
    ui_list_item_tp ui_item;
    list ui_items = list_create( "ui_list_item_tp", 8 );
    ui_image_tp fileImage = to_ui_image("new_file");
    ui_image_tp classImage = to_ui_image("class");

    for( loop = 0; loop < list_count(row_names); loop++ )
    {
        ui_item.label = list_get( row_names, loop );
	if ( REFilterCategory == FileCategory )
        {
            ui_item.image = fileImage;
	    pos = find_filter_file( last_pos, ui_item.label );
	    if ( pos >= 0 )
	      {
		reff = list_get( allREFilterFiles, pos );
		mark_file_in_filter( reff, mark );
		list_set( allREFilterFiles, pos, reff );
	      }
	  }
	else
	  {
            ui_item.image = classImage;
	    pos = find_filter_class( last_pos, ui_item.label, NULL );
	    if ( pos >= 0 )
	      {
		refc = list_get( allREFilterClasses, pos );
		refc.isInFilter = mark;
		list_set( allREFilterClasses, pos, refc );
	      }
	  }
	// this needs to be inserted, although the algorithm will
	// be different if it is a Class or a File.
	selected_count += REFilterCountSelected(last_pos, pos, mark);
        last_pos = pos;

        if (selected_count != last_selected_count + 1 &&
            list_count(ui_items) > 0 )
        {
            ui_list_insert( tolist,
                            last_selected_count - list_count(ui_items) + 1,
                            ui_items );
            list_clear(ui_items);
        }
        list_append(ui_items, ui_item);
        last_selected_count = selected_count;
      }
    ui_list_insert( tolist,
                    last_selected_count - list_count(ui_items) + 1,
                    ui_items );
    ui_list_delete( fromlist, row_numbers );
    return 0;
}


// count the number of already selected entries before the current one.
// this is used to insert a new selection into the correct place in the 
// other list.
int REFilterCountSelected(int start_pos, int end_pos, boolean value)
{
    int loop, result = 0;
    REFilterClass refc;
    REFilterFile  reff;

    if ( REFilterCategory == FileCategory )
      for( loop = start_pos; loop < end_pos; loop++ )
	{
	  reff = list_get( allREFilterFiles, loop );
	  if ( reff.isInFilter == value )
	    result++;
	}
    else
      for( loop = start_pos; loop < end_pos; loop++ )
	{
	  refc = list_get( allREFilterClasses, loop );
	  if ( refc.isInFilter == value )
	    result++;
	}
    return result;
}


// empty the on-screen lists, then remark all the system files as not
// included, and the classes in them likewise. Then reload the lists from
// the lists
//
int REFilterDefaults_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    //print_error("Resetting to Defaults.");
    
    reset_filter_to_default();
    update_ui_filter_lists();
    return 0;
}


string REFilterPersistentFile()
{
    string dir = path_compose( current_projdir(), current_system(),
			       "revc_files", FilterFileName );
    string filename;
    if ( ui_choice_value( to_ui_prop( "REFilterModel", "PersonalChoice" )) == 
	 1 )
      dir += "_" + user();
    return dir;
}


int REFilterChangedUser_cb(ui_event_tp event, ui_prop theprop, int id,
			   string v)
{
    //print_error("ChangedUser_cb.");

    // if there is nothing in the lists, then just continue
    if (allREFilterClasses == NULL)
        return 0;

    int new_value = ui_choice_value( to_ui_prop( "REFilterModel",
						 "PersonalChoice" ));
    if ( new_value == 1 )  // personal 
      {
	string myFile = REFilterPersistentFile();
	if ( read_file_access(myFile) )
	  {
	    ui_activate(to_ui_prop("REFilterModel", "RemovePersonalFile"), True);
	    unmark_files_and_classes();
	    string file_contents = read_file(myFile);
	    mark_files_and_classes(file_contents);
	    update_ui_filter_lists();
	  }
      }
    else
      {
	ui_activate(to_ui_prop("REFilterModel", "RemovePersonalFile"), False);
	string myFile = REFilterPersistentFile();
	if ( read_file_access(myFile) )
	  {
	    unmark_files_and_classes();
	    string file_contents = read_file(myFile);
	    mark_files_and_classes(file_contents);
	    update_ui_filter_lists();
	  }
      }
    return 0;
}


int REFilterDeleted_cb(ui_event_tp event, ui_prop theprop, int id,
		       string v)
{
    string myFile = REFilterPersistentFile();
    delete_file(myFile);
    ui_choice_set_value(to_ui_prop("REFilterModel", "PersonalChoice"), 0);
    REFilterChangedUser_cb(event, theprop, id, v);
    return 0;
}


// called when OK or Apply get hit - we run through the list and work out
// what is selected, and write out their details into the revc_files 
// directory.
//
int REFilterDone_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    string stored_data_file = REFilterPersistentFile();
    string result = "", file_line = "", class_line = "";
    int loop, loop2;
    REFilterClass refc;
    REFilterFile reff;

    if (allREFilterFiles != NULL) 
     {  
       for( loop = 0; loop < list_count( allREFilterFiles ); loop++ )
         {
	   reff = list_get( allREFilterFiles, loop );
	   if ( !reff.isInFilter )
	     file_line = "FILE\t" + reff.myPath + "\t1\n";
	   else
	     file_line = "";
	   class_line = "";
	   for( loop2 = 0; loop2 < list_count( reff.myClasses ); loop2++ )
	     {
	       refc = list_get( allREFilterClasses, list_get( reff.myClasses,
							      loop2 ));
	       if ( !refc.isInFilter )
	         class_line += "CLASS\t" + refc.myName + "\n";
	     }
	   if ( file_line == "" && class_line != "" )
	     file_line = "FILE\t" + reff.myPath + "\t0\n";
	   result += file_line + class_line;
         }
     }
    if (write_file( stored_data_file, result ) <= 0 )
      {
	print_error( "Can't open '" + stored_data_file + "' for writing." );
	return 0;
      }

    if ( ui_prop_name(theprop) == "OK" )
      return 1;
    else
      return 0;
}


// 
// 
void build_files_and_classes(string fc)
{
    //print_error("build_files_and_classes.");

    list lines = string_to_list(fc, "\n");
    list entry;
    int loop;
    REFilterFile filterfile = NULL;
    REFilterClass filterclass = NULL;

    allREFilterClasses = list_create( "REFilterClass", 0 );
    allREFilterFiles = list_create( "REFilterFile", 0 );

    for( loop = 0; loop < list_count(lines); loop++ )
      {
	entry = string_to_list( list_get( lines, loop ), "\t" );
	if ( list_get( entry, 0 ) == "FILE" )
	  {
	    filterfile = create_filter_file( list_get( entry, 1 ),
					     list_get( entry, 2 ));
	    list_append( allREFilterFiles, filterfile );
	  }
	else
	  {
	    filterclass = create_filter_class( list_get( entry, 1 ),
					       filterfile );
	    list_set( allREFilterFiles, list_count( allREFilterFiles ) - 1,
		      filterfile );
	    list_append( allREFilterClasses, filterclass );
	  }
      }
}


void unmark_files_and_classes()
{
    //print_error("unmark_files_and_classes.");

    REFilterFile reff;
    REFilterClass refc;
    int loop;

    if ( allREFilterFiles != NULL )
      for( loop = 0; loop < list_count( allREFilterFiles ); loop++ )
	{
	  reff = list_get( allREFilterFiles, loop );
	  reff.isInFilter = False;
	  list_set( allREFilterFiles, loop, reff );
	}

    if ( allREFilterClasses != NULL )
      for( loop = 0; loop < list_count( allREFilterClasses ); loop++ )
	{
	  refc = list_get( allREFilterClasses, loop );
	  refc.isInFilter = False;
	  list_set( allREFilterClasses, loop, refc );
	}
}

// 
// 
void mark_files_and_classes(string fc)
{
    //print_error("mark_files_and_classes.");

    list lines = string_to_list(fc, "\n");
    list entry;
    int loop, pos;
    REFilterFile filterfile = NULL;
    REFilterClass filterclass = NULL;

    for( loop = 0; loop < list_count(lines); loop++ )
      {
    // ECR4264, fixed typo
	entry = string_to_list( list_get( lines, loop ), "\t" );
	if ( list_get( entry, 0 ) == "FILE" )
	  {
	    pos = find_filter_file( 0, list_get( entry, 1 ));
	    if ( pos >= 0 )
	      {
		filterfile = list_get( allREFilterFiles, pos );
		filterfile.isInFilter = (list_get(entry, 2) == "0");
		list_set( allREFilterFiles, pos, filterfile );
	      }
	  }
	else
	  {
	    pos = find_filter_class( 0, list_get( entry, 1 ),
				     filterfile );
	    if ( pos >= 0 )
	      {
		filterclass = list_get( allREFilterClasses, pos );
		filterclass.isInFilter = False;
		list_set( allREFilterClasses, pos, filterclass );
	      }
	  }
      }
}

int find_filter_file( int start_pos, string path )
{
    REFilterFile result = NULL;
    int loop;

    if ( allREFilterFiles == NULL )
      return -1;

    for( loop = start_pos; loop < list_count( allREFilterFiles ); loop++ )
      {
	result = list_get( allREFilterFiles, loop );
	if ( result.myPath == path )
	  return loop;
      }
    return -1;
}


int find_filter_class( int start_pos, string name, REFilterFile file )
{
    REFilterClass result = NULL;
    int loop;

    if ( allREFilterClasses == NULL )
      return -1;

    for( loop = start_pos; loop < list_count( allREFilterClasses ); loop++ )
      {
	result = list_get( allREFilterClasses, loop );
	if ( result.myName == name &&
	     ( file == NULL || result.myFile.myPath == file.myPath ))
	  return loop;
      }
    return -1;
}


REFilterFile create_filter_file( string path, string user )
{
    REFilterFile result;
    result.myPath = path;
    if ( user == "User" )
      result.isUser = True;
    else
      result.isUser = False;
    result.myClasses = list_create( "int", 0 );
    result.isInFilter = True;
    return result;
}


REFilterClass create_filter_class( string name, REFilterFile file )
{
    REFilterClass result;
    result.myName = name;
    // result.myType = "Class"; may need it in the future
    result.myFile = file;
    result.isInFilter = True;
    list_append( file.myClasses, list_count( allREFilterClasses ));
    return result;
}


void reset_filter_to_default()
{
    //print_error("reset_filter_to_default.");

    REFilterFile file = NULL, same_file;
    int loop;
    if (allREFilterFiles != NULL) 
    {
       for( loop = 0; loop < list_count( allREFilterFiles ); loop++ )
         {
	   file = list_get( allREFilterFiles, loop );
	   if ( file.isUser == True )
	     mark_file_in_filter( file, True );
	   else
	     mark_file_in_filter( file, False );
	   list_set( allREFilterFiles, loop, file );
         }
    }
}


void mark_file_in_filter( REFilterFile file, boolean value )
{
    if ( file == NULL )
      return;

    file.isInFilter = value;
    int loop, each_class_id;
    REFilterClass each_class;
    for( loop = 0; loop < list_count( file.myClasses ); loop++ )
      {
	 each_class_id = list_get( file.myClasses, loop );
	 each_class = list_get( allREFilterClasses, each_class_id );
	 each_class.isInFilter = value;
	 list_set( allREFilterClasses, each_class_id, each_class );
      }
}

// ECR4258: Read MS Project Files.
//
struct REFiles
{
     set SourceFiles;
     set UserIncludes;
     set SystemIncludes;
     set PPDefines;
};

//
//
// Callback for the 'Read selected MS Project File' Button in the RE Prop Sheet.
//
int
REReadMSProjectFile(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop dir_prop;
    list l;

    dir_prop = proper_master( "DirSelector" );
    l = ui_list_selected_items(dir_prop);

    if ( list_count(l) == 0 || ui_list_selected_row(dir_prop) == 0 )
    {
	print_error( "Select the MS Projectfile to use in the Directory list first." ); 
	return 1;
    }
    if ( list_count(l) > 1 )
    {
	print_error( "Select a single Projectfile to use." ); 
	return 1;
    }
    string ProjectFile = list_get(l,0);

    if ( read_dir_access( ProjectFile ))
    {
	print_error( "Select a Projectfile - not a directory." ); 
	return 1;
    }
    // print_message("selected file: " + ProjectFile);
    
    ui_busy(to_ui_owner(dir_prop), True);

    ProjectFile = path_compose(ProjectFile);
    REFiles REFiles = GetREFilesFromMSProject(ProjectFile, ExtraMakePattern( 0, NULL ));
    
    if (REFiles == NULL)
    {
         print_error("No SOURCE Lines in MS Project File");
         ui_busy(to_ui_owner(dir_prop), False);
         return 2;
    }

// now fill the Prop Sheet.
    FillFileValues(REFiles.SourceFiles);
    FillUserIncludes(REFiles.UserIncludes);
    FillSystemIncludes(REFiles.SystemIncludes);
    FillPPDefines(REFiles.PPDefines);
    
    ui_busy(to_ui_owner(dir_prop), False);
    return 1;
}

//
// Read MS Project File and extract the Source Files.
//
REFiles GetREFilesFromMSProject(string MSProjectFile, string SourcePattern)
{
    REFiles REFiles;
    list FileLines;
    string OneLine;
    int i;
    const string SourceTag="SOURCE=";
    const string CppTag="# ADD CPP";
    list ListSourcePattern = string_to_list(SourcePattern, " ");
    string CurrentDir = path_part(MSProjectFile);
    boolean SkipLine = False;
    
    REFiles.SourceFiles    = set_create("string");
    REFiles.UserIncludes   = set_create("string");
    REFiles.SystemIncludes = set_create("string");
    REFiles.PPDefines = set_create("string");

    FileLines = string_to_list(read_file(MSProjectFile), "\n");

    for (i=0; i<list_count(FileLines); i++)
    {
        OneLine = list_get(FileLines, i);       
//        print_message(OneLine);
//
// Check if we have to skip Debug Lines in Project File
//
        if (string_find(OneLine, 0, "!IF") == 0 || string_find(OneLine, 0, "!ENDIF") == 0)
        {
            SkipLine = False;
            continue;
        }
        if (string_find(OneLine, 0, "!ELSEIF") == 0)
        {
            SkipLine = True;
            continue;
        }
        if (SkipLine)
            continue;
        
        if (string_find(OneLine, 0, SourceTag) == 0)
        {
            OneLine = string_search_and_replace(OneLine, SourceTag, "");
            AddSourceFiles(REFiles, OneLine, CurrentDir, ListSourcePattern);
        }
        else if (string_find(OneLine, 0, CppTag) == 0)
        {
            AddCppInfo(REFiles, OneLine, CurrentDir);
        }
    }
    if (set_count(REFiles.SourceFiles) == 0)
        return NULL;

    return REFiles;
}

//
// Add Source Files and User Includes
//
int AddSourceFiles(REFiles REFiles, string OneLine, string CurrentDir, list ListSourcePattern)
{
    list SourceLineParts;
    string FileExtension = "";

    // Sometimes there are " chars in a SOURCE line, remove them.
    OneLine = string_strip(OneLine, "B", "\"");

    // Get File Extension
    SourceLineParts = string_to_list(OneLine, ".");

    // File Extension is the last element in the list.            
    FileExtension = list_get(SourceLineParts, list_count(SourceLineParts)-1);

    if (list_find(ListSourcePattern, 0, "*." + FileExtension) < list_count(ListSourcePattern))
    {
        OneLine = GetFullPath(CurrentDir, OneLine);
//                print_message("Append: " + OneLine);
        set_add(REFiles.SourceFiles, OneLine);
        set_add(REFiles.UserIncludes, path_part(OneLine));

    }
    else if(FileExtension == "h")
    {
        OneLine = GetFullPath(CurrentDir, OneLine);
        set_add(REFiles.UserIncludes, path_part(OneLine));       
    }
    return 1;
}

//
// Add System Includes and DEFINES.
//
int AddCppInfo(REFiles REFiles, string OneLine, string CurrentDir)
{
    list CppInfos;
    int i;
    string OneInfo;
    const string IncludeTag="/I";
    const string DefineTag="/D";
    // list of defines that will create o lot of parser error messages
    // Therefore we filter them out.
    list BadDefines = string_to_list("_AFXDLL", " ");
    string DefineName;
    
    CppInfos = string_to_list(OneLine, " ");
    
    for (i=0; i < list_count(CppInfos); i++)
    {
        OneInfo = list_get(CppInfos, i);
        
        if (OneInfo == IncludeTag)
        {
            OneInfo = list_get(CppInfos, i+1);
            OneInfo = string_strip(OneInfo, "B", "\"");

            // Check if it is a relative path
            if (string_find(OneInfo, 0, ".") == 0)
                OneInfo = GetFullPath(CurrentDir, OneInfo);
                
            set_add(REFiles.SystemIncludes, OneInfo);     
            i++;
        }
        else if (OneInfo == DefineTag)
        {
            OneInfo = list_get(CppInfos, i+1);
            
            if (string_find(OneInfo, 0, "=") == string_length(OneInfo))
            {
                OneInfo = string_strip(OneInfo, "B", "\"");
                OneInfo += "=1";
            }
            DefineName = string_extract(OneInfo, 0, string_find(OneInfo, 0, "="));
            
            if (list_find(BadDefines, 0, DefineName) == list_count(BadDefines))
                set_add(REFiles.PPDefines, OneInfo);
            
            i++;
        }
    }
    return 1;
}

// 
// Compose Path from the two parts.
//
string GetFullPath(string DirPath, string FilePath)
{
    int i,pos;
    list PathParts;
    string FullPath="";
    const string PathDelim="\\";

    PathParts = string_to_list(DirPath, PathDelim);
    list_concatenate(PathParts, string_to_list(FilePath, PathDelim));

    // Remove Current Directory from List
    pos = list_find(PathParts, 0, ".");

    while (pos < list_count(PathParts))
    {
        list_delete(PathParts, pos);
        pos = list_find(PathParts, 0, ".");
    }

    // Remove Parent Directory from List
    pos = list_find(PathParts, 0, "..");

    while (pos < list_count(PathParts))
    {
        list_delete(PathParts, pos);
        list_delete(PathParts, pos-1);
        pos = list_find(PathParts, 0, "..");
    }

    // now build the full path
    FullPath = list_get(PathParts, 0);

    for(i=1; i<list_count(PathParts); i++)
    {
        FullPath += PathDelim + list_get(PathParts, i);
    }

    return FullPath;
}

// 
// Insert File Values into the Prop sheet.
//
int FillFileValues(set FileValues)
{
    list uiValues = list_create("ui_list_item_tp", 0);
    int i;
    ui_list_item_tp ui_item;
    ui_item.image = FileImage;
    ui_prop prop;
    
    for(i=0; i < set_count(FileValues); i++)
    {
        ui_item.label = set_get_element(FileValues, i);
        list_append(uiValues, ui_item);
    }

    prop = proper_master("Files");
    ui_list_clear(prop);

    ui_list_append( prop, uiValues );
    return 1;
}

// 
// Insert User Includes to the Prop sheet.
//
int FillUserIncludes(set UserIncludes)
{
    int i;
    string FillStr="";

    for(i=0; i < set_count(UserIncludes); i++)
    {
       FillStr += set_get_element(UserIncludes, i) + "\n";
    }
    ExtraIncludeValue (FillStr);
    
    return 1;
}

// 
// Insert System Includes to the Prop sheet.
//
int FillSystemIncludes(set SystemIncludes)
{
    int i;
    string FillStr="";

    for(i=0; i < set_count(SystemIncludes); i++)
    {
       FillStr += set_get_element(SystemIncludes, i) + "\n";
    }
    ExtraSysIncludeValue (FillStr);
    
    return 1;
}

// 
// Insert System Includes to the Prop sheet.
//
int FillPPDefines(set Defines)
{
    int i;
    string FillStr="";

    for(i=0; i < set_count(Defines); i++)
    {
       FillStr += set_get_element(Defines, i) + " ";
    }
    ExtraDefineValue (FillStr);
    
    return 1;
}

// ECR4126, Parse directory Tree

//
//
// Callback for the 'Parse Directory Tree' Button in the RE Prop Sheet.
//
int
REParseDirectoryTree(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop dir_prop;
    list l;

    dir_prop = proper_master( "DirSelector" );
    l = ui_list_selected_items(dir_prop);

    if ( list_count(l) == 0 || ui_list_selected_row(dir_prop) == 0 )
    {
	print_error( "Select the Directory to parse in the Directory list first." ); 
	return 1;
    }
    if ( list_count(l) > 1 )
    {
	print_error( "Select a single Directory." ); 
	return 1;
    }
    string Directory = list_get(l,0);

    if ( ! read_dir_access( Directory ))
    {
	print_error( "Select a directory." ); 
	return 1;
    }
    // print_message("selected file: " + Directory);
    
    ui_busy(to_ui_owner(dir_prop), True);

    Directory = path_compose(Directory);
    REFiles REFiles = GetREFilesFromDirectory(Directory, ExtraMakePattern( 0, NULL ));
    
    if (REFiles == NULL)
    {
         print_error("No Source Files in Directory");
         print_message("Check Source File Pattern in Makefile Options");
         ui_busy(to_ui_owner(dir_prop), False);
         return 2;
    }

// now fill the Prop Sheet.
    FillFileValues(REFiles.SourceFiles);
    FillUserIncludes(REFiles.UserIncludes);
    FillSystemIncludes(REFiles.SystemIncludes);
    FillPPDefines(REFiles.PPDefines);
    
    ui_busy(to_ui_owner(dir_prop), False);
    return 1;
}

//
// Parse a Directory Tree and look for Source Files.
//
REFiles GetREFilesFromDirectory(string Directory, string SourcePattern)
{
    REFiles REFiles;
    list ListSourcePattern = string_to_list(SourcePattern, " ");
    
    REFiles.SourceFiles    = set_create("string");
    REFiles.UserIncludes   = set_create("string");
    REFiles.SystemIncludes = set_create("string");
    REFiles.PPDefines = set_create("string");

    ParseDirectory(REFiles, Directory, ListSourcePattern);
    
    if (set_count(REFiles.SourceFiles) == 0)
        return NULL;

    return REFiles;
}

//
// Look for Source Files in a single Directory.
//
int ParseDirectory(REFiles REFiles, string Directory, list ListSourcePattern)
{
    list DirectoryFiles;
    string OneFile;
    int i;
    list SourceLineParts;
    string FileExtension = "";


    DirectoryFiles = directory_files(Directory, "");

    for (i=0; i<list_count(DirectoryFiles); i++)
    {
        OneFile = list_get(DirectoryFiles, i);       
//        print_message(OneFile);
 
        if (read_dir_access(OneFile))
        {
            ParseDirectory(REFiles, OneFile, ListSourcePattern);
        }
        else if (read_file_access(OneFile))
        {
            // Get File Extension
            SourceLineParts = string_to_list(OneFile, ".");

            // File Extension is the last element in the list.            
            FileExtension = list_get(SourceLineParts, list_count(SourceLineParts)-1);

            if (list_find(ListSourcePattern, 0, "*." + FileExtension) < list_count(ListSourcePattern))
            {
 //               print_message("Add File: " + OneFile);        
                set_add(REFiles.SourceFiles, OneFile);
                set_add(REFiles.UserIncludes, path_part(OneFile));

            }
            else if(FileExtension == "h")
            {
                set_add(REFiles.UserIncludes, path_part(OneFile));       
            }
        }
     }
    return 1;
}
// End ECR4258 and ECR4126

// Begin add ECR 3651
int select_rev_dir_callback(ui_event_tp event, ui_prop theprop, int id, string value)
{
    string str;

    ui_owner uiOwner = to_ui_owner(theprop);
    str = ui_get_value(to_ui_prop(uiOwner, "ChooserDirectory"));
    string filter_string = file_part( str );
    string path = path_part( str );

    str = editor_show_dirchooser("Select Source Directory", path);

    if (str != NULL && string_length(str) != 0)
    {
        str = path_normalize(str);
        ui_set_value(to_ui_prop(uiOwner, "ChooserDirectory"), str + "/" + filter_string);
    }

    DirChooserFill_cb( event, theprop, id, value );
    return 0;
}
// End Add ECR 3651
