// Code for the file chooser property sheet


#include "qrl/include/general.inc"

const string Parent = "Parent Directory";
ui_image_tp FileImage = to_ui_image("new_file"); 
ui_image_tp DirImage = to_ui_image("closed_folder");
ui_image_tp UpArrowImage = to_ui_image("parent_directory");

// if this is set to True (by other propsheets that inherit
// from the generic file shooser) then a single default callback
// will be skipped. 
// It is done this way so multiple dialogs that reuse this code can
// selectively turn off the cascade of events to this layer as the events are
// handled.
boolean file_chooser_skip_cb = False;

int
DirChooserFill_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop chooser_prop;
    string dir;
    int i;

    if (file_chooser_skip_cb)
    {
        file_chooser_skip_cb = False;
        return 0;
    }
   
    chooser_prop = to_ui_prop(ui_owner_name(theprop),"ChooserDirectory");
    dir = ui_text_value(chooser_prop);

    if (str_no_val(dir))
    {
        print_error("A pattern or directory is required.");
        return 0;
    }

    dir = expand_directory_filter(dir);

    fill_chooser(ui_owner_name(theprop),dir, False);

    // put the dir, which might be modified, in directory window
    ui_text_set_value(chooser_prop, dir);

    return 0;
}

int 
fill_chooser(string owner, string dir, boolean right_justify)
{
    ui_prop dir_prop;
    list dlist;
    int i, cnt;
    list l = list_create("ui_list_item_tp", 0);
    ui_list_item_tp item;

    dir_prop = to_ui_prop(owner,"DirSelector");

    ui_footer_set_value(to_ui_prop("REParse", "Status"), "");
    ui_busy(to_ui_owner(dir_prop), True);
    dlist = get_dir_list(dir);
    if (dlist == NULL)
    {
        ui_busy(to_ui_owner(dir_prop), False);
        return 0;
    }

    ui_list_clear(dir_prop);

    if (root_part(dir) != dir)
    {
        item.image = UpArrowImage;
        item.label = Parent;
        ui_list_append(dir_prop, item);
    }

    cnt = list_count(dlist);

    if (cnt > 0 && cnt < 1000)
        ui_footer_set_value(to_ui_prop(owner, "Status"), "Processing " + cnt + " items.");
    else if (cnt > 1000 && cnt < 5000)
        ui_footer_set_value(to_ui_prop(owner, "Status"), "Processing " + cnt + " items. This takes a few moments.");
    else
        ui_footer_set_value(to_ui_prop(owner, "Status"), "Processing " + cnt + " items. This can take several minutes.");

    for (i = 0; i < cnt; i++)
    {
        item.label = list_get(dlist, i);
        if (read_dir_access(item.label))
            item.image = DirImage;
        else 
            item.image = FileImage;    

        list_append(l, item);
    }

    if (cnt > 0)
        ui_list_append(dir_prop, l);

    if ( right_justify )
        ui_list_set_hscroll_pos( dir_prop, 200 );

    ui_busy(to_ui_owner(dir_prop), False);
    return 0;
}


int 
StPFileChooserDoubleClick_cb(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop prop, chooser_prop;
    int row, i, indent = 0;
    string val;
    list l;
    boolean add_slash = False;

    if (file_chooser_skip_cb)
    {
        file_chooser_skip_cb = False;
        return 0;
    }

    prop = to_ui_prop(ui_owner_name(theprop),"DirSelector");
    chooser_prop = to_ui_prop(ui_owner_name(theprop),"ChooserDirectory");
    row = ui_list_selected_row(prop);

    if (row >= 0)
        val = ui_list_row_label(prop, row);        // LastValue does not work here
    else
        return 0;

    // JED - orig if (row == 0) //Parent Directory
    if (val == Parent) //Parent Directory
    {
        int orig_len = string_length( ui_text_value(chooser_prop) );
        if (ui_list_num_items(prop) > 1)
            val = ui_list_row_label(prop, 0);
        else
            val = ui_text_value(chooser_prop);

        if(path_part(val) == root_part(val))
            val = root_part(val);
        else
            val = parent_directory(parent_directory(val));
        indent = string_length( val ) - orig_len;
    }
    else
    {
        if (! read_dir_access(val))
        {
            print_message(val + " is not a directory.");
            return 0;
        }
        indent = string_length( val ) -
                 string_length( ui_text_value(chooser_prop));
    }

    val = expand_directory_filter(val);
    fill_chooser(ui_owner_name(theprop),val, True);

    // put the dir in directory window
    ui_text_set_value(chooser_prop, val);
    return 0;

}





// Delete functions

int
scrolling_list_delete(ui_prop prop)
{
    int row, i;
    list rows;

    rows = ui_list_selected(prop);

    ui_busy(to_ui_owner(prop), True);
    ui_list_delete(prop, rows);
    ui_busy(to_ui_owner(prop), False);

    // this was slow and hideous
    //    for (i = 0; i < list_count(rows); i++)
    //    {
    //        row = list_get(rows, i);
    //        ui_list_delete(prop, row - i);
    //    }

    return 0;
}


int
StPRemoveFile(ui_event_tp event, ui_prop theprop, int id, string v)
{
    if (file_chooser_skip_cb)
    {
        file_chooser_skip_cb = False;
        return 0;
    }
    ui_prop prop = to_ui_prop(ui_owner_name(theprop),"Files");
    return scrolling_list_delete(prop);
}



int
StPFileAdd(ui_event_tp event, ui_prop theprop, int id, string v)
{
    ui_prop dir_prop, file_prop;
    list l, existingl;
    string item;
    int i, j;
    boolean dup;

    if (file_chooser_skip_cb)
    {
        file_chooser_skip_cb = False;
        return 0;
    }

    dir_prop = to_ui_prop(ui_owner_name(theprop),"DirSelector");
    file_prop = to_ui_prop(ui_owner_name(theprop),"Files");

    // get the selected files from dir_prop and stuff them in file_prop, if they 
    // are not already in the list.

    l = ui_list_selected_items(dir_prop);
 
    existingl = ui_list_value(file_prop);

    for (i = 0; i < list_count(l); i++)
    {
        item = list_get(l, i);
        
        if (item == Parent) 
            continue;

        dup = False;
        for (j = 0; j < list_count(existingl); j++)
        {
            if (item == list_get(existingl, j))
            {
                   dup = True;
                break;
            }
        }
 
        if (! dup)
            ui_list_append(file_prop, item);
    }
 
    return 0;
}

// file system stuff

list
get_dir_list(string dir)

{
    list dlist;
    
    dlist = directory_files(path_part(dir),file_part(dir));

    if (list_count(dlist) == 0)//
    {
        print_error("No files found matching `" + dir + "'.");
        return NULL;
    }

    return dlist;
}
