//
//      sccsid[] = %W% %Y% %D%
//      StP Core
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1992-1995
//      All rights reserved
//

// driver file for the stpoad daemon. It handles tooltalk communications
// between ObjectAda and StP. It should work with both Booch and OMT.

#include "rules/qrl/ct.inc"
#include "rules/qrl/ci.qrl"

// ToolTalk Addresses

const int TT_PROCEDURE	= 0;
const int TT_OBJECT	= 1;
const int TT_HANDLER	= 2;
const int TT_OTYPE	= 3;

// ToolTalk Dispositions

const int TT_DISCARD    = 0;
const int TT_QUEUE      = 1;
const int TT_START      = 2;

string DEFAULT_EDITOR = "ome";

string logfile = temp_dir() + "stpoad_" + user() + current_system();
int logging = -1;

int first_message = 0;
int desktop_started = 0;
int editor_messaged = 0;

void
main( int started_by_tooltalk )
{
    int ok;

    ok = tooltalk_connect();
    if ( ok < 0 )
      {
    	print_error( "stpoad: Failed to connect to tooltalk." );
	return;
      }

    if ( is_product_booch() )
      DEFAULT_EDITOR = "class";
    else if ( is_product_uml() )
      DEFAULT_EDITOR = "uclassd";
    else
      DEFAULT_EDITOR = "ome";

    // tooltalk callbacks - these are the TT messages I act on
    callback_create("StP_Desktop", "handle_desktop");
    callback_create("StP_Stop", "handle_stp_stop");
    callback_create("StP_Navigate", "handle_stp_navigate");

    pattern_register("TT_HANDLE", "StP_Desktop", "TT_SESSION");
    pattern_register("TT_HANDLE", "StP_Stop", "TT_SESSION");
    // if we have been started with an explicit project/system, then
    // just listen to messages for that
    // if tooltalk starts us then we must listen to all, and set
    // our project/system after
    if ( started_by_tooltalk )
      {
	string ttfile = environment_variable( "TT_FILE" );
	log_print( "Started by ToolTalk : TT_FILE is " + ttfile );
	if ( ttfile != NULL )
	  {
	    pattern_register("TT_HANDLE", "StP_Navigate", "TT_FILE_IN_SESSION",
			     ttfile );
	    reregister_context( extract_stp_project( ttfile ),
				extract_stp_system( ttfile ));
	  }
	else
	  first_message = 1;
      }
    else
      pattern_register("TT_HANDLE", "StP_Navigate", "TT_FILE_IN_SESSION",
		       current_projdir() + current_system());

    // internal message callbacks - these come from our editors, and
    // get mapped into the TT messages listed next
    callback_create("Ada_Navigate", "handle_ada_navigate" );
    callback_create("Ada_Stop", "handle_ada_stop" );
    callback_create("Ada_Start", "handle_ada_start" );

    // reply callbacks - these are the TT messages I send, and expect
    // replies to
    callback_create("OA_Navigate", "handle_ada_reply" );
    callback_create("OA_Start", "handle_ada_reply" );
    callback_create("OA_Reply", "handle_stp_reply" );

    main_event_loop();
}


void handle_desktop(message msg)
{
    list      args = msg.arglist;
    string    oa_cntx = list_get( args, 1 );
    string    stp_cntx = list_get( args, 2 );
    string    stp_project = extract_stp_project( stp_cntx );
    string    stp_system  = extract_stp_system( stp_cntx );

    log_print( "Received StP_Desktop message\n" +
		 "For Project/System " + stp_project + " " + stp_system +
		 "\nFrom ObjectAda context " + oa_cntx );

    // it may be that this project/system is not the same as ours,
    // and this is the first message. In which case we need to set
    // up the file_in_session stuff and reregister ourselves...
    if ( first_message )
      {
	if ( stp_project != current_projdir() ||
	     stp_system != current_system())
	  {
	    pattern_register("TT_HANDLE", "StP_Navigate", "TT_FILE_IN_SESSION",
			     stp_project + stp_system );
	    reregister_context( stp_project, stp_system );	    
	  }
	first_message = 0;
      }


    // we really need to be able to send a message to a different
    // context - in the meantime we can synthesize this with a
    // stpem call
    system( "stpem -ed stp -s " + stp_system + " -p " + stp_project +
	    " -C EditorStart -C EditorDeiconify -C EditorShow" );

    // we assume that this always happens just fine
    message_reply(msg);

    desktop_started = 1;
}


void handle_stp_stop(message msg)
{
    list      args = msg.arglist;
    string    oa_cntx = list_get( args, 1 );
    string    stp_cntx = list_get( args, 2 );
    string    stp_project = extract_stp_project( stp_cntx );
    string    stp_system  = extract_stp_system( stp_cntx );

    log_print( "Received StP_Stop message\n" +
		 "For Project/System " + stp_project + " " + stp_system +
		 "\nFrom ObjectAda context " + oa_cntx );

    // keep tooltalk happy with a reply in the affirmative
    message_reply(msg);

    message zap;
    zap.type = "StP";
    zap.arglist = string_to_list( "EditorQuit", " " );
    zap.class = "";
    zap.handle = 0;
    if ( desktop_started )
      {
	// send an stp command to editorquit
	zap.class = "stp";
	message_send( zap );
      }

    if ( editor_messaged )
      {
	// send a message to the ome to quit
	zap.class = DEFAULT_EDITOR;
	message_send( zap );
      }

    stp_quit();
}

struct nav_object
{
    string    name;
    string    type;
    string    scope;
    string    signature;
};

int internal_message_id = 1;

void handle_stp_navigate(message msg)
{
    list      args = msg.arglist;
    string    oa_cntx = list_get( args, 1 );
    string    stp_cntx = list_get( args, 2 );
    string    stp_project = extract_stp_project( stp_cntx );
    string    stp_system  = extract_stp_system( stp_cntx );
    nav_object myParm = extract_nav_object( list_get( args, 3 ));

    log_print( "Received StP_Navigate message\n" +
		 "For Project/System " + stp_project + " " + stp_system +
		 "\nFrom ObjectAda context " + oa_cntx +
		 "\nObject = <" + myParm.name + ", " + myParm.type + ", " +
		   myParm.scope + ", " + myParm.signature + ">" );

    string member = "", editor = DEFAULT_EDITOR;
    string classname = myParm.name;
    list outargs = list_create( "string", 0 );
    message msg1;
    msg1.type = "StP";
    msg1.class = editor;
    msg1.handle = CONHANDLE_FIRST;

    list_append(outargs, "EditorQrlEvalNoSave");
    string outmsg = "\"nav_from_ada(" + internal_message_id + "," +
      "\\\"" + oa_cntx + "\\\"," +
      "\\\"" + myParm.name + "\\\"," +
      "\\\"" + myParm.type + "\\\"," +
      "\\\"" + myParm.scope + "\\\"," +
      "\\\"" + myParm.signature + "\\\");\"";
    list_append(outargs, outmsg);

    msg1.arglist = outargs;

    int stp_handle = message_send(msg1);
    if ( stp_handle < 0)
	message_fail(msg);
    else
        add_stack_message( stp_handle, internal_message_id, editor, msg );

    internal_message_id++;
    editor_messaged = 1;
}


void handle_ada_navigate(message msg)
{
    list args = msg.arglist;
    int from_handle = to_int( list_get( args, 1 ));
    string projsys = list_get( args, 2 );
    string oa_cntx = list_get( args, 3 );
    string target = list_get( args, 4 );

    log_print( "Received OA_Navigate message\n" +
		 "From Project/System " + projsys +
		 "\nFor ObjectAda context " + oa_cntx +
		 "\nObject = <" + target  + ">" );

    message snd;
    snd.type = "ToolTalk";
    snd.class = "TT_REQUEST";
    snd.scope = "TT_SESSION";
    snd.handle = TT_PROCEDURE;
    snd.disposition = TT_START;
    snd.arglist = string_to_list("OA_Navigate " + projsys + " " +
				 oa_cntx + " " + target,  " ");
    snd.modelist = string_to_list("TT_IN TT_IN TT_IN TT_IN", " ");
    snd.vtypelist = string_to_list("operation string string string", " ");
    add_stack_message( from_handle, 0, msg.class, snd );
    message_send(snd);
}

void handle_ada_stop(message msg)
{
// create a stop message, and send it right along
    list args = msg.arglist;
    string projsys;
    
    projsys = path_compose(list_get( args, 1 ),list_get( args, 2));
    message stop;
    stop.type = "ToolTalk";
    stop.class = "TT_NOTICE";
    stop.scope = "TT_SESSION";
    stop.disposition = TT_DISCARD;
    stop.arglist = string_to_list( "OA_Stop " + projsys + " " +
				   list_get( args, 3 ), " " );
    stop.modelist = string_to_list( "TT_IN TT_IN TT_IN", " " );
    stop.vtypelist = string_to_list( "operation string string", " " );
    message_send(snd);
}


void handle_ada_start(message msg)
{
    list args = msg.arglist;
    string projsys = list_get( args, 2 );
    string oa_cntx = list_get( args, 1 );

    message snd;
    snd.type = "ToolTalk";
    snd.class = "TT_NOTICE";
    snd.scope = "TT_SESSION";
    snd.handle = TT_PROCEDURE;
    snd.disposition = TT_START;
    snd.arglist = string_to_list("OA_Start " + projsys + " " +
				 oa_cntx,  " ");
    snd.modelist = string_to_list("TT_IN TT_IN TT_IN", " ");
    snd.vtypelist = string_to_list("operation string string", " ");
    message_send(snd);
}


void handle_ada_reply(message msg)
{
// we have received a reply from ToolTalk for an Ada message we
// previously sent. We need to take the pending message from our
// stack, and sent on an appropriate message to StP

    const string ERROR_STRING = "EditorPrintError \"Navigation Failed\"";

    nav_stack nav = get_stack_message1( msg );

    log_print( "Received ObjectAda reply with status " +
		 message_status( msg ));

    if ( message_status( msg ) != 0 && nav != NULL)
      {
	// send a bad message to stp
	message reply;
	reply.type = "StP";
	reply.class = nav.editor_name;
	reply.handle = nav.stp_handle;
	reply.arglist = string_to_list(ERROR_STRING, " ");
	message_send(reply);
      }

    // currently we will not do anything if the navigation succeeded
}

void handle_stp_reply(message msg)
{
    int id = to_int( list_get( msg.arglist, 1 ));
    int status = to_int( list_get( msg.arglist, 2 ));
    nav_stack nav = get_stack_message2( id );

    if (status != 0 && nav != NULL)
      {
	// send a bad message back to ObjectAda
	message_fail( nav.tt_msg );
      }
    else if ( nav != NULL )
      message_reply( nav.tt_msg );
    else
      log_print( "Failed to find the nav message with id " + id + "." );
}

////////////////////// nav stack routines /////////////////////////
///////////////////////////////////////////////////////////////////

struct nav_stack
{
    int stp_handle;
    int id;
    string editor_name;
    message tt_msg;
};

list nstack = list_create( "nav_stack", 0 );

void add_stack_message( int stp_handle, int id, string name, message tt_msg )
{
    nav_stack ns;
    ns.stp_handle = stp_handle;
    ns.id = id;
    ns.editor_name = name;
    ns.tt_msg = tt_msg;

    list_append( nstack, ns );

    log_print( "Added pending reply to stack - stack contains " +
		 list_count( nstack ) + " items." );

    return;
}

nav_stack get_stack_message1( message msg )
{
    int l;
    nav_stack e;
    for( l = 0; l < list_count( nstack ); l++ )
      {
	e = list_get( nstack, l );
	if ( e.tt_msg == msg )
	  {
	    list_delete( nstack, l );
	    log_print( "Removed item from reply stack - size = " +
			 list_count( nstack ) + " items." );
	    return e;
	  }
      }
    return NULL;
}

nav_stack get_stack_message2( int id )
{
    int l;
    nav_stack e;
    for( l = 0; l < list_count( nstack ); l++ )
      {
	e = list_get( nstack, l );
	if ( e.id == id )
	  {
	    list_delete( nstack, l );
	    log_print( "Removed item from reply stack - size = " +
			 list_count( nstack ) + " items." );
	    return e;
	  }
      }
    return NULL;
}


/////////////////// support routines //////////////////////////////
///////////////////////////////////////////////////////////////////


string
extract_stp_project( string s )
{
    string project;

    if ( s == NULL || s == "" )
      {
	print_error( "stpcid: Empty StP project in message." );
	return "";
      }
    project = path_part(s);
    if(project == NULL)
	return "";

    return project;
}

string
extract_stp_system( string s )
{
    string system;
    if ( s == NULL || s == "" )
      {
	print_error( "stpcid: Empty StP system in message." );
	return "";
      }
 
    system = file_part(s);
    if(system == NULL)
	return "";

    return system;
}


const string sep_token = "!";

nav_object
extract_nav_object( string s )
{
    nav_object no;
    no.name = "";
    no.type = "";
    no.scope = "";
    no.signature = "";
    string rest;

    if ( s == NULL || s == "" )
      {
	print_error( "stpcid: Empty StP object in message." );
	return no;
      }

    int p = strrchr( s, sep_token );
    if ( p )
      {
	rest = string_extract( s, 0, p - 1 );
	if ( p < string_length( s ))
	  no.sig = string_extract( s, p, string_length( s ) - p );

	p = strrchr( rest, sep_token );
	if ( p )
	  {
	    rest = string_extract( rest, 0, p - 1 );
	    if ( p < string_length( rest ))
	      no.scope = string_extract( rest, p, string_length( rest ) - p );

	    p = strrchr( rest, sep_token );
	    if ( p )
	      {
		no.name = string_extract( rest, 0, p - 1 );
		if ( p < string_length( rest ))
		  no.type = string_extract( rest, p,
					    string_length( rest ) - p );
	      }
	  }
      }
    else
      no.name = s;

    return no;
}


void log_print( string s )
{
    if ( logging == -1 )
      if ( toolinfo_variable( "stpoad_logging" ) == "1" )
	{
	  logging = 1;
	  // clear out the logfile
	  write_file( logfile, "stpoad starting for project/system = " +
		      current_projdir() + current_system() + ".\n\n" );
	}
      else
	logging = 0;
    if ( logging )
      {
	append_file( logfile, "stpoad <" + current_system() + "> :" );
	append_file( logfile, s + "\n" );
      }
}
