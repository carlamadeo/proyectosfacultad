// New file for ECR 3789

string od_calling_ps ;
_ps_field_tp od_calling_field;
int od_calling_idx;
int od_objid;
string od_notetype;

int
ps_ObjectDescription_OK_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	
    string newtext = ui_text_value( to_ui_prop( "UmlObjectDescriptionSheet", 
						"ObjectDescription" ) );
	
	    
    // If we are called from a Property Sheet, we store the object description
    // in the sheet. Otherwise, we set the note description directly (this is
    // the case when we are called via the accelerator
    //
    // 000508-01 AG: The switch for changing the OK-Policy was missing. 
    //               Introduced it here. If ToolInfo NoteDescWaitForOK is
    //               not set, we set the notedescription immediately.
    //               see ps_NoteDescription_cb() for more info on this
    //               variable
    //
    if( od_calling_ps != "" && NULL != toolinfo_variable("NoteDescWaitForOK") )
    {
	_ps_propsheet_tp ps = _ps_find(od_calling_ps);
	_ps_field_tp field = od_calling_field;
	
	if( newtext != field.generic_string_value )
	{
	    field.modified = True;
	    field.generic_string_value = newtext;
	    list_set( ps.propsheet, od_calling_idx , field );
	    _ps_update( ps );
	}
    }
    else
    {
	// Set only if there is a change
	//
	note not = find_by_query( "note[${od_notetype} && obj_id = ${od_objid}]" );
	if( not == NULL || 
	    not.desc == NULL || 
	    not.desc != newtext 
	    )
	{
	    // Changed ps_err to message, because we want to use this from
	    // gde and gte
	    //
	    string tmp_file = temp_file("not","" );
	    string tf = temp_file( to_string(od_objid), 
				   to_string( ps_NoteDescriptionExternal ) );
			
	    // 991208 AG: Was write_file, changed to be append_file, otherwise all other
	    //			  entries in the file are removed
	    append_file( tmp_file,
			 to_string(od_objid) +":"+od_notetype+":NULL:NULL:"+tf+"\n" );

	    write_file( tf, newtext );
			
	    int handle	= editor_send_msg( NGOAE_CLASS,
					   "EditorQrlEval SetAnnotValuesFromFiles(\""+
					   string_escape(tmp_file,"\\")+"\");", 
					   -1 );
			
	    editor_send_msg( NGOAE_CLASS,
			     "EditorQrlEval 	CleanAnnotTmpFiles(\""+
			     string_escape(tmp_file,"\\")+"\");", 
			     handle );

// ECR 7140 begin
        if (od_calling_ps != "")
        {
	        _ps_propsheet_tp ps = _ps_find(od_calling_ps);
	        _ps_field_tp field = od_calling_field;
	    
	        if (newtext != field.generic_string_value)
	        {
		    // We still want this for later comparisons, if the text changed (i.e.,
		    // if the button is clicked again. Note that the modified flag is _not_
		    // set
		    //
	            field.generic_string_value = newtext;
	            list_set(ps.propsheet, od_calling_idx, field);
	            _ps_update(ps);
	        }
        }
// ECR 7140 end
	}
    }
    return 1;
}

void
fill_objectdescription_ps( string calling_ps, _ps_field_tp field, int idx, string filen,
	int objid, string notetype )
{
  od_calling_ps = calling_ps;
  od_calling_field = field;
  od_calling_idx = idx;
  od_objid = objid;
  od_notetype = notetype;
  string content = read_file( filen );
	
  ui_text_set_value( to_ui_prop( "UmlObjectDescriptionSheet", "ObjectDescription" ), 
		     content );
						

}

void
ObjectDescriptionPS_activate( boolean t_or_f )
{
	// Modify this string if fields are modified
	//
	list elements = string_to_list("ObjectDescription,OK",
									"," );
	int i;
	
	for( i = list_count( elements )-1; i>=0;i-- )
	ui_activate( to_ui_prop( "UmlObjectDescriptionSheet", 
				list_get(elements,i)
	 			), t_or_f );
	
	// ECR 6702 begin
	ui_textfocus(to_ui_prop("UmlObjectDescriptionSheet", "ObjectDescription"));
	// ECR 6702 end
}

// This is called from the gde engine when an object is selected. Note
// that we check if the selected symbol is different from the symbol
// for which the property sheet has been opened. This is because of
// a "feature" in the engine, which sends multiple events for one
// object at strange times, so we cannot rely on a new symbol being
// selected just on the fact that the routine is invoked
//
void
ObjectDescriptionPS_deactivate()
{
   	
   	int objid;
	int i;
    if (PropSheet__editor_type() != "gde")  // ECR 8008
        return;
	if( NULL == gde_selected_symbols() || 0 == list_count( gde_selected_symbols() ) )
	{
		objid = NULL;
	}
	else
	{
    	gde_symbol sym = list_get(gde_selected_symbols(), 0);
    		
    	list hl =   	gde_symbol_to_oms (sym );
    	if( NULL == hl || 0== list_count( hl ))
    	{
    		objid = NULL;
    	}
    	else
    	{
    		if( list_get_type( hl,0) == "node" )
    		{
    			node nod;
    			nod = list_get( hl, 0 );
    			objid = nod.id;
    		}    
      		else if ( list_get_type( hl,0) == "link" )
      		{
      			link l = list_get( hl, 0 );
      			objid = l.id;
      		}
		else
		{
			objid = NULL;
		}
      	}
  	}	
  	if( objid == NULL || objid != od_objid )
		ObjectDescriptionPS_activate( False );
}
// ECR 3789 end
