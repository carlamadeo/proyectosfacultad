// ECR 3484, new file

////////////////////////////////////////////////////////////////////////////////////////////
// fill types
////////////////////////////////////////////////////////////////////////////////////////////

// Check if the menu-item should be active
int
gte_fill_type_search_active_func()
{
    if (gte_get_current_cell_is_readonly())
	return(ACTIVE_FUNC_IS_INACTIVE);

    if (gte_get_current_cell_has_semantics() == False)
	return(ACTIVE_FUNC_IS_INACTIVE);
 
    if (gte_get_vsect(gte_get_current_cell_col()) != 1)
	return(ACTIVE_FUNC_IS_INACTIVE);
	
    if (gte_get_hsect(gte_get_current_cell_row()) == 5) {
	if (gte_get_current_cell_col() == 3)
	    return(ACTIVE_FUNC_IS_ACTIVE);
    }
    else if (gte_get_hsect(gte_get_current_cell_row()) == 3) {
	if (gte_get_current_cell_col() == 2)
	    return(ACTIVE_FUNC_IS_ACTIVE);
    }
	
    return(ACTIVE_FUNC_IS_INACTIVE);
}

void
gte_fill_type()
{
    gte_stpem("PropertySheetShow GteFillType");
}

// some locals to avoid a lot of actions twice and triple, saves time and funny blinking

int last_current_cell_row = -1;
int last_current_cell_col = -1;
boolean FT_last_active = False;
string FT_last_filter = "";
string FT_last_current_cell_label;

// called when popped up, when the active column in gte changes and from apply/ok
// fill all the property fields, make them active, fill the list .. with two words: prepare everything
void gte_fill_type_owneraction_cb()
{
    list l;			// List of types
    ui_prop p;			// temporary property handle
    string filter;		// used to check if something has changed
    int current_cell_row;
    int current_cell_col;
    string type;
    int selected;

    // am I active ?
    boolean active = (gte_fill_type_search_active_func() == ACTIVE_FUNC_IS_ACTIVE);

    // If I am active, check if something has changed. Only do the parsing if there was a change!
    if(active == True) {
	current_cell_row = gte_get_current_cell_row();
	current_cell_col = gte_get_current_cell_col();
	type = gte_get_current_cell_label();
	if(last_current_cell_row != current_cell_row ||
	    last_current_cell_col != current_cell_col ||
	    FT_last_current_cell_label != type)
	{
	    FT_last_current_cell_label = type;
	    if(type == NULL || type == "")
		type = "void";

	    // remember what I did parse, to avoid doing it muliple times
	    last_current_cell_row = current_cell_row;
	    last_current_cell_col = current_cell_col;

	    p = to_ui_prop("GteFillType", "SelectionText");
	    ui_set_value(p, type);
	}
    }

    // Is there a switch between active and inactive?
    // switch all the fields on and/or off
    // also fill the list only when switching to active
    if(FT_last_active != active) {
	p = to_ui_prop("GteFillType", "OK");
	ui_activate(p, active);
	p = to_ui_prop("GteFillType", "Reset");
	ui_activate(p, active);
	p = to_ui_prop("GteFillType", "Apply");
	ui_activate(p, active);
	p = to_ui_prop("GteFillType", "SelectionText");
	ui_activate(p, active);

	p = to_ui_prop("GteFillType", "TypeLangFilter");
	ui_activate(p, active);
	selected = ui_get_value(p);

	p = to_ui_prop("GteFillType", "FilterText");
	// ui_activate(p, selected == 0 && active == True);
	ui_activate(p, active == True);
	if(active == True) {
	    filter = ui_get_value(p);
	    if(filter == NULL || filter == "") {
		filter = "*";
		ui_set_value(p, filter);
	    }
	}

	p = to_ui_prop("GteFillType", "TypeTypeList");
	ui_activate(p, active);

	// now fill the list with the known types
	if(active == True && FT_last_filter != filter) {
	    ui_list_clear(p);

	    FT_last_filter = filter;
	    if(selected != 0)
		filter = "*";
	    l = common_uclasst_type_name_completion_func("GteFillType", filter, "", "item",
							 "UmlOperationReturnType", 0);
	    ui_list_append(p, l);
	}

	FT_last_active = active;
    }
}

int gte_fill_type_langfilter_select_cb(ui_event_tp event, 
				       ui_prop theprop, 
				       int id,
				       string value)
{
    ui_prop p;
    list l;
    string filter;

    p = to_ui_prop("GteFillType", "FilterText");
    if(ui_get_value(theprop) == 0) {
	filter = ui_get_value(p);
	if(filter == NULL || filter == "") {
	    filter = "*";
	}
	else if(filter != "*" &&
		(string_length(filter) == 1 || string_find(filter, 1, "*") == string_length(filter)))
	    filter += "*";
    }
    else
	filter = "*";

    // ui_activate(p, ui_get_value(theprop) == 0);
    ui_activate(p, True);

    p = to_ui_prop("GteFillType", "TypeTypeList");
    ui_list_clear(p);
    l = common_uclasst_type_name_completion_func("GteFillType", filter, "",
						 "item", "UmlOperationReturnType", 0);
    if(l != NULL)
	ui_list_append(p, l);
    return 0;
}

int gte_fill_type_type_filter_cb(ui_event_tp event, 
				 ui_prop theprop, 
				 int id,
				 string value)
{
    ui_prop p;
    list l;
    string filter;

    filter = ui_get_value(theprop);
    if(filter == NULL || filter == "") {
	filter = "*";
    }
    else if(filter != "*" &&
	    (string_length(filter) == 1 || string_find(filter, 1, "*") == string_length(filter)))
	filter += "*";

    p = to_ui_prop("GteFillType", "TypeTypeList");
    ui_list_clear(p);
    l = common_uclasst_type_name_completion_func("GteFillType", filter, "", "item",
						 "UmlOperationReturnType", 0);
    ui_list_append(p, l);
    FT_last_filter = filter;

    return 0;
}

// select an item in the list
int gte_fill_type_list_select_cb(ui_event_tp event, 
				 ui_prop theprop, 
			         int id,
			         string value)
{
    ui_prop p;
    string type;
    string selected_type;
    string the_char;
    int fidx;
    int cidx;
    int tidx;

    if(ui_list_selected_row(theprop) == -1) {
	// print_message("Button should be inactive ?, call AONIX"); // seems to happen in 7.2?
	return 0;
    }
    selected_type = list_get(ui_list_selected_items(theprop), 0);

    p = to_ui_prop("GteFillType", "SelectionText");
    type = ui_get_value(p);
    if(type == "")
	type = selected_type;
    else {
	fidx = -1;
	cidx = -1;
	for(tidx = 0; tidx < string_length(type); ++ tidx) {
	    the_char = string_extract(type, tidx, 1);

	    if(("A" <= the_char && "Z" >= the_char) || ("a" <= the_char && "z" >= the_char) ||
	       ("0" <= the_char && "9" >= the_char) || "_" == the_char) {
		if(fidx == -1) // found start of some word
		   fidx = tidx;
	    }
	    else {
		if(fidx != -1) { // found end of some word
		    if(string_extract(type, fidx, tidx - fidx) == "template") // some words to ignore
			fidx = -1; // template is special because of the following '<'
		    else if(string_extract(type, fidx, tidx - fidx) == "class" || // some more words
		       string_extract(type, fidx, tidx - fidx) == "typename" ||
		       string_extract(type, fidx, tidx - fidx) == "struct" ||
		       string_extract(type, fidx, tidx - fidx) == "explicit" ||
		       string_extract(type, fidx, tidx - fidx) == "mutable" ||
		       string_extract(type, fidx, tidx - fidx) == "enum" ||
		       string_extract(type, fidx, tidx - fidx) == "union" ||
		       string_extract(type, fidx, tidx - fidx) == "const") {
			cidx = tidx;
			fidx = -1;
		    }
		    else
			break; // found a type
		}
	    }
	}

	// special case, reached end of string
	if(fidx != -1 && tidx == string_length(type)) {
	    if(string_extract(type, fidx, tidx - fidx) == "template") {
		type = type + "<";
		++ tidx;
		cidx = tidx;
		fidx = -1;
	    }
	    else if(string_extract(type, fidx, tidx - fidx) == "class" || // some more words
	       string_extract(type, fidx, tidx - fidx) == "typename" ||
	       string_extract(type, fidx, tidx - fidx) == "struct" ||
	       string_extract(type, fidx, tidx - fidx) == "explicit" ||
	       string_extract(type, fidx, tidx - fidx) == "mutable" ||
	       string_extract(type, fidx, tidx - fidx) == "enum" ||
	       string_extract(type, fidx, tidx - fidx) == "union" ||
	       string_extract(type, fidx, tidx - fidx) == "const") {
		cidx = tidx;
		fidx = -1;
	    }
	}

	if(fidx == -1) { // no type found
	    if(cidx != -1) {
		if(cidx == tidx) // tidx is equivalent to string_length()
		    type += " " + selected_type;
		else
		    type = string_extract(type, 0, cidx) + " " + selected_type + string_extract(type, cidx, string_length(type) - cidx);
	    }
	    else {
		if(string_extract(type, 0, 1) != " ")
		    type = " " + type;
		type = selected_type + type; 
	    }
	}
	else {
	    if(fidx == 0)
		if(tidx == string_length(type))
		    type = selected_type;
		else
		    type = selected_type + string_extract(type, tidx, string_length(type) - tidx);
	    else
		if(tidx == string_length(type))
		    type = string_extract(type, 0, fidx) + selected_type;
		else
		    type = string_extract(type, 0, fidx) + selected_type + string_extract(type, tidx, string_length(type) - tidx);
	}
    }
    ui_set_value(p, type);
    return 0;
}

// OK - pressed
int gte_fill_type_ok_select_cb(ui_event_tp event, 
			       ui_prop theprop, 
			       int id,
			       string value)
{
    set_new_type();
    return 1;
}

// Apply - pressed
int gte_fill_type_apply_select_cb(ui_event_tp event, 
				  ui_prop theprop, 
				  int id,
			          string value)
{
    set_new_type();
    return 0;
}

// Called by Apply and OK
void set_new_type()
{
    ui_prop p;
    string type;

    p = to_ui_prop("GteFillType", "SelectionText");
    type = string_strip(ui_get_value(p), "B", " ");

    // remove all if no arguments
    if(type == "void")
    	type = "";

    if(gte_get_cell_label(gte_get_current_cell_row(), gte_get_current_cell_col()) != type) {
	gte_filltable_string("FillTable { { Hsect { Index Current}" +
			     "{ Vsect { Index Current } { Row { Index Current }" +
			     "{ Cell { Index Current } { Label \"" + 
			     type + "\"}}}}}}");
	gte_refresh_table();

	// reparse the possible modified
	gte_fill_type_owneraction_cb();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
// edit signature
////////////////////////////////////////////////////////////////////////////////////////////

// Check if the menu-item should be active
int
gte_signature_search_active_func()
{
    if (gte_get_current_cell_is_readonly())
	return(ACTIVE_FUNC_IS_INACTIVE);

    if (gte_get_current_cell_has_semantics())
	return(ACTIVE_FUNC_IS_INACTIVE);
	
    if (gte_get_current_cell_col() != 2)
	return(ACTIVE_FUNC_IS_INACTIVE);

    if (gte_get_hsect(gte_get_current_cell_row()) != 5)
	return(ACTIVE_FUNC_IS_INACTIVE);

    if (gte_get_vsect(gte_get_current_cell_col()) != 1)
	return(ACTIVE_FUNC_IS_INACTIVE);
	
    return(ACTIVE_FUNC_IS_ACTIVE);
}

// same as the function without the my_, but without the buffered stuff
list
my_gte_default_name_completion_func(string pattern, string label, string extent,
				 string apptype, int scopeid)
{
    list names;

    names = list_create("string", 0);

    if (NULL == extent || "" == extent || NULL == apptype || "" == apptype)
	return (names);

    nc_get_names_from_repository(names, pattern, extent, apptype, scopeid, False);
//    nc_get_names_from_buffer(names, pattern, extent, apptype, scopeid, False);

    return (names);
}

// list all the types known to the system
// BUGS: Filter sometimes lists funny results, due to filtering before the removing of garbadge
list
uclasst_type_name_completion_func(string pattern,
				  string label,
				  string extent,
				  string apptype,
				  int scopeid)
{
    return unsorted_uclasst_type_name_completion_func(NULL, pattern, label, extent, apptype, scopeid);
}

list
common_uclasst_type_name_completion_func(string property,
					 string pattern,
					 string label,
					 string extent,
					 string apptype,
					 int scopeid)
{
    list l;
    int cnt;
    int idx;
    string prev_elem;
    string this_elem;

    l = list_sort(unsorted_uclasst_type_name_completion_func(property, pattern, label, extent, apptype, scopeid));

	if( l != NULL ) {
	    cnt = list_count(l);
	
	    // remove duplicate items in the list
	    for(idx = 0; idx < cnt; ++ idx) {
			this_elem = list_get(l, idx);
			if(idx > 0 && this_elem == prev_elem) {
			    list_delete(l, idx);
			    -- idx;
			    -- cnt;
			    continue;
			}
			prev_elem = this_elem;
	    }
	
	    return l;
	} else {
		return NULL;
	}
}

list
unsorted_uclasst_type_name_completion_func(string property,
					   string pattern,
					   string label,
					   string extent,
					   string apptype,
					   int scopeid)
{
    int idx;
    int pos;
    int count;
    int ok;
    string str;
    string the_char;
    string lang_file = "";
    ui_prop p;			// temporary property handle
    int selected;
    string file = NULL;

    list l = list_create("string", 0);

    // only use the language filter when *not* in list labels
    if(property != NULL) {
	p = to_ui_prop(property, "TypeLangFilter");
	selected = ui_get_value(p);

	if(selected != 0) {
	    // selected needs to match the order of ChoiceItems in
	    // uclasst_pick.rules
	    if(selected == 1) file = "cxx";
	    else if(selected == 2) file = "java";
	    else if(selected == 3) file = "idl";
	    else if(selected == 4) file = "ada95";
	    else if(selected == 5) file = "ada95-ada";
	    else if(selected == 6) file = "ada95-if";
	    else if(selected == 7) file = "ada95-sys";
//	    else if(selected == 8) file = "stl";
//	    else if(selected == 9) file = "rw";
//	    else if(selected == 10) file = "tool";

        if( file != NULL ) {
            if( toolinfo_variable(file + "_std_types") == NULL ) {
                // default
                lang_file = path_compose( stp_get_product_path(), 
                    "templates/uml/qrl/code_gen", file + "_std_types" );
            } else
                lang_file = toolinfo_variable(file + "_std_types");
            }
            if( True == read_file_access(lang_file) ) {
        		if(buttons_active == True) {
		            for(idx = 1; idx <= 8; ++ idx) {
			            p = to_ui_prop("GteEditSignature", "Sig" + to_string(idx));
			            ui_activate(p, False);
		            }
		            buttons_active = False;
		        }
		        return filter_list_sh( string_to_list(read_file(lang_file), "\n"), pattern );
    	    }
	        if(NULL == file)
		        print_error("Unsupported type " + selected + " in Menu?");
	        else if(False == read_file_access(lang_file))
		        print_message("Language types file \"" + lang_file + "\" not found!");
	        ui_set_value(p, 0);
	        return NULL;
	    }
    }

    // with buffered stuff (new types and typos get visible without save)
//    list_concatenate(l, gte_default_name_completion_func(pattern,label,extent,"UmlOperationReturnType",scopeid));
//    list_concatenate(l, gte_default_name_completion_func(pattern,label,extent,"UmlAttributeType",scopeid));
//    list_concatenate(l, gte_default_name_completion_func(pattern,label,"node","UmlClass",scopeid));

    // without buffer
    list_concatenate(l, my_gte_default_name_completion_func(pattern,label,extent,"UmlOperationReturnType",scopeid));
    list_concatenate(l, my_gte_default_name_completion_func(pattern,label,extent,"UmlAttributeType",scopeid));
    list_concatenate(l, my_gte_default_name_completion_func(pattern,label,"node","UmlClass",scopeid));

    // show only the base types, remove all the pointer and reference stuff
    // this C++-specific, but trigraphs are not supportet, if you need them, buy another keyboard ;-)

    count = list_count(l);
    for(idx = 0; idx < count; ++ idx)
    {
	str = list_get(l, idx);
	ok = 0;
	for(pos = string_length(str); pos > 0; -- pos)
	{
	    the_char = string_extract(str, pos - 1 , 1);

	    // stop when reaching templates or pointer to functions.
	    if(">" == the_char || ")" == the_char)
		break;

	    // remember the occourance of a legal character
	    if(("A" <= the_char && "Z" >= the_char) || ("a" <= the_char && "z" >= the_char) ||
	       ("0" <= the_char && "9" >= the_char) || "_" == the_char)
		ok = 1;

	    // when there is a '*', '&' or '[', then throw away everything after it
	    // so, there disappears something like '[] const *'
	    if(0 == ok || "*" == the_char || "&" == the_char || "[" == the_char)
	    {
		str = string_extract(str, 0, pos - 1);
		ok = 0;
	    }
	}
	if("" == str)
	{
	    list_delete(l, idx);
	    -- idx;
	    -- count;
	}
	else
	    list_set(l, idx, str);
    }

    return l;
}

list
filter_list_sh( list l, string p )
{
    int i;
    string e;
    list r = list_create( "string", 0 );
    
    for( i=0; i<list_count(l); i++ )
    {
        e = list_get( l, i );
        if( string_match_sh( e, p ) )
            list_append( r, e );
    }
    
    return r;
}

// pop the property up
void
gte_edit_signature()
{
    gte_stpem("PropertySheetShow GteEditSignature");
// ECR 7442
    gte_edit_signature_owneraction_cb();
}

// some locals to avoid a lot of actions twice and triple, saves time and funny blinking

boolean ES_last_active = False;
string ES_last_filter = "";
string ES_last_current_cell_label;
string ES_current_signature;
boolean buttons_active = False;
boolean text_sensitive = True;
struct sig_args {
    string arg;
    int ioidx;
    int fidx;
    int tidx;
    boolean has_colon;
    int inOut;
};
list arguments;

// called when popped up, when the active column in gte changes and from apply/ok
// fill all the property fields, make them active, fill the list .. with two words: prepare everything
void gte_edit_signature_owneraction_cb()
{
    list l;			// List of types
    int cnt;			// # elements in lists
    int idx;
    string prev_elem;		// to avoid duplicates
    string this_elem;
    ui_prop p;			// temporary property handle
    string filter;		// used to check if something has changed
    int current_cell_row;
    int current_cell_col;
    string sig;
    string the_char;		// the character actually parsed
    int sidx;			// the position of the_char in the signature
    int lsidx;			// the start position of the argument
    int slen;
    int aidx;			// index of the attribute (1st, 2nd, ... attribute)
    int in_fcn;			// indicators to find corresponding '(', '<', '['
    int in_tmpl;
    int in_array;
    boolean in_comment;		// indicator for comments, string and characters (default-arguments)
    boolean in_str;
    boolean in_char;
    sig_args one_argument;	// the actual argument
    int selected;

    // am I active ?
    boolean active = (gte_signature_search_active_func() == ACTIVE_FUNC_IS_ACTIVE);

    // If I am active, check if something has changed. Only do the parsing if there was a change!
    if(active == True) {
	current_cell_row = gte_get_current_cell_row();
	current_cell_col = gte_get_current_cell_col();
	sig = gte_get_current_cell_label();
	if(last_current_cell_row != current_cell_row ||
	    last_current_cell_col != current_cell_col ||
	    ES_last_current_cell_label != sig)
	{
	    text_sensitive = False;
	    if(sig == NULL || sig == "")
		sig = "void";

	    ES_current_signature = sig;

	    // parse the signature and disassemble it into a list of arguments. Fill the property with these values
	    // BUGS: Backslash is treated like an ordinary character
	    //       A string is NOT terminated by newline
	    //       C++-Comments are NOT detected/parsed
	    slen = string_length(sig);
	    arguments = list_create("sig_args", 0);
	    aidx = 1;
	    lsidx = 0;
	    in_fcn = 0;
	    in_tmpl = 0;
	    in_array = 0;
	    in_str = False;
	    in_char = False;
	    in_comment = False;
	    one_argument.has_colon = False;

	    // for each character ...
	    for(sidx = 0; sidx < slen; ++ sidx) {
		the_char = string_extract(sig, sidx, 1);

		// the button '->' is only active when I found a colon, this avoids getting confused by function pointers
		if(in_fcn == 0 && in_tmpl == 0 && in_str == False && in_array == 0 &&
		    in_char == False && in_comment == False && the_char == ":") {
		    one_argument.has_colon = True;
		}
		// I found a comma, which is *NOT* in a comment, string, function-pointer etc.
		else if(in_fcn == 0 && in_tmpl == 0 && in_str == False && in_array == 0 &&
		    in_char == False && in_comment == False && the_char == ",") {

		    // fill the structure and property, (dis)activate the button, make the property editable
		    one_argument.arg = 
			string_strip(string_extract(sig, lsidx, sidx - lsidx),
			    "B", "\n\t ");
		    one_argument.ioidx = string_find(sig, lsidx, one_argument.arg);
		    one_argument.inOut = 0;
		    p = to_ui_prop("GteEditSignature", "InOut" + to_string(aidx));
		    ui_activate(p, True);
		    if(string_length(one_argument.arg) > 3 &&
		       to_upper(string_extract(one_argument.arg, 0, 3)) == "IN ") {
			one_argument.inOut += 1;
			one_argument.arg = 
			    string_strip(string_extract(one_argument.arg, 2, string_length(one_argument.arg) - 2),
				"L", "\n\t ");
		    }
		    if(string_length(one_argument.arg) > 4 &&
		       to_upper(string_extract(one_argument.arg, 0, 4)) == "OUT ") {
			one_argument.inOut += 2;
			one_argument.arg = 
			    string_strip(string_extract(one_argument.arg, 3, string_length(one_argument.arg) - 3),
				"L", "\n\t ");
		    }
		    if(string_length(one_argument.arg) > 6 &&
		       to_upper(string_extract(one_argument.arg, 0, 6)) == "INOUT ") {
			one_argument.inOut = 3;
			one_argument.arg = 
			    string_strip(string_extract(one_argument.arg, 5, string_length(one_argument.arg) - 5),
				"L", "\n\t ");
		    }
		    ui_choice_set_value(p, one_argument.inOut);
		    one_argument.fidx = string_find(sig, lsidx, one_argument.arg);
		    one_argument.tidx = one_argument.fidx + string_length(one_argument.arg);
		    list_append(arguments, one_argument);
		    p = to_ui_prop("GteEditSignature", "Sig" + to_string(aidx));
		    if(one_argument.has_colon == False)
			ui_activate(p, False);
		    else if(buttons_active == True)
			ui_activate(p, True);

		    p = to_ui_prop("GteEditSignature", "Type" + to_string(aidx));
		    ui_set_value(p, one_argument.arg);
		    ui_text_set_readonly(p, False);
		    lsidx = sidx + 1;
		    ++ aidx;

		    one_argument.has_colon = False; // for next argument !
		}
		// start of a character-default argument
		else if(in_str == False && in_comment == False && the_char == "'") {
		    if(in_char == True)
			in_char = False;
		    else
			in_char = True;
		}
		// start of a string-default argument
		else if(in_char == False && in_comment == False && the_char == "\"") {
		    if(in_str == True)
			in_str = False;
		    else
			in_str = True;
		}
		// start of a C-Style comment
		else if(in_comment == False && in_char == False && in_str == False &&
			the_char == "/" && slen > sidx + 1 &&
			string_extract(sig, sidx + 1, 1) == "*") {
		    in_comment = True;
		}
		// end of a C-Style comment
		else if(in_comment == True && the_char == "*" && slen > sidx + 1 &&
			string_extract(sig, sidx + 1, 1) == "/") {
		    in_comment = False;
		}
		// keep track of the nesting of arrays, templates and functions
		else if(in_char == False && in_comment == False && in_str == False) {
		    if(the_char == "<") {
			++ in_tmpl;
		    }
		    else if(the_char == "(") {
			++ in_fcn;
		    }
		    else if(the_char == "[") {
			++ in_array;
		    }
		    else if(the_char == "]") {
			-- in_array;
		    }
		    else if(the_char == ")") {
			-- in_fcn;
		    }
		    else if(the_char == ">") {
			-- in_tmpl;
		    }
		}
		// stop when all properties are filled
		if(aidx > 8) {
		    sidx = slen;
		    break;
		}
	    }

	    // I reached the last argument, similar to above when I found the end of one
	    if(lsidx != sidx) {
		one_argument.arg = 
		    string_strip(string_extract(sig, lsidx, sidx - lsidx),
			"B", "\n\t ");
		one_argument.ioidx = string_find(sig, lsidx, one_argument.arg);
		one_argument.inOut = 0;
		p = to_ui_prop("GteEditSignature", "InOut" + to_string(aidx));
		ui_activate(p, True);
		if(string_length(one_argument.arg) > 3 &&
		   to_upper(string_extract(one_argument.arg, 0, 3)) == "IN ") {
		    one_argument.inOut += 1;
		    one_argument.arg = 
			string_strip(string_extract(one_argument.arg, 2, string_length(one_argument.arg) - 2),
			    "L", "\n\t ");
		}
		if(string_length(one_argument.arg) > 4 &&
		   to_upper(string_extract(one_argument.arg, 0, 4)) == "OUT ") {
		    one_argument.inOut += 2;
		    one_argument.arg = 
			string_strip(string_extract(one_argument.arg, 3, string_length(one_argument.arg) - 3),
			    "L", "\n\t ");
		}
		if(string_length(one_argument.arg) > 6 &&
		   to_upper(string_extract(one_argument.arg, 0, 6)) == "INOUT ") {
		    one_argument.inOut = 3;
		    one_argument.arg = 
			string_strip(string_extract(one_argument.arg, 5, string_length(one_argument.arg) - 5),
			    "L", "\n\t ");
		}
		ui_choice_set_value(p, one_argument.inOut);
		one_argument.fidx = string_find(sig, lsidx, one_argument.arg);
		one_argument.tidx = one_argument.fidx +
		    string_length(one_argument.arg);
		if(one_argument.has_colon == False && one_argument.arg == "void")
		    one_argument.has_colon = True;
		list_append(arguments, one_argument);
		if(aidx <= 8) {
		    p = to_ui_prop("GteEditSignature", "Sig" + to_string(aidx));
		    if(one_argument.has_colon == False)
			ui_activate(p, False);
		    else if(buttons_active == True)
			ui_activate(p, True);
		}

		p = to_ui_prop("GteEditSignature", "Type" + to_string(aidx));
		ui_set_value(p, one_argument.arg);
		ui_text_set_readonly(p, False);
		++ aidx;
	    }

	    // enable only the next button and text-property, to avoid getting confused with the internal list
	    if(aidx <= 9) {
		p = to_ui_prop("GteEditSignature", "Type" + to_string(aidx));
		ui_set_value(p, "");
		ui_text_set_readonly(p, False);
		if(aidx <= 8) {
		    if(buttons_active == True) {
			p = to_ui_prop("GteEditSignature", "Sig" + to_string(aidx));
			ui_activate(p, True);
		    }
		    p = to_ui_prop("GteEditSignature", "InOut" + to_string(aidx));
		    ui_activate(p, True);
		    ui_choice_set_value(p, 0);
		}
	    	++ aidx;
	    }

	    for(; aidx <= 9; ++ aidx) {
		p = to_ui_prop("GteEditSignature", "Type" + to_string(aidx));
		ui_set_value(p, "");
		ui_text_set_readonly(p, True);
		if(aidx <= 8) {
		    p = to_ui_prop("GteEditSignature", "Sig" + to_string(aidx));
		    ui_activate(p, False);
		    p = to_ui_prop("GteEditSignature", "InOut" + to_string(aidx));
		    ui_activate(p, False);
		    ui_choice_set_value(p, 0);
		}
	    }

	    // remember what I did parse, to avoid doing it muliple times
	    last_current_cell_row = current_cell_row;
	    last_current_cell_col = current_cell_col;
	    ES_last_current_cell_label = sig;

	    // set the composed line readonly.
	    p = to_ui_prop("GteEditSignature", "Signature");
	    ui_set_value(p, sig);
	    ui_text_set_readonly(p, True);
	    text_sensitive = True;
	}
    }

    // Is there a switch between active and inactive?
    // switch all the fields on and/or off
    // also fill the list only when switching to active
    if(ES_last_active != active) {
	p = to_ui_prop("GteEditSignature", "OK");
	ui_activate(p, active);
	p = to_ui_prop("GteEditSignature", "Reset");
	ui_activate(p, active);
	p = to_ui_prop("GteEditSignature", "Apply");
	ui_activate(p, active);
	p = to_ui_prop("GteEditSignature", "Signature");
	ui_activate(p, active);
	p = to_ui_prop("GteEditSignature", "Arguments");
	ui_activate(p, active);
	p = to_ui_prop("GteEditSignature", "Type9");
	ui_activate(p, active);

	cnt = list_count(arguments);
	for(idx = 1; idx <= 8; ++ idx) {
	    if(buttons_active == True) {
		p = to_ui_prop("GteEditSignature", "Sig" + to_string(idx));
		if(cnt < idx) {
		    if(cnt + 1 == idx)
			ui_activate(p, active);
		    else
			ui_activate(p, False);
		}
		else {
		    one_argument = list_get(arguments, idx - 1);
		    if(one_argument.has_colon == True)
			ui_activate(p, active);
		    else
			ui_activate(p, False);
		}
	    }
	    p = to_ui_prop("GteEditSignature", "InOut" + to_string(idx));
	    if(cnt < idx) {
		if(cnt + 1 == idx)
		    ui_activate(p, active);
		else
		    ui_activate(p, False);
	    }
	    else
		ui_activate(p, active);
	    p = to_ui_prop("GteEditSignature", "Type" + to_string(idx));
	    ui_activate(p, active);
	}

	p = to_ui_prop("GteEditSignature", "TypeLangFilter");
	ui_activate(p, active);
	selected = ui_get_value(p);

	p = to_ui_prop("GteEditSignature", "FilterText");
	ui_activate(p, selected == 0 && active == True);
	if(active == True) {
	    filter = ui_get_value(p);
	    if(filter == NULL || filter == "") {
		filter = "*";
		ui_set_value(p, filter);
	    }
	}

	p = to_ui_prop("GteEditSignature", "SignatureTypeList");
	ui_activate(p, active);

	// now fill the list with the known types
	if(active == True && ES_last_filter != filter) {
	    ui_list_clear(p);

	    ES_last_filter = filter;
	    if(selected != 0)
		filter = "*";
	    l = common_uclasst_type_name_completion_func("GteEditSignature", filter, "", "item",
							 "UmlOperationReturnType", 0);
	    ui_list_append(p, l);

	    // buttons are only active when there is one item selected.
	    if(buttons_active == True) {
	    	// print_message("Off Buttons");
		for(idx = 1; idx <= 8; ++ idx) {
		    p = to_ui_prop("GteEditSignature", "Sig" + to_string(idx));
		    ui_activate(p, False);
		}
		buttons_active = False;
	    }
	}

	ES_last_active = active;
    }
}

// select an item in the list
int gte_edit_signature_list_select_cb(ui_event_tp event, 
				       ui_prop theprop, 
				       int id,
				       string value)
{
    // only action is to switch on the buttons
    if(buttons_active == False) {
	int idx;
	int cnt;
	sig_args one_argument;
	ui_prop p;

	cnt = list_count(arguments);
	for(idx = 1; idx <= 8; ++ idx) {
	    p = to_ui_prop("GteEditSignature", "Sig" + to_string(idx));
	    if(cnt < idx) {
		if(cnt + 1 == idx)
		    ui_activate(p, True);
		else
		    ui_activate(p, False);
	    }
	    else {
		one_argument = list_get(arguments, idx - 1);
		if(one_argument.has_colon == True)
		    ui_activate(p, True);
		else
		    ui_activate(p, False);
	    }
    	}
	buttons_active = True;
    }
    return 0;
}

// in/out or gets selected
int gte_edit_signature_inout_select_cb(ui_event_tp event, 
				       ui_prop theprop, 
				       int id,
				       string value)
{
    sig_args one_argument;	// the actual argument
    int sigidx;
    ui_prop p;
    string arg;
    int cidx;

    // print_message("gte_edit_signature_inout_select_cb");

    if(text_sensitive == False)
        return 0;

    // which button ?
    for(sigidx = 1; sigidx <= 8; ++ sigidx) {
	p = to_ui_prop("GteEditSignature", "InOut" + to_string(sigidx));
	if(p == theprop) {
	    // print_message("Button InOut" + to_string(sigidx) + " pressed, value = " + ui_get_value(p));
	    break;
	}
    }

    p = to_ui_prop("GteEditSignature", "Type" + to_string(sigidx));
    arg = ui_get_value(p);

    // replace the type
    if(arg == "void" || arg == "") {
    	return 0;
    }
    replace_argument(sigidx, arg, ui_get_value(to_ui_prop("GteEditSignature", "InOut" + to_string(sigidx))));
    return 0;
}

int gte_edit_signature_langfilter_select_cb(ui_event_tp event, 
					    ui_prop theprop, 
					    int id,
					    string value)
{
    ui_prop p;
    list l;
    int idx;
    string filter;

    p = to_ui_prop("GteEditSignature", "FilterText");
    if(ui_get_value(theprop) == 0) {
	filter = ui_get_value(p);
	if(filter == NULL || filter == "") {
	    filter = "*";
	}
	else if(filter != "*" &&
		(string_length(filter) == 1 || string_find(filter, 1, "*") == string_length(filter)))
	    filter += "*";
    }
    else
	filter = "*";

    ui_activate(p, ui_get_value(theprop) == 0);

    p = to_ui_prop("GteEditSignature", "SignatureTypeList");
    ui_list_clear(p);
    l = common_uclasst_type_name_completion_func("GteEditSignature", filter, "",
						 "item", "UmlOperationReturnType", 0);
    if(l != NULL)
	ui_list_append(p, l);
    return 0;
}

// a button is selected, replace/add the type
int gte_edit_signature_sig_select_cb(ui_event_tp event, 
				     ui_prop theprop, 
				     int id,
				     string value)
{
    int sigidx;
    ui_prop p;
    string s;
    string arg;
    string sig;
    string the_char;
    int fidx;
    int cidx;
    int tidx;

    // print_message("gte_edit_signature_sig_select_cb");

    p = to_ui_prop("GteEditSignature", "SignatureTypeList");
    if(ui_list_selected_row(p) == -1) {
	// print_message("Button should be inactive ?, call AONIX"); // seems to happen in 7.2?
	return 0;
    }
    s = list_get(ui_list_selected_items(p), 0);

    // which button ?
    for(sigidx = 1; sigidx <= 8; ++ sigidx) {
	p = to_ui_prop("GteEditSignature", "Sig" + to_string(sigidx));
	if(p == theprop) {
	    // print_message("Button " + to_string(sigidx) + " pressed");
	    break;
	}
    }

    if(sigidx > 8) {
	print_message("Unknown Button pressed, call AONIX");
	return 0;
    }

    p = to_ui_prop("GteEditSignature", "Type" + to_string(sigidx));
    arg = ui_get_value(p);

    // replace the type
    if(arg == "void" || arg == "") {
    	arg = ":" + s;
    }
    else {
	// look for the first letter of the type
        for(fidx = 0; fidx < string_length(arg); ++ fidx) {
	    the_char = string_extract(arg, fidx, 1);
	    if(the_char == ":") {
		++ fidx;
	        break;
	    }
	}

	if(fidx >= string_length(arg)) {
	    arg = arg + ":" + s;
	}
	else {
	    // Now, fidx points to the first character after the colon
	    cidx = -1;

	    // Find the first letter of the identifier
	    while(fidx < string_length(arg)) {
		the_char = string_extract(arg, fidx, 1);
		if((the_char >= "A" && the_char <= "Z") ||
		    (the_char >= "a" && the_char <= "z") ||
		    // (the_char >= "0" && the_char <= "9") ||	// not legal !!
		    the_char == "_") {

		    // const - stuff ?
		    if(the_char == "c" && string_length(arg) - fidx > 5) {
			the_char = string_extract(arg, fidx + 5, 1);
			if(string_extract(arg, fidx, 5) == "const" &&
			    (the_char < "A" || the_char > "Z") &&
				(the_char < "a" || the_char > "z") &&
				(the_char < "0" || the_char > "9") &&
				the_char != "_") {
			    cidx = fidx;
			    fidx += 5;
			}
			else
			    break;
		    }
		    else
			break;
		}
		else
		    ++ fidx;
	    }

	    // Huh ???
	    if(fidx >= string_length(arg)) {
		arg = arg + s;
	    }
	    else {

		for(tidx = fidx; tidx < string_length(arg); ++ tidx) {
		    the_char = string_extract(arg, tidx, 1);
		    if((the_char < "A" || the_char > "Z") &&
			(the_char < "a" || the_char > "z") &&
			(the_char < "0" || the_char > "9") &&
			the_char != "_") {
			// print_message("Break on <" + the_char + ">");
			break;
		    }
		}

		// const in both ??
		if(cidx != -1 && string_length(s) > 5) {
		    the_char = string_extract(s, 5, 1);
		    if(string_extract(s, 0, 5) == "const" && (the_char < "A" || the_char > "Z") &&
		       (the_char < "a" || the_char > "z") && (the_char < "0" || the_char > "9") &&
		       the_char != "_") {
		    	fidx = cidx;
		    }
		}

		sig = string_extract(arg, 0, fidx) + s;
		if(string_length(arg) > tidx)
		    sig = sig + string_extract(arg, tidx, string_length(arg) - tidx);

		arg = sig;
	    }
	}
    }
    arg = ui_set_value(p, arg);

    // replace an argument in the list and in the signature
    replace_argument(sigidx, arg, ui_get_value(to_ui_prop("GteEditSignature", "InOut" + to_string(sigidx))));

    return 0;
}

// replace an argument in the list and in the signature
void replace_argument(int sigidx, string arg, int inOut)
{
    sig_args one_argument;
    string sig;
    ui_prop p;
    int len_diff;

    // last argument removed
    if(list_count(arguments) == sigidx && arg == "") {
    	one_argument = list_get(arguments, sigidx - 1);
	if(sigidx == 1)
	    ES_current_signature = "";
	else {
	    len_diff = 2 + string_length(one_argument.arg);
	    if(inOut == 1)
		len_diff += 3;
	    else if(inOut == 2)
		len_diff += 4;
	    else if(inOut == 3)
		len_diff += 6;
	    ES_current_signature = string_extract(ES_current_signature, 0, string_length(ES_current_signature) - len_diff);
	}
    	list_delete(arguments, sigidx - 1);

	if(sigidx + 1 <= 8) {
	    p = to_ui_prop("GteEditSignature", "Sig" + to_string(sigidx + 1));
	    ui_activate(p, False);
	    p = to_ui_prop("GteEditSignature", "InOut" + to_string(sigidx + 1));
	    ui_activate(p, False);
	    ui_choice_set_value(p, 0);
	}
	if(sigidx + 1 <= 9) {
	    p = to_ui_prop("GteEditSignature", "Type" + to_string(sigidx + 1));
	    ui_text_set_readonly(p, True);
	}
    }
    // some argument changed
    else if(list_count(arguments) >= sigidx) {
    	one_argument = list_get(arguments, sigidx - 1);

	if(one_argument.ioidx > 0)
	    sig = string_extract(ES_current_signature, 0, one_argument.ioidx);
	else
	    sig = "";
	if(arg != "") {
	    if(inOut == 1) {
		sig += "IN ";
		one_argument.fidx = one_argument.ioidx + 3;
	    }
	    else if(inOut == 2) {
		sig +="OUT ";
		one_argument.fidx = one_argument.ioidx + 4;
	    }
	    else if(inOut == 3) {
		sig += "INOUT ";
		one_argument.fidx = one_argument.ioidx + 6;
	    }
	    else
		one_argument.fidx = one_argument.ioidx;
	    sig += arg;
	}
	if(string_length(ES_current_signature) > one_argument.tidx)
	    sig = sig + string_extract(ES_current_signature, one_argument.tidx,
				       string_length(ES_current_signature) - one_argument.tidx);

    	one_argument.tidx = one_argument.fidx + string_length(arg);
    	one_argument.arg = arg;
    	one_argument.inOut = inOut;
    	list_set(arguments, sigidx - 1, one_argument);

	// if the length changes, update the position in the list
	len_diff = string_length(sig) - string_length(ES_current_signature);
	if(len_diff != 0) {
	    for(; sigidx < list_count(arguments); ++ sigidx) {
		one_argument = list_get(arguments, sigidx);
		one_argument.ioidx += len_diff;
		one_argument.tidx += len_diff;
		one_argument.fidx += len_diff;
		list_set(arguments, sigidx, one_argument);
	    }
	}

	ES_current_signature = sig;
    }
    // add a new argument
    else {
        if(list_count(arguments) > 0) {
	    one_argument = list_get(arguments, list_count(arguments) - 1);
	    ES_current_signature += ", ";
	    one_argument.ioidx = one_argument.tidx + 2;
	}
	else {
	    one_argument.tidx = 0;
	    one_argument.ioidx = one_argument.tidx;
	}
	if(inOut == 1) {
	    ES_current_signature += "IN ";
	    one_argument.fidx = one_argument.ioidx + 3;
	}
	else if(inOut == 2) {
	    ES_current_signature += "OUT ";
	    one_argument.fidx = one_argument.ioidx + 4;
	}
	else if(inOut == 3) {
	    ES_current_signature += "INOUT ";
	    one_argument.fidx = one_argument.ioidx + 6;
	}
	else
	    one_argument.fidx = one_argument.ioidx;
	ES_current_signature += arg;
    	one_argument.tidx = one_argument.fidx + string_length(arg);
    	one_argument.inOut = inOut;
    	one_argument.arg = arg;
    	one_argument.has_colon = True;
    	list_append(arguments, one_argument);

	if(sigidx + 1 <= 8) {
	    if(buttons_active == True) {
		p = to_ui_prop("GteEditSignature", "Sig" + to_string(sigidx + 1));
		ui_activate(p, True);
	    }
	    p = to_ui_prop("GteEditSignature", "InOut" + to_string(sigidx + 1));
	    ui_activate(p, True);
	}
	if(sigidx + 1 <= 9) {
	    p = to_ui_prop("GteEditSignature", "Type" + to_string(sigidx + 1));
	    ui_text_set_readonly(p, False);
	}
    }

    p = to_ui_prop("GteEditSignature", "Signature");
    ui_set_value(p, ES_current_signature);
}

int gte_edit_signature_type_filter_cb(ui_event_tp event, 
				      ui_prop theprop, 
				      int id,
				      string value)
{
    ui_prop p;
    list l;
    int idx;
    string filter;

    // print_message("gte_edit_signature_filter_select_cb");

    filter = ui_get_value(theprop);
    if(filter == NULL || filter == "") {
	filter = "*";
    }
    else if(filter != "*" &&
	    (string_length(filter) == 1 || string_find(filter, 1, "*") == string_length(filter)))
	filter += "*";

    p = to_ui_prop("GteEditSignature", "SignatureTypeList");
    ui_list_clear(p);
    l = common_uclasst_type_name_completion_func("GteEditSignature", filter, "", "item",
						 "UmlOperationReturnType", 0);
    ui_list_append(p, l);
    ES_last_filter = filter;

    // buttons are only active when there is one item selected.
    if(buttons_active == True) {
	// print_message("Off Buttons");
	for(idx = 1; idx <= 8; ++ idx) {
	    p = to_ui_prop("GteEditSignature", "Sig" + to_string(idx));
	    ui_activate(p, False);
	}
	buttons_active = False;
    }
    return 0;
}

// characters typed/removed in the text-property
int gte_edit_signature_type_text_cb(ui_event_tp event, 
				    ui_prop theprop, 
				    int id,
				    string value)
{
    if(text_sensitive == False)
        return 0;

    int sigidx;
    ui_prop p;
    string s;

    // print_message("gte_edit_signature_type_text_cb");

    // find the property
    for(sigidx = 1; sigidx <= 9; ++ sigidx) {
	p = to_ui_prop("GteEditSignature", "Type" + to_string(sigidx));
	if(p == theprop) {
	    // print_message("Type " + to_string(sigidx) + " edited");
	    break;
	}
    }

    if(sigidx > 9) {
	print_message("Unknown Text edited, call AONIX");
	return 0;
    }

    // change the argument
    if(sigidx > 8)
	replace_argument(sigidx, ui_get_value(p), 0);
    else
	replace_argument(sigidx, ui_get_value(p), ui_get_value(to_ui_prop("GteEditSignature", "InOut" + to_string(sigidx))));

    return 0;
}

// OK - pressed
int gte_edit_signature_ok_select_cb(ui_event_tp event, 
				    ui_prop theprop, 
				    int id,
				    string value)
{
    // print_message("gte_edit_signature_ok_select_cb");
    set_new_signature();
    return 1;
}

// Apply - pressed
int gte_edit_signature_apply_select_cb(ui_event_tp event, 
				       ui_prop theprop, 
				       int id,
				       string value)
{
    // print_message("gte_edit_signature_apply_select_cb");
    set_new_signature();
    return 0;
}

// Called by Apply and OK
void set_new_signature()
{
    int miss_idx;
    int corr_length;
    string sig = ES_current_signature;

    // some postprocessing to correctly handle the removal of arguments in the middle
    while(True) {
	miss_idx = string_find(sig, 0, ", ,");
	if(miss_idx == string_length(sig)) {
	    miss_idx = string_find(sig, 0, ", IN ,");
	    if(miss_idx == string_length(sig)) {
		miss_idx = string_find(sig, 0, ", OUT ,");
		if(miss_idx == string_length(sig)) {
		    miss_idx = string_find(sig, 0, ", INOUT ,");
		    if(miss_idx == string_length(sig)) {
			break;
		    }
		    else
			corr_length = 8;
		}
		else
		    corr_length = 6;
	    }
	    else
		corr_length = 5;
	}
	else
	    corr_length = 2;
    	sig = string_extract(sig, 0, miss_idx) +
	      string_extract(sig, miss_idx + corr_length, string_length(sig) - miss_idx - corr_length);
    }

    // remove trailing commas and space
    while(string_length(sig) > 1 &&
	  (string_extract(sig, string_length(sig) - 1, 1) == "," ||
	   string_extract(sig, string_length(sig) - 1, 1) == " "))
	sig = string_extract(sig, 0, string_length(sig) - 1);

    // remove all if no arguments
    if(sig == "void")
    	sig = "";

    // fill gte, global rename when the operation name is non-empty, otherwise local rename
    if(gte_get_cell_label(gte_get_current_cell_row(), gte_get_current_cell_col()) != sig) {
	if(gte_get_cell_label(gte_get_current_cell_row(), 1) != "") {
	    editor_set_is_busy(True);
	    gte_global_rename_current_cell(sig, False);
	    editor_set_is_busy (False);
	}
	else {
	    gte_filltable_string("FillTable { { Hsect { Index Current}" +
				 "{ Vsect { Index Current } { Row { Index Current }" +
				 "{ Cell { Index Current } { Label \"" + 
				 sig + "\"}}}}}}");
	    gte_refresh_table();
	}
	// reparse the possible modified
	gte_edit_signature_owneraction_cb();
    }
}
