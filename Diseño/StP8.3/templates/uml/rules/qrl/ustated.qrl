
//      StP/UML
//      Confidential property of Aonix
//      Copyright (c) 1997
//      All rights reserved


#include "rules/qrl/ct.inc"

#include "rules/qrl/uml.inc"
#include "rules/qrl/ustated_mapping.inc"
#include "rules/qrl/ustated_syntax.inc"
#include "rules/qrl/ustated.ps.qrl"

// navigations to requirements table
#include "rules/qrl/requirements_nav.inc"

#include "qrl/include/export_to_doors.inc"

// Begin Add ECR 4179
#include "rules/qrl/navtostp.inc"
#include "rules/qrl/navtosniff.inc"
// End Add ECR 4179

// ECR4052 Model Management
#include "rules/qrl/model_management.inc"

#include "rules/qrl/ustated.impl"
// Begin ECR947, ECR 4494
#include "rules/qrl/note_link.inc"

#include "rules/qrl/default_arc_type.inc" //ECR 6469

const    int    ACTIVE_FUNC_IS_UNDEFINED = -1; // SAME AS OMT

// ECR 7215 - Added Junction Points
const string UML_JUNCTION_POINT = "JunctionPoint";

list    the_last_selection = NULL; // SAME AS OMT

int    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;

boolean
idehook_invalidate_all()
{
    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;
    return(True);
}

// SAME AS OMT
void
idehook_force_new_selection()
{
    the_last_selection = NULL;
    idehook_invalidate_all();
}

// SAME AS OMT
boolean
idehook_did_selection_change()
{
    list    symbols;

    symbols = gde_selected_symbols();

    if (the_last_selection == NULL)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (list_count(symbols) != list_count(the_last_selection))
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (lists_equal(symbols, the_last_selection) == False)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    return(False);
}

list
uml_note_link_symbols()
{
    string link_types = "StateTransitionLink SplitControlLink MergeControlLink StateComponentLink";
    return string_to_list(link_types, " ");
}
// End ECR947, ECR 4494

int uml_check_composite_states_semantics()
{
    int err_count = 0;

    list composite_states = gde_nodes_find_by_type(gde_all_symbols(),
					UML_COMPOSITE_STATE_SYMBOL_TYPE);
    list_concatenate(composite_states,
		     gde_nodes_find_by_type(gde_all_symbols(),
					    UML_CONCURRENT_STATE_SYMBOL_TYPE));
    int i;
    list nodes;
    gde_node composite_state;
    node state_node;

    string init_state_query;
    list init_state_list;
    
    print_message("Checking Composite States...");

    for(i = 0;i < list_count(composite_states);i++)
	{
	    composite_state = list_get(composite_states,i);
	    nodes = gde_node_oms_nodes(composite_state);
	    if(list_count(nodes) == 0)
		continue;
	    state_node = list_get(nodes,0);
	    if(find_by_query("link[link_refs && UmlStateActivity && from_node_id = ${state_node.id}]") != NULL)
		{
		    gde_print_error("Composite state " + gde_node_label(composite_state) + " has an activity.",gde_node_psymid(composite_state));
		    err_count++;
		}

            if (i == 0)
            {
            init_state_query = "node[node_refs && UmlInitialState && " +
                               "out_links[to_node[" + state_node.id + "]]]";
 
            init_state_list = list_select(init_state_query);
 
             if (list_count(init_state_list) > 1)
             {
                 gde_print_error("Composite state " + gde_node_label(composite_state) + " has more than one initial vertex.",gde_node_psymid(composite_state));
                 err_count++;
            }
            }

	}
    return err_count;
}

int ustated_check_semantics()
{
    int err_count = 0;
    
    err_count = err_count + uml_check_state_machine_semantics();

    err_count = err_count + uml_check_composite_states_semantics();

  /* transition labels must be syntactically correct and transitions must be deterministic */
    err_count = uml_check_transitions() + err_count;

  
    return err_count;
}

void
UmlStateDiagramInit(int oid)
{
    Impl_UmlStateDiagramInit(oid);
}
boolean
uml_state_has_outgoing_transition(string symbol_type)
{
    if (symbol_type == UML_STATE_SYMBOL_TYPE ||
	    symbol_type == UML_COMPOSITE_STATE_SYMBOL_TYPE ||
	    symbol_type == UML_CONCURRENT_STATE_SYMBOL_TYPE ||
	    symbol_type == UML_INITIAL_STATE_SYMBOL_TYPE ||              // ECR 6369
        // ECR 7215 - Added Junction Points
        symbol_type == UML_JUNCTION_POINT_SYMBOL_TYPE ||
        symbol_type == UML_DYNAMIC_CHOICE_POINT_SYMBOL_TYPE)
	return True;
    return False;
}

list
uml_state_types()
{
    list	types;

    types = string_to_list(
		UML_STATE_SYMBOL_TYPE + " " +
		UML_COMPOSITE_STATE_SYMBOL_TYPE + " " +
		UML_CONCURRENT_STATE_SYMBOL_TYPE + " " +
        // ECR 7215 - Added Junction Points
        UML_JUNCTION_POINT_SYMBOL_TYPE + " " +
        UML_DYNAMIC_CHOICE_POINT_SYMBOL_TYPE, " ");
    return(types);
}

// Same as StatesWithIncomingTransitions in ustated.rules
list
uml_state_types_with_incoming_transitions()
{
    list	types;

    types = uml_state_types();
    list_append(types, UML_FINAL_STATE_SYMBOL_TYPE);
    return(types);
}

// Same as StatesWithOutgoingTransitions in ustated.rules
list
uml_state_types_with_outgoing_transitions()
{
    list	types;

    types = uml_state_types();
    list_append(types, UML_START_STATE_SYMBOL_TYPE);
    return(types);
}

int
idehook_split_control_active_func()
{
    list	symbols, tr, tg, valid_targets;
    int		cnt;
    gde_arc	a;
    gde_node	n;
    list	endn;

    symbols = gde_selected_symbols();

    tr = gde_arcs_find_by_type(symbols, UML_STATE_TRANS_LINK_SYMBOL_TYPE);

    if (list_count(tr) != 1)
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }
    valid_targets = uml_state_types_with_incoming_transitions();
    cnt = list_count(gde_symbols_find_with_types(symbols, valid_targets));
    if ((cnt + 1) != list_count(symbols))
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }

    a = list_get(tr, 0);
    endn = list_create("gde_node", 0);
    n = gde_arc_get_real_tonode(a, False, endn, NULL);
    tg = gde_node_list_to_sym_list(endn);
    cnt = list_count(gde_symbols_find_with_types(tg, valid_targets));
    if (cnt != list_count(tg))
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }

    return ACTIVE_FUNC_IS_ACTIVE;
}

// Assumes it is only called when active function is on ...

void
UStateDCreateControlSplit()
{
    Impl_UStateDCreateControlSplit();
}


int
idehook_merge_control_active_func()
{
    list	symbols, tr, valid_targets, endn, tg;
    gde_node	n;
    gde_arc	a;
    int		i, cnt;

    symbols = gde_selected_symbols();

    tr = gde_arcs_find_by_type(symbols, UML_STATE_TRANS_LINK_SYMBOL_TYPE);

    if (list_count(tr) <= 0)
    {
	return ACTIVE_FUNC_IS_INACTIVE;
    }
    valid_targets = uml_state_types_with_incoming_transitions();
    for(i = 0; i < list_count(tr); i = i + 1)
    {
	a = list_get(tr, i);
	endn = list_create("gde_node", 0);
	n = gde_arc_get_real_tonode(a, False, endn, NULL);
	tg = gde_node_list_to_sym_list(endn);
	cnt = list_count(gde_symbols_find_with_types(tg, valid_targets));
	if (cnt != list_count(tg))
	{
	    return ACTIVE_FUNC_IS_INACTIVE;
	}
    }

    return ACTIVE_FUNC_IS_ACTIVE;
}

// Assumes that the idehook_merge_control_active_func has been called

void
UStateDMergeControl()
{
    Impl_UStateDMergeControl();
}

string
uml_state_refined(int nid)
{
    if(find_by_query("viewpoint[UmlRefinedState && node_id = " + nid + "];")
       != NULL)
	return "Right,Bottom,Left";

    return NULL;

}

string
ustated_history_name(gde_mapsymbol mapsym)
{
    string ret =  gde_nt_name(gde_node_nt(to_gde_node(mapsym)));
    if (ret == "ShallowHistory")
        return NULL;
    return ret;
}

// ECR 7215 begin
string junctionPointStatusLabel()
{
    list    symbols;
    gde_symbol  s;
    string  tp;
    string  noJunctionPointReturn      = "Make Junction Point/Dynamic Choice Point";
    string  dynamicChoicePointReturn = "Make Dynamic Choice Point";
    string  junctionPointReturn  = "Make Junction Point";
    
    symbols = gde_selected_symbols();
    
    if (list_count(symbols) != 1)
    {
        return(noJunctionPointReturn);
    }
    
    s = list_get(symbols, 0);
    if (gde_symbol_is_node(s) == True)
    {
        tp = gde_get_symbol_type(s);
        if(UML_JUNCTION_POINT_SYMBOL_TYPE == tp)
            return dynamicChoicePointReturn;
        else if(UML_DYNAMIC_CHOICE_POINT_SYMBOL_TYPE == tp)
            return junctionPointReturn;
    }
    return noJunctionPointReturn;
}

void changeJunctionPoint()
{
    list    symbols;
    gde_symbol  s;
    string  tp, ntp;
    int     dodefer;
    
    symbols = gde_selected_symbols();
    
    if (list_count(symbols) != 1)
        return;

    s = list_get(symbols, 0);
    if (gde_symbol_is_node(s) == True)
    {
        tp = gde_get_symbol_type(s);
        if (UML_JUNCTION_POINT_SYMBOL_TYPE == tp)
            ntp = UML_DYNAMIC_CHOICE_POINT_SYMBOL_TYPE;
        else if (UML_DYNAMIC_CHOICE_POINT_SYMBOL_TYPE == tp)
            ntp = UML_JUNCTION_POINT_SYMBOL_TYPE;
        else
            return;
        gde_save_state();
        dodefer = gde_start_edit_transaction();
        gde_node_replace_nt(to_gde_node(s), ntp);
        gde_end_edit_transaction(0, dodefer, False);
        gde_builtin( "BufferUpdateDmarks" );
    }
}
int junctionPointSelected()
{
    list    symbols;
    gde_symbol  s;
    string  tp, ntp;
    int     dodefer;
    
    symbols = gde_selected_symbols();
    
    if (list_count(symbols) != 1)
        return ACTIVE_FUNC_IS_INACTIVE;

    s = list_get(symbols, 0);
    if (gde_symbol_is_node(s) == True)
    {
        tp = gde_get_symbol_type(s);
        if ((UML_JUNCTION_POINT_SYMBOL_TYPE == tp) || (UML_DYNAMIC_CHOICE_POINT_SYMBOL_TYPE == tp))
            return ACTIVE_FUNC_IS_ACTIVE;
    }
    return ACTIVE_FUNC_IS_INACTIVE;
}
// ECR 7215 end

// Begin Add ECR 5770
string
uml_state_activity_mark( int id )
{
	node x;
	string label = "";

	x = find_by_query( "node[in_links[UmlStateEntryAction && link_refs && from_node[id="+id+"]]]" );
	if( x )
		label = "Entry: "+x.name+"\n";
	
	x =find_by_query( "node[in_links[UmlStateActivity && link_refs && from_node[id="+id+"]]]" );
	if( x )
	    label = label + "Activitity: " +x.name+"\n";

	x =find_by_query( "node[in_links[UmlStateExitAction && link_refs && from_node[id="+id+"]]]" );
	if( x )
	    label = label + "Exit: " +x.name;

	return label;
}
// End Add ECR 5770

//  Add any user customizations to the file included below:
#include_if_exists "user/uml/rules/qrl/user_ustated.qrl"
