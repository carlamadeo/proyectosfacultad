
//      StP/UML
//      Confidential property of Aonix
//      Copyright (c) 1997
//      All rights reserved
//

#include "rules/qrl/gde_qrl_std.inc"
#include "rules/qrl/uml.inc"
#include "rules/qrl/object_instance.inc"
#include "rules/qrl/scenario_instance.inc"
#include "rules/qrl/find_interaction_scenario.inc"
#include "rules/qrl/interaction_dg_navigation.inc"
#include "rules/qrl/interaction_dg_semantics.inc"
#include "rules/qrl/usequenced.ps.qrl"
#include "rules/qrl/package_sym_rename.inc"
#include "rules/qrl/gde_uml_object_rename.inc"
#include "rules/qrl/message_label.inc"
#include "rules/qrl/message_prop.inc"
#include "qrl/include/export_to_doors.inc"

// ECR4052 Model Management
#include "rules/qrl/model_management.inc"

// Begin ECR947, ECR 4494
#include "rules/qrl/note_link.inc"

// ECR 4110
#include "rules/qrl/navtostp.inc"

#include "rules/qrl/default_arc_type.inc" //ECR 6469

const    int    ACTIVE_FUNC_IS_UNDEFINED = -1; // SAME AS OMT

list    the_last_selection = NULL; // SAME AS OMT

int    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;

boolean
idehook_invalidate_all()
{
    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;
    return(True);
}

// SAME AS OMT
void
idehook_force_new_selection()
{
    the_last_selection = NULL;
    idehook_invalidate_all();
}

// SAME AS OMT
boolean
idehook_did_selection_change()
{
    list    symbols;

    symbols = gde_selected_symbols();

    if (the_last_selection == NULL)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (list_count(symbols) != list_count(the_last_selection))
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (lists_equal(symbols, the_last_selection) == False)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    return(False);
}

list
uml_note_link_symbols()
{
    string link_types = "SimpleMessage SynchronousMessage BalkingMessage TimeoutMessage AsynchronousMessage ReturnMessage";
    return string_to_list(link_types, " ");
}
// End ECR947, ECR 4494

// Added for ECR4454
void
EditorStartupFunction()
{
    gde_draw_ortho( True );
    ui_toolbar_button_select("Standard", "OrthogonalArcs",True);
}

////////////////////////////////////////////////////////////////////////////////
//
//	collaboration editor navigation
//
////////////////////////////////////////////////////////////////////////////////
void collaborationNavigation()
{
    string diagramName;
    string currentQuery;
    list collaborationFileReferences;

    diagramName = gde_substitute_string("${file}");
    currentQuery = "file[UmlCollaborationDiagram && name = '" + diagramName + "']";
    collaborationFileReferences = list_select(currentQuery);
    if (list_count(collaborationFileReferences) != 0)
    {
    	editor_send_msg("ucollaborationd", "FileLoad "+diagramName, CH_FIRST);
    	editor_send_msg("ucollaborationd", "EditorShowDeiconify", CH_FIRST);
	print_message("Navigated to Collaboration Diagram '"+diagramName+"'");
    }
    else
    {
	print_message("No Collaboration Diagram '"+diagramName+"'");
	if (editor_confirm("Generate Collaboration Diagram '"+diagramName+"'?", "OK", "Cancel"))
	{
	    collaborateThisDiagram ();
	}
	else
	{
	    print_message("Navigation Canceled");
	}
    }
}

void collaborateThisDiagram()
{
    string diagramName;
    diagramName = gde_substitute_string("${file}");
    editor_send_msg("ucollaborationd",
	"EditorQrlEvalNoSave clearAndCollaborateASequenceDiagram(\""+diagramName+"\");",
	CH_FIRST);
}

////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////
void clearAndSequenceACollaborationDiagram(string diagramName)
{
    ///////////////////////////////////////////////////////////////////////////
    // Clear the buffer (If user cancels the next if statment succeeds) 
    // and deployment is canceled
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("BufferClear");
    gde_builtin("EditorSetFileName \"Noname\"");
    if (list_count(gde_all_symbols()) != 0)
    {
	return;
    }
    sequenceThisCollaborationDiagram (diagramName);
}

////////////////////////////////////////////////////////////////////////////////
// 
// 	Main routine to generate a sequence from collaboration
// 
////////////////////////////////////////////////////////////////////////////////
void sequenceACollaborationDiagram()
{
    string currentQuery;
    file currentFile;
    list collaborationFileReferences;
    int i;
    list currentCollaborationFiles;

    ///////////////////////////////////////////////////////////////////////////
    // Clear the buffer (If user cancels the next if statment succeeds) 
    // and deployment is canceled
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("BufferClear");
    gde_builtin("EditorSetFileName \"Noname\"");
    if (list_count(gde_all_symbols()) != 0)
    {
	return;
    }

    ///////////////////////////////////////////////////////////////////////////
    //  Query for all UmlCollaborationDiagrams
    ///////////////////////////////////////////////////////////////////////////
    currentQuery = "file[UmlCollaborationDiagram]";
    collaborationFileReferences = list_select(currentQuery);
    ///////////////////////////////////////////////////////////////////////////
    //  Make a list of strings representing the diagrams
    ///////////////////////////////////////////////////////////////////////////
    currentCollaborationFiles = list_create("string",0);
    for (i = 0; i < list_count(collaborationFileReferences); i++)
    {
	currentFile = list_get(collaborationFileReferences,i);
	list_append(currentCollaborationFiles,currentFile.name);
    }

    ///////////////////////////////////////////////////////////////////////////
    // Start the file selection property sheet
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("PropertySheetShow selectDiagram");
    FileSelectionNameInitialize(currentCollaborationFiles);
}

////////////////////////////////////////////////////////////////////////////////
//
//   Sequence the selected collaboration diagram is the continuation of
//   the SequenceACollobrationDiagram after the file is selected
//
////////////////////////////////////////////////////////////////////////////////
struct messageItem
{
    int from;
    int to;
    string type;
    string name;
    string sequence;
    list sequenceList;
};

boolean A_gt_B(messageItem a, messageItem b)
{
    int i;
    boolean inEqualityFound;
    inEqualityFound = False;
    int aValue;
    int bValue;
    boolean returnValue;

    for (i = 0; i < list_count(a.sequenceList) && i < list_count(b.sequenceList) && !inEqualityFound; i++)
    {
	aValue = list_get(a.sequenceList,i);
	bValue = list_get(b.sequenceList,i);
	if (aValue != bValue) 
	    inEqualityFound = True;
    }
    if (inEqualityFound) 
	returnValue = aValue > bValue;
    else
	returnValue = list_count(a.sequenceList) > list_count(b.sequenceList);
    return(returnValue);
}

list sortSequence(list allMessages)
{
    messageItem item1, item2, item3;
    int i;
    int j;

    for (i = 0 ; i < list_count(allMessages); i++)
    {
	for (j = i+1; j < list_count(allMessages); j++)
	{
	    item1 = list_get(allMessages,i);
	    item2 = list_get(allMessages,j);
	    if (A_gt_B(item1,item2))
	    {
		list_set(allMessages,i,item2);
		list_set(allMessages,j,item1);
	    }
	}
    }

    return(allMessages);
}

void move_an_arc(gde_arc a, int fx, int fy, int tx, int ty, boolean relative)
{
    gde_node	tn, fn;
    int		dfx, dfy, dtx, dty;

    // gde_arc_feedback(a);

    // coord == node.coord + coord.d
    fn = gde_arc_fromnode(a);
    tn = gde_arc_tonode(a);
    if (relative == True)
    {
	fx = gde_node_x(fn) + gde_arc_from_dx(a) + fx;
	fy = gde_node_y(fn) + gde_arc_from_dy(a) + fy;
	tx = gde_node_x(tn) + gde_arc_to_dx(a) + tx;
	ty = gde_node_y(tn) + gde_arc_to_dy(a) + ty;
    }

    dfx = fx - gde_node_x(fn);
    dfy = fy - gde_node_y(fn);
    dtx = tx - gde_node_x(tn);
    dty = ty - gde_node_y(tn);
    gde_arc_set_dx_dy(a, dfx, dfy, dtx, dty);
}

///////////////////////////////////////////////////////////////////////
// Special routine to handle to_int capabilities without causing error
// when there are characters involved.  Legal  1a should convert to
// 1; however, 1a1 should convert to 1.  This is a very ineffecient routine.
///////////////////////////////////////////////////////////////////////
int sequence_to_int(string inString)
{
    int returnValue;
    int i;
    boolean done;
    string string_part;

    returnValue = 0;
    done = False;
    for (i = 0; i < string_length(inString) && !done; i++)
    {
	string_part = string_extract(inString,0,i+1);
	if (!string_converts(string_part,"int"))
	{
	    done = True;
	}
	else
	{
	    returnValue = to_int(string_extract(inString,0,i+1));
	}
    }

    return(returnValue);
}

void sequenceThisCollaborationDiagram (string diagramName)
{
    int 	theTransaction;
    int		len;
    list 	collaborationNodeReferences;
    list	collaborationLinkReferences;
    list	collaborationCntxReferences;
    list 	oldNodes;
    list 	newGdeNodes;
    int		newNodesCount;
    string	currentQuery;
    gde_arc	currentArc;
    gde_arc	labelArc;
    gde_cntx	currentCntx;
    int 	i,j,k;
    node_ref	currentNodeReference;
    node	currentNode;
    node	secondaryNode;
    link_ref	currentLinkReference;
    link_ref	secondaryLinkReference;
    link	currentLink;
    item	currentItem;
    gde_node 	currentGdeNode;
    gde_node    vertex1;
    gde_node	vertex2;
    gde_node	theNode;
    int		foundTo;
    int		foundFrom;
    string 	labelString;
    boolean	completedInformation;
    messageItem	currentMessage;
    list	tmpList;
    int		m;
    list	allMessages;
    string	arcType;
    int		messagesToOnesSelf;
    int		ARC_SPACING = 20;
    int		NODE_SPACING = 80;
    int		nodeSize;
    int 	nodeBaseYPosition;
    string  nodeType;
    node    activeNode;
    string fullLabel;

    ///////////////////////////////////////////////////////////////////////////
    // if name is null exit
    ///////////////////////////////////////////////////////////////////////////
    if (diagramName == "")
    {
	return;
    }

    //
    // notes have unique names, to allow for different items,
    // corresponding to different symbols, attached to the same node
    // Prepare the note name prefix.  Name is created by appending the
    // symbol appid to this prefix.
    string dg_type = "UmlCollaborationDiagram";
    string noteNamePrefix = dg_type+"%"+diagramName+"%";

    ///////////////////////////////////////////////////////////////////////////
    // I'd buy a big house, where we both could live.... EJ
    ///////////////////////////////////////////////////////////////////////////
    clearAutoAlignParameters();
    ///////////////////////////////////////////////////////////////////////////
    // save current state for editor
    ///////////////////////////////////////////////////////////////////////////
    gde_save_state();
    theTransaction = gde_start_edit_transaction();

    ///////////////////////////////////////////////////////////////////////////
    // set this deployment diagram name to same as sequence diagram
    ///////////////////////////////////////////////////////////////////////////
    gde_builtin("EditorSetFileName \"" + diagramName  +"\"");

    ///////////////////////////////////////////////////////////////////////////
    // get all nodes && links  associated with this sequence diagram
    ///////////////////////////////////////////////////////////////////////////
    currentQuery = "node_ref[file[type==UmlCollaborationDiagram && name=='"+diagramName+"']]";
    collaborationNodeReferences = list_select(currentQuery);
    currentQuery = "link_ref[file[type==UmlCollaborationDiagram && name=='"+diagramName+"']]";
    collaborationLinkReferences = list_select(currentQuery);
    currentQuery = "cntx_ref[file[type==UmlCollaborationDiagram && name=='"+diagramName+"']]";
    collaborationCntxReferences = list_select(currentQuery);
    ///////////////////////////////////////////////////////////////////////////
    // Sort out the various node types into separte lists and draw them
    ///////////////////////////////////////////////////////////////////////////
    oldNodes 		= list_create("node",0);
    newGdeNodes 	= list_create("gde_node",0);
    newNodesCount	= 0;
    allMessages = list_create("messageItem",0);
    for (i = 0; i < list_count(collaborationNodeReferences); i++)
    {
	currentNodeReference = list_get(collaborationNodeReferences,i);
	currentNode = find_by_query("node[id="+currentNodeReference.node_id+"]");
	secondaryNode = find_by_query("node[id="+currentNode.scope_node_id+"]");
	if (currentNode != NULL)
	{
	    if (currentNode.type == "UmlObjectInstance")
	    {
            nodeType = "PassiveObject";
            activeNode = find_by_query("node[UmlActiveObject && name=" +
                    "'${currentNode.name}'  && sig='${currentNode.sig}'" +
                    " && scope_node_id=${currentNode.scope_node_id} && " +
                    "node_refs]");
            if (NULL != activeNode)
                nodeType = "ActiveObject";
            labelString = currentNode.name + ":" + secondaryNode.name;
            currentGdeNode = gde_node_create(nodeType,
                    newNodesCount*NODE_SPACING,0);
            //gde_node_set_label(currentGdeNode,labelString);
            uml_set_object_label(labelString,currentGdeNode);
            list_append(newGdeNodes,currentGdeNode);
            list_append(oldNodes,currentNode);
            newNodesCount++;
	    }
	    else if (currentNode.type == "UmlActor")
	    {
		currentGdeNode = gde_node_create("Actor",newNodesCount*NODE_SPACING,0);
		gde_node_set_label(currentGdeNode,currentNode.name);
		list_append(newGdeNodes,currentGdeNode);
   		list_append(oldNodes,currentNode);
		newNodesCount++;
	    }
	    else if (currentNode.type == "UmlExtensionPoint")
	    {
		currentMessage.from = NULL;
		currentMessage.to = NULL;
		currentMessage.type = "ExtensionPoint";
		currentMessage.name = currentNode.name;
		currentMessage.sequence = currentNode.name;
	        tmpList = string_to_list(currentMessage.sequence,".");
	        currentMessage.sequenceList = list_create("int",0);
	        for (m = 0; m < list_count(tmpList); m++)
	        {
		    list_append(currentMessage.sequenceList,sequence_to_int(list_get(tmpList,m)));
	        }
	        list_append(allMessages,currentMessage);
	    }
	    else if (currentNode.type == "UmlScenarioInstance")
	    {
		currentGdeNode = gde_node_create("ScenarioInstance",0,0);
		currentItem = find_by_query("item[UmlParentTypeItem && obj_id="+currentNode.id+"]");
		labelString = "";
		if (currentItem != NULL)
		{
		    labelString = currentItem.value;
		}
		currentItem = NULL;
		currentItem = find_by_query("item[UmlParentNameItem && obj_id="+currentNode.id+"]");
		if (currentItem != NULL)
		{
		    labelString = labelString + ":" + currentItem.value;
		}
		gde_node_set_label(currentGdeNode,currentNode.name+"("+labelString+")");
	    }
	}
    }
    ///////////////////////////////////////////////////////////////////////////
    // 
    //
    ///////////////////////////////////////////////////////////////////////////
    messagesToOnesSelf = 0;
    for (i = 0; i < list_count(collaborationLinkReferences); i++)
    {
	currentLinkReference = list_get(collaborationLinkReferences,i);
	currentLink = find_by_query("link[id="+currentLinkReference.link_id+"]");
	if ((currentLink != NULL) &&
	    ((currentLink.type == "UmlSimpleMessage") ||
	     (currentLink.type == "UmlAsynchronousMessage") ||
	     (currentLink.type == "UmlSynchronousMessage") ||
	     (currentLink.type == "UmlBalkingMessage") ||
	     (currentLink.type == "UmlTimeoutMessage") ||
	     (currentLink.type == "UmlReturnMessage")))
	{
	    completedInformation = False;
	    currentMessage.type = currentLink.type;
	    currentMessage.from = currentLink.from_node_id;
	    currentMessage.to   = currentLink.to_node_id;
	    if (currentMessage.from == currentMessage.to)
	    {
		messagesToOnesSelf++;
	    }
	    currentMessage.name = uml_get_message_label_from_link(currentLink,currentLinkReference,noteNamePrefix);
        currentItem = 
    		uml_get_message_seq_item_from_link_ref(currentLinkReference,noteNamePrefix);
	    if (currentItem != NULL) { 
		currentMessage.sequence = currentItem.value;
	    } else { // this is annotation and might not been set yet
		print_message("Warning: the message sequence "+
			      "information not found for message '"+currentMessage.name+"'");
		currentMessage.sequence = "";
	    }
	    tmpList = string_to_list(currentMessage.sequence,".");
	    currentMessage.sequenceList = list_create("int",0);
	    for (m = 0; m < list_count(tmpList); m++)
	    {
		list_append(currentMessage.sequenceList,sequence_to_int(list_get(tmpList,m)));
	    }
	    completedInformation = True;
	    if (!completedInformation)
	    {
		print_error("Error obtaining diagram information from repository");
		print_error("Generated diagram will be incompelte link:"+
			currentLink.name+" info lost");
	    }
	    list_append(allMessages,currentMessage);
	}
    }

    ///////////////////////////////////////////////////////////////////////////////////
    // Sort those puppies
    ///////////////////////////////////////////////////////////////////////////////////
    sortSequence(allMessages);

    ///////////////////////////////////////////////////////////////////////////////////
    // Make all the new nodes big enought to hold the messages
    ///////////////////////////////////////////////////////////////////////////////////
    nodeSize = ((list_count(allMessages) + 2) * ARC_SPACING) + (messagesToOnesSelf * ARC_SPACING);
    nodeBaseYPosition = 0;
    if (list_count(newGdeNodes) > 0)
    {
	nodeBaseYPosition = gde_node_y(list_get(newGdeNodes,0));
    }
    for (i = 0; i < list_count(newGdeNodes); i++)
    {
	gde_node_scale(list_get(newGdeNodes,i),5,0,nodeSize);
    }

    k = ((list_count(allMessages)+messagesToOnesSelf) / -2);
    for (i = 0; i < list_count(allMessages); i++)
    {
	currentMessage = list_get(allMessages,i);
	if (currentMessage.type != "ExtensionPoint")
	{
	    for (j = 0, foundTo = -1; ((j < list_count(oldNodes)) && (foundTo == -1)); j++)
	    {
	 	currentNode = list_get(oldNodes,j);
		if (currentMessage.to == currentNode.id)
		{
 		    foundTo = j;
		}
	    }
	    for (j = 0, foundFrom = -1; ((j < list_count(oldNodes)) && (foundFrom == -1)); j++)
	    {
		currentNode = list_get(oldNodes,j);
		if (currentMessage.from == currentNode.id)
		{
	 	    foundFrom = j;
	        }
	    }
	    len = string_length(currentMessage.type);
	    arcType = string_extract(currentMessage.type,3,len-3);
	    ////////////////////////////////////////////////////////////////////////////////////
	    // handling messages to ones self here
	    ////////////////////////////////////////////////////////////////////////////////////
	    if (foundFrom == foundTo)
	    {
	    	theNode = list_get(newGdeNodes,foundFrom);
	    	vertex1 = gde_node_create("Vertex",gde_node_x(theNode)+(NODE_SPACING/2),k*ARC_SPACING);
	    	vertex2 = gde_node_create("Vertex",gde_node_x(theNode)+(NODE_SPACING/2),
			(k+1)*ARC_SPACING);
	    	currentArc = gde_arc_create(arcType,theNode,vertex1);
            	move_an_arc(currentArc,0,k*ARC_SPACING,0,0,True);
	    	labelArc = gde_arc_create(arcType,vertex1,vertex2);
	    	currentArc = gde_arc_create(arcType,vertex2,theNode);
	    	move_an_arc(currentArc,0,0,0,(k+1)*ARC_SPACING,True);
	    	k += 2;
	    }
	    ////////////////////////////////////////////////////////////////////////////////////
	    // Simple message require only one arc
	    ////////////////////////////////////////////////////////////////////////////////////
	    else
	    {
	    	labelArc = currentArc = gde_arc_create
			(arcType, list_get(newGdeNodes,foundFrom), list_get(newGdeNodes,foundTo));
            	move_an_arc(currentArc,0,k*ARC_SPACING,0,k*ARC_SPACING,True);
	    	k++;
	    }
	    gde_arc_set_label(labelArc,currentMessage.name);
	}	 
	else // it's an extension point (this code added after the fact)
	{
            currentGdeNode = gde_node_create("ExtensionPoint",-20,(k*ARC_SPACING)+nodeBaseYPosition);
            // Instead of using just currentNode.name, get the
            // whole label including sequence value, recurrence.
            fullLabel =uml_get_ext_point_label_from_node(currentNode,currentNodeReference,noteNamePrefix);
            //gde_node_set_label(currentGdeNode,currentNode.name);
            gde_node_set_label(currentGdeNode,fullLabel);
	    k++;
	}
    }

    gde_builtin("BufferZoom FitDiagram");
    gde_builtin("EditorShowDeiconify");
    gde_end_edit_transaction(GDE_CMD_INSERT, theTransaction, False);
}

///////////////////////BEGIN NEW ROUTINES//////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
list sequenceCollaborationObjectTypes(string leader)
{
    list returnList = list_create("string",0);
    list_append(returnList,leader+"PassiveObject");
    list_append(returnList,leader+"ActiveObject");
    list_append(returnList,leader+"Actor");
    return(returnList);
}

list sequenceCollaborationMessageTypes(string leader)
{
    list returnList = list_create("string",0);
    list_append(returnList,leader+"SimpleMessage");
    list_append(returnList,leader+"AsynchronousMessage");
    list_append(returnList,leader+"SynchronousMessage");
    list_append(returnList,leader+"BalkingMessage");
    list_append(returnList,leader+"TimeoutMessage");
    list_append(returnList,leader+"ReturnMessage");
    list_append(returnList,leader+"ExtensionPoint");
    return(returnList);
}

list getAllSymbolsOfType(list typeValues)
{
    list	returnList;
    list	allSymbols;
    gde_arc	currentArc;
    gde_node	currentNode;
    gde_symbol	currentSymbol;
    string	symbolType;
    int		i;
    int		typeValuesCount;
    
    returnList = list_create("gde_symbol",0);
    allSymbols = gde_all_symbols();
    typeValuesCount = list_count(typeValues);
    for (i = 0; i < list_count(allSymbols); i++)
    {
	currentSymbol = list_get(allSymbols,i);
	symbolType = gde_get_symbol_type(currentSymbol);
	if (list_find(typeValues,0,symbolType) != typeValuesCount)
	{
	    if (gde_symbol_is_arc(currentSymbol))
	    {
		currentArc = to_gde_arc(currentSymbol);
		currentNode = gde_arc_fromnode(currentArc);
		symbolType = gde_get_symbol_type(to_gde_symbol(currentNode));
		if (symbolType != "Vertex")
		{
	    	    list_append(returnList,currentSymbol);
		}
	    }
	    else
	    {
	    	list_append(returnList,currentSymbol);
	    }
	}
    }
    return(returnList);
}

list getAllArcsOfThisMessage(gde_arc theArcStart)
{
    list returnList;
    list allSymbols = gde_all_symbols();
    int i;
    int j;
    boolean done;
    gde_arc currentArc;
    gde_symbol currentSymbol;
    gde_node currentToNode;
    string symbolType;

    returnList = list_create("gde_arc",0);
    currentArc = theArcStart;
    list_append(returnList,theArcStart);
    done = False;
    // could be while loop i never used in this loop & done is exit condtion
    ////////////////////////////////////////////////////////////////////////
    //for (i = 0; i < list_count(allSymbols) && !done; i++)
    while (!done)
    {
	currentToNode = gde_arc_tonode(currentArc);
	if (gde_get_symbol_type(to_gde_symbol(currentToNode)) != "Vertex")
	    done = True;
	for (j = 0; j < list_count(allSymbols) && !done; j++)
	{
	    currentSymbol = list_get(allSymbols,j);
	    if (gde_symbol_is_arc(currentSymbol))
	    {
		currentArc = to_gde_arc(currentSymbol);
		if (currentToNode == gde_arc_fromnode(currentArc))
		{
		    list_append(returnList,currentArc);
		    j = list_count(allSymbols);
		}
	    }
	    else
	    {
		list_delete(allSymbols,j); // prune unnecessary info 4 speed
	    }
	}
    }

    return(returnList);
}

void moveANode(gde_node n, int x, int y)
{
    gde_select_node(n);
    gde_builtin("SymbolMove " + x + " " + y );
    gde_builtin("SymbolSelect AppId 0");
}

int moveAnArc(gde_arc theArcStart, int yStart, int yStep)
{
    string toSymbolType;
    list allArcsOfThisMessage;
    gde_node startNode;
    gde_node endNode;
    int startBaseYPosition;
    int startBaseXPosition;
    int endBaseXPosition;
    int halfWayBetweenStopAndEnd;
    int i;
    gde_arc currentArc;
    string arcLabel = "";	// if no previous existing label must be ""
    list objectNodes = sequenceCollaborationObjectTypes("");
    int returnValue = 0;

    toSymbolType = 
	gde_get_symbol_type(to_gde_symbol(gde_arc_tonode(theArcStart)));

    if (list_find(objectNodes,0,toSymbolType) != list_count(objectNodes))
    {
	returnValue = 1;
	gde_arc_set_dx_dy(theArcStart,0,yStart,0,yStart);
    }
    else
    {
        allArcsOfThisMessage = getAllArcsOfThisMessage(theArcStart);
	for (i = 0; i < list_count(allArcsOfThisMessage); i++)
	{
	    if (gde_arc_label(list_get(allArcsOfThisMessage,i)) != "")
	    {
		arcLabel = gde_arc_label(list_get(allArcsOfThisMessage,i));
		gde_arc_set_label(list_get(allArcsOfThisMessage,i),NULL);
	    }
	}
	startNode = gde_arc_fromnode(theArcStart);
	endNode = gde_arc_tonode
	    (list_get(allArcsOfThisMessage,
		(list_count(allArcsOfThisMessage)-1)));
	startBaseYPosition = gde_node_y(startNode);
	startBaseXPosition = gde_node_x(startNode);
	endBaseXPosition = gde_node_x(endNode);
	if (startNode == endNode)
	    halfWayBetweenStopAndEnd = 25;
	else
	    halfWayBetweenStopAndEnd = endBaseXPosition +
		((endBaseXPosition - startBaseXPosition) / 2);
	gde_arc_set_dx_dy(theArcStart,0,yStart,0,0);
	for (i = 0; i < list_count(allArcsOfThisMessage); i++)
	{
	    currentArc = list_get(allArcsOfThisMessage,i);
	    if ((i == 0 && startNode != endNode) || 
		(i == 1 && startNode == endNode))
		gde_arc_set_label(currentArc,arcLabel);
	    if (gde_get_symbol_type
		    (to_gde_symbol
			(gde_arc_tonode(currentArc))) == "Vertex")
	    {
		if (startNode == endNode && i > 0)
		{
	   	    moveANode(gde_arc_tonode(currentArc),
			startBaseXPosition+halfWayBetweenStopAndEnd,
			startBaseYPosition+yStart+yStep-1); // SPR 252 - reflexive msg in seq editor
		}
		else
		{
	   	    moveANode(gde_arc_tonode(currentArc),
			startBaseXPosition+halfWayBetweenStopAndEnd,
			startBaseYPosition+yStart-1);       // SPR 252 - reflexive msg in seq editor
		}
	    }
	    else 
	    {
		if (startNode == endNode)
		{
		    gde_arc_set_dx_dy(currentArc,0,0,0,yStart+yStep);
	    	    returnValue = 2;
		}
		else
		{
		    gde_arc_set_dx_dy(currentArc,0,0,0,yStart);
		    returnValue = 1;
		}
	    }
	}
    }

    return(returnValue);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////////////////////////END  NEW ROUTINES//////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//  This routine will either expand all objects 50% or to the size of a 
//  single selected object.
///////////////////////////////////////////////////////////////////////////////
void expandAllObjects()
{
    list 	nodeTypesList;		// types of nodes in sequence editor
    list 	allNodes;		// all nodes of type nodeTypesList
    list 	selectedSymbols;	// all selected symbols
    int 	desiredHeight;		// computed height for all nodes
    int 	theTransaction;		// el transactiono
    int 	i;

    /////////////////////////////////////////////////////////////////////////// 
    // Start the edit transaction
    /////////////////////////////////////////////////////////////////////////// 
    gde_save_state();
    theTransaction = gde_start_edit_transaction();
    /////////////////////////////////////////////////////////////////////////// 
    // get all the nodes
    /////////////////////////////////////////////////////////////////////////// 
    nodeTypesList = sequenceCollaborationObjectTypes("");
    allNodes = getAllSymbolsOfType(nodeTypesList);
    /////////////////////////////////////////////////////////////////////////// 
    // if an object or actor is selected expand them all to be it's height
    /////////////////////////////////////////////////////////////////////////// 
    if (objectOrActorIsSelectedActiveFunc())
    {
	selectedSymbols = gde_selected_symbols();
    	if (list_count(selectedSymbols) == 1)
    	{
	    desiredHeight= 
		gde_node_height(to_gde_node(list_get(selectedSymbols,0)));
	}
    }
    /////////////////////////////////////////////////////////////////////////// 
    // else expand them 50% of longest
    /////////////////////////////////////////////////////////////////////////// 
    else
    {
	desiredHeight = 1;
	for (i = 0; i < list_count(allNodes); i++)
	{
	    if (desiredHeight < 
		gde_node_height(to_gde_node(list_get(allNodes,i))))
		desiredHeight =
		    gde_node_height(to_gde_node(list_get(allNodes,i)));
	}
	desiredHeight = to_int(1.5 * desiredHeight);
    }
    /////////////////////////////////////////////////////////////////////////// 
    // Expand or contract em
    /////////////////////////////////////////////////////////////////////////// 
    for (i = 0; i < list_count(allNodes); i++)
	gde_node_scale(to_gde_node(list_get(allNodes,i)),4,0,desiredHeight);
    /////////////////////////////////////////////////////////////////////////// 
    // Scale to fit and end the blasted transaction
    /////////////////////////////////////////////////////////////////////////// 
    gde_builtin("BufferZoom FitDiagram");
    gde_end_edit_transaction(GDE_CMD_INSERT, theTransaction, False);
}

////////////////////////////////////////////////////////////////////////////////
// Sort Algorythm used in Distribute All Arcs
////////////////////////////////////////////////////////////////////////////////
int compairNodesBasedOnXPosition (list theList, int a, int b)
{
    int returnValue = 0;
    int aRank = gde_node_x(to_gde_node(list_get(theList,a)));
    int bRank = gde_node_x(to_gde_node(list_get(theList,b)));

    if (aRank > bRank)
	returnValue = 1;
    else if (aRank < bRank)
	returnValue = -1;
    return(returnValue);
}

////////////////////////////////////////////////////////////////////////////////
//  This is usually called from the UML menu item by the same name.  It's 
//  aligning all objects on the pallet
////////////////////////////////////////////////////////////////////////////////
void alignAllObjects()
{
    list nodeTypesList;			//  strings for objects and actors
    list allNodes;			//  all objects and actors
    gde_node currentNode;		//  current node to examine or move
    int yPosMax 	= -9999;	//  mins and maxes used to 
    int xPosMin 	= 9999;		//     compute the working area etc
    int xPosMax 	= -9999;	//
    int heightMax 	= -9999;	//
    int xStep;				//
    int theTransaction;			//  edit transaction id (undo etc.)
    int i;				//

    /////////////////////////////////////////////////////////////////////////// 
    // get all the nodes of type Actor and Object and sort based on X position
    /////////////////////////////////////////////////////////////////////////// 
    nodeTypesList = sequenceCollaborationObjectTypes("");
    allNodes = getAllSymbolsOfType(nodeTypesList);
    allNodes = list_sort_all(allNodes,"compairNodesBasedOnXPosition");

    if (list_count(allNodes) < 2)
        // nothing to do
        return;

    /////////////////////////////////////////////////////////////////////////// 
    // Start the edit transaction
    /////////////////////////////////////////////////////////////////////////// 
    gde_save_state();
    theTransaction = gde_start_edit_transaction();

    /////////////////////////////////////////////////////////////////////////// 
    // Compute the mins and maxes as needed
    /////////////////////////////////////////////////////////////////////////// 
    nodeTypesList = sequenceCollaborationObjectTypes("");
    allNodes = getAllSymbolsOfType(nodeTypesList);
    if (list_count(allNodes) > 1)
    {
        allNodes = list_sort_all(allNodes,"compairNodesBasedOnXPosition");
    /////////////////////////////////////////////////////////////////////////// 
    // Compute the mins and maxes as needed
    /////////////////////////////////////////////////////////////////////////// 
        for (i = 0; i < list_count(allNodes); i++)
        {
   	    currentNode = to_gde_node(list_get(allNodes,i));
	    if (gde_node_y(currentNode) > yPosMax)
	        yPosMax = gde_node_y(currentNode);
	    if (gde_node_x(currentNode) > xPosMax)
	        xPosMax = gde_node_x(currentNode);
	    if (gde_node_x(currentNode) < xPosMin)
	        xPosMin = gde_node_x(currentNode);
    	    if (gde_node_height(currentNode) > heightMax)
	        heightMax = gde_node_height(currentNode);
        }
    /////////////////////////////////////////////////////////////////////////// 
    //  Compute the step and distribute the nodes
    /////////////////////////////////////////////////////////////////////////// 
        xStep = (xPosMax - xPosMin) / (list_count(allNodes) - 1);
        for (i = 0; i < list_count(allNodes); i++)
        {
    	    gde_node_scale(to_gde_node(list_get(allNodes,i)),5,0,heightMax);
	    moveANode
	        (to_gde_node(list_get(allNodes,i)),(xPosMin+(xStep*i)),yPosMax);
        }
    }

    /////////////////////////////////////////////////////////////////////////// 
    //  zoom the buffer to fit and end the edit transaction
    /////////////////////////////////////////////////////////////////////////// 
    gde_builtin("BufferZoom FitDiagram");
    gde_end_edit_transaction(GDE_CMD_INSERT, theTransaction, False);
}

////////////////////////////////////////////////////////////////////////////////
// Sort Algorythms used in Distribute All Arcs
////////////////////////////////////////////////////////////////////////////////
int compairArcsBasedOnYPosition (list theList, int a, int b)
{
    int aRank;
    int bRank;
    int returnValue = 0;

    if (gde_symbol_is_arc(list_get(theList,a)))
	aRank = gde_arc_fromy(to_gde_arc(list_get(theList,a)));
    else
	aRank = gde_node_y(to_gde_node(list_get(theList,a)));

    if (gde_symbol_is_arc(list_get(theList,b)))
	bRank = gde_arc_fromy(to_gde_arc(list_get(theList,b)));
    else
	bRank = gde_node_y(to_gde_node(list_get(theList,b)));

    if (aRank > bRank)
	returnValue = 1;
    else if (aRank < bRank)
	returnValue = -1;
    return(returnValue);
}

int compairArcsBasedOnSequenceNumber (list theList, int a, int b)
{
    list sequenceAList;
    list sequenceBList;
    list labelAComponents;
    list labelBComponents;
    list tmpList;
    int returnValue;
    int aValue;
    int bValue;
    string arcLabel;
    boolean inEqualityFound;
    int i;
    ////////////////////////////////////////////////////////////////////////////
    // for arc a (handle cases where arc is extension point [node])
    ////////////////////////////////////////////////////////////////////////////
    if (gde_symbol_is_arc(list_get(theList,a)))
        arcLabel = gde_arc_get_first_label(to_gde_arc(list_get(theList,a)));
    else 
        arcLabel = gde_node_label(to_gde_node(list_get(theList,a)));
    labelAComponents = uml_parse_message_label(arcLabel);
    tmpList = string_to_list(list_get(labelAComponents,1),".");
    sequenceAList = list_create("int",0);
    for (i = 0; i < list_count(tmpList); i++)
	list_append(sequenceAList,sequence_to_int(list_get(tmpList,i)));
    ////////////////////////////////////////////////////////////////////////////
    // for arc b (handle cases where arc is extension point [node])
    ////////////////////////////////////////////////////////////////////////////
    if (gde_symbol_is_arc(list_get(theList,b)))
	arcLabel = gde_arc_get_first_label(to_gde_arc(list_get(theList,b)));
    else 
        arcLabel = gde_node_label(to_gde_node(list_get(theList,b)));
    labelBComponents = uml_parse_message_label(arcLabel);
    tmpList = string_to_list(list_get(labelBComponents,1),".");
    sequenceBList = list_create("int",0);
    for (i = 0; i < list_count(tmpList); i++)
	list_append(sequenceBList,sequence_to_int(list_get(tmpList,i)));
    ////////////////////////////////////////////////////////////////////////////
    // do the compair
    ////////////////////////////////////////////////////////////////////////////
    inEqualityFound = False;
    for (i = 0; i < list_count(sequenceAList) 
	&& i < list_count(sequenceBList) 
	&& !inEqualityFound; i++)
    {
	aValue = list_get(sequenceAList,i);
	bValue = list_get(sequenceBList,i);
	if (aValue != bValue) 
	    inEqualityFound = True;
    }
    ////////////////////////////////////////////////////////////////////////////
    // convert the results for the sort routine 0-no change, 1 and -1 inequality
    ////////////////////////////////////////////////////////////////////////////
    returnValue = 0;
    if (inEqualityFound) 
    {
	if (aValue > bValue)
	    returnValue = 1;
	else if (aValue < bValue)
	    returnValue = -1;
    }
    else
    {
	if (list_count(sequenceAList) > list_count(sequenceBList))
	    returnValue = 1;
	else if (list_count(sequenceAList) < list_count(sequenceBList))
	    returnValue = -1;
    }
    return(returnValue);
}

////////////////////////////////////////////////////////////////////////////////
// Computes the number of acrs that are complex (have a vertex).  This implies
// the arc is just the first in a series of multiple segments representing a
// message.
////////////////////////////////////////////////////////////////////////////////
int findComplexArcs(list arcList)
{
    int i;
    gde_arc currentArc;
    int complexArcCount = 0;

    for (i = 0; i < list_count(arcList); i++)
    {
	if (gde_symbol_is_arc(list_get(arcList,i)))
	{
	    currentArc = to_gde_arc(list_get(arcList,i));
            if (gde_get_symbol_type(to_gde_symbol(gde_arc_tonode(currentArc))) 
	        == "Vertex")
	        complexArcCount++;
	}
    }

    return (complexArcCount);
}

////////////////////////////////////////////////////////////////////////////////
//  This is usually called from the UML menu item by the same name.  It's 
//  Responsible for distributing all the arcs nice and neatly on the diagram.
//  The parameter sort function will determine if the distribution is based
//  on position or sequence numbers.
////////////////////////////////////////////////////////////////////////////////
list distributeAllArcs(string sortFunction) 
{
    list arcTypesList;		//  All arc types (messages)
    list nodeTypesList;		//  All node types (object/actors)
    list allArcs; 		//  All arcs on diagram 
    list allNodes;		//  All nodes (object/actors) on diagram
    int objectHeight;		//  Height of all objects after they're aligned
    int arcCount;		//  Number of arcs spaces required 
    int arcStep;  		//  Step (area) between arcs
    int yNodeOffset;		//  Y position where aligned nodes start
    gde_node currentNode;	//  Various nodes at different times
    int theTransaction;		//  The transaction (for undo etc.)
    int i, k;

    /////////////////////////////////////////////////////////////////////////// 
    // get all the nodes of type Actor and Object
    /////////////////////////////////////////////////////////////////////////// 
    nodeTypesList = sequenceCollaborationObjectTypes("");
    allNodes = getAllSymbolsOfType(nodeTypesList);
    /////////////////////////////////////////////////////////////////////////// 
    // if there is at least one node
    /////////////////////////////////////////////////////////////////////////// 
    if (list_count(allNodes) > 0)
    {
	/////////////////////////////////////////////////////////////////////// 
	// Save the state and start the transaction
	/////////////////////////////////////////////////////////////////////// 
	gde_save_state();
	theTransaction = gde_start_edit_transaction();
	/////////////////////////////////////////////////////////////////////// 
	// Align all objects making them the same height as well
	/////////////////////////////////////////////////////////////////////// 
    	alignAllObjects();
	/////////////////////////////////////////////////////////////////////// 
	// Get all the acrs of this diagram and sort them based on position
	/////////////////////////////////////////////////////////////////////// 
	arcTypesList = sequenceCollaborationMessageTypes("");
	allArcs = getAllSymbolsOfType(arcTypesList);
	arcCount = list_count(allArcs) + findComplexArcs(allArcs);
	allArcs = list_sort_all(allArcs,sortFunction);
	/////////////////////////////////////////////////////////////////////// 
	// get the nodes again (may have changed size because of alignAllObjects
	// above.  
	/////////////////////////////////////////////////////////////////////// 
        allNodes = getAllSymbolsOfType(nodeTypesList);
	/////////////////////////////////////////////////////////////////////// 
	// compute or obtain height, arc step
	/////////////////////////////////////////////////////////////////////// 
	currentNode = to_gde_node(list_get(allNodes,0));
	objectHeight = gde_node_height(currentNode);
	arcStep = objectHeight / (arcCount + 1);
	yNodeOffset = gde_node_y(currentNode);
	/////////////////////////////////////////////////////////////////////// 
	// for each arc align based on m*arcStep (handle extension points as
	// nodes)
	/////////////////////////////////////////////////////////////////////// 
	k = arcCount / -2;
	for (i = 0; i < list_count(allArcs); i++)
	{
	    if (gde_symbol_is_arc(list_get(allArcs,i)))
	    {
		k += moveAnArc
		    (to_gde_arc(list_get(allArcs,i)),(k*arcStep),arcStep);
	    }
	    else // extension point
	    {
		k++;
		moveANode
		    (to_gde_node(list_get(allArcs,i)),
			gde_node_x(to_gde_node(list_get(allArcs,i))),
			(((k-1)*arcStep)+yNodeOffset));
	    }
	}
	/////////////////////////////////////////////////////////////////////// 
	// zoom the buffer and end the transaction
	/////////////////////////////////////////////////////////////////////// 
	gde_builtin("BufferZoom FitDiagram");
	gde_end_edit_transaction(GDE_CMD_INSERT, theTransaction, False);
    }
    ///////////////////////////////////////////////////////////////////////////
    // return list of sorted arcs used by resequence program
    ///////////////////////////////////////////////////////////////////////////
    return(allArcs);
}

////////////////////////////////////////////////////////////////////////////////
//  Shift all messages down from selected (this will provide room for a new
//  message.
//  BIG NOTE:  the gde_node_scale function doesn't appear to be working as 
//  stated.  To enlarge a node using gde_scale_node from the upper left corner
//  cause a displacement of some of the arcs.  This is unacceptable. To 
//  compensate all arc positions are first gathered and saved
//  and arcs are moved according to this "pre-node scale" saved information.
////////////////////////////////////////////////////////////////////////////////
void shiftMessagesDown()
{
    list selectedSymbols = gde_selected_symbols();
    list allArcs;
    list allNodes;
    list nodeTypesList;
    list allArcsOfThisMessage;
    list arcsPreNodeExpansionYPos;
    list arcsPostNodeExpansionYPos;
    gde_symbol selectedSymbol;
    int foundFrom;
    int distance;
    int nodeHeight;
    int nodeWidth;
    int previousPosition;
    int newPosition;
    int theTransaction;
    int i, j;

    ////////////////////////////////////////////////////////////////////////////
    // Save the state and start the transaction
    ////////////////////////////////////////////////////////////////////////////
    gde_save_state();
    theTransaction = gde_start_edit_transaction();
    ////////////////////////////////////////////////////////////////////////////
    // get selected message 
    ////////////////////////////////////////////////////////////////////////////
    selectedSymbol = list_get(selectedSymbols,0);
    ////////////////////////////////////////////////////////////////////////////
    // distribute and get all the arcs
    ////////////////////////////////////////////////////////////////////////////
    allArcs = distributeAllArcs("compairArcsBasedOnYPosition");
    ////////////////////////////////////////////////////////////////////////////
    // See BIG NOTE Above
    ////////////////////////////////////////////////////////////////////////////
    arcsPreNodeExpansionYPos = list_create("int",0);
    for (i = 0; i < list_count(allArcs); i++)
	if (gde_symbol_is_arc(list_get(allArcs,i)))
	    list_append(arcsPreNodeExpansionYPos,
		gde_arc_fromy(to_gde_arc(list_get(allArcs,i))));
	else  // handle those ugly extension points
	    list_append(arcsPreNodeExpansionYPos,
		gde_node_y(to_gde_node(list_get(allArcs,i))));
    ////////////////////////////////////////////////////////////////////////////
    // traverse the sorted list to the selected item
    ////////////////////////////////////////////////////////////////////////////
    foundFrom = -1;
    for (i = 0; (i < list_count(allArcs)) && (foundFrom == -1); i++)
	if (gde_symbol_is_arc(list_get(allArcs,i)))
	{
	    allArcsOfThisMessage = 
	       getAllArcsOfThisMessage(to_gde_arc(list_get(allArcs,i)));
	    for (j = 0; 
	        ((j < list_count(allArcsOfThisMessage)) && (foundFrom == -1)); 
		j++)
	        if (list_get(allArcsOfThisMessage,j) == 
		   to_gde_arc(selectedSymbol))
	           foundFrom = i;
	}
    ////////////////////////////////////////////////////////////////////////////
    // Setup the adjustment spacing based on the distance from the selected
    // arc (foundFrom) and the next arc or extension point.  BIG NOTE applies
    ////////////////////////////////////////////////////////////////////////////
    previousPosition = list_get(arcsPreNodeExpansionYPos,foundFrom);
    ////////////////////////////////////////////////////////////////////////////
    // Should the next arc not exist (selected arc is the last arc) 
    // simply set the distance to some predeteremined value.
    ////////////////////////////////////////////////////////////////////////////
    if ((foundFrom+1) < list_count(allArcs))
	distance = previousPosition - 
			list_get(arcsPreNodeExpansionYPos,foundFrom+1);
    else
	distance = 20;
    /////////////////////////////////////////////////////////////////////////// 
    // Get all the nodes of type Actor and Object 
    /////////////////////////////////////////////////////////////////////////// 
    nodeTypesList = sequenceCollaborationObjectTypes("");
    allNodes = getAllSymbolsOfType(nodeTypesList);
    ////////////////////////////////////////////////////////////////////////////
    // Compute the new node size by getting the first node size and adding the
    // shift distance  (all nodes are same length at this point because of 
    // previous distributeAllArcs("compairArcsBasedOnYPosition") call.
    ////////////////////////////////////////////////////////////////////////////
    nodeHeight = gde_node_height(to_gde_node(list_get(allNodes,0)));
    nodeWidth  = gde_node_width(to_gde_node(list_get(allNodes,0)));
    ////////////////////////////////////////////////////////////////////////////
    // For all nodes expand to their new size of distance + original size
    ////////////////////////////////////////////////////////////////////////////
    for (i = 0; i < list_count(allNodes); i++)
        gde_node_scale(to_gde_node(list_get(allNodes,i)),
	     0,nodeWidth,(nodeHeight-distance)); // 0 = UPPER_LEFT_CORNER
    ////////////////////////////////////////////////////////////////////////////
    // Go though the positions list and recompute the new spread position
    ////////////////////////////////////////////////////////////////////////////
    arcsPostNodeExpansionYPos = list_create("int",0);
    for (i = 0; i < list_count(arcsPreNodeExpansionYPos); i++)
    {
	if (i < foundFrom)
	    newPosition = list_get(arcsPreNodeExpansionYPos,i) + distance;
	else
	    newPosition = list_get(arcsPreNodeExpansionYPos,i) - (distance/2);
	list_append(arcsPostNodeExpansionYPos,newPosition);
    }
    ////////////////////////////////////////////////////////////////////////////
    // for all of the arcs reposition on new expanded Objects
    ////////////////////////////////////////////////////////////////////////////
    for (i = 0; i < list_count(allArcs); i++)
    {
	if (gde_symbol_is_arc(list_get(allArcs,i)))
	    moveAnArc(to_gde_arc(list_get(allArcs,i)),
		list_get(arcsPostNodeExpansionYPos,i), distance);
	else // extension points are nodes. as previously seen on TV
	    moveANode(to_gde_node(list_get(allArcs,i)),
		gde_node_x(to_gde_node(list_get(allArcs,i))),
		list_get(arcsPostNodeExpansionYPos,i));
    }
    ////////////////////////////////////////////////////////////////////////////
    // zoom the buffer and end the transaction
    ////////////////////////////////////////////////////////////////////////////
    gde_builtin("BufferZoom FitDiagram");
    gde_end_edit_transaction(GDE_CMD_INSERT, theTransaction, False);
}

////////////////////////////////////////////////////////////////////////////////
//  Resequence this label strips off the sequence number if it exists
//  and puts on a new one passed in as the second parameter.
////////////////////////////////////////////////////////////////////////////////
string resequenceThisLabel(string label, int sequenceNumber, boolean isExtPoint)
{
    list labelComponents;
    string newLabel;
    labelComponents = uml_parse_message_label(label);
    list_set(labelComponents,1,to_string(sequenceNumber));
    newLabel = uml_build_new_label(labelComponents,isExtPoint);
    return(newLabel);
}

////////////////////////////////////////////////////////////////////////////////
//  Resequence all messages based on position
////////////////////////////////////////////////////////////////////////////////
void resequenceAllMessages()
{
    list sortedArcs;
    list allArcsOfThisMessage;
    gde_arc labelArc;
    int currentSequenceValue;
    int theTransaction;
    string label;
    int i, j;

    ////////////////////////////////////////////////////////////////////////////
    // Save the state and start the transaction
    ////////////////////////////////////////////////////////////////////////////
    gde_save_state();
    theTransaction = gde_start_edit_transaction();
    ////////////////////////////////////////////////////////////////////////////
    // align all messages based on position
    ////////////////////////////////////////////////////////////////////////////
    sortedArcs = distributeAllArcs("compairArcsBasedOnYPosition");
    ////////////////////////////////////////////////////////////////////////////
    // add sequence numbers
    ////////////////////////////////////////////////////////////////////////////
    for (i = 0; i < list_count(sortedArcs); i++)
    {
	if (gde_symbol_is_arc(list_get(sortedArcs,i)))
	{
        label = gde_arc_get_first_label(to_gde_arc(list_get(sortedArcs,i)));
	    labelArc = to_gde_arc(list_get(sortedArcs,i));
	    allArcsOfThisMessage = getAllArcsOfThisMessage(labelArc);
	    for (j = 0; j < list_count(allArcsOfThisMessage); j++)
	    {
		if (gde_arc_label(list_get(allArcsOfThisMessage,j)) != "")
		{
		    labelArc = list_get(allArcsOfThisMessage,j);
		    j = list_count(allArcsOfThisMessage);
		}
	    }
	    gde_arc_set_label(labelArc,resequenceThisLabel(label,i,False));
	}
	else // extension point
	{
	    label = gde_node_label(to_gde_node(list_get(sortedArcs,i)));
	    gde_node_set_label(to_gde_node(list_get(sortedArcs,i)),
		resequenceThisLabel(label,i,True));
	}
    }
    ////////////////////////////////////////////////////////////////////////////
    // zoom the buffer and end the transaction
    ////////////////////////////////////////////////////////////////////////////
    gde_builtin("BufferZoom FitDiagram");
    gde_end_edit_transaction(GDE_CMD_INSERT, theTransaction, False);
}

////////////////////////////////////////////////////////////////////////////////
// Hey look - Globalies
// Used by the Auto Align routines
////////////////////////////////////////////////////////////////////////////////
boolean __autoAlign = False;
int __yBase = -1;
int __xBase = -1;
int __xStep = -1;
int __xMin  = -1;
int __xMax  = -1;
list __allSymbols = NULL;

////////////////////////////////////////////////////////////////////////////////
// Check for existing objects when turning on auto align
////////////////////////////////////////////////////////////////////////////////
void alignComputeStepMinAndMax()
{
    list allObjectsActors;
    allObjectsActors = 
	list_sort_all(getAllSymbolsOfType(sequenceCollaborationObjectTypes("")),
		"compairNodesBasedOnXPosition");
    // can only get here if there are at least 2 items in all object actors list
    __xMin = __xBase = gde_node_x(to_gde_node(list_get(allObjectsActors,0)));
    __xMax = gde_node_x(to_gde_node(list_get(allObjectsActors,list_count(allObjectsActors)-1)));
    __xStep = gde_node_x(to_gde_node(list_get(allObjectsActors,1))) - 
		gde_node_x(to_gde_node(list_get(allObjectsActors,0)));
    __yBase = gde_node_y(to_gde_node(list_get(allObjectsActors,0)));
}

////////////////////////////////////////////////////////////////////////////////
// Check for existing objects when turning on auto align
////////////////////////////////////////////////////////////////////////////////
boolean autoAlignStartCheckForExistingObjects()
{
    list allObjectsActors;
    boolean allAligned;
    boolean returnValue = True;
    int i;

    allObjectsActors = getAllSymbolsOfType(sequenceCollaborationObjectTypes(""));

    if (list_count(allObjectsActors) > 0)
    {
	__xMin = __xMax = __xBase = gde_node_x(to_gde_node(list_get(allObjectsActors,0)));
	__yBase = gde_node_y(to_gde_node(list_get(allObjectsActors,0)));
    	if (list_count(allObjectsActors) > 1)
    	{
	    allAligned = True;
	    for (i = 1; i < list_count(allObjectsActors) && allAligned; i++)
	        if (__yBase != gde_node_y(to_gde_node(list_get(allObjectsActors,i))))
		     allAligned = False;
	    if (allAligned)
	    {
		alignComputeStepMinAndMax();
	    }
	    else
	    {
		print_message("Existing objects are not aligned!");
		if (editor_confirm("Align Existing Objects?","OK","Cancel Auto Align"))
		{
    		    alignAllObjects();
		    alignComputeStepMinAndMax();
		}
		else
		{
     		     clearAutoAlignParameters();
		     returnValue = False;
		}
	    }
    	}
    }

    return(returnValue);
}

////////////////////////////////////////////////////////////////////////////////
// Toggle Auto Align
////////////////////////////////////////////////////////////////////////////////
void toggleAutoAlign()
{
    const int OBJECT_AUTOALIGN = 9709031428;  // use date & time as unique id
    if (!__autoAlign) // setup the callback
    {
	gde_builtin("EditorActionDoneAfter "+
		OBJECT_AUTOALIGN+" doObjectAutoAlign();");
	__allSymbols = gde_all_symbols();
	__xMin = __xMax = __xStep = __xBase = __yBase = -1;
	if (__autoAlign = autoAlignStartCheckForExistingObjects())
	     print_message("Auto align started");
    }
    else // turn it off
    {
	gde_builtin("EditorActionDoneAfter "+ OBJECT_AUTOALIGN);
     	clearAutoAlignParameters();
    }
}

////////////////////////////////////////////////////////////////////////////////
// Handles Autoalign via the name functions for Actors and Objuct
////////////////////////////////////////////////////////////////////////////////
void doObjectAutoAlign()
{
    int currentAction = gde_node_sym_current_action();
    gde_symbol currentObject;

    if (currentAction == GDE_CMD_INSERT)
    {
	currentObject = getCurrentAutoAlignObject();
	if (currentObject != NULL)
	    continueObjectAutoAlign(currentObject);
    }
}

gde_symbol getCurrentAutoAlignObject()
{
    list allSymbols = gde_all_symbols();
    int i;
    int pos;
    gde_symbol returnValue = NULL;
    string symbolType;

    for (i = 0; i < list_count(allSymbols) && returnValue == NULL; i++)
    {
 	symbolType = gde_get_symbol_type(list_get(allSymbols,i));
	if (symbolType == "PassiveObject" || symbolType == "ActiveObject" ||
            symbolType == "Actor")
	{
	    pos = list_find(__allSymbols, 0, list_get(allSymbols, i));
	    if (pos == list_count(__allSymbols))
	    {
		list_append(__allSymbols, list_get(allSymbols,i));
		returnValue = list_get(allSymbols,i);
	    }
	}
    }
    return(returnValue);
}

void continueObjectAutoAlign(gde_symbol theObject)
{
    gde_node theNode = to_gde_node(theObject);
    if (__autoAlign)
    {
	////////////////////////////////////////////////////////////////////////
	//  If __yBase == -1 then no nodes have been placed yet
	////////////////////////////////////////////////////////////////////////
	if (__yBase == -1)
	{
	    __xMin = __xMax = __xBase = gde_node_x(theNode);
	    __yBase = gde_node_y(theNode);
	}
	else
	{
	    if (__xStep == -1)
	    {
		__xStep = gde_node_x(theNode) - __xBase;
	    }
	    if (gde_node_x(theNode) < __xMin)
	    {
// ECR 4901 begin
	    	//moveANode(theNode,__xMin - __xStep,__yBase);
	    	moveANode(theNode,gde_node_x(theNode),__yBase);
// ECR 4901 end
	    	__xMin -= __xStep;
	    }
	    else 
	    {
// ECR 4901 begin
	    	//moveANode(theNode,__xMax + __xStep,__yBase);
	    	moveANode(theNode,gde_node_x(theNode),__yBase);
// ECR 4901 end
	    	__xMax += __xStep;
	    }
	}
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//  Menu Activity Functions -
//     The next set of functions handle the menu activity status and
//     menu strings.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//  Shut down autoalign
////////////////////////////////////////////////////////////////////////////////
void clearAutoAlignParameters()
{
    __autoAlign = False;
    __yBase = __xBase = __xStep = __xMin = __xMax  = -1;
    if (__allSymbols != NULL)
	list_clear(__allSymbols);
    print_message("Auto Align Cancelled");  // Now I know 401 words! 'cessation'
}

////////////////////////////////////////////////////////////////////////////////
//  This routine will perform a standard builtin (passed in as a parameter)
//  and then turn auto alignment off.  This is useful to make sure Auto align
//  doesn't remain on in cases where the user has loaded another diagram.
////////////////////////////////////////////////////////////////////////////////
void doBuiltinAndTurnAutoAlignOff(string builtInString)
{
    if (builtInString != NULL && builtInString != "")
	gde_builtin(builtInString);
    clearAutoAlignParameters();
}

////////////////////////////////////////////////////////////////////////////////
//  Special case do same above but call another routine to start recent diag 
//  stuff
////////////////////////////////////////////////////////////////////////////////
void recent_menu_show_diag_andTurnAutoAlignOff()
{
    clearAutoAlignParameters();
    recent_menu_show_diag();
}

// ECR 4901 begin
////////////////////////////////////////////////////////////////////////////////
//  Special case do same above but call another routine to open new diag 
////////////////////////////////////////////////////////////////////////////////
void open_new_diag_andTurnAutoAlignOff()
{
    clearAutoAlignParameters();
    new_file();
}
// ECR 4901 end

////////////////////////////////////////////////////////////////////////////////
//  The following auto align stuff applies to UML Menu Item 
//  Turn Auto Align - On / Off
////////////////////////////////////////////////////////////////////////////////
string autoAlignLabelFunc()
{
    if (__autoAlign)
	return("Turn Auto Alignment Off");
    else
	return("Turn Auto Alignment On");
}

///////////////////////////////////////////////////////////////////////////////
//  UML - "Expand All Object 50%", "Expand All Objects to Selected Size"
///////////////////////////////////////////////////////////////////////////////
string expandAllObjectsLabelFunc()
{
    /////////////////////////////////////////////////////////////////////////// 
    // if one of the objects is longer than the other or is selected
    // return Expand less reutrn expand by 50%
    ///////////////////////////////////////////////////////////////////////////
    if (objectOrActorIsSelectedActiveFunc())
    	return("&Expand All Objects To Selected Size");
    else
    	return("&Expand All Objects 50%");
}

///////////////////////////////////////////////////////////////////////////////
//  Called by expandAllObjectsLabelFunc, and expandAllObjects
///////////////////////////////////////////////////////////////////////////////
boolean objectOrActorIsSelectedActiveFunc()
{
    boolean returnValue = False;
    gde_symbol currentSymbol;
    string symbolType;
    list selectedSymbols = gde_selected_symbols();
    list nodeTypesList = sequenceCollaborationObjectTypes("");

    if (list_count(selectedSymbols) == 1)
    {
	currentSymbol = list_get(selectedSymbols,0);
	if (gde_symbol_is_node(currentSymbol)) 
	{
	    symbolType = gde_get_symbol_type(currentSymbol);
	    if (list_find(nodeTypesList,0,symbolType) != 
		list_count(nodeTypesList))
	    	returnValue = True;
	}
    }

    return(returnValue);
}

///////////////////////////////////////////////////////////////////////////////
//  UML - activity function
///////////////////////////////////////////////////////////////////////////////
int messageIsSelectedActiveFunc()
{
    int returnValue = ACTIVE_FUNC_IS_INACTIVE;
    gde_symbol currentSymbol;

    list selectedSymbols = gde_selected_symbols();
    if (list_count(selectedSymbols) == 1)
    {
	currentSymbol = list_get(selectedSymbols,0);
	if (gde_symbol_is_arc(currentSymbol)) 
	{
	    ///////////////////////////////////////////////////////////////////
	    // All selecteable arcs are messages on squence editor
	    ///////////////////////////////////////////////////////////////////
    	    returnValue = ACTIVE_FUNC_IS_ACTIVE;
	}
    }
    return(returnValue);
}

///////////////////////////////////////////////////////////////////////////////
//  UML - if a diagram has at least one message activity function
///////////////////////////////////////////////////////////////////////////////
int diagramHasMessagesActiveFunc()
{
    gde_symbol currentSymbol;
    int i;
    int returnValue = ACTIVE_FUNC_IS_INACTIVE;
    list allSymbols = gde_all_symbols();

    for (i = 0; 
	((returnValue == ACTIVE_FUNC_IS_INACTIVE) && 
	    (i < list_count(allSymbols))); i++)
    {
	currentSymbol = list_get(allSymbols,i);
	if (gde_symbol_is_arc(currentSymbol)) 
	    returnValue = ACTIVE_FUNC_IS_ACTIVE;
    }

    return(returnValue);
}

///////////////////////////////////////////////////////////////////////////////
//  UML - if a diagram has at least one object or actor activity function
///////////////////////////////////////////////////////////////////////////////
int diagramHasActorsOrObjectsActiveFunc()
{
    int returnValue = ACTIVE_FUNC_IS_INACTIVE;
    list allSymbols = gde_all_symbols();
    gde_symbol currentSymbol;
    string symbolType;
    list nodeTypesList = sequenceCollaborationObjectTypes("");
    int i;

    for (i = 0; 
	((returnValue == ACTIVE_FUNC_IS_INACTIVE) && 
	    (i < list_count(allSymbols))); i++)
    {
	currentSymbol = list_get(allSymbols,i);
	symbolType = gde_get_symbol_type(currentSymbol);
	if (list_find(nodeTypesList,0,symbolType) != 
	    list_count(nodeTypesList))
	   returnValue = ACTIVE_FUNC_IS_ACTIVE;
    }

    return(returnValue);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Semantics
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
int usequenced_check_semantics()
{
    int 	errCount 	= 0;
    int 	warningCount 	= 0;
    string 	dg_name 	= gde_diagram_name();
    string 	dg_type 	= current_editor_apptype();

    errCount += interaction_dg_completeness_check_actors
		(dg_type+" & name='"+dg_name+"'");
    warningCount += interaction_dg_completeness_check_parent
		(dg_name,dg_type,"[file["+dg_type+" && name='"+dg_name+"']]");
    errCount += interaction_dg_completeness_check_externalEvents
		("[file["+dg_type+" && name='"+dg_name+"']]");
    errCount += interaction_dg_completeness_check_messages();
    errCount += interaction_dg_completeness_check_objects
		("file[name='"+dg_name+"']");
    errCount += interaction_dg_check_extension_points();

    return errCount;
}

boolean
usequenced_CheckSyntax()
{
    int i;
    boolean diagramIsClean = True;
    string current_type;
    string pretty_name = "Node";
    list symbols;
    gde_symbol current_symbol;
    gde_node current_node;

    // Checking for labels on Active Objects and Passive Objects.
    // NameIsRequired attribute on the mappings aren't picking these up.

    symbols = gde_all_symbols();
    for (i=0; i<list_count(symbols); i++)
    {
        current_symbol = list_get(symbols, i);

        if (gde_symbol_is_node(current_symbol))
        {
            current_node = to_gde_node(current_symbol);
            current_type = gde_nt_name(gde_node_nt(current_node));

            if (current_type == "ActiveObject" ||
                current_type == "PassiveObject")
            {
                if (gde_node_label(current_node) == "")
                {
                    if (current_type == "ActiveObject")
                        pretty_name = "Active Object";
                    else if (current_type == "PassiveObject")
                        pretty_name = "Passive Object";

                    gde_print_error(pretty_name + " must have a label.",
                                    gde_node_psymid(current_node));
                    diagramIsClean = False;
                }
            }
        }
    }

    // Now run the default gde syntax checks.

    if (gde_default_check_syntax() == False)
    diagramIsClean = False;

    return diagramIsClean;
}

//  Add any user customizations to the file included below:
#include_if_exists "user/uml/rules/qrl/user_usequenced.qrl"
