
//      StP/UML
//      Confidential property of Aonix
//      Copyright (c) 1997
//      All rights reserved
//

#include "rules/qrl/uml.inc"
#include "rules/qrl/gde_qrl_std.inc"
#include "rules/qrl/uusecased.ps.qrl"
#include "rules/qrl/gde_utils.inc"
#include "rules/qrl/package_sym_rename.inc"
#include "rules/qrl/gde_uml_object_rename.inc"
#include "rules/qrl/re_pe_label_funcs.inc"
#include "rules/qrl/pe_nav.inc"
#include "qrl/include/export_to_doors.inc"

// local definitions needed for generic navigation code
#include "rules/qrl/uml_ada_nav.inc"

// ECR4052 Model Management
#include "rules/qrl/model_management.inc"

// Begin ECR947, ECR 4494
#include "rules/qrl/note_link.inc"

// ECR 4731
#include "rules/qrl/navtostp.inc"

#include "rules/qrl/default_arc_type.inc" //ECR 6469

const    int    ACTIVE_FUNC_IS_UNDEFINED = -1; // SAME AS OMT

list    the_last_selection = NULL; // SAME AS OMT

int    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;

boolean
idehook_invalidate_all()
{
    idehook_note_link_active_func_lv = ACTIVE_FUNC_IS_UNDEFINED;
    return(True);
}

// SAME AS OMT
void
idehook_force_new_selection()
{
    the_last_selection = NULL;
    idehook_invalidate_all();
}

// SAME AS OMT
boolean
idehook_did_selection_change()
{
    list    symbols;

    symbols = gde_selected_symbols();

    if (the_last_selection == NULL)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (list_count(symbols) != list_count(the_last_selection))
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    if (lists_equal(symbols, the_last_selection) == False)
    {
    the_last_selection = symbols;
    return(idehook_invalidate_all());
    }
    return(False);
}

list
uml_note_link_symbols()
{
    string link_types = "Communicates Extends Uses Inherits Generalization";
    return string_to_list(link_types, " ");
}
// End ECR947, ECR 4494

// ECR 7735
boolean UseCaseHasScenarioOrActivity( string nodeName )
{
    item scenario = find_by_query( "item[UmlParentNameItem && node[UmlScenarioInstance && node_refs] && value = '${nodeName}']" );
    if( scenario != NULL )
        return True;
    node_ref activity = find_by_query( "node_ref[file[UmlActivityDiagram] && node[UmlStateMachine && name='${nodeName}']]" );
    if( activity != NULL )
        return True;
    return False;
}

boolean FindOrCreateScenarioSequenceDg(int nodeId)
{
    string cmd="FindOrCreateScenarioForUseCase("+nodeId+");";
    NavigateSendQrl("usequenced",cmd);
    return True;
}

boolean FindOrCreateScenarioCollaborationDg(int nodeId)
{
    string cmd="FindOrCreateScenarioForUseCase("+nodeId+");";
    NavigateSendQrl("ucollaborationd",cmd);
    return False;
}

list FindActivityDiagramWithCorrespondingScenario(int nodeId)
{
    node useCase = find_by_query("node[${nodeId}]");
    // check if there is a state machine with this name
    string qFindNamedStateMachine = "node_ref[file[UmlActivityDiagram] && node[UmlStateMachine && name='${useCase.name}']]";
    list result = list_select(qFindNamedStateMachine);
    if(list_count(result)==0)
	print_message("Target (Activity Diagram with a Use Case scenario) not found");
	return(result);
}

boolean FindOrCreateScenarioActivityDg(int nodeId)
{
    //string cmd="UmlStateDiagramInitFromUseCase("+nodeId+");";
	string cmd="FindOrCreateScenarioForUseCaseInActivityDiagram("+nodeId+");";
	NavigateSendQrl("uactivityd",cmd);
    return True;
}


list FindScenarioInvolvingExternalEvent(int linkId)
{
    //find the communicates link that is source of navigation
    link commLink = find_by_query("link[${linkId}]");
    node theActor = find_by_query("node[${commLink.from_node_id}]");
    node theUseCase = find_by_query("node[${commLink.to_node_id}]");
    //node theScenario = find_by_query(qFindScenario);
    //string qFindExternalEventLink = "link_ref[file[(UmlSequenceDiagram || UmlCollaborationDiagram) && node_refs[node[UmlScenarioInstance && items[UmlParentTypeItem && value='${theUseCase.type}'] && items[UmlParentNameItem && value='${theUseCase.name}']]] && node_refs[node[${theActor.id}]]] && link[from_node_id=${theActor.id}]]";
    string qFindExternalEventLink = "link_ref[file[(UmlSequenceDiagram || UmlCollaborationDiagram) && node_refs[node[UmlScenarioInstance && items[UmlParentTypeItem && value='${theUseCase.type}'] && items[UmlParentNameItem && value='${theUseCase.name}']]]] && link[from_node_id=${theActor.id}]]";

    //link_ref extEventLink_Ref = find_by_query(qFindExternalEventLink);
    list extEventLinkRefs_list = list_select(qFindExternalEventLink);
    if(list_count(extEventLinkRefs_list)==0) {
	print_message("Target (scenario with corresponding external event) not found");
	return NULL;
    }
//     string cmd="FindOrCreateScenarioForUseCase("+linkId+");";
//     NavigateSendQrl("ucollaborationd",cmd);
    return(extEventLinkRefs_list);
}


// string uml_label_mark_func_get_default(list matched_items,string defaultVal)
// {
//     string result = defaultVal;
//     item anItem;
//     int howMany = list_count(matched_items);
//     if(howMany==1) {
// 	anItem = list_get(matched_items, 0);
// 	result = anItem.value;
//     }
//     result = "«" + result + "»";
//     //message("uml_label_mark_func_get_default::count="+howMany+"result='"+result+"'");
//     return(result);
// }


// This function takes a list of items and creates a comma and \n
// separated list of them. open_str and close_str are used to enclose
// the string
// string uml_dpymark_list_formatter(list matched_items, string open_str,
// 		string close_str)
// {
//     item            one_item;
//     int             i;
//     string          props = open_str;
// 	int             numItems = list_count(matched_items);

//     for (i = 0; i < numItems; i = i + 1)
//     {
// 		one_item = list_get(matched_items, i);

// 		if (NULL != one_item.value && "" != one_item.value)
// 		{
// 			if (i > 0) {
// 				props += ",\n";
// 			}
// 			props += one_item.value;
// 		} 
//     }
// 	props += close_str;
//     return props;
// }

int
uusecased_check_semantics()
{
    int errCount = 0;
    string dg_name = gde_diagram_name();
    string dg_type = current_editor_apptype();

    errCount += uusecased_completeness_check_usecases_have_scenarios();
    //errCount += uml_completeness_check_usecases_have_scenarios("[file[name='"+dg_name+"']]");
    errCount += uusecased_completeness_check_actors_have_scenarios(" && name='"+dg_name+"'");
    errCount += uusecased_completeness_check_externalEvents();
    //errCount += uml_completeness_check_externalEvents("[file[name='"+dg_name+"']]");
    //errCount += uusecased_consistency_check_actors_scenarios("[name='"+dg_name+"']");
    errCount += uusecased_check_extension_points();
    //errCount += uml_check_extension_points("[name='"+dg_name+"']");

    return errCount;
}

const string UML_USECASE = "UseCase";
const string UML_ACTOR = "Actor";
const string UML_COMMUNICATES = "Communicates";
const string UML_EXTENDS = "Extends";

int
uusecased_completeness_check_usecases_have_scenarios()
{
    // Check all actors in the current diagram
    list useCaseGNodes = gde_nodes_find_by_type(gde_all_symbols(),UML_USECASE);
    list nodes;
    gde_node ucGNode;
    node useCase;
    int ii;
    int errCount = 0;
    string useCaseStr = " UseCases do";
    node_ref aScenario;
    const string qFindScenarios = "node_ref[node[UmlScenarioInstance && items[UmlParentNameItem && value='${useCase.name}'] && items[UmlParentTypeItem && value='UmlUseCase']] && file[UmlSequenceDiagram || UmlCollaborationDiagram]]";
    
    print_message("Checking Use Cases ...");

    for(ii = 0; ii < list_count(useCaseGNodes); ii++) {
	ucGNode = list_get(useCaseGNodes,ii);
	//print_node("checking node "+ii+":",ucGNode);
	nodes = gde_node_oms_nodes(ucGNode);
	if(list_count(nodes) == 0) {
	    errCount++;
	    gde_print_error("Use Case '"+gde_node_label(ucGNode)+"' does not have mapped object",gde_node_psymid(ucGNode));
	    continue;
	}
	useCase = list_get(nodes,0);
	aScenario = find_by_query(qFindScenarios);
	if(aScenario==NULL) {
	    errCount++;
	    gde_print_error("Use Case '"+useCase.name+"' does not have an interaction scenario",gde_node_psymid(ucGNode));
	}
    }
    return errCount;
}

int
uusecased_completeness_check_actors_have_scenarios(string constraint_dg_name)
{
    print_message("Checking Actors ...");
    int ii;
    int count;
    int errCount = 0;
    node actor;
    node_ref actorRef;
    string actorStr = " Actors do";
    list actors = list_select("node[UmlActor && node_refs[file[UmlUseCasediagram "+constraint_dg_name+"]] && !node_refs[file[UmlSequenceDiagram || UmlCollaborationDiagram]]]");
    count = list_count(actors);
    if(count > 0) {
	if(count==1)
	    actorStr = " Actor does";
	print_message(count + actorStr + " not appear in any interaction scenario:");
	for(ii=0; ii<count; ii++) {
	    actor = list_get(actors,ii);
	    actorRef = find_by_query("node_ref[node_id=${actor.id}]");
	    gde_print_error("Actor '"+actor.name+"' does not appear in any interaction scenario",to_int(actorRef.appid));
	}
    }
    errCount = count;
    return errCount;
}

int uusecased_completeness_check_externalEvents()
{
    // Check all Communicates links in the current diagram
    const string qFindExternalEventLink = "link_ref[file[(UmlSequenceDiagram || UmlCollaborationDiagram) && node_refs[node[UmlScenarioInstance && items[UmlParentTypeItem && value='${theUseCase.type}'] && items[UmlParentNameItem && value='${theUseCase.name}']]]] && link[from_node_id=${theActor.id}]]";
    list commLinks = gde_arcs_find_by_type(gde_all_symbols(),UML_COMMUNICATES);
    gde_arc gArc;
    link commLink;
    node theActor;
    node theUseCase;
    int ii, errCount = 0;
    link_ref aCommRef;
    list gdeArcLinks, links, extEventLinkRefs_list;
    
    print_message("Checking Communicates links ...");

    for(ii = 0; ii < list_count(commLinks); ii++) {
	gArc = list_get(commLinks,ii);
	gdeArcLinks = gde_arc_links(gArc);
	//print_arc("checking arc "+ii+":",gArc);
	links = gde_link_oms_links(list_get(gdeArcLinks,0));
	if(list_count(links) == 0) {
	    errCount++;
	    gde_print_error("Communicates link '"+gde_arc_label(gArc)+"' does not have mapped object",gde_arc_psymid(gArc));
	    continue;
	}
	commLink = list_get(links,0);
	theActor = find_by_query("node[${commLink.from_node_id}]");
	theUseCase = find_by_query("node[${commLink.to_node_id}]");
	extEventLinkRefs_list = list_select(qFindExternalEventLink);
	if(list_count(extEventLinkRefs_list)==0) {
	    errCount++;
	    gde_print_error("Interaction between Actor '"+theActor.name+"' and Use Case '"+theUseCase.name+"' does not have a corresponding external event in any scenario", gde_arc_psymid(gArc));
	}
    }
    return errCount;
}


int uml_completeness_check_externalEvents(string constraint_dg_name)
{
    // Check all Communicates links in a given diagram
    const string qFindCommunicatesLinks = "link[UmlUseCaseInteraction && link_refs"+constraint_dg_name+"]";
    const string qFindExternalEventLink = "link_ref[file[(UmlSequenceDiagram || UmlCollaborationDiagram) && node_refs[node[UmlScenarioInstance && items[UmlParentTypeItem && value='${theUseCase.type}'] && items[UmlParentNameItem && value='${theUseCase.name}']]]] && link[from_node_id=${theActor.id}]]";
    int errCount = 0;
    link commLink;
    node theActor;
    node theUseCase;
    list extEventLinkRefs_list;
    for_each_in_select(qFindCommunicatesLinks, commLink) {
	theActor = find_by_query("node[${commLink.from_node_id}]");
	theUseCase = find_by_query("node[${commLink.to_node_id}]");
	extEventLinkRefs_list = list_select(qFindExternalEventLink);
	if(list_count(extEventLinkRefs_list)==0) {
	    errCount++;
	    print_error("Interaction between Actor '"+theActor.name+"' and Use Case '"+theUseCase.name+"' does not have a corresponding external event in any scenario");
	}
    }
    return errCount;
}


int
uml_check_extension_points(string constraint_dg_name)
{
    return 0;
}

int uusecased_check_extension_points()
{
    // Check all Extend Use Cases in the current diagram
    print_message("Checking Extend Use Cases links ...");
    // First find all extends links
    list extLinks = gde_arcs_find_by_type(gde_all_symbols(),UML_EXTENDS);
    gde_node extendUC, extendedUc;
		
const string qFindScenarioFile = "file[(UmlSequenceDiagram || UmlCollaborationDiagram) & node_refs[node[id=${theExtPoint.id}]] & node_refs[node[UmlScenarioInstance & items[UmlParentTypeItem & value='${extendedUseCase.type}'] & items[UmlParentNameItem & value='${extendedUseCase.name}']]]]";
    gde_arc gArc;
    link commLink;
    node useCase, theExtPoint,extendedUseCase;
    int ii, errCount = 0;
    link_ref aCommRef;
    list nodes;
    file scenarioFile;
    
    for(ii = 0; ii < list_count(extLinks); ii++) {
	gArc = list_get(extLinks,ii);
	extendUC = gde_arc_fromnode(gArc);
        if (gde_nt_name(gde_node_nt(extendUC)) == "Vertex" )
            continue;

	//print_node("checking Use Case "+ii+":",extendUC);
	nodes = gde_node_oms_nodes(extendUC);
	if(list_count(nodes) == 0) {
	    errCount++;
	    gde_print_error("The Extend Use Case '"+gde_node_label(extendUC)+"' does not have mapped object",gde_node_psymid(extendUC));
	    continue;
	}
	useCase = list_get(nodes,0);
	theExtPoint = find_by_query("node[UmlExtensionPoint & name='${useCase.name}' & node_refs]");
	if(theExtPoint==NULL) {
	    errCount++;
	    gde_print_error("The Extend Use Case '"+gde_node_label(extendUC)+"' does not have a corresponding Extension Point", gde_node_psymid(extendUC));
	} else {
	    extendedUc = gde_arc_tonode(gArc);
            if (gde_nt_name(gde_node_nt(extendedUc)) == "Vertex" )
                continue;
	    nodes = gde_node_oms_nodes(extendedUc);
	    if(list_count(nodes) == 0) {
		errCount++;
		gde_print_error("The Extended Use Case '"+gde_node_label(extendedUc)+"' does not have mapped object",gde_node_psymid(extendedUc));
		continue;
	    }
	    extendedUseCase = list_get(nodes,0);
	    scenarioFile = find_by_query(qFindScenarioFile);
	    //if(scenarioFile==NULL) 
	    if(!return_scenario_with_extension(extendedUseCase, theExtPoint))
            {
		errCount++;
		gde_print_error("The Extend Use Case '"+gde_node_label(extendUC)+"' does not have an Extension Point in the scenario of the Use Case it extends", gde_node_psymid(extendUC));
	    }
	}
    }
    return errCount;
}



boolean
return_scenario_with_extension(node extendedUseCase, node theExtPoint)
{

    int x, y;
    node current_scen_node;
    item current_item;
    string nm_item_query, tp_item_query;
    list nm_item_list, tp_item_list;
    boolean found_name = False, found_type = False;
    string type_string;
    string euc_type_string = extendedUseCase.type;
    
    string scen_query = "node[UmlScenarioInstance && " +
            "node_refs[file[(UmlSequenceDiagram || UmlCollaborationDiagram) " +
            "&& node_refs[node[" + theExtPoint.id + "]]]]]";

    list scen_node_list = list_select(scen_query);

    if (list_count(scen_node_list) == 0)
        return False;

    for (x=0; x<list_count(scen_node_list); x++)
    {
        current_scen_node = list_get(scen_node_list, x);

        nm_item_query = "item[UmlParentNameItem && obj_id = " + 
                         current_scen_node.id + "]";
        tp_item_query = "item[UmlParentTypeItem && obj_id = " + 
                         current_scen_node.id + "]";
        nm_item_list = list_select(nm_item_query);
        tp_item_list = list_select(tp_item_query);

        for (y=0; y<list_count(nm_item_list); y++)
        {
            current_item = list_get(nm_item_list, y);

            if (current_item.value == extendedUseCase.name)
                found_name = True;
        }

        for (y=0; y<list_count(tp_item_list); y++)
        {
            current_item = list_get(tp_item_list, y);

            type_string = current_item.value;

            if (type_string == euc_type_string)
                found_type = True;
        }
    }

    if (found_name && found_type) 
    {
        return True;
    }
    else 
    {
        return False;
    }
}








// int
// uusecased_consistency_check_actors_scenarios(string constraint_dg_name)
// {
//     const string qFindCommunicatesLinks = "link[UmlActor && link_refs"+constraint_dg_name+"]";
//     const string qFindActors = "link[UmlUseCaseInteraction && link_refs"+constraint_dg_name+"]";
//     const string qFindExternalEventLink = "link_ref[file[(UmlSequenceDiagram || UmlCollaborationDiagram) && node_refs[node[UmlScenarioInstance && items[UmlParentTypeItem && value='${theUseCase.type}'] && items[UmlParentNameItem && value='${theUseCase.name}']]]] && link[from_node_id=${theActor.id}]]";
//     int errCount = 0;
//     link commLink;
//     node theActor;
//     for_each_in_select(qFindActors, theActor) {
// 	node theUseCase;
// 	list extEventLinkRefs_list;
// 	for_each_in_select(qFindAllScenariosByParent, commLink) {
// 	    theActor = find_by_query("node[${commLink.from_node_id}]");
// 	    theUseCase = find_by_query("node[${commLink.to_node_id}]");
// 	    extEventLinkRefs_list = list_select(qFindExternalEventLink);
// 	    if(list_count(extEventLinkRefs_list)==0) {
// 		errCount++;
// 		print_error("Interaction between Actor '"+theActor.name+"' and Use Case '"+theUseCase.name+"' does not have a corresponding external event in any scenario");
// 	    }
// 	}
//     }
//     return errCount;
// }

int
uml_completeness_check_usecases_have_scenarios(string constraint_dg_name)
{
    // This one can check all actors, in any diagram, or given
    // diagrams, but can point to objects in error messages
    const string qFindUseCases = "node[UmlUseCase && node_refs"+constraint_dg_name+"]";
    const string qFindScenarios = "node_ref[node[UmlScenarioInstance && items[UmlParentNameItem && value='${useCase.name}'] && items[UmlParentTypeItem && value='UmlUseCase']] && file[UmlSequenceDiagram || UmlCollaborationDiagram]]";
    int ii;
    int errCount = 0;
    node useCase;
    string useCaseStr = " UseCases do";
    node_ref aScenario;
    //node_ref ucRef;
    for_each_in_select(qFindUseCases, useCase) {
	aScenario = find_by_query(qFindScenarios);
	if(aScenario==NULL) {
	    errCount++;
	    //ucRef = find_by_query("node_ref[node_id=${useCase.id}]");
	    print_error("Use Case '"+useCase.name+"' does not have an interaction scenario");
	}
    }
    return errCount;
}


/////////////////////////////////////////////////////////
// UseCase rename 
/////////////////////////////////////////////////////////

const	string	USECASE_RENAME_PROP_SHEET = "UseCaseRename";

void
uml_usecase_rename_init(gde_mapsymbol the_usecase)
{
    uml_rename_set_curr_label(USECASE_RENAME_PROP_SHEET, the_usecase);
    uml_rename_set_dep_ui(USECASE_RENAME_PROP_SHEET,
			  "dep_UmlUseCase_UmlScenarioInstance_FileName");
}

void
uml_usecase_rename(gde_mapsymbol the_usecase)
{
    gde_builtin("PropertySheetShow " + USECASE_RENAME_PROP_SHEET);

    uml_usecase_rename_init(the_usecase);
}

void
uml_usecase_rename_action_done()
{
    gde_mapsymbol ms = gde_selected_mapsymbol();
    ui_prop p = to_ui_prop(USECASE_RENAME_PROP_SHEET, "All");
    
    if (gde_rename_action_done_standard_checks(ms, p, "uml_usecase_rename") == False)
	return;
    
    uml_usecase_rename_init(ms);
}

// Begin Add ECR 2850
string 
show_uc_extension_point(int id, int psymid) {
    const float  DEFAULT_HEIGHT = 0.7;
    const float  DEFAULT_WIDTH = 2.2;

    //ECR 4769 begin
    //const string extp_query = "item[UmlUseCaseExtensionPoint && node[id=${id} && node_refs]]";
    const string extp_query = "item[UmlUseCaseExtensionPoint && node[id=${id}]]";
    //ECR 4769 end
    item        extp;
    string      msg = "";
    string      extp_list = " ";
    string      dmark = "";
    string      divider = "";
    string      label = ""; 
    int         label_count = 0;
    int         max_length = 17, temp_length = 0;
    float       height = 0.0, width = 0.0;

    // Make string of all extension point values
    for_each_in_select(extp_query, extp) {
        label_count = label_count + 1;
        label = extp.value;
 
        temp_length = string_length(label);
        if(temp_length > max_length)
            max_length = temp_length;
        extp_list = extp_list + "\n" + label;
    }
                 
    divider = "\n_________________\nExtension points:"; // ECR 6063
 
    // Magic formula for height
    // this is far from perfect ...
    height = 1.95 + (label_count * 0.245);
    if ((height < DEFAULT_HEIGHT) || (label_count = 0))
         height = DEFAULT_HEIGHT;
    
    // Magic formula for width
    width = 0.200 * max_length;  
    if (width < DEFAULT_WIDTH) width = DEFAULT_WIDTH;

    // Select the node, re-scale it, and deselect.
    msg = "SymbolSelect AppId " + psymid;
    gde_builtin(msg);
    msg = "SymbolScale " + width + " " + height;
    gde_builtin(msg);
    gde_builtin("SymbolSelect AppId 0");
 
    // Build the display mark by adding together parts
    dmark = divider + extp_list;
    return(dmark);
}
// End Add ECR 2850

//  Add any user customizations to the file included below:
#include_if_exists "user/uml/rules/qrl/user_uusecased.qrl"
