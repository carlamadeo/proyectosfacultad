// ECR3609 UclassD Auto-Draw
// new file
//
// Here's the stuff which is supported and tested:
// Generalizations:
// - parents and children
//
// Dependencie:
// - in and out
//
// Associations:
// - unlabeled assocs
// - labeled assocs
// - assocs with roles
// - qualifiers etc.
// - multiple assocs between 2 classes
// - reflexive labeled and unlabeled assocs
// + pick-list of all associations between 2 selected classes
//   including label and roles
//
//
// TODO:
// - check if classes about to be inserted already exist in the diagram


// OMS Query constants ----------------------------------------------------------------------
// find all associated classes
const string node_assoc_query = "node[name != '${from_classname}' && out_links[UmlRole && link_refs && to_node[UmlAssociation && node_refs && in_links[UmlRole && link_refs && from_node[name='${from_classname}']]]]]";

// this one catches reflexive associations
const string node_assoc_query2 = "node[out_links[UmlRole && link_refs && to_node[name $ '*${from_classname},${from_classname}' && node_refs]]]";

// find generalization parentnodes of a class
const string node_gen_parent_query = "node[in_links[link_refs && UmlGeneralization && from_node[UmlClass && name = '${from_classname}']]]";

// find generalization children of a class
const string node_gen_child_query = "node[out_links[link_refs && UmlGeneralization && to_node[UmlClass && name = '${from_classname}']]]";

// find dependency inlinks of a class
const string node_dep_in_query = "node[in_links[link_refs && UmlDependency && from_node[UmlClass && name = '${from_classname}']]]";

// find dependency outlinks of a class
const string node_dep_out_query = "node[out_links[link_refs && UmlDependency && to_node[UmlClass && name = '${from_classname}']]]";

// vertical and horizontal offset
const int node_vert_dist = 150;
const int node_horiz_dist = 500;

// delimiters for picklist strings
const string LABEL_DELIMITER = ";";
const string ROLE_DELIMITER = ":";
const string FROM_TO_DELIMITER = ",";

const string UML_CLASS_SYMBOL_APPLICATION_TAG = "ClassSymbol";

const int hier_vert_offset = 120;
const int hier_horz_offset = 10;

// struct to hold label, from and to role names of an OMT relationship
struct TLightRelModel
{
    string label;
    string to_role;
    string from_role;
};

struct TAssocName {
    string label;
    string role;
};

struct TRelName {
    string from_class;
    string to_class;
    string label;
    string from_role;
    string to_role;
};

// these are the globals used to save the selection for PickList callbacks
gde_node auto_draw_from_gde_symbol;
gde_node auto_draw_to_gde_symbol;


void UclassdAutoDraw( string type, string direction, int new_diagram ) {

    if( new_diagram ) {
    list classes = gde_nodes_find_by_application_tag( gde_selected_symbols(),
                             UML_CLASS_SYMBOL_APPLICATION_TAG );
    int sel_count = list_count( classes );
    if( sel_count > 1 ) {
        print_error( "More than one class selected." );
        return;
    }
    gde_node first_class = list_get( classes, 0 );
    string the_type = gde_nt_name( gde_node_nt( first_class ) );
    string classname = to_oms_string( strip_whitespace(gde_node_label( first_class ) ) );

    gde_builtin( "FileLoad " + classname + "_" + type );
    gde_node gn = gde_node_create( the_type, 150, 150);
    gde_node_set_label( gn, classname );
    gde_node_select( gn );
    }

    if( type == "associations" )
    DrawAssociationView();

    if( new_diagram ) {
    gde_select_symbols_in_list( gde_all_symbols() );
    gde_builtin( "BufferZoom FitSelection" );
    gde_node_select( gn );
    }
}

// The following functions are derived from the respective Impl_* functions
// in templates/omt/rules/qrl/ome_view.impl

// (the original function is in ome_view.impl )
list new_layout_nodes_in_list(list nodes, int cx, int cy, int dcx, int dcy, int vert_dist)
{
    node            nd, subsys;
    gde_node        gn, silly_node = NULL;
    int             x, y, i, tw, w;
    string          tp, atp;
    list            all_cl_w, grnodes;
    int             align, lc, perline_offset;
    int             perline;
    string          perline_toolinfo;

    align = gde_alignment();
    gde_builtin( "BufferAlign 1" );

    perline_toolinfo = toolinfo_variable( "AutoDrawPerGroup" );
    if(perline_toolinfo == NULL || string_converts(perline_toolinfo, "int") == False || to_int(perline_toolinfo) < 2)
    perline = 999999;
    else
    perline = to_int(perline_toolinfo);

    grnodes = list_create( "gde_node", 0 );

    all_cl_w = list_create( "int", 0 );

    lc = list_count( nodes );
    for(perline_offset = 0; perline_offset < lc; perline_offset += perline) {
    tw = 0;
    if( lc - perline_offset > 1 ) {
        tw = - (hier_horz_offset + 10);
        for( i = 0; i + perline_offset < lc && i < perline; ++ i ) {
        nd = list_get( nodes, i + perline_offset );
        tp = uml_class_elaborated_app_type( nd.name );
        if( vert_dist == 0 ) {
            // local
            w = get_node_width_of_new( tp, silly_node, nd.name );
            tw += hier_horz_offset + w + 10;
        } else {
            // local
            w = get_node_height_of_new( tp, silly_node, nd.name );
            tw += hier_horz_offset + w + 10;
        }
        list_append( all_cl_w, w );
        }
    } else
        list_append( all_cl_w, 0 );

    get_node_width_of_new( NULL, silly_node, NULL);

    if( vert_dist == 0 ) {
        x = cx - tw / 2;
        y = cy;
    }
    else {
        x = cx;
        y = cy - tw / 2;
    }

    for( i = 0; i + perline_offset < lc && i < perline; ++ i ) {
        nd = list_get( nodes, i + perline_offset );

        // we should check if the nodes are already ref'ed in the current diag
//      if( nd == nd ) {
        // ECR 5111
        if(nd.type == "UmlEllipsis")
                    tp = "Ellipsis";
        else
                    tp = uml_class_elaborated_app_type( nd.name );
                if( tp == NULL )
                    continue;

        w = list_get( all_cl_w, i );
        if( vert_dist == 0 )
            x += w / 2;
        else
            y += w / 2;
        gn = gde_node_create( tp, x, y );
        print_message("Create " + tp + " at " + x + "/" + y);
        // ECR 5111
        if(nd.name != "")
                    gde_node_set_label( gn, nd.name );
        if( vert_dist == 0 )
            // w - (w / 2) is different to w / 2 if w is an odd number, this avoids rounding problems
            x += w - (w / 2) + hier_horz_offset + 10;
        else
            y += w - (w / 2) + hier_horz_offset + 10;
        list_append( grnodes, gn );
//      }
    }

    list_clear( all_cl_w );

    if( vert_dist == 0 )
        cy += dcy;
    else
        cx += dcx;
    }
    gde_builtin( "BufferAlign " + align );
    return grnodes;
}

/*****************************************************************
 * Since the node might scale itself to the new label, and since
 * gde has no qrl interface to move a node (why?)
 * the only way to find out what size a node has is to create it ....
 *********************************************************************/

int get_node_width_of_new(string tp, gde_node silly_node, string label) {
    if (silly_node != NULL) {
    if (tp != gde_nt_name(gde_node_nt(silly_node))) {
        gde_node_delete(silly_node);
        silly_node = NULL;
    }
    }
    if (silly_node == NULL && tp != NULL)
    silly_node = gde_node_create(tp, 2000, 2000);
    if (silly_node != NULL) {
    gde_node_set_label(silly_node, label);
    return gde_node_width(silly_node);
    }
    return 0;
}

int
get_node_height_of_new(string tp, gde_node silly_node, string label)
{
    if (silly_node != NULL) {
    if (tp != gde_nt_name(gde_node_nt(silly_node))) {
        gde_node_delete(silly_node);
        silly_node = NULL;
    }
    }
    if (silly_node == NULL && tp != NULL)
    silly_node = gde_node_create(tp, 2000, 2000);
    if (silly_node != NULL) {
    gde_node_set_label(silly_node, label);
    return gde_node_height(silly_node);
    }
    return 0;
}

// return a list of currently selected classes
// ECR 5111
list get_selected_classes(boolean withEllipsis) {
    list selset = gde_selected_symbols();
    list source_symbols = gde_nodes_find_by_type( selset, "Class" );
    list_concatenate( source_symbols, gde_nodes_find_by_type( selset, "InstantiatedClass" ) );
    // ECR 5111
    if(withEllipsis == True)
        list_concatenate( source_symbols, gde_nodes_find_by_type( selset, "Ellipsis" ) );
    list_concatenate( source_symbols, gde_nodes_find_by_type( selset, "ParameterizedClass" ) );
    return source_symbols;
}

string uml_class_elaborated_app_type(string classname)
{
    node    elaborated_type;
    string  gde_type = "Class";

    elaborated_type = find_by_query("node[(UmlParameterizedClass|UmlInstantiatedClass) & name='" +
                    to_oms_string(classname) + "' & node_refs]");
    if (elaborated_type != NULL)
    gde_type = string_strip( elaborated_type.type, "B", "Uml" );

    return gde_type;
}

int two_classes_selected_active_func() {
    string c1 = "", c2 = "";
    // ECR 5111
    list classes = get_selected_classes(False);
    int sel_count = list_count( classes );

    if( sel_count == 2 ) {
    c1 = gde_node_label( list_get( classes, 0 ) );
    c2 = gde_node_label( list_get( classes, 1 ) );
    if( c1 != "" && c2 != "" )
        return ACTIVE_FUNC_IS_ACTIVE;
    }
    return ACTIVE_FUNC_IS_INACTIVE;
}

int one_class_selected_active_func()
{
    list classes = get_selected_classes(False);

    if( list_count( classes ) == 1 )
    return ACTIVE_FUNC_IS_ACTIVE;

    return ACTIVE_FUNC_IS_INACTIVE;
}

// ECR 5111
int one_class_or_ellipsis_selected_active_func()
{
    list classes = get_selected_classes(True);

    if( list_count( classes ) == 1 )
    return ACTIVE_FUNC_IS_ACTIVE;

    return ACTIVE_FUNC_IS_INACTIVE;
}

int class_or_ellipsis_selected_active_func()
{
    list classes = get_selected_classes(True);

    if( list_count( classes ) > 0 )
    return ACTIVE_FUNC_IS_ACTIVE;

    return ACTIVE_FUNC_IS_INACTIVE;
}

// Create classes and association links which are connected to the
// currently selected class symbol
void DrawAssociationView()
{
    list    classes, compnodes, grnodes, myself;
    int     x, y, dx, dy, link_count = 0;
    gde_node    first_class, from_class, to_class;
    string  from_classname, raw_classname;
    int     dodefer;
    boolean     pick_draw = False;

    classes = gde_nodes_find_by_application_tag(gde_selected_symbols(),
                        UML_CLASS_SYMBOL_APPLICATION_TAG);
    int sel_count = list_count( classes );

    first_class = list_get( classes, 0 );
    raw_classname = strip_whitespace(gde_node_label(first_class));
    from_classname = to_oms_string(raw_classname);

    dodefer = gde_start_edit_transaction();

    if( list_count(classes) == 2 ) {
    pick_draw = True;
    to_class = list_get( classes, 1 );
    first_class = to_class;
    from_class = list_get( classes, 0 );
    auto_draw_from_gde_symbol = from_class;
    auto_draw_to_gde_symbol = to_class;
    grnodes = list_create( "gde_node", 0 );
    list_append( grnodes, from_class );
    } else if( list_count( classes ) == 1 ) {
    //  message( node_assoc_query );
    compnodes = list_select(node_assoc_query);

    // check for reflexive associations
    myself = list_select(node_assoc_query2);
    if( list_count(myself) != 0 ) {
        CreateReflAssocLinks( first_class, "Association" );
        gde_node_select( first_class );
    }

    if (list_count(compnodes) == 0 && list_count( myself ) == 0 ) {
        print_error("Class '" + raw_classname + "' has no associations",
            gde_node_psymid(first_class));
        return;
    }

    x = gde_node_x(first_class) + node_horiz_dist - gde_node_width(first_class);
    dx = node_horiz_dist - gde_node_width(first_class);
    y = gde_node_y(first_class) + 6;
    dy = 6;

    grnodes = new_layout_nodes_in_list(compnodes, x, y, dx, dy, 1);

    } else {
    print_error( "Please select 1 or 2 classes !" );
    return;
    }

    if (list_count(grnodes) != 0) {
    if( list_count( classes ) != 2 )
        gde_select_symbols_in_list(gde_node_list_to_sym_list(grnodes));
    link_count = CreateAssocLinks(first_class, "Association", pick_draw );
    }

    if( list_count( classes ) != 2 ) {
    if( link_count < 2 )
        gde_align_all_links();
    gde_select_node( first_class );
    }
    gde_end_edit_transaction(GDE_CMD_INSERT, dodefer, False);

    // Force a canvas refresh
    gde_builtin( "BufferUpdateDmarks" );
}

// Create classes and generalization links which are Generalization children
// to the currently selected class symbol
// things is either "superclasses" or "subclasses"
void CreateHierarchyView( string things )
{
    list        classes, subs, grnodes;
    int         x, y, dx, dy, i;
    gde_node        the_class, parent_node;
    string      from_classname, raw_classname;
    int         dodefer;
    list        class_list;
    string      link_type;

    classes = gde_nodes_find_by_application_tag(gde_selected_symbols(),
                        UML_CLASS_SYMBOL_APPLICATION_TAG);
    if (list_count(classes) != 1) {
        print_error( "No class selected." );
    return;
    }

    the_class = list_get(classes, 0);
    raw_classname = strip_whitespace(gde_node_label(the_class));
    from_classname = to_oms_string(raw_classname);

    if( things == "subclasses" ) {
    class_list = list_select(node_gen_child_query);
    if (list_count(class_list) == 0) {
        gde_print_error("Class '" + raw_classname + "' has no subclasses", gde_node_psymid(the_class));
        return;
    }
    link_type = "Generalization";
    } else if( things == "superclasses" ) {
    class_list = list_select(node_gen_parent_query);
    if (list_count(class_list) == 0) {
        gde_print_error("Class '" + raw_classname + "' has no superclasses", gde_node_psymid(the_class));
        return;
    }
    link_type = "Generalization";
    } else if( things == "dependentclasses" ) {
    class_list = list_select(node_dep_out_query);   //ECR 5712
    if (list_count(class_list) == 0) {
        gde_print_error("Class '" + raw_classname + "' has no dependent classes", gde_node_psymid(the_class));
        return;
    }
    link_type = "Dependency";
    } else if( things == "classdependencies" ) {
    class_list = list_select(node_dep_in_query);    //ECR 5712
    if (list_count(class_list) == 0) {
        gde_print_error("Class '" + raw_classname + "' has no dependencies", gde_node_psymid(the_class));
        return;
    }
    link_type = "Dependency";
    }

    dodefer = gde_start_edit_transaction();

    // same x results in a slight non-straight link ...
    x = gde_node_x( the_class ) - 1;
    dx = 0;
    if( things == "subclasses" || things == "dependentclasses" ) {     //ECR 5712
        y = gde_node_y( the_class ) + gde_node_height( the_class ) / 2 + node_vert_dist;
        dy = gde_node_height( the_class ) / 2 + node_vert_dist;
    } else if( things == "superclasses" || things == "classdependencies" ) {       //ECR 5712
        y = gde_node_y( the_class ) + gde_node_height( the_class ) - node_vert_dist;
        dy = gde_node_height( the_class ) - node_vert_dist;
    }

    grnodes = new_layout_nodes_in_list( class_list, x, y, dx, dy, 0 );
    if( things == "subclasses" || things == "dependentclasses" ) {      //ECR 5712
        if ( list_count( grnodes ) != 0 ) {
            gde_select_symbols_in_list( gde_node_list_to_sym_list( grnodes ) );
            if( toolinfo_variable( "AutoDrawGenTree" ) == NULL || things == "dependentclasses" ) { //ECR 5712
                CreateDirectArcs( the_class, link_type, things == "subclasses" );
            } else {
                CreateHierarchyToParent( the_class, "Generalization" );
                CreateArcHierarchy("Generalization", "Class Ellipsis ParameterizedClass", True );
                TheExplicitHierarchyParent = NULL;
            }
        }
    } else if( things == "superclasses" || things == "classdependencies" ) {    //ECR 5712
        for( i = 0; i < list_count( grnodes ); ++ i ) {
            gde_select_node( the_class );
            parent_node = list_get( grnodes, i );
            if( toolinfo_variable( "AutoDrawGenTree" ) == NULL || things == "classdependencies" ) { //ECR 5712
                CreateDirectArcs( parent_node, link_type, False );
            } else {
                CreateHierarchyToParent( parent_node, "Generalization" );
                CreateArcHierarchy("Generalization", "Class Ellipsis ParameterizedClass", True );
                TheExplicitHierarchyParent = NULL;
            }
        }
    }

    gde_select_node( the_class );
    gde_end_edit_transaction( GDE_CMD_INSERT, dodefer, False );

    // Force a canvas refresh
    gde_builtin( "BufferUpdateDmarks" );
}

// Creates a link of type link_tp from selected symbols to symbol to_gnode
int CreateAssocLinks(gde_node to_gnode, string link_tp, boolean pick_draw ) {
    gde_node from_gnode;
    gde_arc new_arc;
    int i, j, vert_x, vert_y;
    TLightRelModel rel_model;
    node assoc;
    list assoc_list;
    string from_cname, to_cname, label = "", role = "", query;
    string signature;
    string the_role;
    list item_sel_list = list_create( "string", 0 );
    int sl, col_pos, comma_pos;
    TAssocName my_assoc;
    boolean arc_draw_ortho;

    // ECR 5111
    list source_symbols = get_selected_classes(False);

    for( i=0; i<list_count( source_symbols ); ++ i ) {
    from_gnode = list_get( source_symbols, i );

    // I don't know why I need to swap here, but I have to ...
    to_cname = to_oms_string( strip_whitespace( gde_node_label( from_gnode ) ) );
    from_cname = to_oms_string( strip_whitespace( gde_node_label( to_gnode ) ) );

    // Get the association object(s) and their label
    assoc_list = NULL;
    query = "node[UmlAssociation && node_refs && " +
        "in_links[UmlRole && link_refs && from_node[UmlClass && name = '" + to_cname + "']] && " +
        "in_links[UmlRole && link_refs && from_node[UmlClass && name = '" + from_cname + "']]]";
    assoc_list = list_select( query );

    // the above query should always give the assoc object since logically
    // order does not matter with this query, but apparently it does :-(((
    // so .... trial and error, I could do that with the name, too ....

    if( list_count( assoc_list ) == 0 ) {
        // print_message( "Not found:\n" + query );
        query = "node[UmlAssociation && node_refs && " +
        "in_links[UmlRole && link_refs && from_node[UmlClass && name = '" + from_cname + "']] && " +
        "in_links[UmlRole && link_refs && from_node[UmlClass && name = '" + to_cname + "']]]";
        // print_message( "Trying with:\n" + query );
        assoc_list = list_select( query );
    }

    if( pick_draw ) {
        for( j=0; j<list_count( assoc_list ); ++ j ) {
        assoc = list_get( assoc_list, j );

        // Build the relationship model and lable the assoc and the roles
        rel_model = get_rel_model( assoc, from_cname, to_cname );

        if( rel_model.from_role != "" || rel_model.to_role != "" )
            the_role = rel_model.from_role + ROLE_DELIMITER + rel_model.to_role;
        else
            the_role = "<no role>";

        list_append( item_sel_list, assoc.name + LABEL_DELIMITER + the_role );
        }

        if( list_count( item_sel_list ) == 0 ) {
        gde_print_message( "No Associations found !" );
        return 0;
        }
        editor_item_selector(item_sel_list, "CreateOneAssocLinkFromList();",
                 "Draw Association",
                 False);
        // ui_selector_owner_id = editor_selector_owner_id();
        return 0;

    }

    if( list_count( assoc_list ) > 1 ) {
        // multiple links dont work with ortho drawing
        arc_draw_ortho = gde_draw_ortho( False );
    }

    // Iterate the associations, there might be more than one !
    for( j=0; j<list_count( assoc_list ); j=j+1 ) {
        assoc = list_get( assoc_list, j );

        new_arc = gde_arc_create( link_tp, from_gnode, to_gnode );

        if( j > 0 ) {
        // we are inserting more than one arc for the same 2 classes
        // so get the center-point of the new arc and insert a new
        // vertex at xccord + j * 40 to avoid invisible arcs
        vert_x = gde_arc_fromx( new_arc ) +
            ( ( gde_arc_tox( new_arc ) - gde_arc_fromx( new_arc ) ) / 2 );
        vert_y = gde_arc_fromy( new_arc ) + ( j * 40 ) +
            ( ( gde_arc_toy( new_arc ) - gde_arc_fromy( new_arc ) ) / 2 );
        gde_arc_select( new_arc );
        gde_builtin("SymbolInsertVertex " + vert_x + " " + vert_y );
        }

        // Build the relationship model and lable the assoc and the roles
        rel_model = get_rel_model( assoc, from_cname, to_cname );
        if( rel_model.label != "" )
        gde_arc_set_label( new_arc, rel_model.label );
        if( rel_model.to_role != "" || rel_model.from_role != "" )
        CreateRole( new_arc, rel_model.from_role, rel_model.to_role );
        gde_map_all_symbols();
    }

//  if( list_count( assoc_list ) > 1 ) {
    // multiple links dont work with ortho drawing
//      gde_draw_ortho( arc_draw_ortho );
//  }
    }
    return list_count( assoc_list );
}

// syntax: Label:FromClass,ToClass<LABEL_DELIMITER>fromRole,toRole
//
TAssocName parse_assoc_name( string the_name ) {

    int sl = string_length( the_name );
    int label_end = string_find( the_name, 0, LABEL_DELIMITER );
    int role_split = string_find( the_name, label_end, ROLE_DELIMITER );
    TAssocName the_assoc;

    if( label_end <= sl ) {
    the_assoc.label = string_extract( the_name, 0, label_end );
    the_assoc.role = string_extract( the_name, label_end+1, sl-label_end-1 );
    } else {
    the_assoc.label = "";
    the_assoc.role = the_name;
    }

    if( the_assoc.label == "<no label>" )
    the_assoc.label = "";
    if( the_assoc.role == "<no role>" )
    the_assoc.role = "";

//    print_error( "Label: " + the_assoc.label );
//    print_error( "Role: " + the_assoc.role );

    return the_assoc;
}

// Create one Association from picklist
void CreateOneAssocLinkFromList()
{
    list sel = editor_selector_selected_labels();
    list gde_sel, sel_symbols;
    string assoc_name, from_cname, to_cname, raw_classname, query;
    gde_node from_gnode, to_gnode, buffer;
    TAssocName my_assoc;
    TLightRelModel rel_model;
    node assoc;
    int dodefer;
    gde_arc new_arc;

    if( list_count( sel ) != 1 )
    return;

    dodefer = gde_start_edit_transaction();

    //  picking the selection from the selection before the picklist was opened
    from_gnode = auto_draw_to_gde_symbol;
    raw_classname = strip_whitespace(gde_node_label(from_gnode));
    from_cname = to_oms_string(raw_classname);

    to_gnode = auto_draw_from_gde_symbol;
    raw_classname = strip_whitespace(gde_node_label(to_gnode));
    to_cname = to_oms_string(raw_classname);

    assoc_name = list_get( sel, 0 );
    my_assoc = parse_assoc_name( assoc_name );
    assoc_name = my_assoc.label;

    query = "node[UmlAssociation && node_refs && name == '" + assoc_name +
        "' && sig = '" + my_assoc.role + "']";
    assoc = find_by_query( query );

    if( assoc == NULL ) {
        // Swap the roles in the signature
        // print_message( query + " not found." );
    int sl = string_length( my_assoc.role );
    int role_split = string_find( my_assoc.role, 0, ROLE_DELIMITER );
    string role1 = string_extract( my_assoc.role, 0, role_split );
    string role2 = string_extract( my_assoc.role, role_split+1, sl-role_split-1 );
        query = "node[UmlAssociation && node_refs && name == '" + assoc_name +
            "' && sig = '" + role2 + ROLE_DELIMITER + role1 + "']";
    assoc = find_by_query( query );
    }

    if( assoc == NULL ) {
    print_message( query + " not found." );
    // return;
    }

//    gde_save_state();
    new_arc = gde_arc_create( "Association", from_gnode, to_gnode );
    gde_map_all_symbols();

    // Build the relationship model and lable the assoc and the roles
    rel_model = get_rel_model( assoc, from_cname, to_cname );
    if( rel_model.label != "" ) {
    gde_arc_set_label( new_arc, rel_model.label );
    gde_map_all_symbols();
    }
    if( rel_model.to_role != "" || rel_model.from_role != "" ) {
    CreateRole( new_arc, rel_model.to_role, rel_model.from_role );
    gde_map_all_symbols();
    }

    gde_arc_select( new_arc );

    gde_align_all_links();
    gde_end_edit_transaction(GDE_CMD_INSERT, dodefer, False);

    // Force a canvas refresh
    gde_builtin( "BufferUpdateDmarks" );
}

// Creates reflexive Associations
void CreateReflAssocLinks( gde_node to_gnode, string link_tp )
{
    gde_arc new_arc;
    int i, j, vert_x, vert_y;
    TLightRelModel rel_model;
    node assoc;
    list assoc_list;
    string to_cname;

    // Get the association object(s) and their label
    to_cname = to_oms_string( strip_whitespace( gde_node_label( to_gnode ) ) );
    assoc_list = list_select( "node[UmlAssociation && node_refs && name $ '*" +
                 to_cname + FROM_TO_DELIMITER + to_cname + "']" );

    // Iterate the associations, there might be more than one !
    for( j=0; j<list_count( assoc_list ); ++ j ) {

    new_arc = gde_arc_create( link_tp, to_gnode, to_gnode );
    gde_arc_select( new_arc );
    vert_y = gde_arc_toy( new_arc ) - ( 100 + (j*20) );
    vert_x = gde_arc_tox( new_arc ) - ( 30 * (j+1) );
    gde_builtin("SymbolInsertVertex " + vert_x + " " + vert_y );
    gde_arc_select( new_arc );
    vert_x = vert_x + ( ( 30 * (j+1) ) * 2 );
    gde_builtin("SymbolInsertVertex " + vert_x + " " + vert_y );

    // Build the relationship model and lablel the assoc and the roles
    assoc = list_get( assoc_list, j );
    rel_model = get_rel_model( assoc, to_cname, to_cname );
    if( rel_model.label != "" )
        gde_arc_set_label( new_arc, rel_model.label );
    if( rel_model.to_role != "" || rel_model.from_role != "" )
        CreateRole( new_arc, rel_model.to_role, rel_model.from_role );
    }
}

// build a lightweight model (label and roles) of an association
TLightRelModel get_rel_model( node assoc, string from_cname, string to_cname ) {
    link role;
    list role_list;
    TLightRelModel m;
    int i;

    if( assoc == NULL || string_find( assoc.name, 0, UML_ASSOCIATION_NAME_DELIMITER1 ) == string_length(assoc.name) )
    m.label = "";
    else
    m.label = list_get(string_to_list(assoc.name, UML_ASSOCIATION_NAME_DELIMITER1), 0);

    if( to_cname == from_cname ) {
    // Is this the way to do it ??? (the roles are in the sig of the assoc node, too !)
    role_list = list_select( "link[link_refs && UmlRole && from_node[UmlClass && " +
                "name = '" + from_cname + "'] && to_node[id=" + assoc.id + "]]" );
    // What's from and to here ???
    role = list_get(role_list, 0 );
    m.from_role = role.name;
    if( list_count( role_list ) > 1 ) {
        role = list_get(role_list, 1 );
        m.to_role = role.name;
    } else
        m.to_role = "";
    } else {
    // Get the assocs FROM role label
    role = find_by_query( "link[link_refs && UmlRole && from_node[UmlClass && " +
                  "name = '" + from_cname + "'] && to_node[id=" + assoc.id + "]]" );
    if( role != NULL )
        m.from_role = role.name;
    else
        m.from_role = "";

    // Get the assocs TO role label
    role = find_by_query( "link[link_refs && UmlRole && from_node[UmlClass && " +
                  "name = '" + to_cname + "'] && to_node[id=" + assoc.id + "]]" );
    if( role != NULL ) {
        m.to_role = role.name;
    } else {
        m.to_role = "";
    }

/*
    // the signature isn't always in the correct order !!!
    if( assoc.sig != "" ) {
        int role_split = string_find( assoc.sig, 0, ROLE_DELIMITER );
        m.from_role = string_extract( assoc.sig, 0, role_split );
        m.to_role = string_extract( assoc.sig, role_split+1,
            string_length( assoc.sig )-role_split-1 );
    } else {
        m.from_role = "";
        m.to_role = "";
    }
*/

    }

/*
    print_error( "Label = " + m.label );
    print_error( "FromRole = " + m.from_role );
    print_error( "ToRole = " + m.to_role );
*/

    return m;

}

// Create the role labels for an association
void CreateRole( gde_arc s, string l_to, string l_from )
{
    gde_cntx r;

    // check if there is already a set of role labels
    gde_arc_select( s );
    r = gde_first_arcs_links_cntx_from_ct( s, "RelLabelTo" );

    if( r == NULL ) {
    // role labels do not exist yet, create the labels
    gde_builtin("SymbolBachLabels");
    r = gde_first_arcs_links_cntx_from_ct( s, "RelLabelTo" );
    }
    if( r != NULL ) {
    if( l_to != "" )
        gde_cntx_set_label( r, l_to );
    else
        gde_cntx_delete(r);
    }

    r = gde_first_arcs_links_cntx_from_ct( s, "RelLabelFrom" );
    if( r != NULL ) {
    if( l_from != "" )
        gde_cntx_set_label( r, l_from );
    else
        gde_cntx_delete(r);
    }
}

// ECR 5111
void CreateDirectArcs( gde_node parent, string arc_type, boolean withEllipsis ) {
    int i;

    // ECR 5111
    list source_symbols = get_selected_classes(withEllipsis);
    //ECR 5712 begin
    gde_arc g_arc;

    for( i = 0; i < list_count( source_symbols ); ++ i )
    {
        g_arc = gde_arc_create( arc_type, list_get( source_symbols, i ), parent );
        set_arc_label(g_arc, arc_type, list_get( source_symbols, i ), parent);
        gde_map_all_symbols();
    //ECR 5712 end
    }
}

//ECR 5712 begin
void set_arc_label(gde_arc g_arc, string arc_type, gde_node from_node, gde_node to_node)
{
    list links;
    link l;
    string from_node_name, to_node_name;
    from_node_name = to_oms_string(strip_whitespace(gde_node_label(from_node)));
    to_node_name = to_oms_string(strip_whitespace(gde_node_label(to_node)));
    links = list_select("link[Uml" + arc_type + " && link_refs && from_node[UmlClass && name = '${from_node_name}'] && to_node[UmlClass && name = '${to_node_name}']]"); 
    if( (links != NULL) && (list_count(links) > 0) )
    {
        l = list_get(links, 0);
        if( (l != NULL) && (l.name != NULL) )
            gde_arc_set_label( g_arc, l.name );
    }
}
//ECR 5712 end


// stuff ported from ome_create_generalization.impl ------------------------------------------
gde_node    TheExplicitHierarchyParent = NULL;
string      TheExplicitHierarchyParentLinkType = NULL;
string      TheTargetType = NULL;

const int   UML_GEN_TRI_OFFSET = 70;
const int   UML_GEN_TRI_VERT_OFF = 8;

void
CreateHierarchyToParent(gde_node parent, string ltp)
{
    TheExplicitHierarchyParent = parent;
    TheExplicitHierarchyParentLinkType = ltp;
}

void
CreateInclusiveGeneralization()
{
    CreateArcHierarchy("Generalization", "Class Ellipsis ParameterizedClass", False );
    TheExplicitHierarchyParent = NULL;
}

// ECR 5111
// changes to enable ellipsis symbol
void
CreateArcHierarchy(string ltp, string selsym, boolean many_layers)
{
    list    source_symbols, selvert, selset;
    int     i, j;
    int     ymin, ymax, xmin, xmax, xmaxx, x, y, vx, vy, tmpmidx, midx, midy, num_classes;
    int     lastx, lasty, sel_counter;
    gde_node    gnode, vnode1, vnode2, midv, tmpnd;
    gde_node    parent_sym;
    gde_arc g_arc;
    int     arc_id;
    list    vertices;
    string  arc_appids;
    gde_symbol  sym;
    set         ycoord;

    tmpnd = NULL;
    arc_appids = "";
    selset = gde_selected_symbols();
    parent_sym = NULL;
    TheTargetType = NULL;

    if(string_find(selsym, 0, " ") < string_length(selsym)) {
        list selsyms = string_to_list(selsym, " ");
        string one_selsym;
        for(i = 0; i < list_count(selsyms); ++ i) {
            one_selsym = list_get(selsyms, i);
            if(i == 0)
                source_symbols = gde_nodes_find_by_type(selset, one_selsym);
            else
                list_concatenate(source_symbols, gde_nodes_find_by_type(selset, one_selsym));
        }
    }
    else
        source_symbols = gde_nodes_find_by_type(selset, selsym);

    num_classes = list_count(source_symbols);
    //print_message("No source symbols: " + list_count(source_symbols));

    if (0 >= num_classes) {
        print_error("No Symbols of type " + selsym + " Selected", NULL);
        return;
    }
    gde_set_status(0);

    gnode = list_get(source_symbols, 0);

    x = gde_node_x(gnode);
    y = gde_node_y(gnode) - (gde_node_height(gnode) / 2);
    xmin = x;
    xmax = x;
    ymin = y;
    ymax = y;

    // Find left/right and top extreme values of selected group

    for (i = 1; i < list_count(source_symbols); ++ i) {
        gnode = list_get(source_symbols, i);
        x = gde_node_x(gnode);
        y = gde_node_y(gnode) - (gde_node_height(gnode) / 2);
        if (y < ymin)
            ymin = y;

        if (y > ymax)
            ymax = y;

        if (x < xmin)
            xmin = x;

        if (x > xmax)
            xmax = x;
    }

    if(ymax - ymin <= 20)
        many_layers = False;

    y = ymin - UML_GEN_TRI_OFFSET;
    x = (xmax + xmin)/2;
    midx = x;
    if (TheExplicitHierarchyParent != NULL) {
        midx = gde_node_x(TheExplicitHierarchyParent);
        x = midx;
    }

    vy = y + UML_GEN_TRI_VERT_OFF;

    gde_defer_action_completed(1);
    gde_defer_save_state(DISABLE_SAVE_STATE);

    if (num_classes == 1) {
        gnode = list_get(source_symbols, 0);
        if (parent_sym != NULL) {
            g_arc = gde_arc_create(ltp, gnode, parent_sym);
            arc_id = gde_arc_psymid(g_arc);
            gde_builtin(SYM_SEL_APPID_MSG + arc_id);

            gde_builtin(BUF_ALIGN_MSG);

            sym = to_gde_symbol(parent_sym);
        } else {
            sym = to_gde_symbol(gnode);
            TheTargetType = ltp;
        }

        if (TheExplicitHierarchyParent != NULL &&
            TheExplicitHierarchyParentLinkType != NULL) {
            FinishExplicitHierarchy(sym, arc_appids);
            return;
        }

        start_an_arc_from(sym, TheTargetType, SEL_TARGET_PROMPT, True);
        return;
    }

    // A list with all the vertices inserted
    vertices = list_create("gde_node", 0);

    midv = NULL;
    tmpnd = gde_node_create(VERTEX_SYMBOL_TYPE, midx, vy);
    // Aligned ...
    midx = gde_node_x(tmpnd);
    midy = gde_node_y(tmpnd);

    // ECR 7540 begin
    vy = gde_node_y(tmpnd) - gde_node_height(tmpnd) / 2;
    // ECR 7540 end

    sel_counter = 0;
    // Create a vertex above the child node

    xmaxx = xmax;
    ycoord = set_create("int");

    for (i = 0; i < list_count(source_symbols); ++ i) {
        gnode = list_get(source_symbols, i);
        vx = gde_node_x(gnode);
        if(many_layers == True)
            vy = UML_GEN_TRI_VERT_OFF - UML_GEN_TRI_OFFSET + gde_node_y(gnode) - gde_node_height(gnode) / 2;

        //set_add(ycoord, vy); // ECR 7540 - moved about 10 lines down
        if(i == 0)
            ymin = vy;
        else if(ymin > vy)
            ymin = vy;
        vnode1 = gde_node_create(VERTEX_SYMBOL_TYPE, vx, vy);

        // ECR 7540 begin
        if (many_layers == True)
            vy = gde_node_y(vnode1) - gde_node_height(vnode1) / 2;
        set_add(ycoord, vy);
        // ECR 7540 end

        vx = gde_node_x(vnode1);
        if (vx == midx && vy == midy)
            midv = vnode1;

        // takes care of alignment ...
        if (vx < xmin)
            xmin = vx;

        if (vx > xmax) {
            xmax = vx;
            xmaxx = vx + gde_node_width(gnode) / 2 + hier_horz_offset + 10;
        }

        // arc from class node to vertex
        g_arc = gde_arc_create(ltp, gnode, vnode1);
        list_append(vertices, vnode1);
        arc_id = gde_arc_psymid(g_arc);
        arc_appids = arc_appids + " " +  arc_id;
        sel_counter = sel_counter + 1;
        if (sel_counter >= SEL_ITEM_LIMIT) {
            gde_builtin(SYM_SEL_APPID_MSG + arc_appids);
            gde_builtin(BUF_ALIGN_MSG);
            arc_appids = "";
            sel_counter = 0;
        }
    }
    if (midv == NULL)
        midv = tmpnd;
    else
        gde_node_delete(tmpnd);

    // some layers ...
    if(set_count(ycoord) > 1) {
        lasty = ymin - 1;
        vnode1 = NULL;
        for(j = get_next_ycoord(ycoord, lasty); j != -1; j = get_next_ycoord(ycoord, lasty)) {
            lasty = set_get_element(ycoord, j);
            vnode2 = gde_node_create(VERTEX_SYMBOL_TYPE, xmaxx, lasty);
            list_append(vertices, vnode2);

            if(vnode1 != NULL) {
                g_arc = gde_arc_create(ltp, vnode2, vnode1);
                // message("up arc from " + lastx + " to " + gde_node_x(vnode2));
                arc_id = gde_arc_psymid(g_arc);
                arc_appids = arc_appids + " " +  arc_id;
                sel_counter = sel_counter + 1;
                if (sel_counter >= SEL_ITEM_LIMIT) {
                    gde_builtin(SYM_SEL_APPID_MSG + arc_appids);
                    gde_builtin(BUF_ALIGN_MSG);
                    arc_appids = "";
                    sel_counter = 0;
                }
            }
            vnode1 = vnode2;
        }
        xmax = xmaxx;
    }

    if (parent_sym) {
        g_arc = gde_arc_create(ltp, midv, parent_sym);
        arc_id = gde_arc_psymid(g_arc);
        arc_appids = arc_appids + " " +  arc_id;
        sel_counter = sel_counter + 1;
        if (sel_counter >= SEL_ITEM_LIMIT) {
            gde_builtin(SYM_SEL_APPID_MSG + arc_appids);
            gde_builtin(BUF_ALIGN_MSG);
            arc_appids = "";
        }
    }

    lasty = ymin - 1;
    for(j = get_next_ycoord(ycoord, lasty); j != -1; j = get_next_ycoord(ycoord, lasty)) {
        lasty = set_get_element(ycoord, j);
        // message("lasty: " + lasty + "midy: " + midy);
        if(lasty + 5 < midy || lasty - 5 > midy)
            tmpmidx = midx + 1000000;
        else
            tmpmidx = midx;
        // message("found y (" + lasty + ") at index " + j);
        // Find left most unhandled vertex and connect it with the
        // next vertex to the right until we get to the mid vertex
        vnode1 = NULL;
        i = get_next_child_up(vertices, xmin-1, tmpmidx, lasty);
        if (i >= 0)  {
            vnode1 = list_get(vertices, i);
            lastx = gde_node_x(vnode1);
            list_delete(vertices, i);
            i = get_next_child_up(vertices, lastx, tmpmidx, lasty);
        }

        for( ; i >= 0; i = get_next_child_up(vertices, lastx, tmpmidx, lasty)) {
            vnode2 = list_get(vertices, i);
            list_delete(vertices, i);
            g_arc = gde_arc_create(ltp, vnode1, vnode2);
            // message("up arc from " + lastx + " to " + gde_node_x(vnode2));
            arc_id = gde_arc_psymid(g_arc);
            arc_appids = arc_appids + " " +  arc_id;
            lastx = gde_node_x(vnode2);
            vnode1 = vnode2;
            sel_counter = sel_counter + 1;
            if (sel_counter >= SEL_ITEM_LIMIT) {
            gde_builtin(SYM_SEL_APPID_MSG + arc_appids);
            gde_builtin(BUF_ALIGN_MSG);
            arc_appids = "";
            sel_counter = 0;
            }
        }

        if(tmpmidx == midx) {
            if (vnode1 != NULL && vnode1 != midv) {
                // message("Create arc up to mid");
                g_arc = gde_arc_create(ltp, vnode1, midv);
                arc_id = gde_arc_psymid(g_arc);
                arc_appids = arc_appids + " " +  arc_id;
            }

            // Find Right most unhandled vertex and connect it with the
            // next vertex to the left until we get to the mid vertex

            vnode1 = NULL;

            i = get_next_child_down(vertices, xmax+1, midx, lasty);
            if (i >= 0) {
                vnode1 = list_get(vertices, i);
                lastx = gde_node_x(vnode1);
                list_delete(vertices, i);
                i = get_next_child_down(vertices, lastx, midx, lasty);
            }

            for( ; i >= 0; i = get_next_child_down(vertices, lastx, midx, lasty)) {
                vnode2 = list_get(vertices, i);
                list_delete(vertices, i);
                g_arc = gde_arc_create(ltp, vnode1, vnode2);
                // message("down arc from " + lastx + " to " + gde_node_x(vnode2));
                arc_id = gde_arc_psymid(g_arc);
                arc_appids = arc_appids + " " +  arc_id;
                lastx = gde_node_x(vnode2);
                vnode1 = vnode2;

                sel_counter = sel_counter + 1;
                if (sel_counter >= SEL_ITEM_LIMIT) {
                    gde_builtin(SYM_SEL_APPID_MSG + arc_appids);
                    gde_builtin(BUF_ALIGN_MSG);
                    arc_appids = "";
                    sel_counter = 0;
                }
            }

            if (vnode1 != NULL && vnode1 != midv) {
                // message("Create arc down to mid");
                g_arc = gde_arc_create(ltp, vnode1, midv);
                arc_id = gde_arc_psymid(g_arc);
                arc_appids = arc_appids + " " +  arc_id;
            }
        }
    }
    if (parent_sym)
        sym = to_gde_symbol(parent_sym);
    else
        sym = to_gde_symbol(midv);

    if (TheExplicitHierarchyParent != NULL &&
        TheExplicitHierarchyParentLinkType != NULL) {
        FinishExplicitHierarchy(sym, arc_appids);
        return;
    }

    // message("select arcs: " + arc_appids);

    // Align the newly inserted arcs

    gde_builtin(SYM_SEL_APPID_MSG + arc_appids);

    gde_builtin(BUF_ALIGN_MSG);

    start_an_arc_from(sym, NULL, SEL_TARGET_PROMPT, True);
}

void
FinishExplicitHierarchy(gde_symbol sym, string arc_appids)
{
    gde_node    n;
    gde_arc a;


    n = to_gde_node(sym);
    a = gde_arc_create(TheExplicitHierarchyParentLinkType,
                n, TheExplicitHierarchyParent);
    set_arc_label(a, TheExplicitHierarchyParentLinkType, n, TheExplicitHierarchyParent); //ECR 5712 
    arc_appids = arc_appids + " " +  gde_arc_psymid(a);

    gde_builtin(SYM_SEL_APPID_MSG + arc_appids);

    gde_builtin(BUF_ALIGN_MSG);

    TheExplicitHierarchyParent = NULL;
    TheExplicitHierarchyParentLinkType = NULL;

    gde_defer_action_completed(0); // Allow more action completed calls
    gde_action_completed(); // Call action completed now
    gde_defer_save_state(ENABLE_SAVE_STATE);
}

int
get_next_child_up(list vertices, int xp, int xlim, int ycoord)
{
    int     i, x, y, minx, ind;
    gde_node    a_vertex;

    minx = xlim + 1;
    ind = -1;

    for (i = 0; i < list_count(vertices); ++ i) {
    a_vertex = list_get(vertices, i);
    y = gde_node_y(a_vertex);
    if(y + 5 < ycoord || y - 5 > ycoord)
        continue;
    x = gde_node_x(a_vertex);
    if (x >= xp && x <= xlim && x < minx) {
        minx = x;
        ind = i;
    }
    }
    return ind;
}

int
get_next_child_down(list vertices, int xp, int xlim, int ycoord)
{
    int     i, x, y, maxx, ind;
    gde_node    a_vertex;

    maxx = xlim - 1;
    ind = -1;

    for (i = 0; i < list_count(vertices); ++ i) {
    a_vertex = list_get(vertices, i);
    y = gde_node_y(a_vertex);
    if(y + 5 < ycoord || y - 5 > ycoord)
        continue;
    x = gde_node_x(a_vertex);
    if (x <= xp && x >= xlim && x > maxx) {
        maxx = x;
        ind = i;
    }
    }
    return ind;
}

int
get_next_ycoord(set ycoord, int yp)
{
    int     i, y, miny, ind;

    miny = NULL;
    ind = -1;

    for (i = 0; i < set_count(ycoord); ++ i) {
    y = set_get_element(ycoord, i);
    if (y > yp && (miny == NULL || y < miny)) {
        miny = y;
        ind = i;
    }
    }
    return ind;
}

// ECR4350
// Callback to draw Generalization in Tree Style
//

// messages sent to the editor
const string SEL_TARGET_PROMPT = "Please Select the Parent Class";
//const string SEL_CONSTRAINT_TARGET_PROMPT = "Please Select the target for the Constraint";

void
DrawGeneralization()
{
// ECR2653
    CreateArcHierarchy("Generalization", "Class Ellipsis ParameterizedClass", False);
// ECR2653
    TheExplicitHierarchyParent = NULL;
}
