
#include "rules/qrl/uml.inc"
#include "rules/qrl/uml_stereotypes.inc"
#include "rules/qrl/uclassd_semantics.inc"
#include "rules/qrl/oper_parse.inc"
#include "rules/qrl/uml_class_semantics.inc"

#include "rules/qrl/ustated_transition.inc"

list whole_model_sem_check_msg_list = list_create("string", 0);

int
save_message(string diag_type, string diag_name, string object_type, 
             string object_name, string message)
{
    string save_msg; 

    save_msg = convert_diag_type_sem_check(diag_type) + "/" + diag_name + "/" + 
               message;

    list_append(whole_model_sem_check_msg_list, save_msg);

    return 0;
}

string 
convert_diag_type_sem_check(string diag_type)
{

    if (diag_type == "UmlClassDiagram")
        return "Class";
    if (diag_type == "UmlUseCaseDiagram")
        return "Use Case";
    if (diag_type == "UmlSequenceDiagram")
        return "Sequence";
    if (diag_type == "UmlCollaborationDiagram")
        return "Collaboration";
    if (diag_type == "UmlStereotypeDiagram")
        return "Stereotype";
    if (diag_type == "UmlActivityDiagram")
        return "Activity";
    if (diag_type == "UmlStateDiagram")
        return "State";
    if (diag_type == "UmlComponentDiagram")
        return "State";
    if (diag_type == "UmlDeploymentDiagram")
        return "Deployment";

    return diag_type;
}


external string parent_func = "";
external int out_form;
external string out_file = "";
external string sem_file_names = "";
external string ed_type = "";

int 
main()
{
    int error_count = 0;
    int x;
 
    string class_diag_query;
    string usecase_diag_query;
    string sequence_diag_query;
    string collaboration_diag_query;
    string stereotype_diag_query;
    string activity_diag_query;
    string state_diag_query;
    string component_diag_query;
    string deployment_diag_query;

    string check_semantics_current_file_name = sem_file_names;


    if (parent_func == "CheckSubMenu")
    {

        if (ed_type == "UmlClassDiagramFiles") 
            parent_func = "StartCheckClassDiagramFile";

        else if (ed_type == "UmlUseCaseDiagramFiles") 
            parent_func = "StartCheckUseCaseDiagramFile";

        else if (ed_type == "UmlSequenceDiagramFiles") 
            parent_func = "StartCheckSequenceDiagramFile";

        else if (ed_type == "UmlCollaborationDiagramFiles") 
            parent_func = "StartCheckCollaborationDiagramFile";

        else if (ed_type == "UmlStereotypeDiagramFiles") 
            parent_func = "StartCheckStereotypeDiagramFile";

        else if (ed_type == "UmlActivityDiagramFiles") 
            parent_func = "StartCheckActivityDiagramFile";

        else if (ed_type == "UmlStateDiagramFiles") 
            parent_func = "StartCheckStateDiagramFile";

        else if (ed_type == "UmlDeploymentDiagramFiles") 
            parent_func = "StartCheckDeploymentDiagramFile";

        else if (ed_type == "UmlComponentDiagramFiles") 
            parent_func = "StartCheckComponentDiagramFile";

        else
        {
            print_error("Unknown editor type " + ed_type);
            return 1;
        }

    }


    if (parent_func == "StartCheckClassDiagramFile")
        class_diag_query = "file[UmlClassDiagram && " + 
                            check_semantics_current_file_name + "]"; 
    if (parent_func == "StartCheckClassDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
        class_diag_query = "file[UmlClassDiagram]"; 

    if (parent_func == "StartCheckUseCaseDiagramFile")
        usecase_diag_query = "file[UmlUseCaseDiagram && " +
                            check_semantics_current_file_name + "]";
    if (parent_func == "StartCheckUseCaseDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
        usecase_diag_query = "file[UmlUseCaseDiagram]";

    if (parent_func == "StartCheckSequenceDiagramFile") 
        sequence_diag_query = "file[UmlSequenceDiagram && " + 
                            check_semantics_current_file_name + "]"; 
    if (parent_func == "StartCheckSequenceDiagramFiles" || 
        parent_func == "StartCheckWholeModel")   
        sequence_diag_query = "file[UmlSequenceDiagram]"; 

    if (parent_func == "StartCheckCollaborationDiagramFile")  
       collaboration_diag_query = "file[UmlCollaborationDiagram && " +  
                            check_semantics_current_file_name + "]";  
    if (parent_func == "StartCheckCollaborationDiagramFiles" ||  
        parent_func == "StartCheckWholeModel")   
        collaboration_diag_query = "file[UmlCollaborationDiagram]";  

    if (parent_func == "StartCheckStereotypeDiagramFile")   
        stereotype_diag_query = "file[UmlStereotypeDiagram && " +   
                            check_semantics_current_file_name + "]";   
    if (parent_func == "StartCheckStereotypeDiagramFiles" ||   
        parent_func == "StartCheckWholeModel")    
        stereotype_diag_query = "file[UmlStereotypeDiagram]";

    if (parent_func == "StartCheckActivityDiagramFile")    
        activity_diag_query = "file[UmlActivityDiagram && " +    
                            check_semantics_current_file_name + "]";    
    if (parent_func == "StartCheckActivityDiagramFiles" ||    
        parent_func == "StartCheckWholeModel")    
        activity_diag_query = "file[UmlActivityDiagram]"; 

    if (parent_func == "StartCheckStateDiagramFile")     
        state_diag_query = "file[UmlStateDiagram && " +     
                            check_semantics_current_file_name + "]";     
    if (parent_func == "StartCheckStateDiagramFiles" ||     
        parent_func == "StartCheckWholeModel")       
        state_diag_query = "file[UmlStateDiagram]";

    if (parent_func == "StartCheckComponentDiagramFile")      
        component_diag_query = "file[UmlComponentDiagram && " +     
                            check_semantics_current_file_name + "]";      
    if (parent_func == "StartCheckComponentDiagramFiles" ||      
        parent_func == "StartCheckWholeModel")        
        component_diag_query = "file[UmlComponentDiagram]";

    if (parent_func == "StartCheckDeploymentDiagramFile")       
        deployment_diag_query = "file[UmlDeploymentDiagram && " +      
                            check_semantics_current_file_name + "]";       
    if (parent_func == "StartCheckDeploymentDiagramFiles" ||      
        parent_func == "StartCheckWholeModel")         
        deployment_diag_query = "file[UmlDeploymentDiagram]"; 



    if (parent_func == "StartCheckClassDiagramFile" || 
        parent_func == "StartCheckClassDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Class Diagrams");
        error_count += check_whole_model_uclassd_semantics(class_diag_query);
    }

    if (parent_func == "StartCheckUseCaseDiagramFile" || 
        parent_func == "StartCheckUseCaseDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Use Case Diagrams");
        error_count += check_whole_model_uusecased_semantics(usecase_diag_query);
    }

    if (parent_func == "StartCheckSequenceDiagramFile" || 
        parent_func == "StartCheckSequenceDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Sequence Diagrams");
        error_count += check_whole_model_ucollaborationd_semantics(sequence_diag_query);
    }

    if (parent_func == "StartCheckCollaborationDiagramFile" || 
        parent_func == "StartCheckCollaborationDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Collaboration Diagrams");
        error_count += check_whole_model_ucollaborationd_semantics(collaboration_diag_query);
    }

    if (parent_func == "StartCheckStereotypeDiagramFile" || 
        parent_func == "StartCheckStereotypeDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Stereotype Diagrams");
        error_count += check_whole_model_ustereotyped_semantics(stereotype_diag_query);
    }

    if (parent_func == "StartCheckActivityDiagramFile" || 
        parent_func == "StartCheckActivityDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Activity Diagrams");
        error_count += check_whole_model_uactivityd_semantics(activity_diag_query);
    }

    if (parent_func == "StartCheckStateDiagramFile" || 
        parent_func == "StartCheckStateDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking State Diagrams");
        error_count += check_whole_model_ustated_semantics(state_diag_query);
    }

    if (parent_func == "StartCheckComponentDiagramFile" || 
        parent_func == "StartCheckComponentDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Component Diagrams");
        error_count += check_whole_model_ucomponentd_semantics(component_diag_query);
    }

    if (parent_func == "StartCheckDeploymentDiagramFile" || 
        parent_func == "StartCheckDeploymentDiagramFiles" ||
        parent_func == "StartCheckWholeModel")
    {   
        print_message("Checking Deployment Diagrams");
        error_count += check_whole_model_udeploymentd_semantics(deployment_diag_query);
    }

    if (error_count > 0 && out_form != 3)
    {
        print_message("Found " + error_count + 
                          " error" + sc_pl_str(error_count) + ".");

        print_message("Writing report to file " + out_file + "...");

        create_table(out_form, out_file);

// ECR 7410 begin
        if (is_windows_platform() && out_form != 3)
        {
            if (view_after_run())
                shell_execute("open", out_file);
        }
// ECR 7410 end

        print_message("Check Semantics Completed (" + error_count + 
                          " error" + sc_pl_str(error_count) + ").");
    }
    else if (error_count > 0 && out_form == 3)
    {
        print_message("Found " + error_count + 
                           " error" + sc_pl_str(error_count) + ".");
    }
    else if (error_count == 0)
    {
        print_message("No errors found.");
    }

    return error_count;
}

string
sc_pl_str(int error_count)
{
    if (error_count == 1)
        return "";
    else
        return "s";
}

int
check_whole_model_uclassd_semantics(string query)
{
    int x;
    int error_count = 0;
    file current_diag;
    list diag_list = list_select(query); 

    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);

        print_message("Checking Class Diagram \"" + current_diag.name + "\"");

        error_count += check_semantics_global_classes(current_diag);
        error_count += check_semantics_global_instantiated_classes(current_diag);
        error_count += check_semantics_global_parameterized_classes(current_diag);
        error_count += check_semantics_global_packages(current_diag);
        error_count += check_semantics_global_refines(current_diag);
        error_count += check_semantics_global_roles(current_diag);
        error_count += check_semantics_global_associations(current_diag);
        error_count += check_semantics_global_association_class(current_diag);
        error_count += check_semantics_global_interface_class(current_diag);
    }
    print_message("Checking for Circular Inheritance");
    error_count += check_circular_inheritance("UmlClassDiagram");

    return error_count;
}


int
check_whole_model_uusecased_semantics(string query)
{
    int x;
    int error_count = 0;
    file current_diag;
    list diag_list = list_select(query); 

    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);

        print_message("Checking Use Case Diagram \"" + current_diag.name + "\"");

        error_count += check_semantics_global_usecases(current_diag);
        error_count += check_semantics_global_actors(current_diag);
        error_count += check_semantics_global_communicates(current_diag);
        error_count += check_semantics_global_extends(current_diag);
    }

    return error_count;
}


int
check_whole_model_ucollaborationd_semantics(string query)
{
    int x;
    int error_count = 0; 
    file current_diag;
    list diag_list = list_select(query); 

    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);

        if (current_diag.type == "UmlCollaborationDiagram")
            print_message("Checking Collaboration Diagram \"" + current_diag.name + "\"");
        else
            print_message("Checking Sequence Diagram \"" + current_diag.name + "\"");

        error_count += check_semantics_global_collaboration_actors(current_diag);
        error_count += check_semantics_global_collaboration_parent(current_diag);
        error_count += check_semantics_global_collaboration_external_event(current_diag);
        error_count += check_semantics_global_collaboration_messages(current_diag);
        error_count += check_semantics_global_collaboration_objects(current_diag);
        error_count += check_semantics_global_collaboration_extension_points(current_diag);
        error_count += check_semantics_global_collaboration_scenario_instance(current_diag);
        error_count += check_semantics_global_collaboration_type_definition(current_diag);
    }

    return error_count;  
}

int
check_whole_model_ustereotyped_semantics(string query)
{
    int x;
    int error_count = 0;
    file current_diag;
    list diag_list = list_select(query);
 
    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);
 
        print_message("Checking Stereotype Diagram \"" + current_diag.name + "\"");

        error_count += check_stereotype_predefined_definitions(current_diag);
    }
    print_message("Checking for Circular Inheritance");
    error_count += check_circular_inheritance("UmlStereotypeDiagram");
 
    return error_count;
}

int
check_whole_model_uactivityd_semantics(string query)
{
    int x;
    int error_count = 0;
    file current_diag;
    list diag_list = list_select(query);
 
    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);
 
        print_message("Checking Activity Diagram \"" + current_diag.name + "\"");
 
        error_count += check_activity_state_machine(current_diag);
        error_count += check_activity_transitions(current_diag);
    }
 
    return error_count;
}

int
check_whole_model_ustated_semantics(string query)
{
    int x;
    int error_count = 0;
    file current_diag;
    list diag_list = list_select(query);
 
    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);
 
        print_message("Checking State Diagram \"" + current_diag.name + "\"");
 
        error_count += check_activity_state_machine(current_diag);
        error_count += check_activity_transitions(current_diag);
        error_count += check_state_composite_states(current_diag);
    }
 
    return error_count;
}

int
check_whole_model_ucomponentd_semantics(string query)
{
    int x;
    int error_count = 0;
    file current_diag;
    list diag_list = list_select(query);

    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);

        print_message("Checking Component Diagram \"" + current_diag.name + "\"");

        error_count += check_component_interfaces(current_diag);
    }

    return error_count;
}

int
check_whole_model_udeploymentd_semantics(string query)
{
    int x;
    int error_count = 0;
    file current_diag;
    list diag_list = list_select(query);
 
    for (x=0; x<list_count(diag_list); x++)
    {
        current_diag = list_get(diag_list, x);
 
        print_message("Checking Deployment Diagram \"" + current_diag.name + "\"");

        error_count += check_component_interfaces(current_diag);
    }
 
    return error_count;
}

int
check_semantics_global_collaboration_actors(file diag)
{
 
    int x;
    int error_count = 0; 
    node current_actor;
    list all_actors = list_select("node[UmlActor && node_refs[file[" + diag.id + "]] " + 
                                  "&& !node_refs[file[UmlUseCasediagram]]]");
 
    for (x=0; x<list_count(all_actors); x++)
    {
        current_actor = list_get(all_actors, x);
        error_count += check_collaboration_actor_completeness(current_actor, diag);
    }
    return error_count;  
}

int
check_semantics_global_collaboration_parent(file diag)
{
    int error_count = 0; 
 
    error_count += check_collaboration_parent_completeness(diag);

    return error_count;  
}


int
check_semantics_global_collaboration_external_event(file diag)
{

    int x;
    int error_count = 0;
    file current_external_event_diag;
    //ECR 5147 begin
    string query = "file[" + diag.id + 
                   " && link_refs[link[to_node[UmlActor] && " +
                   "(type == UmlSimpleMessage || type == UmlSynchronousMessage || " + 
                   " type == UmlBalkingMessage || type == UmlTimeoutMessage || " + 
                   " type == UmlAsynchronousMessage)]]]";
    set all_external_events_diags = set_select(query);
    query = "file[" + diag.id + 
                   " && link_refs[link[from_node[UmlActor] && " +
                   "(type == UmlSimpleMessage || type == UmlSynchronousMessage || " + 
                   " type == UmlBalkingMessage || type == UmlTimeoutMessage || " + 
                   " type == UmlAsynchronousMessage)]]]";

    set s = set_select(query);
    set_union(all_external_events_diags, s);
    for (x=0; x<set_count(all_external_events_diags); x++)
    {
        current_external_event_diag = set_get_element(all_external_events_diags, x);
        error_count += check_collaboration_external_event_completeness(current_external_event_diag, diag);
    }
    //ECR 5147 end
    return error_count;  
}

int
check_semantics_global_collaboration_messages(file diag)
{
 
    int x;
    int error_count = 0;
    link current_message;
    string query = "link[link_refs[file[" + diag.id + "]] && to_node[type != UmlActor] && " +
                   "(type == UmlSimpleMessage || type == UmlSynchronousMessage || " +
                   " type == UmlBalkingMessage || type == UmlTimeoutMessage || " +
                   " type == UmlAsynchronousMessage)]";
    list all_messages = list_select(query);
 
    for (x=0; x<list_count(all_messages); x++)
    {
        current_message = list_get(all_messages, x);
        error_count += check_collaboration_message_completeness(current_message, diag);
    }
    return error_count;
}

int
check_semantics_global_collaboration_extension_points(file diag)
{
 
    int x;
    int error_count = 0;
    node current_extension_point;
    string query = "node[node_refs[file[" + diag.id + "]] && UmlExtensionPoint]";
    list all_extension_points = list_select(query);
 
    for (x=0; x<list_count(all_extension_points); x++)
    {
        current_extension_point = list_get(all_extension_points, x);
        error_count += check_collaboration_extension_point_completeness(current_extension_point, diag);
    }
    return error_count;
}

int
check_semantics_global_collaboration_scenario_instance(file diag)
{
    int x;
    int error_count = 0;
    node current_scenario;
    string query = "node[node_refs[file[" + diag.id + "]] && UmlScenarioInstance]";
    list all_scenario_instances = list_select(query);

    error_count += check_collaboration_multiple_instance(all_scenario_instances, diag);

    for (x=0; x<list_count(all_scenario_instances); x++)
    {
        current_scenario = list_get(all_scenario_instances, x);
        error_count += check_collaboration_parent_usecase(current_scenario, diag);
    }

    return error_count;  
}

int
check_semantics_global_collaboration_type_definition(file diag)
{
    int x;
    int error_count = 0;
    node current_typedef;
    string query = "node[node_refs[file[" + diag.id + "]] && UmlType]";
    list all_typedefs = list_select(query);

    for (x=0; x<list_count(all_typedefs); x++)
    {
        current_typedef = list_get(all_typedefs, x);
        error_count += check_collaboration_type_defs(current_typedef, diag);
    }

    return error_count;  
}



int
check_semantics_global_usecases(file diag)
{
 
    int x;
    int error_count = 0;
    node current_usecase;
    list all_usecases = list_select("node[node_refs[file[" + diag.id + 
                                    "]] && UmlUseCase]");
 
    for (x=0; x<list_count(all_usecases); x++)
    {
        current_usecase = list_get(all_usecases, x);
        error_count += check_usecase_has_scenario(current_usecase, diag);
    }
    return error_count;
}

int
check_semantics_global_actors(file diag)
{
 
    int x;
    int error_count = 0; 
    node current_actor;
    list all_actors = list_select("node[node_refs[file[" + diag.id + 
                                  "]] && UmlActor]");
 
    for (x=0; x<list_count(all_actors); x++)
    {
        current_actor = list_get(all_actors, x);
        error_count += check_actor_has_scenario(current_actor, diag);
    }
    return error_count;  
}

int
check_semantics_global_communicates(file diag)
{
 
    int x;
    int error_count = 0; 
    link current_communicate; 
    list all_communicates = list_select("link[link_refs[file[" + diag.id + 
                                        "]] && UmlUseCaseInteraction]");
 
    for (x=0; x<list_count(all_communicates); x++)
    {
        current_communicate = list_get(all_communicates, x);
        error_count += check_communicates_has_external_event(current_communicate, diag);
    }
    return error_count;  
}

int
check_semantics_global_extends(file diag)
{
 
    int x;
    int error_count = 0;
    link current_extend;
    list all_extends = list_select("link[link_refs[file[" + diag.id + 
                                   "]] && UmlUseCaseExtends]");
 
    for (x=0; x<list_count(all_extends); x++)
    {
        current_extend = list_get(all_extends, x);
        error_count += check_extends_has_point(current_extend, diag);
    }
    return error_count;
}


int
check_semantics_global_classes(file diag)
{

    int x; 
    int j;
    int error_count = 0;
    node current_class; 
    list all_classes = list_select("node[node_refs[file[" + diag.id + 
                                   "]] && UmlClass]"); 
 
    list errlist = list_create("string",0);

    for (x=0; x<list_count(all_classes); x++) 
    {   
        current_class = list_get(all_classes, x); 
        error_count += check_abstract_and_concrete_classes(current_class, diag);
        error_count += check_unique_namespace(current_class, diag);
        error_count += check_duplicated_components(current_class, diag);
        error_count += check_duplicated_operation_param_names(current_class, diag);
        error_count += check_operation_interface_param_names(current_class, diag);

        //if (!uml_check_class_semantics(current_class.name,"", "",errlist)) 
        //{
        //    for (j=0;j<list_count(errlist);j++) 
        //    {
        //        message(list_get(errlist, j));
        //    }
        //}
    } 

    return error_count;
}

int
check_semantics_global_instantiated_classes(file diag) 
{
 
    int x;
    int error_count = 0; 
    node current_inst_class;
    list all_inst_classes = list_select("node[node_refs[file[" + diag.id + 
                                        "]] && UmlInstantiatedClass]");
 
    for (x=0; x<list_count(all_inst_classes); x++) 
    {    
        current_inst_class = list_get(all_inst_classes, x); 
        error_count += check_instantiated_classes(current_inst_class, diag);
    }    
    return error_count;  
}

int
check_semantics_global_parameterized_classes(file diag) 
{
 
    int x;
    int error_count = 0; 
    node current_param_class;
    list all_param_classes = list_select("node[node_refs[file[" + diag.id + 
                                         "]] && UmlParameterizedClass]");
 
    for (x=0; x<list_count(all_param_classes); x++) 
    {    
        current_param_class = list_get(all_param_classes, x);
        error_count += check_parameterized_classes(current_param_class, diag);
    }    
    return error_count;  
}

int
check_semantics_global_packages(file diag)
{
 
    int x;
    int error_count = 0;
    node current_package;
    list all_packages = list_select("node[node_refs[file[" + diag.id + 
                                    "]] && UmlPackage]");
 
    for (x=0; x<list_count(all_packages); x++)
    {
        current_package = list_get(all_packages, x);
        error_count += check_unique_namespace(current_package, diag);
        error_count += check_unique_package_class_names(current_package, diag);
    }
    return error_count;
}


int
check_semantics_global_refines(file diag)
{
 
    int x;
    int error_count = 0;
    link current_refines;
    list all_refines = list_select("link[link_refs[file[" + diag.id + 
                                   "]] && UmlRefines]");

    graph sTypes = uml_get_full_stereotype_graph();
 
    for (x=0; x<list_count(all_refines); x++)
    {
        current_refines = list_get(all_refines, x);

        error_count += check_bind_stereotype(current_refines, sTypes, diag);
        error_count += check_refine_parameters(current_refines, sTypes, diag);
    }
    return error_count;
}


int
check_semantics_global_roles(file diag)
{
 
    int x;
    int error_count = 0;
    link current_association;
    list all_associations = list_select("link[link_refs[file[" + diag.id + 
                                        "]] && UmlRole]");

    graph sTypes = uml_get_full_stereotype_graph();
 
    for (x=0; x<list_count(all_associations); x++)
    {
        current_association = list_get(all_associations, x);
 
        error_count += check_composition_class_stereotypes(current_association, sTypes, diag);
        error_count += check_association_navigability(current_association, diag);
        error_count += check_role_ends_for_comp_and_agg(current_association, diag);
    }   
    return error_count;
}


int
check_semantics_global_association_class(file diag)
{

    int x;
    int error_count = 0;
    link current_association_link;
    list all_association_class_link = list_select("link[link_refs[file[" + diag.id + 
                                        "]] && UmlAssociationClassLink]");
 
    for (x=0; x<list_count(all_association_class_link); x++)
    {
        current_association_link = list_get(all_association_class_link, x);
 
        error_count += check_associaton_class_link(current_association_link, diag);
    }    
    return error_count;  
}

// Begin Change ECR 6463
int
check_semantics_global_interface_class(file diag)
{
    int x;
    int error_count = 0;
    node current_interface_class;
    set all_interface_classes = set_select("node[node_refs[file[" + diag.id + 
        "]] && UmlClass && items[UmlStereotype && " + 
        "(value = 'interface' || value = 'Interface')]]");
    
    set_union(all_interface_classes, set_select("node[node_refs[file[" + diag.id + 
        "]] && UmlClass && in_links[UmlImplements]]"));
    
    set_union(all_interface_classes, set_select("node[node_refs[file[" + diag.id + 
        "]] && UmlInterface]"));
    
    for (x=0; x<set_count(all_interface_classes); x++)
    {
        current_interface_class = set_get_element(all_interface_classes, x);
        if( current_interface_class.type == "UmlInterface" )
        {
            current_interface_class = find_by_query( "node[UmlClass && name == '" +
                current_interface_class.name + "']" );
        }
        //error_count += check_interface_class_attributes(current_interface_class, diag);
        error_count += check_interface_class_operations(current_interface_class, diag);
        error_count += check_interface_class_inner_classes(current_interface_class, diag);
    }
    return error_count;
}
// End Change ECR 6463

int
check_semantics_global_associations(file diag)
{

    int x;
    int error_count = 0;
    node current_association;
    list all_associations = list_select("node[node_refs[file[" + diag.id +
                                        "]] && UmlAssociation]");

    for (x=0; x<list_count(all_associations); x++)
    {
        current_association = list_get(all_associations, x);

        error_count += check_nary_associaton_aggregation(current_association, diag);
        error_count += check_nary_associaton_navigation(current_association, diag);
        error_count += check_association_dup_names(current_association, diag);
        error_count += check_role_ends_for_att_name_collision(current_association, diag);
        //error_count += check_role_ends_for_dup_name_collision(current_association, diag);
    }
    return error_count;
}


int
check_unique_namespace(node class, file diag)
{
    string type_string = "";
    list packages = uml_get_containing_packages(class);  
    string msg;

    if (class.type == "UmlClass")
        type_string = "Class";
    if (class.type == "UmlPackage")
        type_string = "Package";

    if (packages != NULL && list_count(packages) > 1)  
    {
        msg = type_string + " '" + class.name + 
              "' is contained by more than one package.\n"+
			  "Packages: " + nodes_names(packages) + ".";
        print_error(msg);
        save_message(diag.type, diag.name, "Class", class.name, msg);

        return 1;
    }
    return 0;
}


// Begin Change ECR 6465
int
check_unique_package_class_names(node package, file diag)
{
   string msg;
   
   if (selection_count("node[UmlClass&&node_refs&&name='${package.name}']") > 0)
   {
        msg = "Package '" + package.name + 
            "' is using a name already given to a class.";
        print_error(msg);
        save_message(diag.type, diag.name, "Package", package.name, msg);
        return 1;
   }
   return 0;
}
// End Change ECR 6465

int
check_duplicated_operation_param_names(node current_class, file diag)
{
    int x, y;
    int error_count = 0;
    string sig_string;
    string current_param;
    string current_param_name;
    string previous_name;
    string current_sorted_name;
    list sig_list;
    list param_name_list = list_create("string", 0);
    node current_operation;
    string query = "node[node_refs && UmlOperation && scope_node_id = " +
                    current_class.id + "]";
    string msg;

    list operation_list = list_select(query);

    for (x=0; x<list_count(operation_list); x++)
    {
        current_operation = list_get(operation_list, x);
        sig_string = current_operation.sig;

        sig_list = string_to_list(sig_string, ",");

        if (list_count(sig_list) < 2)
            continue;

        for (y=0; y<list_count(sig_list); y++)
        {
            current_param = list_get(sig_list, y);
            current_param_name = return_first_token_gsc(current_param, ":");
            current_param_name = string_strip(current_param_name, "B", " ");
            list_append(param_name_list, current_param_name);
        }
 
        param_name_list = list_sort(param_name_list);
        previous_name = NULL;  

        for (y=0; y<list_count(param_name_list); y++)
        {
            current_sorted_name = list_get(param_name_list, y);

            if (current_sorted_name == previous_name)
            {
                    msg = "Operation \"" + current_class.name + "::" + 
                            current_operation.name + "\" has duplicate parameter names \"" + 
                            current_sorted_name + "\".";
                    print_error(msg);
                    save_message(diag.type, diag.name, "Operation", current_operation.name, msg);
                error_count++;
                //list_clear(param_name_list);
                //break;
            }
            previous_name = current_sorted_name;
        }
        list_clear(param_name_list);
    }
    return error_count;
}

int
check_operation_interface_param_names(node current_class, file diag)
{
    int x, y;
    int error_count = 0; 
    string sig_string; 
    string current_param;
    string current_param_name;   
    list sig_list;
    node current_operation;
    string query = "node[node_refs && UmlOperation && scope_node_id = " +
                    current_class.id + "]";
    string msg;

    list operation_list = list_select(query);
 
    for (x=0; x<list_count(operation_list); x++)
    {
        current_operation = list_get(operation_list, x);
        sig_string = current_operation.sig;
 
        sig_list = string_to_list(sig_string, ",");
         
        // Begin change ECR 6463
        for (y=0; y<list_count(sig_list); y++)
        {
            current_param = list_get(sig_list, y);
            current_param_name = return_last_token_gsc(current_param, ":");
            current_param_name = string_strip(current_param_name, "B", " ");
            
            if(selection_count("node[node_refs && name = '" + 
                current_param_name + "' && " + 
                "UmlClass && items[UmlStereotype && " + 
                "(value = 'interface' || value = 'Interface')]]") > 0 ||
                selection_count("node[node_refs && name = '" + 
                current_param_name + "' && " + 
                "UmlClass && in_links[UmlImplements]]") > 0 ||
               selection_count("node[node_refs && name = '" + 
                current_param_name + "' && " + 
                "UmlInterface]") > 0 )
            {
                msg = "Operation \"" + current_class.name + "::" + 
                    current_operation.name + "\" uses a parameter type " +
                    "\"" + current_param_name + "\" that is an interface.";
                print_error(msg);
                save_message(diag.type, diag.name, "Operation", current_operation.name, msg);
                error_count++;
            }
        }
        // End change ECR 6463
    }
    return error_count;
}

int
check_abstract_and_concrete_classes(node class, file diag)
{
    int x;
    int error_count = 0;
    string msg;
    node current_component_node;
    item stereotype_item;
    item abstract_item;
    item is_member_item;
    item abstact_class_item;
    item abstract_op_item;
    set component_node_set;
    boolean class_is_concrete = True;
    boolean has_implement_links = False;
    set class_members_set;
    node class_member;

    list implements_links_list = list_select("link[link_refs && UmlImplements " + 
                                             "&& to_node_id = " + class.id + "]");

    if (list_count(implements_links_list) > 0)
        has_implement_links = True;

    graph stereotype_graph = uml_get_full_stereotype_graph();

    stereotype_item = find_by_query("item[type==UmlStereotype && " +
                                    " obj_id == " + class.id + "]");

    if (stereotype_item != NULL)
    {
        if (uml_is_stereotype_of(stereotype_item.value, "type", stereotype_graph) ||
            uml_is_stereotype_of(stereotype_item.value, "interface", stereotype_graph) ||
            uml_is_stereotype_of(stereotype_item.value, "Interface", stereotype_graph) ||
            has_implement_links)
        {
            class_is_concrete = False;
            component_node_set = uml_class_all_members(class, "", "");

            for (x=0; x<set_count(component_node_set); x++)
            {
                current_component_node = set_get_element(component_node_set, x);

                if (current_component_node.type == "UmlOperation")
                {
                    abstract_item = find_by_query("item[type = UmlOperationIsAbstract && " + 
                                    "obj_id = " + current_component_node.id + 
                                    " && value == 'True']");

                    if (abstract_item == NULL)
                    {
                        msg = "Interface Operation \"" + class.name + "::" + 
                                current_component_node.name + "\" is not abstract.";
                        print_error(msg);
                        save_message(diag.type, diag.name, NULL, NULL, msg);
                        error_count++;
                    }
                }

                if (current_component_node.type == "UmlAttribute" &&
                    uml_is_stereotype_of(stereotype_item.value, "interface", stereotype_graph) ||
                    uml_is_stereotype_of(stereotype_item.value, "Interface", stereotype_graph))
                {
					msg = member_format_error(class, current_component_node,
                        "Attribute cannot be included in Interface");
                    //msg = "Attribute \"" + class.name + "::" +
                    //       current_component_node.name + "\" cannot be included in Interface.";
                    print_error(msg);
                    save_message(diag.type, diag.name, NULL, NULL, msg);
                    error_count++;
                }
            }
        }

        if (uml_is_stereotype_of(stereotype_item.value, "utility", stereotype_graph))
        { 
            class_is_concrete = False;
            component_node_set = uml_class_local_members(class, "", "");

            for (x=0; x<set_count(component_node_set); x++)
            {
                current_component_node = set_get_element(component_node_set, x);
 
                is_member_item = find_by_query("item[type = UmlMemberIsClass && " + 
                                "obj_id = " + current_component_node.id +  
                                " && value == 'True']"); 
 
                if (is_member_item == NULL)
                {      
                    msg = "Utility Class Member \"" + class.name + "::" +
                            current_component_node.name + "\" is not class scoped.";
                    print_error(msg);
                    save_message(diag.type, diag.name, NULL, NULL, msg);
                    error_count++;
                }    
            }
        }
    }

    abstact_class_item = find_by_query("item[type = UmlClassIsAbstract && " +
                                       " obj_id = " + class.id + 
                                       " && value = 'True']");

    if (abstact_class_item != NULL)
        class_is_concrete = False;

    if (class_is_concrete)
    {
        class_members_set = uml_class_all_operations(class, "", "");

        for (x=0; x<set_count(class_members_set); x++) 
        {
            class_member = set_get_element(class_members_set, x);

            abstract_op_item = find_by_query("item[type = UmlOperationIsAbstract && " + 
                               "obj_id == " + class_member.id + " && value == 'True']");
            if (abstract_op_item != NULL) 
            {
                if (class_member.scope_node_id == class.id) 
                {
                    msg = "Class Member \"" + class.name + "::" +
                            class_member.name + "\" is locally defined and abstract.";
                    print_error(msg);
                    save_message(diag.type, diag.name, NULL, NULL, msg);
                    error_count++;
                } 
                else 
                {
                    msg = "Class Member \"" + class.name + "::" +
                            class_member.name + "\" has no local operation provided " +
                           "for inherited abstract operation.";
                    print_error(msg);
                    save_message(diag.type, diag.name, NULL, NULL, msg);
                    error_count++;
                }
            }
        }
    }
    return error_count;
}

int
check_duplicated_components(node class, file diag)
{

    int x, y;
    int previous_id;
    string query = "node[node_refs && scope_node_id = " + 
                    class.id + "]";
    node current_component;
    int index;
    list component_refs;
    node_ref current_node_ref;
    boolean duplicate_component = False;
    string type_string;
    int error_count = 0;
    string msg;
    item type_item;

    list class_components = list_select(query);

    for (x=0; x<list_count(class_components); x++)
    {
        current_component = list_get(class_components, x);

        if (current_component.type == "UmlAttribute")
            type_string = "Attribute";
        else if (current_component.type == "UmlOperation")
            type_string = "Operation";
        else
            break;

        component_refs = list_select("node_ref[node_id = " + 
                         current_component.id + "] sort by scope_node_ref_id");

        previous_id = -1;
        duplicate_component = False;
        for (y=0; y<list_count(component_refs); y++)
        {
            current_node_ref = list_get(component_refs, y);

            if (current_node_ref.scope_node_ref_id == previous_id)
                duplicate_component = True;

            previous_id = current_node_ref.scope_node_ref_id;
        }

        if (duplicate_component)
        {
            msg = type_string + " '" + current_component.name + 
                    "' is duplicated in '" + class.name + "'";
            print_error(msg);
            save_message(diag.type, diag.name, type_string, class.name, msg);
            error_count++;
        }

        if (current_component.type == "UmlAttribute")
        {
            type_item = find_by_query("item[UmlAttributeType && obj_id = " + 
                                       current_component.id + "]");
            if (type_item == NULL)
            {
                msg = type_string + " '" + current_component.name + 
                        "' has no type definition.";
                print_error(msg);
                save_message(diag.type, diag.name, type_string, class.name, msg);
                error_count++;
            }
        }
    }
    return error_count;
}


int
check_instantiated_classes(node current_inst_class, file diag)
{

    int error_count = 0;
    node real_class_node;
    node pc_node;
    list refines_out_links;
    string msg;

    real_class_node = find_by_query("node[node_refs && UmlClass && name = '" + 
                                     current_inst_class.name + "']");

    if (real_class_node != NULL)
    {
        refines_out_links = list_select("link[UmlRefines && link_refs && from_node_id = " + 
                                         real_class_node.id + "]");

        pc_node = find_by_query("node[node_refs && UmlParameterizedClass && " +
                                "name = '" + current_inst_class.name + "']"); 

        if (current_inst_class.sig != NULL && current_inst_class.sig != "") 
        {
            // This means its name is the name of a parameterized
            // class, thus it refines that class.
            if (list_count(refines_out_links) > 0)
            {
                msg = "Anonymous Instantiated Class '" + current_inst_class.name +
                      "' may not have Binds Links.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }

            if (pc_node == NULL)
            {
                msg = "Instantiated Class '" + current_inst_class.name + 
                      "' uses a Parameterized Class that " + 
                        "does not exist in the repository.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
        }
        else
        {
            if (list_count(refines_out_links) < 1)
            {
                msg = "Instantiated Classes '" + current_inst_class.name +
                      "' must refine at least one ParameterizedClass.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }

            if (pc_node != NULL)
            {
                msg = "Instantiated Class '" + current_inst_class.name +
                      "' also represented by a " + 
                        "Parameterized Class symbol.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
        }
    }
    return error_count;
}



int
check_parameterized_classes(node current_param_class, file diag)
{
    int error_count = 0;
    node real_class = find_by_query("node[node_refs && UmlClass && name = '" + 
                                     current_param_class.name + "']");
    string msg;

    if (real_class == NULL)
        return 0;

    item param_annots = find_by_query("item[type=UmlClassParameters && 
                                  obj_id=" + real_class.id + "]");
    if (param_annots == NULL || param_annots.value == NULL || param_annots.value == "") 
    {                                                       
        msg = "Parameterized Class '" + current_param_class.name + 
              "' does not have any parameter annotations.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++ ;
    }
    return error_count;
}


int
check_bind_stereotype(link refines, graph sTypes, file diag)
{
    int error_count = 0;
    item stereo_item = find_by_query("item[type=UmlStereotype && obj_id = " + 
                                      refines.id + "]");
    string msg;

    node from_node = find_by_query("node[node_refs && " + refines.from_node_id + "]");
    node to_node = find_by_query("node[node_refs && " + refines.to_node_id + "]");

    if (stereo_item == NULL || !uml_is_stereotype_of(stereo_item.value, "bind", sTypes)) 
    {
         msg = "Binds link from '" + from_node.name + "' to '" + to_node.name + 
               "' must have the stereotype 'bind'.";
         print_error(msg);
         save_message(diag.type, diag.name, NULL, NULL, msg);

         error_count++;
    }
    return error_count;
}

int
check_refine_parameters(link refines, graph sTypes, file diag)
{
    int error_count = 0;
    item refines_param_item;
    item class_param_item;
    list refines_arg_list = list_create("all", 0); 
    list class_arg_list = list_create("all", 0); 
    string msg;

    node from_node = find_by_query("node[node_refs && " + refines.from_node_id + "]");
    node to_node = find_by_query("node[node_refs && " + refines.to_node_id + "]");

    refines_param_item = find_by_query("item[type=UmlRefineArgs && obj_id = " 
                                        + refines.id + "]"); 
  
    if ((refines_param_item == NULL) || 
        (refines_param_item.value == NULL) || 
        (refines_param_item.value == "")) 
    {                                                                                             
        msg = "Binds argument annotations are not present on Binds link " +
              "from '" + from_node.name + "' to '" + to_node.name + "'.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    else
    {
        class_param_item = find_by_query("item[type=UmlClassParameters && obj_id = " + 
                                        refines.to_node_id + "]");

        if (class_param_item != NULL && class_param_item.value != NULL)
        {
            if (!uml_split_arguments(refines_param_item.value, refines_arg_list)) 
            {
                msg = "Error parsing actual parameters on link.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
            if (!uml_split_arguments(class_param_item.value, class_arg_list)) 
            {
                msg = "Error parsing formal parameters on to-node.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }

            if (list_count(refines_arg_list) != list_count(class_arg_list)) 
            {
                msg = "Number of actual parameters does not match formal parameters " +
                      " for refines link " + 
                      "from '" + from_node.name + "' to '" + to_node.name + "'.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
        }
    }
    return error_count;
}

int
check_role_ends_for_comp_and_agg(link role_link, file diag)
{
 
    int error_count = 0;
    item stereo_item;
    string msg;

    node association_node = find_by_query("node[" + role_link.scope_node_id + "]");
 
    link other_role_link = find_by_query("link[UmlRole && to_node_id = " +
                                     association_node.id + " && id != " + role_link.id +
                                     " && link_refs]");

    if (other_role_link == NULL)
        return 0;

    item this_agg_type_item = find_by_query("item[UmlAggregationType && obj_id = " +
                                   role_link.id + 
                                  " && (value = 'Composition' || value = 'Aggregation')]");
    item other_agg_type_item = find_by_query("item[UmlAggregationType && obj_id = " +
                                   other_role_link.id + 
                                  " && (value = 'Composition' || value = 'Aggregation')]");

    if (this_agg_type_item != NULL && other_agg_type_item != NULL)
    {
        msg = "Association " + association_node.name + 
                " may not have an aggregation " + 
                "or composition on both ends.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    return error_count;
}

int
check_role_ends_for_att_name_collision(node association_node, file diag)
{
    int x, y;
    int error_count = 0;
    string msg;

// Removed for ECR 7205
//    list end_nodes = list_select("node[node_refs && UmlClass && " + 
//                                 "out_links[UmlRole && to_node_id = " + 
//                                  association_node.id + "]]");

    list role_list = list_select("link[link_refs && UmlRole && " + 
                                    "to_node_id = " + association_node.id + "]");

    if (list_count(role_list) != 2)
        return error_count;

    link one_role = list_get(role_list, 0);
    link other_role = list_get(role_list, 1);

    // Begin change ECR 7205
    boolean both_navi, other_navi, my_aggr;
    item the_item;
    
    list navigability = list_select( "item[UmlRoleNavigability && " +
        "link[link_refs && ( id = ${one_role.id} || id = ${other_role.id} )]]" );
    if( list_count( navigability ) == 0 || list_count( navigability ) == 2 )
        both_navi = True;
    else
        both_navi = False;
 
    node current_class;
    node current_matching_att;
    list att_list;
 
    for (x=0; x<list_count(role_list); x++)
    {
        one_role = list_get(role_list, x);
        // selects the class on the other(!) end of the association
        current_class = find_by_query("node[node_refs && UmlClass && " + 
                                "out_links[UmlRole && id!= ${one_role.id} && " +
                                "to_node_id = " + association_node.id + "]]");
        if( ! both_navi )
        {
            // Get navigability on opposite end of assoc
            the_item = find_by_query( "item[UmlRoleNavigability && link[link_refs && id = ${one_role.id}]]" );
            if( the_item != NULL )
                other_navi = True;
            else
                other_navi = False;
            
            // Get aggregation/composition on my side
            // we need to check this too for the case of an aggregation *and*
            // navigability set on one side of the assoc
            the_item = find_by_query( "item[UmlAggregationType && " +
                "( value = 'Aggregation' || value = 'Composition' ) && " +
                "link[UmlRole && link_refs && from_node_id = ${current_class.id}]]" );
            if( the_item != NULL )
                my_aggr = True;
            else
                my_aggr = False;
        }
        else
            other_navi = False;
        
        if( other_navi || both_navi || my_aggr )
        {
            att_list = list_select("node[node_refs && UmlAttribute && scope_node_id = " +
                 current_class.id + " && name = '" + one_role.name + "']");
            for (y=0; y<list_count(att_list); y++)
            {
                current_matching_att = list_get(att_list, y);
    
                msg = "Class \"" + current_class.name + "\" has an attribute and an " + 
                        "association role that share the same name \"" + 
                        current_matching_att.name + "\".";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
        }
    }
    // End change ECR 7205        
    return error_count;
}

int
check_role_ends_for_dup_name_collision(node association_node, file diag)
{
    int x, y;
    int error_count = 0;
    string msg;

    list role_list = list_select("link[link_refs && UmlRole && " +
                                    "to_node_id = " + association_node.id + "]");
 
    if (list_count(role_list) != 2)
        return error_count;
 
    link one_role = list_get(role_list, 0);
    link other_role = list_get(role_list, 1);

    if (one_role.name == "" || other_role.name == "")
        return error_count;

    if (one_role.name == other_role.name)
    {
        msg = "Association \"" + association_node.name +  
                "\" has duplicate role names " + one_role.name + "\".";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    return error_count;
}


int
check_composition_class_stereotypes(link role_link, graph sTypes, file diag)
{

    int error_count = 0;
    item stereo_item;
    node association_node = find_by_query("node[" + role_link.scope_node_id + "]");
    string msg;

    link other_role = find_by_query("link[UmlRole && to_node_id = " +
                                     association_node.id + " && id != " + role_link.id + 
                                     " && link_refs]");

    if (other_role == NULL)
        return error_count;

    item agg_type_item = find_by_query("item[UmlAggregationType && obj_id = " + 
                                        role_link.id + " && value = 'Composition']");

    if (agg_type_item != NULL) 
    {
        stereo_item = find_by_query("item[type=UmlStereotype && obj_id=" + 
                                     other_role.from_node_id + "]");

        if (stereo_item != NULL &&
            (uml_is_stereotype_of(stereo_item.value, "type", sTypes) || 
             uml_is_stereotype_of(stereo_item.value, "interface", sTypes) ||
             uml_is_stereotype_of(stereo_item.value, "utility", sTypes) ||
             uml_is_stereotype_of(stereo_item.value, "metaclass", sTypes))) 
        {
            msg = "Classes with stereotype '" +
                     stereo_item.value + "' may not be targets " + 
                    "of aggregation by value.";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;  
        }
    }
    return error_count;
}

int
check_association_navigability(link role_link, file diag)
{

    int error_count = 0;
    boolean roleIsNavigable;
    boolean otherRoleIsNavigable;
    node association_node = find_by_query("node[" + role_link.scope_node_id + "]");
    link other_role = find_by_query("link[UmlRole && to_node_id = " +
                                     association_node.id + " && id != " + role_link.id +
                                     " && link_refs]");
    string msg;

    if (other_role == NULL)
        return error_count;

    if (NULL != find_by_query("item[UmlRoleNavigability && " +
                              "obj_id=" + role_link.id + " && value = 'True']")) 
    {
        roleIsNavigable = True;  
    } 
    else 
    {
        roleIsNavigable = False;
    }
    if (NULL != find_by_query("item[UmlRoleNavigability && " +
                              "obj_id = " + other_role.id + " && value = 'True']")) 
    { 
        otherRoleIsNavigable = True;
    } 
    else 
    {
        otherRoleIsNavigable = False;
    }

    if (otherRoleIsNavigable && NULL != uml_find_elab_node(role_link.from_node_id,
       "UmlInstantiatedClass")) 
    {
        msg = "Association links may not be navigable from Instantiated Classes."; 
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;          
    }

    if (roleIsNavigable && NULL != uml_find_elab_node(role_link.from_node_id,
        "UmlParameterizedClass")) 
    {
        msg = "Association links may not be navigable to Parameterized Classes."; 
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;          
    }
    return error_count;
}

int
check_association_dup_names(node association_node, file diag)
{

    int error_count = 0;
    string msg;

    if (association_node.sig == "")
        return error_count;

    if (string_find(association_node.sig, 0, ":") ==
        string_length(association_node.sig))
        return error_count;

    string left_role = return_first_token_gsc(association_node.sig, ":");
    string right_role = return_last_token_gsc(association_node.sig, ":");

    if (left_role == right_role)
    {
        msg = "Association \"" + association_node.name + "\" has roles with " + 
                "the same name \"" + left_role + "\".";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    return error_count;
}


int
check_nary_associaton_aggregation(node association_node, file diag)
{
    int x;
    int error_count = 0;
    link current_role;
    item comp_item;
    string msg;

    list role_list = list_select("link[link_refs && scope_node_id = " + 
                                  association_node.id + "]");

    if (list_count(role_list) > 2)
    {
        for (x=0; x<list_count(role_list); x++)
        {
            current_role = list_get(role_list, x);
            comp_item = find_by_query("item[type=UmlAggregationType && obj_id = " + 
                                       current_role.id + "]");
            if (comp_item != NULL)
            {
                msg = "N-ary Association Roles may not have aggregation annotations.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
                break;
            }
        }
    }
    return error_count;
}


int
check_nary_associaton_navigation(node association_node, file diag)
{
    int x; 
    int error_count = 0;
    link current_role; 
    item comp_item; 
    item nav_item;
    node elab_node;
    string msg;
 
    list role_list = list_select("link[link_refs && scope_node_id = " +
                                  association_node.id + "]");
 
    if (list_count(role_list) > 2)
    {    
        for (x=0; x<list_count(role_list); x++) 
        { 
            current_role = list_get(role_list, x); 

            nav_item = find_by_query("item[UmlRoleNavigability && " +
                                     "obj_id=" + current_role.id + " && value='True']"); 

            elab_node = uml_find_elab_node(current_role.from_node_id, "UmlParameterizedClass");

            if (nav_item != NULL && elab_node != NULL)
            {
                msg ="N-ary Association Roles may not be navigable to Parameterized Classes.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
                break;
            }
        }
    }   
    return error_count;  
}

int
check_interface_class_attributes(node interface_class, file diag)
{

    int error_count = 0;
    string att_query = "node[node_refs && UmlAttribute && scope_node_id = " + 
                        interface_class.id + "]";
    string msg;
    list attribute_list = list_select(att_query);

    if (list_count(attribute_list) > 0)
    {
        msg = "Interface \"" + interface_class.name + "\" cannot have attributes.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    return error_count;
}

int
check_interface_class_operations(node interface_class, file diag)
{

    int x;
    int error_count = 0;
    string opp_query = "node[node_refs && UmlOperation && scope_node_id = " +
                        interface_class.id + "]";
    list operation_list = list_select(opp_query);
    node current_opearation;
    item visibility_item;
    string msg;

    for (x=0; x<list_count(operation_list); x++) 
    {
        current_opearation = list_get(operation_list, x);

        visibility_item = find_by_query("item[UmlMemberVisibility && obj_id = " + 
                                         current_opearation.id + "]"); 

        if (visibility_item == NULL)
            continue;

        if (visibility_item.value != "public")
        {
            msg = "Interface \"" + interface_class.name + 
                    "\" has operation \"" + current_opearation.name + 
                    "\" without public visibility \"" + 
                    visibility_item.value + "\".";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;

        }
    }
    return error_count;
}

int
check_interface_class_inner_classes(node interface_class, file diag)
{
    int x;
    int error_count = 0;
    node current_inner_class;
    string inner_class_query = "node[node_refs && UmlClass && " + 
                               "items[UmlEnclosingScope && value = '" + 
                                interface_class.name + "']]";
    list inner_class_list = list_select(inner_class_query);
    string msg;

    for (x=0; x<list_count(inner_class_list); x++) 
    {
        current_inner_class = list_get(inner_class_list, x);
        msg = "Class \"" + current_inner_class.name + 
                "\" is enclosed by interface \"" + 
                interface_class.name + "\".";  
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    } 
    return error_count;  
}

int
check_associaton_class_link(link assoc_link, file diag)
{
    int error_count = 0;
    string ass_link_label;
    node association_node = find_by_query("node[node_refs && UmlAssociation && " + 
                                      assoc_link.from_node_id + "]");

    node association_class_node = find_by_query("node[node_refs && UmlClass && " + 
                                assoc_link.to_node_id + "]");

    string msg;

    if (string_find(association_node.name, 0, ":") != 
        string_length(association_node.name))
    {
        ass_link_label = return_first_token_gsc(association_node.name, ":");

        if (ass_link_label != association_class_node.name)
        {
            msg = "Association \"" + ass_link_label + "\" with association class \"" + 
                    association_class_node.name + "\" should share the same name.";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }
    }
    return error_count;
}

int
check_usecase_has_scenario(node usecase, file diag)
{

    int error_count = 0;
    node_ref scenario_node_ref;
    string msg;

    string scenarios_query = "node_ref[node[UmlScenarioInstance && " + 
                             "items[UmlParentNameItem && value='" + usecase.name + "'] " + 
                             "&& items[UmlParentTypeItem && value='UmlUseCase']] && " + 
                             "file[UmlSequenceDiagram || UmlCollaborationDiagram]]";

    scenario_node_ref = find_by_query(scenarios_query);

    if (scenario_node_ref == NULL)
    {
        msg = "Use Case '" + usecase.name + "' does not have an interaction scenario.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }

    return error_count;
}

int
check_actor_has_scenario(node actor, file diag)
{

    int error_count = 0;
    node_ref scenario_node;
    string msg;

    string scenarios_query = "node_ref [node_id = " + actor.id + " && " + 
                             "file[UmlSequenceDiagram || UmlCollaborationDiagram]]";

    scenario_node = find_by_query(scenarios_query);

    if (scenario_node == NULL)
    {
        msg = "Actor '" + actor.name + "' does not have an interaction scenario.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }

    return error_count;
}


int
check_communicates_has_external_event(link communicates, file diag)
{

    int error_count = 0;
    list event_node_ref_list;

    node actor = find_by_query("node[" + communicates.from_node_id + "]");
    node usecase = find_by_query("node[" + communicates.to_node_id + "]");
    string msg;

    string event_query = "link_ref[file[(UmlSequenceDiagram || UmlCollaborationDiagram) " + 
                         "&& node_refs[node[UmlScenarioInstance && " + 
                         "items[UmlParentTypeItem && value='" + usecase.type + "'] && " + 
                         "items[UmlParentNameItem && value='" + usecase.name + "']]]] && " + 
                         "link[from_node_id=" + actor.id + "]]";

    event_node_ref_list = list_select(event_query);

    if (list_count(event_node_ref_list) == 0)
    {

        msg = "Interaction between Actor '" + actor.name + "' and Use Case '" + 
                usecase.name + "' does not have a corresponding external event in any scenario.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    return error_count;
}

int
check_extends_has_point(link extend, file diag)
{
 
    int error_count = 0;
    list event_node_ref_list;
    file scenario_file;
    string msg;
 
    node usecase = find_by_query("node[" + extend.from_node_id + "]");
    node extended_usecase = find_by_query("node[" + extend.to_node_id + "]");
    node extention_point_node = find_by_query("node[UmlExtensionPoint & name='" + 
                                               usecase.name + "' & node_refs]");

    if (extention_point_node == NULL)
    {
        msg = "The Extend Use Case '" + usecase.name + 
                "' does not have a corresponding Extension Point.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    else
    {
        string find_scenario_file = "file[(UmlSequenceDiagram || UmlCollaborationDiagram) && " + 
                        "node_refs[node[id=" + extention_point_node.id + "]] && " + 
                        "node_refs[node[UmlScenarioInstance && " + 
                        "items[UmlParentTypeItem && value='" + extended_usecase.type + "'] && " + 
                        "items[UmlParentNameItem && value='" + extended_usecase.name + "']]]]";
        //scenario_file = find_by_query(find_scenario_file);

        if (!return_scenario_with_extension_glb(extended_usecase, extention_point_node))
        //if (scenario_file == NULL)
        {
            msg = "The Extend Use Case '" + extended_usecase.name + "' does not have " + 
                    "an Extension Point in the scenario of the Use Case it extends.";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }
    }
    return error_count;
}

boolean
return_scenario_with_extension_glb(node extendedUseCase, node theExtPoint)
{

    int x, y;
    node current_scen_node;
    item current_item;
    string nm_item_query, tp_item_query;
    list nm_item_list, tp_item_list;
    boolean found_name = False, found_type = False;
    string type_string;
    string euc_type_string = extendedUseCase.type;

    string scen_query = "node[UmlScenarioInstance && " +
            "node_refs[file[(UmlSequenceDiagram || UmlCollaborationDiagram) " +
            "&& node_refs[node[" + theExtPoint.id + "]]]]]";

    list scen_node_list = list_select(scen_query);

    if (list_count(scen_node_list) == 0)
        return False;

    for (x=0; x<list_count(scen_node_list); x++)
    {
        current_scen_node = list_get(scen_node_list, x);

        nm_item_query = "item[UmlParentNameItem && obj_id = " +
                         current_scen_node.id + "]";
        tp_item_query = "item[UmlParentTypeItem && obj_id = " +
                         current_scen_node.id + "]";
        nm_item_list = list_select(nm_item_query);
        tp_item_list = list_select(tp_item_query);

        for (y=0; y<list_count(nm_item_list); y++)
        {
            current_item = list_get(nm_item_list, y);

            if (current_item.value == extendedUseCase.name)
                found_name = True;
        }

        for (y=0; y<list_count(tp_item_list); y++)
        {
            current_item = list_get(tp_item_list, y);

            type_string = current_item.value;

            if (type_string == euc_type_string)
                found_type = True;
        }
    }

    if (found_name && found_type)
    {
        return True;
    }
    else
    {
        return False;
    }
}



int
check_circular_inheritance(string diag_type)
{

    int x;
    int error_count = 0; 
    int index;
    string to_name;
    node from_node, to_node;
    link current_inh_link;
    graph inh_graph = graph_create();
    list all_links;
    string msg;

    if (diag_type == "UmlClassDiagram")
        all_links = list_select("link[link_refs && UmlGeneralization]");
    else
        all_links = list_select("link[link_refs && UmlStereotypeInheritance]");

    list from_names = list_create("string",0);
    set to_names = set_create("string");
    list from_nodes = list_create("node",0);

    for (x=0; x<list_count(all_links); x++)
    {
        current_inh_link = list_get(all_links, x);

        from_node = find_by_query("node[" + current_inh_link.from_node_id + "]");
        to_node = find_by_query("node[" + current_inh_link.to_node_id + "]");

        graph_add_arc(inh_graph, from_node.name, to_node.name);
        list_append(from_names, from_node.name);
        set_add(to_names, to_node.name);
        list_append(from_nodes, from_node);
    }

    for (x=0; x<set_count(to_names); x++)
    {
        to_name = set_get_element(to_names, x);

        if (graph_is_indirect_arc(inh_graph, to_name, to_name)) 
        {
            index = list_find(from_names, 0, to_name);
            from_node = list_get(from_nodes, index);

            if (diag_type == "UmlClassDiagram")
            {
                if (from_node.type == "UmlClass")
                {
                    msg = "Class \"" + from_node.name + 
                            "\" is involved in an inheritance cycle.";
                    print_error(msg);
                    save_message(diag_type, "NA", NULL, NULL, msg);
                }
                else
                {
                    msg = "Package \"" + from_node.name + 
                            "\" is involved in an inheritance cycle.";
                    print_error(msg);
                    save_message(diag_type, "NA", NULL, NULL, msg);
                }
            }
            else
            {
                msg = "Stereotype \"" + from_node.name + 
                        "\" is involved in an inheritance cycle.";
                print_error(msg);
                save_message(diag_type, "NA", NULL, NULL, msg);
            }
            error_count++;
        }
    }
    return error_count;
}


int
check_collaboration_actor_completeness(node actor, file diag)
{
    int error_count = 0;
    string msg;
    msg = "Actor '" + actor.name + "' does not appear in any Use Case diagram.";
    print_error(msg);
    save_message(diag.type, diag.name, NULL, NULL, msg);
    return ++error_count;
}


int
check_collaboration_parent_completeness(file parent)
{

    int error_count = 0;
    string query;

    if (parent.type == "UmlCollaborationDiagram")
        query = "node[UmlScenarioInstance && node_refs[file[UmlCollaborationDiagram " + 
                     "&& name='" + parent.name + "']]]";

    else if (parent.type == "UmlSequenceDiagram")
        query = "node[UmlScenarioInstance && node_refs[file[UmlSequenceDiagram " + 
                     "&& name='" + parent.name + "']]]";
    else
        return error_count;

    node scen_inst = find_by_query(query);
    string msg;

    if (scen_inst == NULL)
    {
        msg = "Diagram '" + parent.name +"' does not have a " +
                        "ScenarioInstance object (does not have a parent).";
        print_error(msg);
        save_message(parent.type, parent.name, NULL, NULL, msg);
        error_count++;
    }
    return error_count;
}


int
check_collaboration_external_event_completeness(file external_event_diag, file diag)
{
    int x;
    int error_count = 0;
    list ex_event_from_link_list = list_create("link", 0);
    list ex_event_to_link_list = list_create("link", 0);
    link external_event_from_link;
    link external_event_to_link;
    link comm_link;
    string external_event_from_link_query;
    string external_event_to_link_query;
    item usename_item;
    string msg;

    node scenario_node = find_by_query("node[UmlScenarioInstance && node_refs[file[" + 
                                        external_event_diag.id + "]]]"); 

    if (scenario_node == NULL)
    {
        msg = "Diagram '" + diag.name + "' has External events, " + 
                "but does not have a parent Use Case.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    else
    {

        usename_item = find_by_query("item[UmlParentNameItem && obj_id=" + 
                       scenario_node.id + "]");

        external_event_from_link_query = "link[link_refs[file[" + external_event_diag.id + 
                     "]] && from_node[UmlActor] && " +
                     "(type == UmlSimpleMessage || type == UmlSynchronousMessage || " + 
                     " type == UmlBalkingMessage || type == UmlTimeoutMessage || " + 
                     " type == UmlAsynchronousMessage)]";

        external_event_to_link_query = "link[link_refs[file[" + external_event_diag.id + 
                     "]] && to_node[UmlActor] && " +
                     "(type == UmlSimpleMessage || type == UmlSynchronousMessage || " + 
                     " type == UmlBalkingMessage || type == UmlTimeoutMessage || " + 
                     " type == UmlAsynchronousMessage)]";

        ex_event_from_link_list = list_select(external_event_from_link_query);
        ex_event_to_link_list = list_select(external_event_to_link_query);

        for (x=0; x<list_count(ex_event_from_link_list); x++)
        {
            external_event_from_link = list_get(ex_event_from_link_list, x);

            comm_link = find_by_query("link[link_refs && UmlUseCaseInteraction && " + 
                        "from_node_id == " + external_event_from_link.from_node_id + " && " +
                        "to_node[UmlUseCase && node_refs && name = '" + usename_item.value + "']]");

            if (comm_link == NULL)
            {
                msg = "External event '" + external_event_from_link.name + 
                        "' does not have a corresponding communicates link.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
        }

        for (x=0; x<list_count(ex_event_to_link_list); x++)
        {
            external_event_to_link = list_get(ex_event_to_link_list, x);
 
            comm_link = find_by_query("link[link_refs && UmlUseCaseInteraction && " +
                        "from_node_id == " + external_event_to_link.from_node_id + " && " +
                        "to_node[UmlUseCase && node_refs && name = '" + usename_item.value + "']]");
 
            if (comm_link == NULL)
            {
                msg = "External event '" + external_event_to_link.name +
                        "' does not have a corresponding communicates link.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
        }
    }

    return error_count;
}

int
check_collaboration_message_completeness(link current_message, file diag)
{

    int error_count = 0;
    int message_arg_count;
    int operation_arg_count;
    node corresponding_operation;
    item message_name_item;
    item message_arg_item;
    string msg;

    message_name_item = find_by_query("item[UmlObjectName & obj_id == " + 
                        current_message.id + "]");
    message_arg_item = find_by_query("item[UmlMessageArgs & obj_id == " + 
                        current_message.id + "]");

    message_arg_count = list_count(string_to_list(message_arg_item.value, ","));

    corresponding_operation = find_by_query("node[node_refs && UmlOperation && name == '" + 
                              message_name_item.value + "']");

    if (corresponding_operation == NULL)
    {
        msg = "Message '" + message_name_item.value + 
                "' does not have a corresponding Operation defined.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;    
    }
    else
    {
        operation_arg_count = list_count(string_to_list(corresponding_operation.sig, ","));

        if (operation_arg_count != message_arg_count)
        {
            msg = "Message '" +message_name_item.value + 
            "' does not have a corresponding Operation defined with the " +
            "same number of arguments (" + message_arg_count + ")";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }

    }

    return error_count;
}


int
check_semantics_global_collaboration_objects(file diag)
{
    int x;
    int error_count = 0;
    list obj_scopes_list = list_select("node[UmlObjectClassScope && node_refs[file[" + 
                                        diag.id + "]]]");
    node current_obj_scope;
    node class_node;
    item sttype;
    string msg;

    for (x=0; x<list_count(obj_scopes_list); x++)
    {
        current_obj_scope = list_get(obj_scopes_list, x);

        if (string_extract(current_obj_scope.name, 0, 2) != "%%")
        {
            class_node = find_by_query("node[node_refs && UmlClass && name == '" + 
                             current_obj_scope.name + "']");

            if (class_node == NULL) 
            {
                msg = "Object (scope) class \"" + current_obj_scope.name +
                        "\" does not have a corresponding Class defined.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
            else
            {
                sttype = find_by_query("item[UmlStereotype & node[UmlClass && name == '" + 
                         current_obj_scope.name + "'] & value='utility']");

                if (sttype != NULL)
                {
                    msg = "Class '" + current_obj_scope.name + "' is of stereotype <<" +
                            sttype.value + ">> and cannot have instances.";
                    print_error(msg);
                    save_message(diag.type, diag.name, NULL, NULL, msg);
                    error_count++;
                }
            }
        }
    }
    return error_count++;
}


int
check_collaboration_extension_point_completeness(node extension_point, file diag)
{

    int error_count = 0;
    string msg;

    string query = "node[UmlScenarioInstance && node_refs[file[node_refs[node[" + 
                    extension_point.id + "]]]]]";

    list scenario_list = list_select(query);

    if (list_count(scenario_list) == 0)
    {
        msg = "Scenario has an Extension Point \"" + extension_point.name + 
                "\" but not a parent (there is no ScenarioInstance in a diagram).";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;
    }
    return error_count;
}

int
check_collaboration_multiple_instance(list scenario_instance_list, file diag)
{

    int x;
    int error_count = 0;
    node current_scenario;
    string msg;

    if (list_count(scenario_instance_list) > 1)
    {
        for (x=0; x<list_count(scenario_instance_list); x++)
        {
            current_scenario = list_get(scenario_instance_list, x);
            msg = "Scenario has more than one ScenarioInstance \"" + 
                    current_scenario.name + "\"";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }
    }
    return error_count;
}

 

int
check_collaboration_parent_usecase(node current_scenario, file diag)
{

    int x;
    int error_count = 0;
    list extension_point_list;
    node current_extension_point;
    link extends_link;
    string msg;

    item parenttype = find_by_query("item[UmlParentTypeItem & obj_id = " + 
                                     current_scenario.id + "]");    
    item parentname = find_by_query("item[UmlParentNameItem & obj_id = " + 
                                     current_scenario.id + "]");

    if (parenttype == NULL || parentname == NULL) 
    {
        msg = "ScenarioInstance '" + current_scenario.name + 
                "' has incomplete mappings:: UmlParentTypeItem='" + parenttype + 
                "' UmlParentNameItem = '" + parentname + "'";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        return ++error_count;
    }

    if (parenttype.value != "UmlUseCase") 
    {
        msg = "Scenario's parent is not a Use Case (it is '" + 
                parenttype.value + "')";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        return ++error_count;
    } 

    node use_case_parent = find_by_query("node[UmlUseCase & node_refs & name = '" + 
                           parentname.value + "']");

    if(use_case_parent == NULL) 
    {
        msg = "Scenario's parent is not found (it does not exist or perhaps you " + 
                " have unsaved files?)";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        return ++error_count;
    }

    extension_point_list = list_select("node[node_refs[file[" + 
                                        diag.id + "]] && UmlExtensionPoint]");

    for (x=0; x<list_count(extension_point_list); x++)
    {
        current_extension_point = list_get(extension_point_list, x);

        extends_link = find_by_query("link[UmlUseCaseExtends && link_refs && " + 
                                     "from_node[UmlUseCase && name = '" + 
                                      current_extension_point.name + "'] & to_node_id = " + 
                                      use_case_parent.id + "]");
        if (extends_link == NULL)
        {
            msg = "Extension Point '" + current_extension_point.name + " does not " +
                    "have a corresponding Extend Use Case," +
                    "there is no such extension for this scenario's parent Use Case '" + 
                    parentname.value + "'";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }
    }
    return error_count;
}


int
check_collaboration_type_defs(node current_typedef, file diag)
{

    int error_count = 0;
    string query = "link[link_refs[file[" + diag.id + "]] && " +  
                   "(type == UmlSimpleMessage || type == UmlSynchronousMessage || " + 
                   " type == UmlBalkingMessage || type == UmlTimeoutMessage || " + 
                   " type == UmlAsynchronousMessage)]";
    string msg;

    list messages_list = list_select(query);

    if (list_count(messages_list) > 0)
    {
        msg = "Diagram \"" + diag.name + "\" contains Type definition \"" + 
                current_typedef.name + "\" and should not contain message flows.";
        print_error(msg);
        save_message(diag.type, diag.name, NULL, NULL, msg);
        error_count++;

    }
    return error_count;
}


int 
check_stereotype_predefined_definitions(file diag)
{

    int x;
    int error_count = 0;
    node current_stereotype;
    string predefined_stereotypes = "actor application becomes bind call " + 
           "constraint copy derived document enumeration extends facade file friend " + 
           "import instance interface library metaclass page powertype process " + 
           "refinement requirement role send signal stub subclass subtype table thread " + 
           "trace uses utility";

    list predefined_stereotypes_list = string_to_list(predefined_stereotypes, " ");
    string node_query = "node[node_refs[file[" + diag.id + "]] && UmlStereotype && " +
                        "out_links[link_refs]]";
    string msg;

    list all_stereotype_list = list_select(node_query);

    for (x=0; x<list_count(all_stereotype_list); x++)
    {
        current_stereotype = list_get(all_stereotype_list, x);

        if (list_find(predefined_stereotypes_list, 0, current_stereotype.name) ==
            list_count(predefined_stereotypes_list))
            continue;
        else
        {
            msg = "Predefined Stereotypes can only be root elements, Stereotype \"" + 
                    current_stereotype.name + "\" cannot be a child."; 
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++; 
        }
    }
    return error_count;
}


int
check_activity_state_machine(file diag)
{

    int x;
    int error_count = 0;
    int pos;
    string query = "node[node_refs[file[" + diag.id + "]] && UmlStateMachine]";
    node state_machine_node;
    node corresponding_class;
    node corresponding_operation;
    uml_operation parsed_operation;
    string class_name;
    string operation_name;
    string msg;

    list state_machines_list = list_select(query);

    for (x=0; x<list_count(state_machines_list); x++)
    {
        state_machine_node = list_get(state_machines_list, x);

        if (string_find(state_machine_node.name, 0, UML_PATH_SEPARATOR) == 
            string_length(state_machine_node.name)) 
        {
            corresponding_class = find_by_query("node[UmlClass && node_refs && name = '" + 
                                                state_machine_node.name + "']");
            if (corresponding_class == NULL)
            {
                msg = "State Machine \"" + state_machine_node.name + 
                        "\" has no corresponding Class.";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
            }
        }
        else
        {
            pos = string_find(state_machine_node.name, 0, UML_PATH_SEPARATOR);
            class_name = string_extract(state_machine_node.name ,0, pos);
            pos = pos + string_length(UML_PATH_SEPARATOR);

            if(pos >= string_length(state_machine_node.name))
                return error_count;
 
            operation_name = string_extract(state_machine_node.name ,pos,
                             string_length(state_machine_node.name) - pos);
        
            parsed_operation = uml_parse_operation(operation_name);
        
            if (parsed_operation.error)
                return error_count;

            corresponding_operation = find_by_query("node[UmlOperation && node_refs && " + 
                             "sig == '" + parsed_operation.opArgs + "' && " + 
                             "name == '" + parsed_operation.opName + "' && " + 
                             "scope_node[name = '" + class_name + "']]");

            if (corresponding_operation == NULL)
            {
                 msg = "No Operation \"" + state_machine_node.name +
                         "\" corresponding to State Machine.";
                 print_error(msg);
                 save_message(diag.type, diag.name, NULL, NULL, msg);
                 error_count++;
            }
        }
    }
    return error_count; 
}

int
check_activity_transitions(file diag)
{
    int x, y;
    int error_count = 0;

    string query = "node[node_refs[file[" + diag.id + 
                   "]] && (UmlInitialState || UmlActionState || UmlState)]";
    node current_state;
    link current_transition_link;
    list transition_links_list;
    list transition_name_list = list_create("string", 0);
    string current_sorted_name;
    string previous_name;
    string msg;
    int cnt; // ECR 6369
    UMLParsedTransition pt; // ECR 6369

    list all_trans_nodes = list_select(query);

    for (x=0; x<list_count(all_trans_nodes); x++)
    {
        current_state = list_get(all_trans_nodes, x);

        transition_links_list = list_select("link[link_refs && UmlTransition && from_node[" + 
                                             current_state.id + "]]");

        for (y=0; y<list_count(transition_links_list); y++)
        {
            current_transition_link = list_get(transition_links_list, y);
            list_append(transition_name_list, current_transition_link.name); 
        }

        transition_name_list = list_sort(transition_name_list);
        previous_name = NULL;

        for (y=0; y<list_count(transition_name_list); y++)
        {
            current_sorted_name = list_get(transition_name_list, y);
            if (current_sorted_name == previous_name)
            {
                if (current_state.name != "")
                {
                    msg = "State \"" + current_state.name + "\" has " +
                          "non-deterministic transitions.";
                    print_error(msg);
                    save_message(diag.type, diag.name, NULL, NULL, msg);
                }
                else
                {
                    msg = "State has non-deterministic transitions.";
                    print_error(msg);
                    save_message(diag.type, diag.name, NULL, NULL, msg);
                }

                error_count++;
                list_clear(transition_name_list);
                break;
            }
            previous_name = current_sorted_name;

// ECR 6369 begin
            pt = uml_parse_transition_label(current_sorted_name);
            cnt = count_comma_separated_expressions(pt.event);
            if (cnt > 1)
            {
                msg = "Transition link '" + current_sorted_name + "' has " + cnt + " events!";
                print_error(msg);
                save_message(diag.type, diag.name, NULL, NULL, msg);
                error_count++;
                list_clear(transition_name_list);
                break;
            }
// ECR 6369 end
        }
        list_clear(transition_name_list);
    }
    return error_count;
}


int 
check_state_composite_states(file diag)
{
    int x, y;
    int error_count = 0;
    string query = "node[node_refs[file[" + diag.id + 
                   "]] && UmlState && scoped_nodes[UmlState]]";
    string act_query;
    list comp_node_list = list_select(query);
    node current_comp_node;
    node corresponing_concurrent_node;
    link activity_link;
    string msg;
    string init_state_query;
    list init_state_list;
    list comp_state_node_ref_list;
    node_ref current_comp_node_ref;
    list history_state_ref_list;

    for (x=0; x<list_count(comp_node_list); x++)
    {
        current_comp_node = list_get(comp_node_list, x);

        corresponing_concurrent_node = find_by_query("node[node_refs && name = '" + 
                       current_comp_node.name + "' && scope_node[UmlStateMachine]]");

        if (corresponing_concurrent_node != NULL)
            current_comp_node = corresponing_concurrent_node; 

        act_query = "link[link_refs && UmlStateActivity && from_node_id = " + 
                    current_comp_node.id +"]";

        activity_link = find_by_query(act_query);

        if (activity_link != NULL)
        {
            msg = "Composite state \"" + current_comp_node.name + 
                    "\" has an activity.";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }

        init_state_query = "node[node_refs && UmlInitialState && " + 
                           "out_links[to_node[" + current_comp_node.id + "]]]";

        init_state_list = list_select(init_state_query);

        if (list_count(init_state_list) > 1)
        {
            msg = "Composite state \"" + current_comp_node.name + 
                    "\" has more than one initial vertex.";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }

        //comp_state_node_ref_list = list_select("node_ref[node_id = " + 
        //                           current_comp_node.id + "]");

        //for (y=0; y<list_count(comp_state_node_ref_list); y++)
        //{
        //    current_comp_node_ref = list_get(comp_state_node_ref_list, y);

        //    history_state_ref_list = list_select("node_ref[node[UmlHistoryState] && " +
        //                       "scope_node_ref_id = " + current_comp_node_ref.id + "]");

        //    if (list_count(history_state_ref_list) > 1)
        //    {
        //        msg = "Composite state \"" + current_comp_node.name + 
        //                "\" has more than one history vertex.";
        //        print_error(msg);
        //        save_message(diag.type, diag.name, NULL, NULL, msg);
        //        error_count++;
        //        break;
        //    }
        //}

    }
    return error_count;
}


int
check_component_interfaces(file diag)
{
    int x;
    int error_count = 0;
    string query = "node[node_refs[file[" + diag.id + "]] && UmlComponentInterface]";
    list component_node_list = list_select(query);
    node current_interface_node;
    list out_links_list;
    string msg;

    for (x=0; x<list_count(component_node_list); x++)
    {
        current_interface_node = list_get(component_node_list, x);

        out_links_list = list_select("link[link_refs && UmlComponentInterface " + 
                         "&& from_node_id = " + current_interface_node.id + "]");

        if (list_count(out_links_list) == 0)
        {
            msg = "Interface \"" + current_interface_node.name +
                    "\" is not attached to a component.";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }
        if (list_count(out_links_list) > 1)
        { 
            msg = "Interface \"" + current_interface_node.name +  
                    "\" is attached to " + list_count(out_links_list) + " components.";
            print_error(msg);
            save_message(diag.type, diag.name, NULL, NULL, msg);
            error_count++;
        }
    }
    return error_count;
}


string
return_first_token_gsc(string in_string, string separator)
{
    if (string_length(in_string) > 0
        && string_find(in_string, 0, separator)
        < string_length(in_string))
        return string_extract(in_string, 0, string_find(in_string, 0, separator));
    else
        return in_string;
}


string
return_last_token_gsc(string in_string, string separator)
{
    if (string_length(in_string) > 0
        && string_find(in_string, 0, separator) < string_length(in_string))
    {
        return string_extract(in_string,
               string_find(in_string, 0, separator) + string_length(separator),
               string_length(in_string) - string_find(in_string, 0, separator) -
               string_length(separator));
    }
    else
        return in_string;
}


int
create_table(int out_form, string out_file)
{

    string out_file_name = path_compose(current_projdir() + current_system(), 
        "misc_files"); // ECR 7403

    if (!write_file_access(out_file_name))
    {
        print_error("Cannot write output table file " + out_file);
        return 1;
    }
    //if (!write_file_access(out_file))
    //{
    //    print_error("Cannot write output table file " + out_file);
    //    return 1;
    //}

    int x;

    string transfer_file_name = current_projdir() + current_system() +
                              "/.sem_check_table_info_" + getpid();

    write_file(transfer_file_name, 
               list_to_string(whole_model_sem_check_msg_list, "\n"));

    int rc;
    string system = " -s " + current_system();
    string projdir = " -p " + current_projdir();

    string output_file = " -o " + out_file;
    string table_file_info = " -x table_file_info " + transfer_file_name + " ";

    string output_format;
    string format_file;

    if (out_form == 0)
    {
        output_format = " -t mif ";
        format_file = " -f stpreport.mif ";
    }
    //else if (out_form == 1)
    //{
    //    output_format = " -t leaf ";
    //    format_file = " -f all_files ";
    //}
    else if (out_form == 1)
    {
        output_format = " -t rtf ";

        // SPR 42 - Error messages printed in header and footer of
        //  report document. The stpreport.rtf format file doesn't fit
        //  this type of report. To make it consistent with the HTML
        //  version, stpreport.rtf has been replaced with basic.
        // format_file = " -f stpreport.rtf ";
           format_file = " -f basic ";
    }

    else if (out_form == 2)
    {
        output_format = " -t html ";
        format_file = " -f stpreport.css ";
    }

    string cmd = "qrp" + system + projdir + output_file + output_format +
                  table_file_info + format_file + 
                 " uml/rules/qrl/semantic_check_whole_model_table.qrl";

    rc = system(cmd);

    if (rc == 0)
        print_message("Report Completed.");
    if (rc == 1)
        print_error("Could not write output table file.");

    return 0;
}



