//      StP/UML
//      Confidential property of Aonix
//      Copyright (c) 2000
//      All rights reserved

// New File for ECR 3786, 4110

#include "rules/qrl/uml_inherit_ops.inc"
#include "rules/qrl/oper_parse.inc"
#include "rules/qrl/navtostp.inc"

// We have to remember what property sheet called us, so
// that we can refresh fields in that sheet
// upon clicking on the OK Button
string st_calling_ps ="";

// We need to remember this. As we cannot close PSs from within
// StP, we have to rembember the symbol and deactivate the ps
// if a different symbol is selected.
//
gde_symbol st_target_symbol;

// ============================================================================
// Guard chooser callbacks etc.
// ============================================================================
void 
fill_guard_ps( string c_ps )
{
	int i;
	
	// We need to remember the calling property sheet at the time the OK
	// button is pressed. 
	//
	st_calling_ps = c_ps;
	string oldval;
	string oldtype;
	
//    fill_list_with_attributes("GuardChooser", "GuardList",!is_reflexive_message());
    fill_list_with_attributes("GuardChooser", "GuardList",False); // ECR 7675
	ui_choice_set_value( to_ui_prop("GuardChooser", "GuardTypeGroupChoice" ), 0 );
  	ui_text_set_value( to_ui_prop( "GuardChooser", "ParentClass" ), get_scope_class() );
  	ui_text_set_readonly( to_ui_prop( "GuardChooser", "ParentClass" ), True );
	
	if(list_count( gde_selected_symbols() ) == 1 )
		st_target_symbol = list_get( gde_selected_symbols(), 0 );
	else
		st_target_symbol = NULL;

}

// Callback for the combox box defining the list of properties that are displayed
//
int
ps_ChangeGuardGroup_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	int val;
	
	val = ui_choice_value( to_ui_prop("GuardChooser", "GuardTypeGroupChoice" ) );
	
	if( val == 0 )
//    	fill_list_with_attributes("GuardChooser", "GuardList", !is_reflexive_message());
    	fill_list_with_attributes("GuardChooser", "GuardList", False); // ECR 7675
	else if( val == 1 )
    	fill_list_with_operations("GuardChooser", "GuardList", !is_reflexive_message() );
	else if( val == 2 )
    	fill_list_with_states("GuardChooser", "GuardList");
		
 	return 0;	
}

// Loops through the fields and (de) activates the fields of the
// sheet
void
GuardChooser_activate( boolean t_or_f )
{
	// Modify this string if fields are modified
	//
	list elements = string_to_list("GuardList,GuardTypeGroupChoice",
									"," );
	int i;
	
	for( i = list_count( elements )-1; i>=0;i-- )
	ui_activate( to_ui_prop( "GuardChooser", 
				list_get(elements,i)
	 			), t_or_f );
	
}

// This is called from the gde engine when an object is selected.
void
GuardChooser_deactivate()
{
	if(list_count( gde_selected_symbols() ) == 1 &&  
		st_target_symbol == list_get( gde_selected_symbols(), 0 ) )
		return;

	GuardChooser_activate( False );
}

// Called when the user clicks ok
//
int
ps_TransitionGuardChooser_OK_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	string nv = get_guard_from_list();
	
	if( nv != ui_text_value(to_ui_prop( st_calling_ps, "TransitionGuard" ) ) )
    {
		ui_text_set_value( to_ui_prop( st_calling_ps, "TransitionGuard" ), nv );
	}
	return 1;
}

// Called when the user clicks ok
//
int
ps_PredecessorGuardChooser_OK_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	string nv = get_guard_from_list();

	if( nv != ui_text_value(to_ui_prop( st_calling_ps, "PredecessorGuard" ) ) )
    {
		ui_text_set_value( to_ui_prop( st_calling_ps, "PredecessorGuard" ), nv );
	}
	return 1;
}

string
get_guard_from_list()
{
	list l = ui_list_selected_items( to_ui_prop( "GuardChooser", "GuardList" ) );
	string nv;
	
	if( l != NULL && list_count(l) > 0 )
		nv = list_get( l, 0 );
	else
    {
		nv = "";
	    return nv;
	}
	
    if( string_find( nv, 0, ":" ) < string_length( nv ) &&
        string_find( nv, 0, "(" ) < string_length( nv ) )
	{
        // we have an operation with sig
        uml_operation op = uml_parse_operation( nv );
        string arg_str = sig_to_args( op.opArgs );
        nv = op.opName + "(" + arg_str + ")";
    }
    else
    {
        // should be an attribute or state
        if(  string_find( nv, 0, ":" ) < string_length( nv ) )
            // we have a type
            nv = list_get( string_to_list( nv, " " ), 1 );
        else if( string_find( nv, 0, "=" ) < string_length( nv ) )
            // we have a default value on an attribute
            nv = list_get( string_to_list( nv, " " ), 0 );
    }
    
    return nv;
}

// ============================================================================
// Action chooser callbacks etc.
// ============================================================================
void 
fill_Action_ps( string c_ps )
{
	int i;
	
	// We need to remember the calling property sheet at the time the OK
	// button is pressed. 
	//
	st_calling_ps = c_ps;
	string oldval;
	string oldtype;
	
	// ECR 6589 begin
    // fill_list_with_operations("ActionChooser", "ActionList", !is_reflexive_message());
	fill_list_with_operations("ActionChooser", "ActionList", False);
	// ECR 6589 end
	ui_choice_set_value( to_ui_prop("ActionChooser", "ActionTypeGroupChoice" ), 0 );
  	ui_text_set_value( to_ui_prop( "ActionChooser", "ParentClass" ), get_scope_class() );
  	ui_text_set_readonly( to_ui_prop( "ActionChooser", "ParentClass" ), True );
	
	if(list_count( gde_selected_symbols() ) == 1 )
		st_target_symbol = list_get( gde_selected_symbols(), 0 );
	else
		st_target_symbol = NULL;

}

// Loops through the fields and (de) activates the fields of the
// sheet
//
void
ActionChooser_activate( boolean t_or_f )
{
	// Modify this string if fields are modified
	//
	list elements = string_to_list("ActionList,ActionTypeGroupChoice",
									"," );
	int i;
	
	for( i = list_count( elements )-1; i>=0;i-- )
	ui_activate( to_ui_prop( "ActionChooser", 
				list_get(elements,i)
	 			), t_or_f );
	
}

// This is called from the gde engine when an object is selected.
void
ActionChooser_deactivate()
{
	if(list_count( gde_selected_symbols() ) == 1 &&  
		st_target_symbol == list_get( gde_selected_symbols(), 0 ) )
		return;

	ActionChooser_activate( False );
}

int
ps_ActionChooser_Refresh_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	// ECR 6589 begin
    // fill_list_with_operations("ActionChooser", "ActionList",!is_reflexive_message());
	fill_list_with_operations("ActionChooser", "ActionList", False);
	// ECR 6589 end
    return 0;
}
    
// Called when the user clicks ok
//
int
ps_OperationChooser_OK_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	list l;
	string nv, arg_str;
	int col_pos;
	
	l = ui_list_selected_items( to_ui_prop( "ActionChooser", "ActionList" ) );
	
	if( l != NULL && list_count(l) > 0 )
		nv = list_get( l, 0 );
	else
	{
		nv = "";
	    return 1;
	}
	
    uml_operation op = uml_parse_operation( nv );
    // uml_parse_operation doesn't set opRetType :-(((
    col_pos = string_find( nv, 0, ": " );
    if( col_pos < string_length( nv ) ) 
        op.opRetType = string_extract( nv, 0, col_pos );
    else
        op.opRetType = "";
    
	if( op.opName != ui_text_value(to_ui_prop( st_calling_ps, "NameComponent" ) ) )
	{
		ui_text_set_value( to_ui_prop( st_calling_ps, "NameComponent" ), op.opName );
	}

	if( op.opRetType != ui_text_value(to_ui_prop( st_calling_ps, "ReturnType" ) ) )
	{
		ui_text_set_value( to_ui_prop( st_calling_ps, "ReturnType" ), op.opRetType );
	}

    arg_str = sig_to_args( op.opArgs );
	if( arg_str != ui_text_value(to_ui_prop( st_calling_ps, "MessageArgs" ) ) )
	{
		ui_text_set_value( to_ui_prop( st_calling_ps, "MessageArgs" ), arg_str );
	}

	return 1;
}

// Called when the user clicks ok
//
int
ps_ActionChooser_OK_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	list l;
	string nv;
	
	l = ui_list_selected_items( to_ui_prop( "ActionChooser", "ActionList" ) );
	
	if( l != NULL && list_count(l) > 0 )
		nv = list_get( l, 0 );
	else
	{
		nv = "";
	    return 1;
	}
	
    uml_operation op = uml_parse_operation( nv );
    string arg_str = sig_to_args( op.opArgs );
    nv = op.opName + "(" + arg_str + ")";
    
    string old_value = ui_get_value( to_ui_prop( st_calling_ps, "TransitionAction" ) );
    if( string_length( old_value ) > 0 )
    {
        old_value = string_strip( old_value, "T", "\n" );
        old_value += "\n";
    }
	ui_text_set_value( to_ui_prop( st_calling_ps, "TransitionAction" ), old_value + nv );

	return 1;
}


// ============================================================================
// InEvent chooser callbacks etc.
// ============================================================================
void 
fill_inevent_ps( string c_ps )
{
	int i;
	
	// We need to remember the calling property sheet at the time the OK
	// button is pressed. 
	//
	st_calling_ps = c_ps;
	string oldval;
	string oldtype;
	
	fill_event_list_with_inevents();
  	ui_text_set_value( to_ui_prop( "InEventChooser", "ParentClass" ), get_scope_class() );
  	ui_text_set_readonly( to_ui_prop( "InEventChooser", "ParentClass" ), True );
	
	if(list_count( gde_selected_symbols() ) == 1 )
		st_target_symbol = list_get( gde_selected_symbols(), 0 );
	else
		st_target_symbol = NULL;

}

list
get_in_events( string class ) {
    string ev_query = "link[link_refs && to_node[UmlObjectInstance && " +
        "scope_node[name == '" + class + "']]]";
    list ev = list_select( ev_query );
    return ev;
}

void
fill_event_list_with_inevents( )
{
	int i;
	link l;
	set event_names = set_create( "string" );  // ECR 5519
	
	list events = get_in_events( get_scope_class() );
	ui_list_clear( to_ui_prop("InEventChooser", "InEventList") );

	for( i = 0; i < list_count( events ); i++ )
	{
		l = list_get( events , i );
        if( string_length( l.name ) > 0) 
            // ECR 5519
            set_add( event_names, l.name );
	}
	// ECR 5519
	for( i = 0; i < set_count( event_names ); i++ )
    {
	    ui_list_append( to_ui_prop("InEventChooser", "InEventList"), 
	        set_get_element( event_names, i ) );
	}
}


// Loops through the fields and (de) activates the fields of the
// sheet
//
void
InEventChooser_activate( boolean t_or_f )
{
	// Modify this string if fields are modified
	//
	list elements = string_to_list("EventList",
									"," );
	int i;
	
	for( i = list_count( elements )-1; i>=0;i-- )
	ui_activate( to_ui_prop( "InEventChooser", 
				list_get(elements,i)
	 			), t_or_f );
	
}

// This is called from the gde engine when an object is selected.
void
InEventChooser_deactivate()
{
	if(list_count( gde_selected_symbols() ) == 1 &&  
		st_target_symbol == list_get( gde_selected_symbols(), 0 ) )
		return;

	InEventChooser_activate( False );
}

int
ps_InEventChooser_Refresh_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	fill_event_list_with_inevents();
    return 0;
}

// Called when the user clicks ok
//
int
ps_InEventChooser_OK_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	list l;
	string nv;
	
	l = ui_list_selected_items( to_ui_prop( "InEventChooser", "InEventList" ) );
	
	if( l != NULL && list_count(l) > 0 )
		nv = list_get( l, 0 );
	else
		nv = "";
	
	// Only set the value if it changed
	//	
	if( nv != ui_text_value(to_ui_prop( st_calling_ps, "TransitionEvent" ) ) )
	{
		ui_text_set_value( to_ui_prop( st_calling_ps, "TransitionEvent" ), 
						nv );
	}
	return 1;
}

// ============================================================================
// OutEvent chooser callbacks etc.
// ============================================================================
void 
fill_OutEvent_ps( string c_ps )
{
	int i;
	
	// We need to remember the calling property sheet at the time the OK
	// button is pressed. 
	//
	st_calling_ps = c_ps;
	string oldval;
	string oldtype;
	
	fill_event_list_with_OutEvents();
  	ui_text_set_value( to_ui_prop( "OutEventChooser", "ParentClass" ), get_scope_class() );
  	ui_text_set_readonly( to_ui_prop( "OutEventChooser", "ParentClass" ), True );
	
	if(list_count( gde_selected_symbols() ) == 1 )
		st_target_symbol = list_get( gde_selected_symbols(), 0 );
	else
		st_target_symbol = NULL;

}

list
get_out_events( string class ) {
    string ev_query = "link[link_refs && from_node[UmlObjectInstance && " +
        "scope_node[name == '" + class + "']]]";
    list ev = list_select( ev_query );
    return ev;
}

void
fill_event_list_with_OutEvents( )
{
	int i;
	link l;
	set event_names = set_create( "string" ); // ECR 5519
	
	list events = get_out_events( get_scope_class() );
	ui_list_clear( to_ui_prop("OutEventChooser", "OutEventList") );

	for( i = 0; i < list_count( events ); i++ )
	{
		l = list_get( events , i );
        if( string_length( l.name ) > 0) // ECR 5519
            set_add( event_names, l.name );
	}			
	// ECR 5519
	for( i = 0; i < set_count( event_names ); i++ )
    {
	    ui_list_append( to_ui_prop("OutEventChooser", "OutEventList"), 
	        set_get_element( event_names, i ) );
	}
}


// Loops through the fields and (de) activates the fields of the
// sheet
//
void
OutEventChooser_activate( boolean t_or_f )
{
	// Modify this string if fields are modified
	//
	list elements = string_to_list("EventList",
									"," );
	int i;
	
	for( i = list_count( elements )-1; i>=0;i-- )
	ui_activate( to_ui_prop( "OutEventChooser", 
				list_get(elements,i)
	 			), t_or_f );
	
}

// This is called from the gde engine when an object is selected.
void
OutEventChooser_deactivate()
{
	if(list_count( gde_selected_symbols() ) == 1 &&  
		st_target_symbol == list_get( gde_selected_symbols(), 0 ) )
		return;

	OutEventChooser_activate( False );
}

int
ps_OutEventChooser_Refresh_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	fill_event_list_with_OutEvents();
    return 0;
}

// Called when the user clicks ok
//
int
ps_OutEventChooser_OK_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
	list l;
	string nv;
	
	l = ui_list_selected_items( to_ui_prop( "OutEventChooser", "OutEventList" ) );
	
	if( l != NULL && list_count(l) > 0 )
		nv = list_get( l, 0 );
	else
	{
		nv = "";
		return 1;
	}
	
    string old_value = ui_get_value( to_ui_prop( st_calling_ps, "TransitionSend" ) );
    if( string_length( old_value ) > 0 )
    {
        int i = string_find( old_value, 0, "\n" );
        if( i < string_length( old_value ) )
            old_value = string_extract( old_value, 0, i );
        old_value += "\n";
    }
	ui_text_set_value( to_ui_prop( st_calling_ps, "TransitionSend" ), old_value + nv );

	return 1;
}

// ============================================================================
// Common funcs
// ============================================================================

int
ps_OpenClass_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
    string scope_class = get_scope_class();
    file uclasst = find_by_query( "file[UmlClassTable && node_refs[node[UmlClass && name == '${scope_class}']]]" );
    if( uclasst != NULL )
        editor_send_msg( "uclasst", "EditorQrlEval \"Nav2StP(\\\"uclasst\\\",\\\"UmlClass\\\",\\\"" + get_scope_class() + "\\\");\"", -1 );
    else
    {
        node the_class = find_by_query( "node[UmlClass && name == '${scope_class}']" );
        if( the_class == NULL )
        {
            print_error( "Class " + scope_class + " doesn't exist yet." );
            return 0;
        }
        else    
            NavigateSendQrl( "uclasst", "UmlClassTableInitialize(" + the_class.id + ");" );
    }
    return 0;
}

int
ps_OpenScenario_cb( ui_event_tp event, ui_prop prop, int id, string value)
{
    // look for UmlObjectClassScope
    editor_send_msg( "usequenced", "EditorQrlEval \"Nav2StP(\\\"usequenced\\\",\\\"UmlObjectClassScope\\\",\\\"" + get_scope_class() + "\\\");\"", -1 );
    return 0;
}

// convert an arg list to a comma separated list of arg names
string
sig_to_args( string sig )
{
	uml_argument arg;
    list args = list_create( "string", 0 ),
         arg_names = list_create( "string", 0 );
	int i;
	string arg_str = "";
    	
    uml_split_arguments( sig, args );
    for( i=0; i<list_count(args); i++ )
    {
        arg = uml_arg_string_to_struct( list_get( args, i ) );
        list_append( arg_names, arg.argName );
    }
    if( list_count( arg_names ) > 0 )
        arg_str = list_to_string( arg_names, ", " );
    
    return arg_str;
}

void
fill_list_with_attributes( string prop, string list_ui, boolean public_only )
{
	int i;
	node attr;
	note n;
	item it, visibility;
	string attr_str;
	
	list attributes = list_select( "node[UmlAttribute && node_refs && " +
	    "scope_node[UmlClass && name == '" + get_scope_class() + "']] sort by name" );
	ui_list_clear( to_ui_prop(prop, list_ui) );

	for( i = 0; i < list_count( attributes ); i++ )
	{
        attr_str = "";
		attr = list_get( attributes , i );
        n = find_by_query( "note[UmlAttributeDefinition && node[node_refs && UmlAttribute && " + 
            "id == ${attr.id} && " +
            "scope_node[UmlClass && name == '" + get_scope_class() + "']]]" );

        if( n != NULL )
        {
            visibility = find_by_query( "item[UmlMemberVisibility && note[id==${n.id}]]" );
            if( ( visibility == NULL ||
                  visibility.value == "" ||
                  visibility.value == "public" ||
                  visibility.value == "Public" ) ||
                  !public_only )
            {
                it = find_by_query( "item[UmlAttributeType && note[id==${n.id}]]" );
                if( it != NULL ) 
                    attr_str += it.value + ": ";
                attr_str += attr.name;
                it = find_by_query( "item[UmlAttributeDefaultValue && note[id==${n.id}]]" );
                if( it != NULL ) 
                    attr_str += " = " + it.value;
        		ui_list_append( to_ui_prop(prop, list_ui), attr_str );
        	}
    	}
	}			
}


void
fill_list_with_operations( string prop, string list_ui, boolean public_only )
{
	int i;
	node n;
	item op_ret_type, visibility;
	string parent_class = get_scope_class();
	string type = "", op_str;
	set ops = set_create("string");
    
	list operations=list_select( "node[UmlOperation && node_refs && " +
	    "scope_node[UmlClass && name == '" + parent_class + "']] sort by name" );
    list iops = set_to_list(uml_classname_inherited_ops(parent_class, "", "",False));
    list_concatenate( operations, iops );
    
	ui_list_clear( to_ui_prop(prop, list_ui) );

	for( i = 0; i < list_count( operations ); i++ )
	{
        type = "";
		n = list_get( operations , i );
        visibility = find_by_query( "item[UmlMemberVisibility && node[id==${n.id}]]" );
        if( ( visibility == NULL ||
              visibility.value == "" ||
              visibility.value == "public" ||
              visibility.value == "Public" ) ||
              !public_only )
        {
            op_ret_type = find_by_query( "item[UmlOperationReturnType && node[id==${n.id}]]" );
            if( op_ret_type != NULL )
                type = op_ret_type.value + ": ";
    		set_add( ops, type + n.name + " (" + n.sig + ")" );
        }
	}			
    for( i = 0; i < set_count( ops ); i++ )
    {
        op_str = set_get_element( ops, i );
        ui_list_append( to_ui_prop(prop, list_ui), op_str );
    }
}

void
fill_list_with_states( string prop, string list_ui )
{
	int i;
    set states = get_all_states();
    if( states == NULL )
        return;
	ui_list_clear( to_ui_prop(prop, list_ui) );
	for( i = 0; i < set_count( states ); i++ )
	{
		ui_list_append( to_ui_prop(prop, list_ui), set_get_element( states , i ) );
	}			
}

set
get_all_states()
{
    string my_editor = current_editor_apptype();
    string my_state_type;
    int i, j;
    file my_file;
    list my_states;
    node my_state;
        
    if( my_editor == "UmlStateDiagram" )
        my_state_type = "UmlState";
    else
        my_state_type = "UmlActionState";
    	
    int my_id = get_parent_file_id();
    if( my_id == 0 )
        return NULL;
    
    gde_node sm = uml_state_machine();
    if( sm != NULL )
    {
        string my_sm = gde_node_label( sm );
        list state_files = list_select( "file[${my_editor} && " +
            "node_refs[node[UmlStateMachine && name == '${my_sm}']]]" );
        set all_states = set_create( "string" );
        
        for( i=0; i<list_count( state_files ); i++ )
        {
            my_file = list_get( state_files, i );    
            my_states = list_select( "node[${my_state_type} && node_refs[file[id=${my_file.id}]]] sort by name" );
            for( j=0; j<list_count( my_states ); j++ )
            {
                my_state = list_get( my_states, j );
                set_add( all_states, my_state.name );
            }            
        }
        return all_states;
    } else
        return NULL;
}

boolean
is_reflexive_message()
{
    string my_editor = current_editor_apptype();
    if( my_editor == "UmlSequenceDiagram" || my_editor == "UmlCollaborationDiagram" )
    {
        // this is more or less from usequenced_get_current_message_class() ...
    	list selected_syms;
    	gde_node theNode;
    	gde_symbol theSym;
        gde_arc theArc;

    	selected_syms = gde_selected_symbols();
    	if (NULL == selected_syms || list_count(selected_syms) != 1)
    		return False;
    
    	theSym = list_get(selected_syms,0);
        // JED - fix for ucollaborationd, which uses this code but uses cntx
        // symbols attached to links instead of the links themselves.
        if (gde_symbol_is_cntx(theSym))
            theArc = gde_cntx_parent(to_gde_cntx(theSym));
        else
            if (gde_symbol_is_arc(theSym))
                theArc = to_gde_arc(theSym);
            else
                return False;
    
        if( gde_node_oms_nodes(gde_arc_tonode(theArc)) == gde_node_oms_nodes(gde_arc_fromnode(theArc)) )
            return True;
    }
    // ECR 6589
    // MB: In State and Activity diagrams Actions can be reflexe too. 
    // With other words: The context for this diagram is the class.
    // An action can be called by the class itself. Therefore all
    // operations should show up in the chooser.
    // ECR 6854 rollbacked this implementation of 6589
    // else
    //     if( my_editor == "UmlStateDiagram" || my_editor == "UmlActivityDiagram" )
	//     return True;
    
    return False;
}
        
string
get_scope_class()
{
    string my_editor = current_editor_apptype();
    if( my_editor == "UmlStateDiagram" || my_editor == "UmlActivityDiagram" ) 
    {
        gde_node sm = uml_state_machine();
        if( sm != NULL ) 
        {
            string sm_name = gde_node_label( sm );
            if( sm_name != NULL && sm_name != "" ) {
                return uml_state_machine_class_name( sm_name );
            }
            return "";
        }
        return "";
    }
    else
    {
        node t_class = usequenced_get_current_message_class();
        if( t_class != NULL )
            return t_class.name;
        else
            return "";
    }
}

int
get_parent_file_id()
{
    string my_editor = current_editor_apptype();
    string diag_name = gde_diagram_name();
    file my_file = find_by_query( "file[${my_editor} && name == '${diag_name}']" );
    if( my_file != NULL )
        return my_file.id;
    return 0;
}

