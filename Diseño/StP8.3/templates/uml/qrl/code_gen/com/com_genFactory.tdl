//*****************************************************************************
// $RCSfile: com_genFactory.tdl,v $
// $Revision: 1.3 $
// $Date: 2001/07/06 18:00:33 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates a cpp file for each factory. Factories are fully generated for 
   classes with <<COMObject>>.
   Calls the starting procedure for generation of factory header.
*/

/*
import other template files
*/
USES com_std;
USES com_genFactoryHeader;
USES ../tdl/std;


proc MNormalClass.genFactoryClass(MClass)
	/* local variables */
	local packageList;
	local fileName;

	/* The variable [packageList] holds an id list of all packages that is build
	   up of two parts: the id of the domain package (if one exists) and the 
	   id of the enclosing package (relativ to MClass, if one exists) 
	   This id list is needed as a condition for the next loop statement 
	   getIdListRec is a predefined function */
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	
	/* Determine the first part of the file name to be generated.
	   If an instance of metamodel type MClass is part of an enclosing package
	   this packagename will be the name for the subdirectory the source
	   files are generated in */
	loop(Instances->MPackage([packageList]))
		[fileName] = [fileName] [MPackage.name] "/";
	end loop

	/* Build the final filename for MClass 
		getTaggedValueValue is a procedure to extract the value of tagged value
		with tag==Factory, in com_std.tdl
	*/
	[fileName] = [srcdir] "/" [fileName] getTaggedValueValue([MClass], "Factory")".cpp";
	/* Redirect output to standard output */
	info = "generate " [fileName] "\n";
	/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
	   in std.tdl) */
	mkdir(lsdir( [fileName]));
	
	/* Set the output redirection to [fileName]. setOutput is a predefined
	   function */
	output( [fileName] );
	/* insert package id that is used inside the templates by the procedure
	   provided as the second parameter to the mark function */
	insert("package",[Class_[MClass.name]]);

	/* Call the appropriate template (either MInterface.genClass or 
	   MClass.genClass) depending on the actual subtype of MClass
	   and redirect output to the channel set by setOutput (s. above) */
	
	out = [MClass].genFactory();
	/* calls starting procedure for generation of factory header, in com_genFactoryHeader.tdl */
	genFactoryHeader([MClass]);
end proc

template MClass.genFactory()
#include "[MClass.name]Factory.h"

[/* IClassFactory inherits from IUnknown, thus provide methods of IUnknown with 
	standard implementation 
*/]
STDMETHODIMP [getTaggedValueValue([MClass], "Factory")]::QueryInterface(REFIID riid, void** ppv)
{
	if (riid == IID_IClassFactory || riid == IID_IUnknown) {
		*ppv = (IClassFactory*) this;
		AddRef();
		return S_OK;
	}
	*ppv = NULL;
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) [getTaggedValueValue([MClass], "Factory")]::AddRef()
{
	localRefCounter++;
	return localRefCounter;	
}
STDMETHODIMP_(ULONG) [getTaggedValueValue([MClass], "Factory")]::Release()
{
	localRefCounter--;
	if (localRefCounter==0)
	{
		delete this;
		return 0;	
	}
	return localRefCounter;
}

// Implementation of interface IClassFactory with standard implementation
STDMETHODIMP [getTaggedValueValue([MClass], "Factory")]::CreateInstance(LPUNKNOWN pUnk, REFIID riid, void** ppv)	
{
	[getDefaultInterface([MClass])]* pUnk = ([getDefaultInterface([MClass])]*) new RunderStift();
	HRESULT hr = pUnk->QueryInterface(riid, ppv);
	pUnk->Release();
	return hr;
} 
STDMETHODIMP [getTaggedValueValue([MClass], "Factory")]::LockServer(BOOL f)
{
	if (f)
		AddRef();
	else
		Release();
	return S_OK;	
}
end template




























