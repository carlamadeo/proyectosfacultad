//*****************************************************************************
// $RCSfile: com_genFactoryHeader.tdl,v $
// $Revision: 1.3 $
// $Date: 2001/07/06 18:00:33 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates a header file for each factory. Factories are fully generated for 
   classes with <<COMObject>>.
*/

/*
import other template files
*/
USES com_std;
USES ../tdl/std;

proc genFactoryHeader(MClass)
	/* local variables */
	local packageList;
	local fileName;

	/* The variable [packageList] holds an id list of all packages that is build
	   up of two parts: the id of the domain package (if one exists) and the 
	   id of the enclosing package (relativ to MClass, if one exists) 
	   This id list is needed as a condition for the next loop statement 
	   getIdListRec is a predefined function */
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	
	/* Determine the first part of the file name to be generated.
	   If an instance of metamodel type MClass is part of an enclosing package
	   this packagename will be the name for the subdirectory the source
	   files are generated in */
	loop(Instances->MPackage([packageList]))
		[fileName] = [fileName] [MPackage.name] "/";
	end loop

	/* Build the final filename for MClass 
		getTaggedValueValue is a procedure to extract the value of tagged value
		with tag==Factory, in com_std.tdl
	*/
	[fileName] = [srcdir] "/" [fileName] getTaggedValueValue([MClass], "Factory")".h";
	/* Redirect output to standard output */
	info = "generate " [fileName] "\n";
	/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
	   in std.tdl) */
	mkdir(lsdir( [fileName]));
	
	/* Set the output redirection to [fileName]. setOutput is a predefined
	   function */
	output( [fileName] );
	/* insert package id that is used inside the templates by the procedure
	   provided as the second parameter to the mark function */
	insert("package",[Class_[MClass.name]]);

	/* Call the appropriate template (either MInterface.genClass or 
	   MClass.genClass) depending on the actual subtype of MClass
	   and redirect output to the channel set by setOutput (s. above) */
	
	out = [MClass].genFactoryHeader();
end proc

template MClass.genFactoryHeader()
[loop (MClass->MPackage)]
#include "[MPackage.name].h"	// Header generated by com.exe
[end loop]
#include "[MClass.name].h"

[/* generate the name of the factory class. 
	 getTaggedValueValue is defined in com_std.tdl 
*/]
class [getTaggedValueValue([MClass], "Factory")] : public IClassFactory
{
	public:
	// IUnknown
	STDMETHODIMP QueryInterface (REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	
	// IClassFactory
	STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID iid, void **ppv);
	STDMETHODIMP LockServer(BOOL fLock);
	
	[/* generate constructor for factory */]
	[getTaggedValueValue([MClass], "Factory")]() {localRefCounter=0;}
	private:
	[/* attribute is needed for the standard implementation of IUnknown methods */]
	ULONG localRefCounter;
	
};
end template