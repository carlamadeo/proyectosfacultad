//*****************************************************************************
// $RCSfile: com_genInterface.tdl,v $
// $Revision: 1.2 $
// $Date: 2001/06/15 02:11:22 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates an idl file for all interfaces, having implements link to 
   class with <<COMObject>>. This is the actual instance of meta model type MClass.
*/

/*
import other template files
*/
USES com_std;


proc startGenInterfaces(MClass)
	/* local variables */
	local packageList;
	local fileName;
	/* The variable [packageList] holds an id list of all packages that is build
	   up of two parts: the id of the domain package (if one exists) and the 
	   id of the enclosing package (relativ to MClass, if one exists) 
	   This id list is needed as a condition for the next loop statement 
	   getIdListRec is a predefined function */
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	
	/* Determine the first part of the file name to be generated.
	   If an instance of metamodel type MClass is part of an enclosing package
	   this packagename will be the name for the subdirectory the source
	   files are generated in */
	loop(Instances->MPackage([packageList]))
		[PackageName] = [MPackage.name];
		[fileName] = [fileName] [MPackage.name] "/";
	end loop
	/* ignore class if marked as external, s. below */
	if (!ClassIsExternal([MClass]))
		/* Build the final filename for idl file on basis of package name */
		[fileName] = [srcdir] "/" [fileName] [PackageName] ".idl";
		/* Redirect output to standard output */
		info = "generate " [fileName] "\n";
		/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
		   in std.tdl) */
		mkdir(lsdir( [fileName]));
		
		/* Set the output redirection to [fileName]. setOutput is a predefined
		   function */
		output( [fileName] );
		/* insert package id that is used inside the templates by the procedure
		   provided as the second parameter to the mark function */
		insert("package",[Class_[MClass.name]]);
	
		/* Call the appropriate template (either MInterface.genClass or 
		   MClass.genClass) depending on the actual subtype of MClass
		   and redirect output to the channel set by setOutput (s. above) */
		out = [MClass].genInterfaces();
	end if
end proc

template MClass.genInterfaces()
[loop(MClass->Implement)]
[/* call template genSingleInterface (s. below) for each interface having 
	 implements link to actual instance of meta model type of MClass */]
[genSingleInterface([Implement])]
[end loop]
[/* generate library section in idl file, s. below */]
[genLibrary([MClass])]
end template

/*	generate whole interface section (including COM attributes) for interface
*/
template genSingleInterface(MInterface)
[/* generate UUID calling uuidgen.exe, temp. file saved in second parameters path */]
//[exec_system("uuidgen","-o\\Temp\\om.idl")]
\[  object,
   uuid([getUniqueId([MInterface])]),
   helpstring("[generate_helpstringForInterface([MInterface])]"),
   pointer_default(unique)
]	
[/* proc. inheritedFromInterface delivers the name of that interface, the actual interface inherits from */]
interface [MInterface.name] : [inheritedFromInterface([MInterface])]	
{ 
[/* generate methods of interface, s. below */]
[genMethod([MInterface])]
};
end template

template genLibrary(MClass)
[/* generate UUID calling uuidgen.exe, temp. file saved in second parameters path */]
//[exec_system("uuidgen","-o\\Temp\\om.idl")]
[loop(MClass->MPackage)]
\[  uuid([getUniqueId([MPackage])]),
[end loop]
   version([genVersion([MClass])]),
   helpstring("[generate_helpstringForPackage([MClass])]")
]
[/* proc getPackageName return name of package, s. below */]
library [getPackageName([MClass])]	
{
    importlib("stdole32.tlb");
[genImplemantationClass([MClass])]	[/* generate coclass entry in idl file, s. below */]
};
end template

/* generate version information for package in library section of idl file */
proc genVersion(MClass)
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	loop(Instances->MPackage([packageList]))
	/* return value of tagged value with tag==version */
		return getTaggedValueValue([MPackage], "version");
	end loop
end proc

/* generate helpstring information for interface as part of the COM attributes for 
	each interface in idl file
*/
proc generate_helpstringForInterface(MInterface)
	/* return value of tagged value with tag==helpstring */
	return getTaggedValueValue([MInterface], "helpstring");
end proc

/*	generate helpstring information for package as part of the COM attributes
	in idl file
*/
proc generate_helpstringForPackage(MClass)
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	loop(Instances->MPackage([packageList]))
		/* return value for tagged value with tag==helpstring */
		return getTaggedValueValue([MPackage], "helpstring");
	end loop
end proc

/*	generate helpstring information for class as part of the COM attributes
	in idl file
*/
proc generate_helpstringForClass(MClass)
/* return value of tagged value with tag==helpstring */
	return getTaggedValueValue([MClass], "helpstring");
end proc

/*	return string with name package that instance of MClass belongs to
*/
proc getPackageName(MClass)
	loop(MClass->MPackage)
		[packageList] = getIdListRec(MPackage->Domain) [MPackage.id];
	end loop
	loop(Instances->MPackage([packageList]))
		return [MPackage.name];
	end loop
end proc

/* generate methods of interface MInterface
 */
template genMethod(MInterface)
[setLanguage("IDL")]	[/* sets the tag for typemapping. See TDL documentation for further information */]
		import "unknwn.idl";
[loop(MInterface->MOperation)]
		[getDataType([MOperation.returnType])] [MOperation.name]([getOpTypeList([MOperation])]);
[end loop]
end template

/* returns string with name of interface from that actual instance of MClass inherits */
proc inheritedFromInterface(MClass)
	loop(MClass->SuperClass)
	    return [SuperClass.name];
	end loop
end proc

/* generates the coclass section in idl file
*/
template genImplemantationClass(MClass)
[/* generate UUID calling uuidgen.exe, temp. file saved in second parameters path */]
//[exec_system("uuidgen","-o\\Temp\\om.idl")]
	\[ uuid([getUniqueId([MClass])]),
      helpstring("[generate_helpstringForClass([MClass])]")
    ]
	coclass [MClass.name]
	{ 
	[/* isDefaultInterface determines the interface marked as the default interface, s. midl_std.tdl */]
	[loop(MClass->Implement)]
		[isDefaultInterface([Implement])]interface [Implement.name];
	[end loop]
	};
end template

/* check if class is marked as external, return TRUE if class is external
	normaly there is no code generation for external classes
*/ 
proc ClassIsExternal(MElement)
	loop(MElement->Note->Item where [Item.type] == "UmlClassIsImported")
		return TRUE;
	end loop
	return FALSE;
end proc


























