// Wrapper-Script to generate an IMF file and ACD based code
//
// ECR 5818 begin
/*
// default template used to generate code
external string tdl_template = "";
// default language
external string tdl_language = "";
external string tdl_language_version = "";
// default output directory (is set to .../src_files further down)
external string file_directory = "";
// default output file
external string out_file = "";
// default is to generate the IMF file
external boolean generate_imf = True;
*/

// ECR 7640
#include "uml/qrl/include/extract_classes_components.inc" // Package- and ClassIds

void code_gen_main( string tdl_template,
                    string tdl_language,
                    string tdl_language_version,
                    string file_directory,
                    boolean generate_imf,
                    boolean suppress_log,
                    string obj_names, // ECR 7640
                    string obj_type)  // ECR 7640
{
    string proj = current_projdir();
    string sys = current_system();
    string syscall, path, stp_bin;
    int x;

    if( file_directory == "" ) {
        file_directory = proj + sys + "/src_files/";
    }

    // ECR: 4816 removed **  message("Starting generate " + tdl_language + " by Template");

    // This is where the IMF file is going to be generated to
    string imf_file = proj + sys + "/qrl_files/" + sys + ".imf";

	// ECR7229
	string codegen_file_lock = proj + sys + "/.codegen_busy";

    string tdl_path = toolinfo_variable( "tdl_path" );
    string merge_path = toolinfo_variable( "merge_path" );

	string lock_info;
	boolean generate = True;

    // TI-Var tdl_path needs to be set to <StP-Base>/templates/uml/qrl/code_gen
    // or wherever the tdl scripts are going to be put
    if( tdl_path == NULL ) {
        print_error( "ToolInfo Variable 'tdl_path' not defined, exiting" );
        return;
    } else {
         tdl_path = tdl_path + "/" + tdl_language;
    }
    // ECR 4506 begin
    // string tdl_file = tdl_path + "/" +  tdl_template;
    string tdl_file;
    int tdl_template_len = string_length(tdl_template);
    if( (string_find(tdl_template, 0, "\\") == tdl_template_len) &&
        (string_find(tdl_template, 0, "/") == tdl_template_len) )
    {
        tdl_file = tdl_path + "/" +  tdl_template;
    }
    else
    {
        tdl_file = tdl_template;
    }
    // ECR 4506 end

    if( ! file_exists( tdl_file ) ) {
        print_error( "Template '" + tdl_file + "' not found, exiting." );
        return;
    }

    // ECR7229
	if (file_exists( codegen_file_lock ) )
	{
		lock_info = read_file( codegen_file_lock );
		message( "Code generation already started by " + lock_info);
		if (editor_confirm(
	       "Code generation is started by " + lock_info + ".",
	       "Wait", "Skip") == True)
		{
			while (file_exists( codegen_file_lock) )
				sleep(1);			
		}
		else
			generate = False;
	}
	else
	{
		if (generate_imf)
		{
			write_file(codegen_file_lock, user() + " on " + 
				time_to_string(time_now(), NULL));

			message( "Generating IMF File " + imf_file + " ..." );
			// ECR 7281 begin: C++ IMF generation
			// syscall = "qrp qrl/code_gen/uml2interface.qrl " + forward_messages_arg() +
			syscall = "uml2imf " + forward_messages_arg() +
			// ECR 7281 end
						   " -p " + proj +
						   " -s " + sys +
						   " -o " + imf_file;

			//message( syscall );
			system( syscall );

			// ECR7229
			delete_file( codegen_file_lock);
		}
	}

    if( ! file_exists( imf_file ) ) {
        print_error( "IMF File does not exist, exiting !" );
    } else 
	{
		if (generate) {
			message( "Generating code ..." );
			syscall = "acd -f " + imf_file + " -t " + tdl_file + " -T " + tdl_path + " -var '";
			// added ejb for ECR 6546
			if( tdl_language == "ejb" ) {
				syscall = syscall + "language=" + tdl_language_version + "= ";
			}
			// ECR 5818 begin
			// if( out_file != "" ) {
			//     syscall = syscall + "outfile=" + file_directory + "/" + out_file;
			// } else {
			//     syscall = syscall + "srcdir=" + file_directory;
			// }
			syscall = syscall + "srcdir=" + file_directory;
			// ECR 5818 end
            // ECR 7640
			// syscall = syscall + "'";
			syscall = syscall + "=class_id_list=" + gen_classId_string(obj_names, obj_type) + "'";

			// ECR 5708 begin
			if ( !suppress_log )
			// ECR 5708 end
				syscall = "stdout2msgd " + forward_messages_arg() + " " + syscall; // ECR 4057

			//message( syscall );
			system( syscall );

			// ECR 7142 start
			// path = environment_variable ("PATH");
			// stp_bin = list_get(string_to_list(path,";"),0);
			// path = stp_bin + "/tcl/bin;" + path;
			// put_environment_variable ("PATH=" + path);
			// put_environment_variable ("MERGE_PATH=" + merge_path);

			path = environment_variable("MERGE_PATH");
			if(path == NULL || path != merge_path) {
				path = path_compose(bin_directory(), "tcl", "bin");
				if(is_windows_platform())
					path += ";";
				else
					path += ":";
				path += environment_variable("PATH");

				put_environment_variable("PATH=" + path);
				put_environment_variable("MERGE_PATH=" + merge_path);
			}
			// ECR 7142 end

			// ECR 4057 begin
			// syscall = "silentcmd.exe " + string_search_and_replace(log_file,"/","\\") + " merge.exe " + merge_path; // + "/tcl/merge.tcl";
			syscall = "merge " + merge_path; // + "/tcl/merge.tcl";

			// ECR 5708 begin
			if ( !suppress_log )
			// ECR 5708 end
				syscall = "stdout2msgd " + forward_messages_arg() + " " + syscall;
			// ECR 4057 end

			//message( syscall );
			system( syscall );
		}
		else
		{
			message( "Generating code skipped." );
			return;
		}
	}

    message( "Done generating code." );
}

// Begin Add ECR 7640
string gen_classId_string(string obj_names, string obj_type)
{
    if (obj_type == "whole_model")
        return "";

    node class;
    int i, n;
    set class_set = set_create("node");
    list class_id_list = list_create("int", 0);
    string class_id_string;

    if (! extract_classes(class_set, obj_names, obj_type)) {
        message("extract classes failed");
        return "";
    }

    for (i=0, n=set_count(class_set); i < n; i++) {
        class = set_get_element(class_set, i);
        list_append(class_id_list, class.id);
    }
    class_id_string = list_to_string(class_id_list, " ");
    return class_id_string;
}


boolean
extract_classes(set class_set, string obj_names, string obj_type)
{
    string class_diagrams = "";
    string tables = "";
    string packages = "";
    string classes = "";

    if (obj_type == "class_diagrams")
        class_diagrams = obj_names;
    else if (obj_type == "tables")
        tables = obj_names;
    else if (obj_type == "packages")
        packages = obj_names;
    else if (obj_type == "classes")
        classes = obj_names;

    int     i, j;
    string  query;
    list    class_nodes, package_nodes;
    set     package_set = set_create("node");
    file    file;
    string  name_restrictor = "";

    //
    // Create an id_list with the results of the query
    //
    if (classes != "") {
        select_from_names(class_set, "node[UmlClass ${name_restrictor} && node_refs ]", classes);
    }
    else if (tables != "") {
        select_from_names(class_set, "node[UmlClass && node_refs[file[UmlClassTable ${name_restrictor}]]]", tables);
    }
    else if (class_diagrams != "") {
        select_from_names(class_set, "node[UmlClass && node_refs[file[UmlClassDiagram ${name_restrictor}]]]", class_diagrams);
    }
    else if (packages != "") {
        select_from_names(package_set, "node[ UmlPackage ${name_restrictor} && node_refs ]", packages);
        for (i=0; i<set_count(package_set); i++) {
	          class_nodes = list_create("node", 0);
	          package_nodes = list_create("node", 0);
            extract_package_contents(set_get_element(package_set, i), True, class_nodes, package_nodes);
            for (j=0; j<list_count(class_nodes); j++) {
                set_add (class_set, list_get(class_nodes,j));
            }
        }
    }
    else {
        class_set = set_select("node[UmlClass & node_refs]");
    }

    // if no classes or packages extracted then report an error
    if (set_count(class_set) == 0) {
	      print_error("No classes found!");
	      return False;
    }
    return True;
}
// End Add ECR 7640
