//*****************************************************************************
// $RCSfile: c_gensm.tdl,v $
// $Revision: 1.3 $
// $Date: 2002/02/22 14:20:44 $
// Author: Markus Kern
//*****************************************************************************
/*
Generates the state machine for each active instance of meta type MNormalClass.
genStateMachine is called by genH (defined in c_genh.tdl).
genStateMachineBody is called by genC (defined in c_genc.tdl).
*/

/* the interface of a state machine is given by:
   an enumeration of all events (objEvent)
   an enumeration of all states (objState)
   an operation for sending an Event (takeEvent)
   a static operation instantiating the class and sending a creation event 
   (classEvent)
   
   the argument variable 'StateEventTable' triggers, whether the state machine
   is realized by case statements or with an event-state-table. The default
   case is a table.
*/

/******************************************************************************
generates the enums objEvent and objState
******************************************************************************/
template genStatemachine(MClass)
[/* add each MEvent belonging to the MClass to <class>_objEvent. 
    setDelim()/delim() (defined in std.tdl) specify delimiter placement. */]
enum [MClass.name]_objEvent {
	[setDelim("") setVar("__VALUE__", " = 0")]
	[loop(MClass->ReceiveEvent)][delim()][setDelim(",")]
	_[MClass.name]_[ReceiveEvent.name][[__VALUE__]][setVar("__VALUE__", "")][end loop]

};

[/* add each MCreationState and each MNormalState belonging to the 
    MClass to <class>_objStates, i.e. MFinalState is omitted. */]
enum [MClass.name]_objStates {
	[setDelim("") setVar("__VALUE__", " = 0")]
	[loop(MClass->MStatemachine->MState->MCreationState)][delim()][setDelim(",")]
	ST_[MClass.name]_[MState.name][[__VALUE__]][setVar("__VALUE__", "")][end loop]
	[loop(MClass->MStatemachine->MState->MNormalState)][delim()][setDelim(",")]
	ST_[MClass.name]_[MState.name][end loop]

};

void [MClass.name]_takeEvent(struct [MClass.name]_obj *, enum [MClass.name]_objEvent);
[MClass.name] * [MClass.name]_classEvent(enum [MClass.name]_objEvent);
end template

/******************************************************************************
generates the action functions, classEvent and takeEvent handler. Depend on the
variable 'StateEventTable', takeEvent is realized with a table or with case
statements.
******************************************************************************/
template genStateMachineBody(MClass)
[/* generates for all MNormalState an action function. */]
[loop(MClass->MStatemachine->MState->MNormalState)]
/*-----------------------------------------------------------------------------
 State :	[MState.name]
-----------------------------------------------------------------------------*/
void C[MClass.name]_[MState.name]_Action (struct [MClass.name]_obj *self) {
	self->currentState = ST_[MClass.name]_[MState.name];
	{
	[mergeOut("UDAC::" getUniqueId([MState]),"Action Code")]
	}
}
[end loop]

/*-----------------------------------------------------------------------------
 class Event
-----------------------------------------------------------------------------*/
[MClass.name] * [MClass.name]_classEvent (enum [MClass.name]_objEvent ev) {

	[MClass.name] *	newInstance = 0;

	switch(ev) {
	[/* accept each event (TriggerEvent) which causes a transition from an
	    instance of MCreationState to some other state (ToState) */]
	[loop(MClass->MStatemachine->MState->MCreationState->ToState->MTransition->TriggerEvent)]
	case _[MClass.name]_[TriggerEvent.name]:
		[/* for this event create a new instance of MClass
		    and send the event to that instance */]
		newInstance = [MClass.name]_getNew();
		[MClass.name]_takeEvent(newInstance,ev);
		break;
	[end loop]
	default:
		[/* An illegal event has been used. For now we just put
		    an error message */]
		printf("([MClass.name]) illegal create event\n"); 
		break;
	}
	return newInstance;
}

/*-----------------------------------------------------------------------------
 class Event
-----------------------------------------------------------------------------*/
[if([StateEventTable] != FALSE)]
[/* takeEvent realized with a table */]
void [MClass.name]_takeEvent (struct [MClass.name]_obj *self, enum [MClass.name]_objEvent ev) {
	
	void (*stateAction)(struct [MClass.name]_obj*);
	[/* returns a pointer to an action function, triggered by the current state
	    and the incoming event (ev)  */]
	stateAction = self->[MClass.name]_stateEventTable\[self->currentState]\[ev];
	if(stateAction) {
		[/* if the current state accepts the incoming event, the action will
		    be executed.*/]
		stateAction(self);
	} else {
		[/* An illegal event has been used. For now we just put
		    an error message */]	
		printf("([MClass.name]) illegal event %i in state %i\n",ev,self->currentState);
	}
}
[else]
[/* takeEvent realized with case statements */]
void [MClass.name]_takeEvent (struct [MClass.name]_obj *self, enum [MClass.name]_objEvent ev) {

	[/* handle each possible state, currentState holds the current state
	    of the state machine */]
	switch(self->currentState) {
		[loop(MClass->MStatemachine->MState)]
		[/* the state machine is in state <class>_<state> now. Accept all events
		    legal for this state */]
		case ST_[MClass.name]_[MState.name]:
			switch(ev) {
			[loop(MState->ToState->MTransition->TriggerEvent) ]
			case _[MClass.name]_[TriggerEvent.name]:
			[/* TriggerEvent is a legal event in state MState, causing a
			    transition to state ToState. Update currentState and
			    call action procedure for ToState */]
				C[MClass.name]_[ToState.name]_Action(self);
				break;
			[end loop]
			default:
				[/* An illegal event has been used. For now we just put
				    an error message */]
		    	printf("([MClass.name]) illegal event %i in state ST_[MClass.name]_[MState.name]\n",ev);
			} /* end event switch for state [MState.name] */

			break;
		[end loop]
	} /* end state switch */
}
[end if]
end template

/******************************************************************************
generates a forward declaration for all MNormalState.
(used in genH, c_genH.tdl)
******************************************************************************/
template genStateDeclaration(MClass)
/* State Action Declaration */
[loop(MClass->MStatemachine->MState->MNormalState)]
void C[MClass.name]_[MState.name]_Action (struct [MClass.name]_obj *self);
[end loop]
end template

/******************************************************************************
generates the integer variable 'currentState' in the instance structure.
'currentState' holds the current state of the state machine. (used in genH, 
c_genh.tdl)
******************************************************************************/
proc genCurrentStateDecl(ClassList)
	loop(Instances->MClass([ClassList]) Where [MClass.active])
		return "int currentState;";
	end loop
	return "";
end proc

/******************************************************************************
generates the initialization of the variable 'currentState' in the standard
constructor (used in genC, c_genc.tdl). 'currentState' is assigned to the
start state. 
******************************************************************************/
proc genCurrentStateInit(MClass)
	loop(MClass->MStatemachine->MState->MCreationState)
		return "self->currentState = ST_" [MClass.name] "_" [MState.name] ";";
	end loop
end proc

/******************************************************************************
generates the initialization of the state-event-table in the standard
constructor. The x-position contains all possible events, the y-position
contains all states. (used in genC, c_genc.tdl)
******************************************************************************/
proc genStateEventTableInit(MClass)
	/* contains the return value */
	local ret = "";
	/* for each loop, contains a pointer to the action function */
	local action = "";
	
	/* returns an empty string, if the variable 'StateEventTable' is false */
	if( [StateEventTable] == FALSE ) return ""; end if
	
	/* loop over all states belonging to the current looped class instance */
	loop(MClass->MStatemachine->MState;setDelim("");setDelim("\t"))
		/* loop over all ReceiveEvent */
		loop(MClass->ReceiveEvent;;setDelim("\t"))
			/* set the action pointer to null */
			[action] = "0";
			/* look if the current looped State can receive the ReceiveEvent */
			loop(MState->ToState->MTransition->TriggerEvent Where [ReceiveEvent.id] == [TriggerEvent.id])
				/* set the action pointer */
				[action] = "C"[MClass.name]"_"[ToState.name]"_Action";
			end loop
			/* generates the assignment */
			[ret] = [ret] delim() "self->"[MClass.name]"_stateEventTable[ST_"
					[MClass.name]"_"[MState.name]"][_"[MClass.name]"_"
					[ReceiveEvent.name]"] = "[action] ";\n";
		end loop
	end loop
	return [ret];
end proc

/******************************************************************************
generates the declaration of the array <class>_stateEventTable, which contains
all possible state event transitions.
******************************************************************************/
proc genStateEventTableDecl(SuperClassList)

	/* returns an empty string, if the variable 'StateEventTable' is false or
	    the class is no state machine */
	if([StateEventTable] == FALSE)
		return;
	end if
	
	loop(Instances->MClass([SuperClassList]) Where [MClass.active] == TRUE)
		/* return the state-event-table declaration */
		return "void(*" [MClass.name]"_stateEventTable[" 
		       loopCount(MClass->MStatemachine->MState) "]["
		       loopCount(MClass->ReceiveEvent) "])(struct " [MClass.name]
		       "_obj*);";
	end loop
end proc
