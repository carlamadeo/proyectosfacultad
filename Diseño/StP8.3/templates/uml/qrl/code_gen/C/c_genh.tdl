//*****************************************************************************
// $RCSfile: c_genh.tdl,v $
// $Revision: 1.2 $
// $Date: 2001/06/15 02:10:34 $
// Author: Markus Kern
//*****************************************************************************
/*
Generates the header file for each instance of meta type MNormalClass.
genH is called by main (defined in c_main.tdl).

Generates for each MNormalClass in the model two structures:

	 - class structure (struct <class>_class)
	   contains the static attributes, the virtual functions, the instance
	   handlers and a class id for the runtime type information.
	   
	 - instance structure (struct <class>_obj)
	   contains the none static attributes and the association information
	   and a pointer to the corresponding class structure.
	   
Every class defines all elements (operation, attributes), including the parent
elements. Therefore there is a special requirement for inheritance. The class
structure and the instance structure must be an extension to the corresponding
parent structures. This means that the order of the overlapping elements are
the same.
*/

template genH(MClass)
#ifndef _[MClass.name]_h
#define _[MClass.name]_h

#include "classes.h"
[/* write out an include statement for each direct parent class */]
[loop(MClass->SuperClass)]
#include "[SuperClass.name].h"
[end loop]

[/* Generates a marked section in the output. The content of this section can
be changed by the user in the generated file. These changes will not be 
overwritten, in the following cycles of code generation */]
[mergeOut("UDIF","include files")]

[/* generates the operation calls. The provided calling convention
    is <class>_<operation-name>(<parameter>). (the procedure is defined
    defined below) */]
[genOperationCall([MClass])]

[/* generates the attribute accessors. The provided calling
    convention is <class>_set<attribute-name>(<parameter>) and 
    <class>_get<attribute-name>(). (the procedure is defined below) */]
[genAttributeAccesor([MClass])]

[/* generates the standard allocator and the standard deallocator. The usage
    of the allocator is <class>_getNew() and the usage of the deallocator is
    <class>_free(self). (the procedure is defined below) */]
[genInstanceHandleCall([MClass])]

[/* generates a forward declaration of the operations and the state actions.
    (genOperationDeclaration is defined below, genStateDeclaration is defined
     in c_gensm.tdl) */]
[genOperationDeclaration([MClass])]
[genStateDeclaration([MClass])]

[/* generates the class structure. It contains the static attributes, the
    virtual functions, the instance handlers and a class id for the runtime
    type information. Note that the order of the structure is important. */]
typedef struct [MClass.name]_class {
    [/* the class id, which is defined as enum in classes.h (genClassesH,
        defined in c_main.tdl. */]
    enum ClassID     cid;
    [/* pointer to the class structure of the parent class */]
    void *      super;
    [/* standard allocator */]
    struct [MClass.name]_obj * (* getNew)();			
    [/* standard deallocator */]
    void (* free) (struct [MClass.name]_obj *);			
    [/* standard constructor */]
    void (* ctor) (struct [MClass.name]_obj *);			
    [/* standard destructor */]
    void (* dtor) (struct [MClass.name]_obj *);	
    [/* loop over all direct and indirect parent classes and the class itself.
        The used id list <SuperClassList> is created by the procedure
        'initOperationList' (defined in c_main.tdl) */]
    [loop(Instances->MClass([SuperClassList]) As SClass)]
     [/* loop over the virtual operations, belonging to the currently looped
         instance. */]
     [loop(Instances->MOperation([[MClass.id]"_"[SClass.id] "virtOpIdList"]))]
    [getDataType([MOperation.returnType])] (* [MOperation.name]) (struct [getClassName([MClass],[MOperation])]_obj *[genOpParaList([MOperation])]);
     [end loop]
     [/* loop over static attributes, belonging to the currently looped
         instance. */]
     [loop(SClass->MAttribute Where [MAttribute.binding] == "static")]
    [getDataType([MAttribute.type])] [MAttribute.name];
     [end loop]
    [end loop]
} [MClass.name]Class;

[/* the class structure exists exactly one time in the runtime memory. The name
    for this instance is C<class> */]
extern [MClass.name]Class C[MClass.name];

[/* generates the instance structure. It contains the none static attributes and
    the association information. Note that the order of the structure is
    important. */]
typedef struct [MClass.name]_obj {
    [/* pointer to the corresponding class structure.*/]
    [MClass.name]Class * myClass;
    [/* if the class or a parent class has a state machine, the instances
        structure contains a attribute called 'currentState'. This attribute
        holds the current state of the state machine. The used id list
        <SuperClassList> is created in procedure 'initOperationList'
        (defined in c_main.tdl). */]
    [genCurrentStateDecl([SuperClassList])]
    [/* if the state machine is realized with a table, the array
        <class>_stateEventTable contains all possible state event
        transitions.*/]
    [genStateEventTableDecl([SuperClassList])]
    [/* loop over all direct and indirect parent classes and the class
        itself. */]
    [loop(Instances->MClass([SuperClassList]) As SClass)]
     [/* loop over all none static attributes, belonging to the currently
         looped instance. */]    
     [loop(SClass->MAttribute Where [MAttribute.binding] == "normal")]
     [/* getDataType (defined in std.tdl) maps type names used in the model onto
         language specific type names. See the documentation for type
         mapping. */]
     [getDataType([MAttribute.type])] [MAttribute.name];
     [end loop]
	 [/* each relation (MAssociation) has two end points (MAssociationEnd). 
	     We look for pairs of end points where one end point is attached to 
	     the source class and the other end point is attached to the 
	     destination class. We use the alias name 'FromRole' for the end point
	     of the source class, 'ToRole' for the end point of the destination 
	     class, and 'Partner' for the destination class itself. The condition
	     'Where [FromRole.id] != [ToRole.id]' assures that both end points are
	     different. */]
	 [loop(SClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner
	 Where [FromRole.id] != [ToRole.id])]
    struct [Partner.name]_obj [genRelation([ToRole])];
     [end loop]
    [end loop]
  [/* Instead of using the instance structure as 'struct <class>_obj, the name
      of the instance structure is like the class name. It is realized with a
      typedef. See beginning of the struct. */]
} [MClass.name];

[/* if the class has a state machine in the model, it is an active class. 
    genStateMachine (defined in c_sm.tdl) generates declarations for the state
    machine in this case. */]	
[if([MClass.active])]
[genStatemachine([MClass])]
[end if]
#endif
end template


/*****************************************************************************
the used c architecture makes a difference between calling an virtual
operation and an none virtual operation. Therefore each operation is 
encapsulated with a define statement. The provided calling convention
is <class>_<operation-name>(<parameter>).
genOpParaList puts the paramer list (defined in c_std.tdl)
*****************************************************************************/
template genOperationCall(MClass)
/* virtual operations */
[loop(Instances->MOperation([MClass:opIdList])->MClass As SClass Where [MOperation.binding] == "virtual")]
#define [MClass.name]_[MOperation.name](self [genOpParaNameList([MOperation])])	(* (self->myClass->[MOperation.name]))(self [genOpParaNameList([MOperation])])
[end loop]

/* non virtual operations */
[loop(Instances->MOperation([MClass:opIdList])->MClass As SClass Where [MOperation.binding] != "virtual")]
#define [MClass.name]_[MOperation.name](self [genOpParaNameList([MOperation])])	C[SClass.name]_[MOperation.name](self [genOpParaNameList([MOperation])])
[end loop]
end template

/*****************************************************************************
the used c architecture makes a difference between accessing an static
attribute and an none static attribute. Therefore each attribute is 
encapsulated with a set and a get statement. The provided calling
convention is <class>_set<attribute-name>(<parameter>) and 
<class>_get<attribute-name>().
*****************************************************************************/
template genAttributeAccesor(MClass)
/* Attribute Accesors */
[loop(Instances->MClass([SuperClassList]) As SC->MAttribute)]
#define [MClass.name]_set[MAttribute.name](self,arg) self->[MAttribute.name] = arg
#define [MClass.name]_get[MAttribute.name](self) self->[MAttribute.name]
[end loop]

/* static Attribute Accesors */
[loop(Instances->MClass([SuperClassList]) As SC->MAttribute Where [MAttribute.binding] == "static")]
#define [MClass.name]_set[MAttribute.name](arg) C[MClass.name].[MAttribute.name] = arg
#define [MClass.name]_get[MAttribute.name]() C[MClass.name].[MAttribute.name]
[end loop]
end template

/*****************************************************************************
every class has a standard allocator and a standard deallocator. The
deallocator is virtual. The handlers are encapsulated to get a 
standard calling convention. The usage of the allocator is <class>_getNew()
and the usage of the deallocator is <class>_free(self).
*****************************************************************************/
template genInstanceHandleCall(MClass)
/* Instance handle */
#define [MClass.name]_getNew() (* C[MClass.name].getNew)()
#define [MClass.name]_free(self) (* self->myClass->free) (self)
end template

/*****************************************************************************
every operation and state action is implemented in the body file (<class>.c)
*****************************************************************************/
template genOperationDeclaration(MClass)
/* Operation Declaration */
[loop(MClass->MOperation)]
[getDataType([MOperation.returnType])] C[MClass.name]_[MOperation.name](struct [MClass.name]_obj * self [genOpParaList([MOperation])]);
[end loop]
end template

/******************************************************************************
maps the multiplicity of the end point MAssociationEnd. We distinguish the 
following cases:
"One"  : a single pointer
"Many" : an array of pointers, currently 100
"n"    : an array of n pointers 
Procedure getMultiplicity (defined in std.tdl) provides the multiplicity of 
the end point
******************************************************************************/
proc genRelation(MAssociationEnd)
	local multiplicity = getMultiplicity([MAssociationEnd.multiplicity]);
	switch([multiplicity])
	case "Many" : return " *_" [MAssociationEnd.name] "[100]";
	case "One"	: return " *_" [MAssociationEnd.name];
	default 	: return " *_" [MAssociationEnd.name] "[" [multiplicity] "]";
	end switch
end proc
