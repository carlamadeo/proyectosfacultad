//*****************************************************************************
// $RCSfile: c_genbody.tdl,v $
// $Revision: 1.2 $
// $Date: 2001/06/15 02:10:34 $
// Author: Markus Kern
//*****************************************************************************
/*
Generates the body file for each instance of meta type MClass.
genC is called by main (defined in c_main.tdl).
*/

template genC(MClass)
#include <stdio.h>  
#include <stdlib.h>  
#include "[MClass.name].h"
[/* include all partner classes. Find out each partner class :
    Each relation (MAssociation) has two end points (MAssociationEnd). 
    We look for pairs of end points where one end point is attached to 
    the source class and the other end point is attached to the 
    destination class. We use the alias name 'FromRole' for the end point
    of the source class, 'ToRole' for the end point of the destination 
    class, and 'Partner' for the destination class itself. The condition
    'Where [FromRole.id] != [ToRole.id]' assures that both end points are
    different. */]
[loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner
Where [FromRole.id] != [ToRole.id])]
#include "[Partner.name].h"
[end loop]

[mergeOut("UDIF","Include Files")]


/*-----------------------------------------------------------------------------
 Constructor
-----------------------------------------------------------------------------*/
[/* generates the standard constructor. The ctor is used by the new
    handler. */]
void C[MClass.name]_ctor([MClass.name] * self)
{
[/* if the class has a state machine in the model, it is an active class. 
    genCurrentStateInit (defined in c_gensm.tdl) generates code to initialize
    the variable currentState with the start state. */]	
    [genCurrentStateInit([MClass])]
    [/* if the state machine is realized with a table, the array
        <class>_stateEventTable will be initialized here (defined in
        c_gensm.tdl). */]
   	[genStateEventTableInit([MClass])]
   	[/* assigns of the corresponding class structure. */]
    self->myClass = &C[MClass.name];

	[mergeOut("UDC","Constructor")]
}

/*-----------------------------------------------------------------------------
 Desctructor
-----------------------------------------------------------------------------*/
[/* generates the standard descructor. The dtor is used by the free
   handler. */]
void C[MClass.name]_dtor([MClass.name] * self)
{
	[mergeOut("UDD","Desctructor")]
}

/*-----------------------------------------------------------------------------
 New
-----------------------------------------------------------------------------*/
[/* generates the new handler. */]
[MClass.name] * C[MClass.name]_new()
{
    [MClass.name] * self = ([MClass.name] *) malloc(sizeof ([MClass.name]));    
    if(self) {
	    [/* generates code for calling all parents constructor. */]
        [genCtor([MClass],"C" [MClass.name] ".super")]
		[/* call the own constructur */]
    	(* C[MClass.name].ctor)(self);
    }
    return self;
}

/*-----------------------------------------------------------------------------
 free
-----------------------------------------------------------------------------*/
[/* generates the free handler. */]
void C[MClass.name]_free([MClass.name] * self)
{
	if(self) {
		[/* call the own desctructor */]
    	(* self->myClass->dtor)(self);
	    [/* generates code for calling all parents destructor. */]
		[genDtor([MClass],"C" [MClass.name] ".super")]
	    free(self);
    }
}

/*-----------------------------------------------------------------------------
 init class structure
-----------------------------------------------------------------------------*/
[/* initializes the class structure. (defined in genH, c_genh.tdl )*/]
[MClass.name]Class C[MClass.name] =
{
    [MClass.name]Type,
    [/* initializes with the parent class structure, if available.
        (genSuperClassInit is defined below */]
    [genSuperClassInit([MClass])],
    C[MClass.name]_new,
    C[MClass.name]_free,
    C[MClass.name]_ctor,
    C[MClass.name]_dtor,
    [/* loop over all direct and indirect parent classes and the class itself.
        The used id list <SuperClassList> is created by the procedure
        'initOperationList' (defined in c_main.tdl) */]    
    [loop(Instances->MClass([SuperClassList]) As SClass)]
     [/* loop over the virtual operations, belonging to the currently looped
         instance. */]
     [loop(Instances->MOperation([[MClass.id]"_"[SClass.id] "virtOpIdList"]))]
     [/* initializes with the pointer of all virtual operations. 'getClassName'
         (defined in c_main.tdl) puts the topmost class, which has a operation
         it matches with the currently loop operation. */]
    C[getClassName([MClass],[MOperation])]_[MOperation.name],
     [end loop]
     [loop(SClass->MAttribute Where [MAttribute.binding] == "static")]
    [MAttribute.defaultValue],
     [end loop]
    [end loop]
};

[/* virtual operations of MClass. The description in the model is put as comment
    in the header (genLines is defined in c_std.tdl).
    getDataType (defined in std.tdl) maps type names used in the model onto 
    language specific type names. See the documentation for type mapping.
    genOpParaList puts the paramer list (defined in c_std.tdl) */]
[loop(MClass->MOperation Where [MOperation.binding] == "virtual")]
/*-----------------------------------------------------------------------------
 virtual Operation : [MOperation.name]

 Description :		 [genLines([MOperation.description])]
-----------------------------------------------------------------------------*/
[getDataType([MOperation.returnType])] C[MClass.name]_[MOperation.name]([MClass.name] * self [genOpParaList([MOperation])])
{
	[mergeOut("UDMF::" getUniqueId([MOperation]),"Member Function")]
}
[end loop]

[/* none virtual operations of MClass. */]
[loop(MClass->MOperation Where [MOperation.binding] != "virtual")]
/*-----------------------------------------------------------------------------
 Operation :	[MOperation.name]

 Description :	[genLines([MOperation.description])]
-----------------------------------------------------------------------------*/
[getDataType([MOperation.returnType])] C[MClass.name]_[MOperation.name]([MClass.name] * self [genOpParaList([MOperation])])
{
	[mergeOut("UDMF::" getUniqueId([MOperation]),"Member Function")]
}
[end loop]

[/* if the class has a state machine in the model, it is an active class. 
    genStateMachineBody (defined in c_gensm.tdl) generates code for the state
    machine in this case. */][if([MClass.active])]
[genStateMachineBody([MClass])]
[end if]
end template


/******************************************************************************
used to initialize the class structure (genH). If the class in the model has a
parent class, it will be initialized with the pointer to the parents
class structure, otherwise it is 0.
******************************************************************************/
proc genSuperClassInit(MClass)
	loop(MClass->SuperClass)
	    return "&C" [SuperClass.name];
	end loop
	return 0;
end proc

/******************************************************************************
returns code to call all parent constructors. The order of calling the
constructor is from top to the bottom. (used in genH)
******************************************************************************/
proc genCtor(MClass,classPtr)
	local ret;
	loop(MClass->SuperClass)
		[classPtr] = "((" [SuperClass.name] "Class*)"[classPtr] ")";
		[ret] = genCtor([SuperClass],[classPtr] "->super");
		[ret] = [ret] "\t(* "[classPtr]"->ctor)((" [SuperClass.name] " *) self);\n";
	end loop
	return [ret];
end proc

/******************************************************************************
returns code to call all parent destructor. The order of calling the
constructor is from bottom to the top. (used in genC)
******************************************************************************/
proc genDtor(MClass,classPtr)
	local ret;
	loop(MClass->SuperClass)
		[classPtr] = "((" [SuperClass.name] "Class*)"[classPtr] ")";
		[ret] = "\t(* "[classPtr]"->dtor)((" [SuperClass.name] " *) self);\n";
		[ret] = [ret] genDtor([SuperClass],[classPtr] "->super");
	end loop
	return [ret];
end proc