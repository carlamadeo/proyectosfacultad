//
//      StP/UML 
//      Confidential property of Aonix
//      Copyright (c) 1997
//      All rights reserved

//
//  C++ code generation for UML
//

#include "qrl/code_gen/code_gen.inc"
#include "qrl/code_gen/cxx/string_constants.inc"
#include "qrl/code_gen/cxx/association_patterns.inc"
#include "rules/qrl/oper_parse.inc"
#include "rules/qrl/uml.inc"

//
//  External variables specific to C++
//
 

// --- START PATCH ECR 5025 ---
// This variable is introduced to resolve a conflict with
// a non-external variable.
//
external boolean x_generate_namespace = True;
// --- END PATCH ECR 5025 ---
external boolean inlines_in_class = False;
external_help = "True:  Place inline code within class declaration. (Operation file extension = interface file extension, if True.)";

external string implement_associations_using_pattern_family = "Default Template";
external_help = "Use this pattern family to implement association roles.";

external boolean use_packages_in_filenames = False;
external_help = "This applies when code is being generated with one file name per class.  If a class in a model is contained within a package or packages, this boolean determines whether or not the enclosing package names are used as part of the generated file name.  If the same class name were to be used for two different classes in different packages, it would be necessary to use the package name in the generated file name.  However, as of version 3.4.2, StP/UML does not support true scoping of class names within packages, rather class names must be globally unique.  Whether or not to include package names as part of the file name is therefore a matter of preference.  One advantage of not using package names is that if a class is moved from one package to another, then it will be found in the same file by incremental code generation.  If the package name were included in the file name, any non-StP generated code would have to be manually transferred over to the new file.";


/////////////////////////////////////////////////////////////////////////////


struct all_visibilities
{
    string public;
    string protected;
    string private;
};

/////////////////////////////////////////////////////////////////////////////

list
UmlAttributeItems(node attribute)
{
    return list_select("item[obj_id=${attribute.id} & note[UmlAttributeCxxDefinition]]");
}

list
UmlOperationItems(node operation)
{
    return list_select("item[obj_id=${operation.id} & note[UmlOperationCxxDefinition]]");
}

note
UmlOperationCode(node operation)
{
    return find_by_query("note[obj_id=${operation.id} & UmlOperationCxxCode]");
}

list
UmlRoleItems(link role)
{
    return list_select("item[obj_id=${role.id} & note[UmlRoleCxxDefinition]]");
}

list
UmlAssociationItems(node association)
{
    list item_list = list_create("item", 0);
    return item_list;
}

list
UmlGeneralizationItems(link generalization)
{
    list l = list_select("item[obj_id=${generalization.id} & note[UmlCxxInheritanceDefinition]]");

    // For refinement args when inheriting from a parameterized class
    list_concatenate(l, list_select("item[obj_id=${generalization.id} & note[UmlRefinesDefinition]]"));

    return l;
}

list
UmlClassItems(node class)
{
    list l = list_select("item[obj_id=${class.id} & note[UmlClassCxxDefinition | UmlClassCxxDeclarations | UmlClassCxxTableNote ]]");

    return l;
}

void
LanguageUmlGeneralizations(list generalizations, node class)
{
    int i, n;
    link implements_link, corresponding_generalization_link;
    
    // get the UmlImplements links for this class
    list implementations = list_select("link[UmlImplements & from_node_id=${class.id} & link_refs]");

    // append each implements link to the generalizations list, but
    // not if there is already a corresponding generalization link
    for (i = 0, n = list_count(implementations); i < n; i = i + 1) {
	implements_link = list_get(implementations, i);
	corresponding_generalization_link = find_by_query("link[UmlGeneralization & from_node_id=${implements_link.from_node_id} & to_node_id=${implements_link.to_node_id} & link_refs]");
	if(corresponding_generalization_link == NULL)
	    list_append(generalizations, implements_link);
    }
}


//////////////////////////////////////////////////////////////////////////////
struct typedef_struct
{
    list   scope_list;
    string definition;
};


ClassCodeVariant
ClassCodeVariant(node class)
{
    ClassCodeVariant self;

    self.is_template = False;
    self.template_prefix = "";
    self.template_parameters = "";
    self.constructor_initialization_list = "";
    self.static_attribute_initializers = "";
    self.instantiated_class_typedefs = list_create("typedef_struct", 0);

    self.generalizations = list_create("string", 0);
    self.associations = list_create("string", 0);
    self.dependencies = set_create ("string");

    return self;
}

void
ClassCodeVariant__Compile(ClassCodeVariant self, ClassCodeDescriptor c)
{
    UmlAttribute    uml_attribute;
    item            def, plist, stereotype;
    string          separator, attribute_name, attribute_type, parameters;
    list            instances;
    node            instance, instance_elaborated;
    link            refines_link;
    int             i;
    typedef_struct  typedef;

    set_template_prefix_and_parameters(c);
    
    for (i = 0; i < list_count(c.uml_class.UmlAttributes); i = i + 1)
    {
	uml_attribute = list_get(c.uml_class.UmlAttributes, i);
	def = UmlAttribute__GetItem(uml_attribute, "UmlAttributeDefaultValue");
	if (def != NULL)
	{
	    attribute_name = make_attribute_name(uml_attribute);
	    if (UmlAttribute__GetItemValue(uml_attribute, 
					   "UmlMemberIsClass") == "True")
	    {
		attribute_type = make_attribute_type(uml_attribute);
		if (self.is_template == False) // supported by compilers yet?
		    self.static_attribute_initializers = 
			self.static_attribute_initializers +
			attribute_const_string(uml_attribute) +
			attribute_volatile_string(uml_attribute) +
			attribute_type + " " +
			c.def.language_qualified_name + "::" + attribute_name +
			" = " + def.value + ";\n";

		// can add code here to automatically generate 
		// constructor_initialization_list, something like:

// Begin uncomment
// this code was commented by Joe. Dont know what he had in
// mind.  

	    } else
	    {
		if (self.constructor_initialization_list == "")
		    separator = "";
		else
		    separator = ", ";

		self.constructor_initialization_list = 
		    self.constructor_initialization_list + separator + 
		    attribute_name + "(" + def.value + ")";
                
// End uncomment
	    }
	}
    }

    // get named instantiations of this parameterized class
    // un-named instantiations cannot be typedefs
    instances = list_select("node[UmlClass & out_links[UmlRefines & to_node_id=${c.oms_class.id} & link_refs] & node_refs]");

    for (i = 0; i < list_count(instances); i = i + 1)
    {
	instance = list_get(instances, i);
	
	instance_elaborated = class_elaborated_type(instance);
	
	// if type = NULL, then it's inheritance by regular class.
	// if type = UmlParameterizedClass, then it's inheritance by
	//     Parameterized Class.
	if (instance_elaborated != NULL && 
	    instance_elaborated.type == "UmlInstantiatedClass")
	{
	    refines_link = find_by_query("link[UmlRefines & from_node_id=${instance.id} & to_node_id=${c.oms_class.id} & link_refs]");
	    
	    stereotype = find_by_query("item[UmlStereotype & obj_id=${refines_link.id}]");
	    if (stereotype == NULL || stereotype.value == "")
		ide_warning("  Warning: No stereotype defined for Refinement relationship, assuming 'bind'.");
	    else if (stereotype.value != "bind")
		break;
	    
	    plist = find_by_query("item[UmlRefineArgs & obj_id=${refines_link.id}]");
	    if (plist == NULL)
		parameters = "";
	    else
		parameters = plist.value;

	    typedef.scope_list = language_make_scope_list(instance);
	    typedef.definition = "typedef " + c.def.language_qualified_name + "< " + parameters + " > " + language_make_base_name(instance) + ";\n";
	    list_append(self.instantiated_class_typedefs, typedef);
	    
	    // parameterized class must depend on anything that its named
	    // instantiations depend on, since the named instantiations 
	    // appear in the parameterized class file as typedefs
	    generate_dependencies(instance, self.dependencies);
	}
    }
    
    return;
}

void
ClassCodeVariant__AppendGeneralizations(ClassCodeVariant self, 
					ClassCodeDescriptor c, 
					node superclass_node)
{
    list_append(self.generalizations, 
		make_dependency_name(superclass_node));

    make_transitive_dependencies(superclass_node, self.dependencies);
    
    return;
}

void
ClassCodeVariant__AppendAssociations(ClassCodeVariant self, 
				     ClassCodeDescriptor c, 
				     node target_node)
{
    list_append(self.associations, 
		make_dependency_name(target_node));

    make_transitive_dependencies(target_node, self.dependencies);
    
    return;
}

//////////////////////////////////////////////////////////////////////////////

void
ClassCodeFile__AdjustName(ClassCodeFile self, ClassCodeDescriptor c)
{
    return;
}

//////////////////////////////////////////////////////////////////////////////

void
ClassCodeDefinition__SetIdentifier(ClassCodeDefinition self, 
				   ClassCodeDescriptor c)
{

    self.language_base_name = language_make_base_name(c.oms_class);
}

void
ClassCodeDefinition__SetDefinitionHeader(ClassCodeDefinition self, 
					 ClassCodeDescriptor c)
{
    UmlGeneralization  uml_generalization;
    int                i, n;
    string             generalization, visibility, virtual,
                       refinement_args, superclass_instantiation_params;

    self.definition_header = "";

    if (comment_classes == True)
	self.definition_header = self.definition_header + 
	    generic_generate_object_comment(c.oms_class, 
					    "Class", "", "//", "", "");

    // template<template-paramter-list> class class-name
    if (c.var.template_prefix != "")
	self.definition_header = self.definition_header + 
	    c.var.template_prefix + "\n";
    self.definition_header = self.definition_header + "class " + 
	self.language_qualified_name;

    // [: [vis] [virt] super[params] [, [vis] [virt] super[params]]]
    for (i = 0, n = list_count(c.uml_class.UmlGeneralizations); i<n; i=i+1) {
	uml_generalization = list_get(c.uml_class.UmlGeneralizations, i);

	if (i == 0)
	    self.definition_header = self.definition_header + " : ";
	else
	    self.definition_header = self.definition_header + ", ";

	visibility = UmlGeneralization__GetItemValue(uml_generalization, 
						    "UmlCxxInheritanceVisibility");

	if (to_lower(visibility) == "private")
	    visibility = "private ";
	else if (to_lower(visibility) == "protected")
	    visibility = "protected ";
	else
	    visibility = "public ";

	if (UmlGeneralization__GetItemValue(uml_generalization, "UmlCxxInheritanceIsVirtual") == "True")
	    virtual = "virtual ";
	else
	    virtual = "";

	generalization = language_make_qualified_name(uml_generalization.class);

	superclass_instantiation_params = "";
	if (uml_generalization.elaborated_type != NULL) 
	{
	    // this is for inheriting from anonymous instantiated class
	    if(uml_generalization.elaborated_type.type == 
	       "UmlInstantiatedClass" &&
	       uml_generalization.class.sig != "") 
	    {
		superclass_instantiation_params = "< " + 
		    uml_generalization.class.sig + " >";
	    }

	    // this is for inheriting from parameterized class
	    if(uml_generalization.elaborated_type.type == 
	       "UmlParameterizedClass")
	    {
		refinement_args = 
		    UmlGeneralization__GetItemValue(uml_generalization,
						    "UmlRefineArgs");
		if (refinement_args != "")
		    superclass_instantiation_params = 
			"< " + refinement_args + " >";
	    }
	}

	ClassCodeVariant__AppendGeneralizations(c.var, c, uml_generalization.class);
	self.definition_header = self.definition_header +
	    visibility + virtual +
	    generalization + superclass_instantiation_params;
    }

    self.definition_header = self.definition_header + "\n";

    return;
}

void
ClassCodeDefinition__SetDefinition(ClassCodeDefinition self, 
				   ClassCodeDescriptor c)
{
    all_visibilities  attrs, ops, assns;
    string            declarations, friends;

    if (is_class_table_defined(c.oms_class) == False &&
	c.oms_class.type == "UmlClass")   // Don't warn for pseudo-classes
        ide_warning("  Warning: Class '" + self.language_qualified_name + "' does not have a class table definition.");

    // generic "before" declarations
    declarations = UmlClass__GetNoteDescription(c.uml_class, 
						"UmlClassCxxDeclarations");
    if (declarations != "" && 
	string_extract(declarations, string_length(declarations)-1, 1) != "\n")
	declarations = declarations + "\n";

    friends = generate_friends(c);

    attrs        = generate_attributes(c);
    ops          = generate_operations(c);
    assns        = generate_associations(c);
    
    generate_dependencies(c.oms_class, c.var.dependencies);

    self.definition =
	declarations +
	friends + 
	"public:\n"    + ops.public    + attrs.public    + assns.public +
	"protected:\n" + ops.protected + attrs.protected + assns.protected +
	"private:\n"   + ops.private   + attrs.private   + assns.private;

    return;
}

//////////////////////////////////////////////////////////////////////////////

all_visibilities
generate_attributes(ClassCodeDescriptor c)
{
    list              UmlAttributes = c.uml_class.UmlAttributes;
    all_visibilities  generated;
    int               i, n;
    UmlAttribute      uml_attribute;
    string            visibility, cxx_visibility;

    generated.public = "";
    generated.protected = "";
    generated.private = "";

    // Attributes are not always generated for classes with stereotype
    // of 'type' or 'interface'
    if (class_is_uml_type(c.uml_class) &&
	!should_generate_uml_type_attributes(c.uml_class))
	return generated;

    for (i = 0, n = list_count(UmlAttributes); i < n; i = i + 1)
    {
	uml_attribute = list_get(UmlAttributes, i);

	visibility = UmlAttribute__GetItemValue(uml_attribute, 
						"UmlMemberVisibility");
	cxx_visibility = UmlAttribute__GetItemValue(uml_attribute, 
						"UmlMemberCxxVisibility");
	if (cxx_visibility != "")
	    visibility = cxx_visibility;

        if (to_lower(visibility) == "public")
	    generated.public = generated.public + 
		generate_attribute(c, uml_attribute);
	else if (to_lower(visibility) == "protected")
	    generated.protected = generated.protected + 
		generate_attribute(c, uml_attribute);
	else  // default private
	    generated.private = generated.private + 
		generate_attribute(c, uml_attribute);
    }

    return generated;
}

all_visibilities
generate_operations(ClassCodeDescriptor c)
{
    list              UmlOperations = c.uml_class.UmlOperations;
    all_visibilities  generated;
    int               i, n;
    UmlOperation      uml_operation;
    string            visibility, cxx_visibility;
    boolean           must_be_abstract;

    generated.public = "";
    generated.protected = "";
    generated.private = "";

    // For classes with stereotypes 'type' or 'interface', make
    // all operations abstract.
    must_be_abstract = class_is_uml_type(c.uml_class);

    for (i = 0, n = list_count(UmlOperations); i < n; i = i + 1)
    {
	uml_operation = list_get(UmlOperations, i);

	visibility = UmlOperation__GetItemValue(uml_operation, 
						"UmlMemberVisibility");
	cxx_visibility = UmlOperation__GetItemValue(uml_operation, 
						"UmlMemberCxxVisibility");
	if (cxx_visibility != "")
	    visibility = cxx_visibility;

	if (to_lower(visibility) == "protected")
	    generated.protected = generated.protected + 
		generate_operation(c, uml_operation, must_be_abstract);
	else if (to_lower(visibility) == "private")
	    generated.private = generated.private + 
		generate_operation(c, uml_operation, must_be_abstract);
        else // default public
	    generated.public = generated.public + 
		generate_operation(c, uml_operation, must_be_abstract);
    }

    return generated;
}

all_visibilities
generate_associations(ClassCodeDescriptor c)
{
    list              UmlAssociations = c.uml_class.UmlAssociations;
    all_visibilities  generated;
    int               i, j, m, n;
    UmlAssociation    uml_association;
    UmlRole           source, target;
    string            visibility;

    generated.public = "";
    generated.protected = "";
    generated.private = "";

    for (i = 0, n = list_count(UmlAssociations); i < n; i = i + 1)
    {
	uml_association = list_get(UmlAssociations, i);

	source = uml_association.UmlSourceRole;

	if (list_count(uml_association.UmlTargetRoles) == 0)
	    target = source;
	else
	    target = list_get(uml_association.UmlTargetRoles, 0);

	visibility = UmlRole__GetItemValue(target, "UmlRoleCxxVisibility");

	if (to_lower(visibility) == "public")
	    generated.public = generated.public + 
		generate_association(c, uml_association, source, target, 
				     uml_association.class);
	else if (to_lower(visibility) == "private")
	    generated.private = generated.private + 
		generate_association(c, uml_association, source, target, 
				     uml_association.class);
	else // default protected
	    generated.protected = generated.protected + 
		generate_association(c, uml_association, source, target, 
				     uml_association.class);

	// look for reflexive associations
	for (j=0, m=list_count(uml_association.UmlTargetRoles); j<m; j=j+1)
	{
	    target = list_get(uml_association.UmlTargetRoles, j);

	    if (source.role.from_node_id == target.role.from_node_id) 
	    {
		visibility = UmlRole__GetItemValue(source, 
						   "UmlRoleCxxVisibility");

		if (to_lower(visibility) == "public")
		    generated.public = generated.public + 
			generate_association(c, uml_association, target, source,
					     uml_association.class);
		else if (to_lower(visibility) == "private")
		    generated.private = generated.private + 
			generate_association(c, uml_association, target, source,
					     uml_association.class);
		else // default protected
		    generated.protected = generated.protected + 
			generate_association(c, uml_association, target, source,
					     uml_association.class);
	    }
	}
    }

    generated.protected = generated.protected + 
	generate_associations_from_association_class(c) +
	generate_associations_from_pseudo_class(c);

    return generated;
}

string
generate_attribute(ClassCodeDescriptor c, UmlAttribute uml_attribute)
{
    // generate a single attribute definition
    string          attribute_name, attribute_type, attribute_comment,
                    attribute_stat, attribute_const, attribute_volatile;

    // name and type
    attribute_name = make_attribute_name(uml_attribute);
    attribute_type = make_attribute_type(uml_attribute);

    // static and const and volatile
    if (UmlAttribute__GetItemValue(uml_attribute, "UmlMemberIsClass") == "True")
	attribute_stat = "static ";
    else
	attribute_stat = "";

    attribute_const    = attribute_const_string(uml_attribute);
    attribute_volatile = attribute_volatile_string(uml_attribute);

    // comments
    if (comment_attributes == True)
	attribute_comment = generic_generate_object_comment(uml_attribute.attribute, "Attribute", "", "//", "", "");
    else
	attribute_comment = "";

    return
	attribute_comment +
	indent(1) +
	attribute_stat +
	attribute_const +
	attribute_volatile +
	attribute_type +
	" " +
	attribute_name +
	
	";\n";
}

string
generate_operation(ClassCodeDescriptor c, 
		   UmlOperation uml_operation,
		   boolean must_be_abstract)
{
    // generate a single operation definition
    int     i, n;
    boolean  abstract = False, inline = False;
    string   operation_id, operation_type, operation_sig, operation_comment,
	operation_abstract, operation_virtual, operation_inline, operation_const,
	operation_static, operation_body, operation_end, 
	constructor_initialization_list,
	operation_throws, file_extension;
    
    // generate the dependencies originating from this operation 
    generate_dependencies(uml_operation.operation, c.var.dependencies);

    // code gen id
    operation_id = UmlOperation__GetItemValue(uml_operation, "UmlCxxCodeGenId");
    if (operation_id == "")
	operation_id = "0";

    // operation type
    operation_type = UmlOperation__GetItemValue(uml_operation, 
						"UmlOperationReturnType");
    if (operation_type == "" && 
	is_operation_type_assumed_void(c.oms_class, uml_operation.operation))
	operation_type = "void";
    if (operation_type != "")
	operation_type = operation_type + " ";

    // argument list
    operation_sig = uml_operation.operation.sig;
    if (operation_sig == "")
	operation_sig = "void";
    else
	operation_sig = uml_args_to_format(operation_sig , Cxx);

    // virtual, const, abstract, inline, static
    if (UmlOperation__GetItemValue(uml_operation, 
				   "UmlOperationCxxIsVirtual") == "True")
	operation_virtual = "virtual ";
    else
	operation_virtual = "";

    if (UmlOperation__GetItemValue(uml_operation, 
				   "UmlMemberCxxIsConst") == "True")
	operation_const = " const";
    else
	operation_const = "";

    if (must_be_abstract ||
	UmlOperation__GetItemValue(uml_operation, 
				   "UmlOperationIsAbstract") == "True")
    {
	abstract = True;
	operation_abstract = " = 0";
	operation_virtual = "virtual ";
    } else
	operation_abstract = "";

    if (UmlOperation__GetItemValue(uml_operation, 
				   "UmlOperationCxxIsInline") == "True")
    {
	inline = True;
	operation_inline = "inline ";
     }else
	operation_inline = "";

    if (UmlOperation__GetItemValue(uml_operation, "UmlMemberIsClass") == "True")
	operation_static = "static ";
    else
	operation_static = "";

    // comments
    if (comment_operations == True)
	operation_comment = 
	    generic_generate_object_comment(uml_operation.operation, 
					    "Operation", "", "//", "", "");
    else
	operation_comment = "";

    // ctor init list
    if (is_operation_constructor(c.oms_class, uml_operation.operation)) 
    {
	string CtorInitListItemValue = 
	    UmlOperation__GetItemValue(uml_operation,
				       "UmlOperationCxxCtorInitList");
	
        if (CtorInitListItemValue != "")
            constructor_initialization_list = CtorInitListItemValue;
        else
            constructor_initialization_list = 
		c.var.constructor_initialization_list;
    }
    else
        constructor_initialization_list = "";

    if (constructor_initialization_list != "")
	constructor_initialization_list = " : " + 
	    constructor_initialization_list;

    // throws exceptions
    operation_throws = UmlOperation__GetItemValue(uml_operation, 
						  "UmlOperationThrows");
    if (operation_throws != "")
	operation_throws = " throw(" + operation_throws + ")";

    operation_end = ";\n";

    if (!abstract)
    {
	if (uml_operation.UmlOperationCode == NULL) 
	{
//	    if (operation_type != "" && operation_type != "void ") {
		// This is dummy code to allow operations with no
		// source code which have a return type to compile.
//		operation_body = indent(1) + operation_type + 
//		    "return_value;\n\n" + indent(1) + 
//		    "return return_value;";
//	    } else
	    operation_body = "";
	}
	else
	    operation_body = uml_operation.UmlOperationCode.desc;

	// inline code
	if (inline && inlines_in_class)
	{
	    operation_end = constructor_initialization_list + operation_throws +
		"\n    {\n" + operation_body + "\n    }\n";
	} else
	{
	    if (inline)
		file_extension = c.file.operation_extension;
	    else
		file_extension = c.file.implementation_extension;

	    ClassCodeOperations__Append(c.ops, to_int(operation_id), generate_operation_header(c, uml_operation.operation, operation_type, operation_inline, operation_sig, operation_const, constructor_initialization_list, operation_throws), operation_body, "", "", file_extension);
	}
    }
// Bug 324 (Carlos Lin) switched order of operation_throws
// and operation_const in the following line
    return
	operation_comment +
	indent(1) +
	operation_inline +
	operation_static +
	operation_virtual +
	operation_type +
	make_operation_identifier(operation_name(c.oms_class, 
						 uml_operation.operation)) + 
	"(" + operation_sig + ")" +
	operation_const +
	operation_throws +
	operation_abstract +
	operation_end;
}

string
generate_operation_header(ClassCodeDescriptor c, node operation, string operation_type, string operation_inline, string operation_sig, string operation_const, string constructor_initialization_list, string operation_throws)
{
    //
    // function-definition:  [decl-specs] decl [ctor-init] fct-body
    //
    string          template_prefix = "";

    if (c.var.template_prefix != "")
	template_prefix = c.var.template_prefix + "\n";

    if (operation_inline != "")
	operation_inline = operation_inline + "\n";

    if (operation_type != "")
	operation_type = operation_type + "\n";

// Bug 324 (Carlos Lin) Switched order of operation_throws and operation_const
    return
	template_prefix +
	operation_inline +
	operation_type +
	c.def.language_qualified_name + c.var.template_parameters + "::" + make_operation_identifier(operation_name(c.oms_class, operation)) + "(" + strip_argument_list_default_values(operation_sig) + ")" +
	operation_const +
	operation_throws +
	constructor_initialization_list +
	"\n";
}

string
generate_friend_class_declaration(node class_node)
{
    ClassCodeDescriptor c;
    string template_actual_params;

    c = ClassCodeDescriptor (class_node);
    c.uml_class = UmlClass(class_node);

    set_template_prefix_and_parameters(c);

    if (c.uml_class.elaborated_type != NULL &&
	c.uml_class.elaborated_type.type == "UmlInstantiatedClass" &&
	c.uml_class.class.sig != "")
	// an anonymous instantiation -- insert actual params
	template_actual_params = "< " + c.uml_class.class.sig + " >";
    else
	// named instantiations and regular classes look the same
	template_actual_params = "";
	
    return indent(1) +
	c.var.template_prefix + 
	"friend class " +
	c.def.language_qualified_name +
	template_actual_params +
	";\n";
}

string
generate_friend_operation_declaration(node class_node, UmlOperation uml_operation)
{
    // This function duplicates some code in 'generate_operation',
    // and 'generate_operation_header',
    // but to remove all duplcation would require extensive rewriting
    // of those functions.  That will be deferred until later.

    string  operation_type, operation_sig, operation_throws, 
	operation_const;
    ClassCodeDescriptor c;

    c = ClassCodeDescriptor (class_node);
    c.uml_class = UmlClass(class_node);

    set_template_prefix_and_parameters(c);
    
    // operation return type
    operation_type = UmlOperation__GetItemValue(uml_operation, 
						"UmlOperationReturnType");
    if (operation_type == "" && 
	is_operation_type_assumed_void(class_node, uml_operation.operation))
	operation_type = "void";
    if (operation_type != "")
	operation_type = operation_type + " ";

    // argument list
    operation_sig = uml_operation.operation.sig;
    if (operation_sig == "")
	operation_sig = "void";
    else
	operation_sig = uml_args_to_format(operation_sig , Cxx);

    // throws exceptions
    operation_throws = UmlOperation__GetItemValue(uml_operation, 
						  "UmlOperationThrows");
    if (operation_throws != "")
	operation_throws = " throw(" + operation_throws + ")";

    if (UmlOperation__GetItemValue(uml_operation, 
				   "UmlMemberCxxIsConst") == "True")
	operation_const = " const";
    else
	operation_const = "";

    // Bug 324. Switched order of operation_throws & operation_const
    return indent(1) +
	c.var.template_prefix + 
	"friend " +
	operation_type +
	c.def.language_qualified_name + c.var.template_parameters + "::" + make_operation_identifier(operation_name(c.oms_class, uml_operation.operation)) + "(" + strip_argument_list_default_values(operation_sig) + ")" +
	operation_const +
	operation_throws +
	";\n";
}

//
// constructs that are implemented as classes, e.g. ternary associations
//
set pseudo_classes = set_create("node");

string
generate_association(ClassCodeDescriptor c, UmlAssociation uml_association, 
		     UmlRole source, UmlRole target, 
		     node link_attribute_or_target_class)
{
    boolean is_binary, is_navigable_forward, 
	is_aggregation = False, is_composition = False;
    string  association_identifier, role_visibility, role_pattern_family;
    uml_pattern_descriptor pattern;
    node target_elaborated_type;


    role_pattern_family = UmlRole__GetItemValue(target, 
						"UmlRoleCxxPatternFamily");
    if (role_pattern_family == "")
	role_pattern_family = implement_associations_using_pattern_family;

    pattern = get_family_uml_pattern_descriptor(role_pattern_family);

    is_binary = (list_count(uml_association.UmlTargetRoles) < 2);

    if (is_binary)
    {
	is_aggregation = 
	    (UmlRole__GetItemValue(source, "UmlAggregationType") == "Aggregation") ||
	    (UmlRole__GetItemValue(target, "UmlAggregationType") == "Aggregation");

	is_composition = 
	    (UmlRole__GetItemValue(source, "UmlAggregationType") == "Composition") ||
	    (UmlRole__GetItemValue(target, "UmlAggregationType") == "Composition");

	is_navigable_forward = 
	    (UmlRole__GetItemValue(target, "UmlRoleNavigability") == "True");

	// Remedy 2632. (C.L.) Return empty string if link is cannot be 
	// navigable forward and it is not a composition or aggregation.
	if (!(is_navigable_forward || is_composition || is_aggregation))
	  return "";
	
	// Also return empty string if it is composition or aggragation 
	// target.
	if (is_composition && !(UmlRole__GetItemValue(source, "UmlAggregationType")=="Composition"))
	  return "";

	if (is_aggregation && !(UmlRole__GetItemValue(source, "UmlAggregationType")=="Aggregation"))
	  return "";
	// End Remedy 2632.

	if (link_attribute_or_target_class == NULL)
	    link_attribute_or_target_class = find_by_query("node[id=${target.role.from_node_id} & node_refs]");

	// Do not implement association to a parameterized class.
	target_elaborated_type = 
	    class_elaborated_type(link_attribute_or_target_class);
	if (target_elaborated_type != NULL && 
	    target_elaborated_type.type == "UmlParameterizedClass")
	    return "";

	association_identifier = language_make_identifier(target.role.name);

	//
	//  Don't use the name of the association because it only makes
	//  sense in one direction.
	//

	if (association_identifier == "")
	    association_identifier = "ref_" + language_make_identifier(class_qualified_name(link_attribute_or_target_class));

	ClassCodeVariant__AppendAssociations(c.var, c, link_attribute_or_target_class);

    } else
    {
	if (link_attribute_or_target_class == NULL)
	{
	    link_attribute_or_target_class = uml_association.association;

	    set_add(pseudo_classes, link_attribute_or_target_class);

	    association_identifier = language_make_identifier(link_attribute_or_target_class.name);

	    ClassCodeVariant__AppendAssociations(c.var, c, link_attribute_or_target_class);

	} else
	{
	    association_identifier = "ptr" + language_make_identifier(class_qualified_name(link_attribute_or_target_class));

	    ClassCodeVariant__AppendAssociations(c.var, c, link_attribute_or_target_class);
	} 
    }

    return 
	indent(1) + 
	generate_association_cxx_data_member
	(association_identifier, c.oms_class, link_attribute_or_target_class, 
	 source, target, is_binary, is_aggregation, is_composition, pattern) + 
	";\n";
}

string
generate_associations_from_association_class(ClassCodeDescriptor c)
{
    string generated = "";
    link   association_class_link, first_link, second_link;
    set    link_set;
    int    i, num_links;

    //
    // If the class is an association class, we need to implement
    // associations for it since navigation along the association goes through
    // this class.  This needs to be implemented as a simple 1-1 association.
    //

    // for each association to which the association class is attached
    for_each_in_select("link[UmlAssociationClassLink & to_node_id=${c.oms_class.id} & link_refs]", association_class_link)
    {
	// get links from each class involved in the association
	link_set = set_select("link[((UmlRole & to_node_id=${association_class_link.from_node_id})) & link_refs]");
	
	// num_links == 1 for reflexive with no roles defined,
	//              2 for reflexive with roles,
	//              2 for binary, 
	//              3 for ternary, ...
	num_links = set_count (link_set);
	
	if (num_links == 1)
        {
            ide_warning ("  Warning: Roles are not defined for reflexive association.");
        }
        else if (num_links == 2)
        {
            first_link = set_get_element (link_set, 0);
            second_link = set_get_element (link_set, 1);

            generated = generated + 
	        generate_ref_for_binary_association_class 
		(c, first_link, second_link);

            generated = generated + 
	        generate_ref_for_binary_association_class 
		(c, second_link, first_link);
        }
        else if (num_links > 2)
        {
	    // generate association references to all involved classes
	    for (i=0; i < num_links; i=i+1)
	    {
		first_link = set_get_element (link_set, i);
		
		generated = generated + 
		    generate_ref_for_nary_association_class (c, first_link);
	    }
        }
    }
    return generated;
}

string
generate_ref_for_binary_association_class(ClassCodeDescriptor c,
					  link source_link, 
					  link target_link)
{
    string generated = "", cxx_data_member, association_identifier, 
	target_pattern_family;
    UmlRole source_role, target_role;
    node   target_class, target_elaborated;
    uml_pattern_descriptor pattern;
    boolean is_navigable_forward;

    source_role = UmlRole (source_link);
    target_role = UmlRole (target_link);

    is_navigable_forward = 
	(UmlRole__GetItemValue(target_role, "UmlRoleNavigability") == "True");

    if (is_navigable_forward)
    {
	target_class = find_by_query("node[id=${target_link.from_node_id} & node_refs]");

	target_pattern_family = 
	    UmlRole__GetItemValue(target_role, "UmlRoleCxxPatternFamily");
	if (target_pattern_family == "")
	    target_pattern_family = implement_associations_using_pattern_family;
    
	pattern = get_family_uml_pattern_descriptor(target_pattern_family);
	association_identifier = language_make_identifier(target_link.name);
	if (association_identifier == "")
	    association_identifier = "ref_" + 
		language_make_identifier(class_qualified_name(target_class));
	
	cxx_data_member = pattern.associations.unqualified_single_pattern;
	cxx_data_member = string_search_and_replace(cxx_data_member, "${target_class.name}", language_make_qualified_name(target_class));
	
	cxx_data_member = string_search_and_replace(cxx_data_member, "${identifier_name}", association_identifier);
	
	ClassCodeVariant__AppendAssociations(c.var, c, target_class);
	
	generated = generated + indent(1) + cxx_data_member + ";\n";
    }
    
    return generated;
}

string
generate_ref_for_nary_association_class(ClassCodeDescriptor c,
					link target_link)
{
    string generated = "", cxx_data_member, association_identifier, 
	target_pattern_family;
    UmlRole target_role;
    node   target_class;
    uml_pattern_descriptor pattern;

    target_role = UmlRole (target_link);

    target_class = find_by_query("node[id=${target_link.from_node_id} & node_refs]");
    
    target_pattern_family = 
	UmlRole__GetItemValue(target_role, "UmlRoleCxxPatternFamily");
    if (target_pattern_family == "")
	target_pattern_family = implement_associations_using_pattern_family;
    
    pattern = get_family_uml_pattern_descriptor(target_pattern_family);
    association_identifier = language_make_identifier(target_link.name);
    if (association_identifier == "")
	association_identifier = "ref_" + 
	    language_make_identifier(class_qualified_name(target_class));
    
    cxx_data_member = pattern.associations.unqualified_single_pattern;
    cxx_data_member = string_search_and_replace(cxx_data_member, "${target_class.name}", language_make_qualified_name(target_class));
    
    cxx_data_member = string_search_and_replace(cxx_data_member, "${identifier_name}", association_identifier);
    
    ClassCodeVariant__AppendAssociations(c.var, c, target_class);
    
    generated = generated + indent(1) + cxx_data_member + ";\n";

    return generated;
}

string
generate_associations_from_pseudo_class(ClassCodeDescriptor c)
{
    string          generated = "";
    uml_pattern_descriptor pattern;
    string          cxx_data_member, association_identifier;
    link            association, association_class;
    node            class;

    // types of pseudo-classes: ternary association w/o association class
   
    //
    // if the class is ternary association w/o class, we need to implement
    // associations for it since navigations along the association goes through 
    // it.  This needs to be implemented as a simple 1-1 association.
    //

    pattern = get_family_uml_pattern_descriptor(implement_associations_using_pattern_family);

    if (c.oms_class.type == "UmlAssociation")
    {
	for_each_in_select("link[UmlRole & to_node_id=${c.oms_class.id} & link_refs]", association)
	{
	    class = find_by_query("node[id=${association.from_node_id} & node_refs]");

	    association_identifier = language_make_identifier(association.name);
	    if (association_identifier == "")
		association_identifier = "ref_" + 
		    language_make_identifier(class_qualified_name(class));

	    cxx_data_member = pattern.associations.unqualified_single_pattern;
	    cxx_data_member = string_search_and_replace
		(cxx_data_member, 
		 "${target_class.name}", language_make_qualified_name(class));
	    cxx_data_member = string_search_and_replace(cxx_data_member, "${identifier_name}", association_identifier);
    
	    ClassCodeVariant__AppendAssociations(c.var, c, class);

	    generated = generated + indent(1) + cxx_data_member + ";\n";
	}
    }

    return generated;
}

string
generate_association_cxx_data_member(string name, node class, node target_class,
				     UmlRole from_role, UmlRole to_role,
				     boolean is_binary, boolean is_aggregation,
				     boolean is_composition,
				     uml_pattern_descriptor patterns)
{
    boolean is_multiple, is_ordered, is_qualified = False, 
	is_inverse_qualified = False;
    string cxx_data_member, qualifier, qualifier_name = "", 
	inverse_qualifier_name = "", qualifier_type = "", 
	inverse_qualifier_type = "", multiplicity,
	target_class_name_replacement;
    node target_elaborated;


    multiplicity = UmlRole__GetItemValue(to_role, "UmlMultiplicity");

    is_multiple = (multiplicity != "" && 
		   multiplicity != "0" && 
		   multiplicity != "1" && 
		   multiplicity != "0-1" && 
		   multiplicity != "0,1" && 
		   multiplicity != "0..1" && 
		   multiplicity != "ExactlyOne" && 
		   multiplicity != "exactlyone" && 
		   multiplicity != "exactly_one" && 
		   multiplicity != "One" && 
		   multiplicity != "one" && 
		   multiplicity != "Single" && 
		   multiplicity != "single" && 
		   multiplicity != "Optional" &&
		   multiplicity != "optional");

    is_ordered = (UmlRole__GetItemValue(to_role, "UmlRoleIsOrdered") == "True");

    if ((qualifier = UmlRole__GetItemValue(from_role, "UmlRoleQualifier")) != "")
    {
	is_qualified = True;
	qualifier_name = uml_name_type_syntax_2_type_space_name_syntax(qualifier, "N");
	qualifier_type = uml_name_type_syntax_2_type_space_name_syntax(qualifier, "T");
	if (qualifier_type == "")
	    qualifier_type = attribute_type(get_attribute_by_name(class, qualifier_name));
	qualifier_type = parse_array_syntax_from_type(qualifier_type);
	
	if (qualifier_type == "")
	    ide_warning("  Warning: Qualifier '" + class_qualified_name(class) + SD + qualifier_name + "' missing type.");
    }

    if ((qualifier = UmlRole__GetItemValue(to_role, "UmlRoleQualifier")) != "")
    {
	is_inverse_qualified = True;
	inverse_qualifier_name = uml_name_type_syntax_2_type_space_name_syntax(qualifier, "N");
	inverse_qualifier_type = uml_name_type_syntax_2_type_space_name_syntax(qualifier, "T");
	if (inverse_qualifier_type == "")
	    inverse_qualifier_type = attribute_type(get_attribute_by_name(target_class, inverse_qualifier_name));
	inverse_qualifier_type = parse_array_syntax_from_type(inverse_qualifier_type);

	if (inverse_qualifier_type == "")
	    ide_warning("  Warning: Qualifier '" + class_qualified_name(target_class) + SD + inverse_qualifier_name + "' missing type.");
    }

    if (!is_binary)
    {
	cxx_data_member = patterns.nary_pattern;
    } else if (is_composition)
    {
	if (is_qualified == False && is_inverse_qualified == False)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.compositions.unqualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.compositions.unqualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.compositions.unqualified_ordered_pattern;
	} else if (is_qualified == True && is_inverse_qualified == False)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.compositions.qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.compositions.qualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.compositions.qualified_ordered_pattern;
	} else if (is_qualified == False && is_inverse_qualified == True)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.compositions.inverse_qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.compositions.inverse_qualified_unordered_pattern;
	    else
		cxx_data_member =
		    patterns.compositions.inverse_qualified_ordered_pattern;
	} else if (is_qualified == True && is_inverse_qualified == True)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.compositions.double_qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.compositions.double_qualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.compositions.double_qualified_ordered_pattern;
	}
    } else if (is_aggregation)
    {
	if (is_qualified == False && is_inverse_qualified == False)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.aggregations.unqualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.aggregations.unqualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.aggregations.unqualified_ordered_pattern;
	} else if (is_qualified == True && is_inverse_qualified == False)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.aggregations.qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.aggregations.qualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.aggregations.qualified_ordered_pattern;
	} else if (is_qualified == False && is_inverse_qualified == True)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.aggregations.inverse_qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.aggregations.inverse_qualified_unordered_pattern;
	    else
		cxx_data_member =
		    patterns.aggregations.inverse_qualified_ordered_pattern;
	} else if (is_qualified == True && is_inverse_qualified == True)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.aggregations.double_qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.aggregations.double_qualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.aggregations.double_qualified_ordered_pattern;
	}
    } else // regular binary association
    {
	if (is_qualified == False && is_inverse_qualified == False)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.associations.unqualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.associations.unqualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.associations.unqualified_ordered_pattern;
	} else if (is_qualified == True && is_inverse_qualified == False)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.associations.qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.associations.qualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.associations.qualified_ordered_pattern;
	} else if (is_qualified == False && is_inverse_qualified == True)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.associations.inverse_qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.associations.inverse_qualified_unordered_pattern;
	    else
		cxx_data_member =
		    patterns.associations.inverse_qualified_ordered_pattern;
	} else if (is_qualified == True && is_inverse_qualified == True)
	{
	    if (is_multiple == False)
		cxx_data_member = 
		    patterns.associations.double_qualified_single_pattern;
	    else if (is_ordered == False)
		cxx_data_member = 
		    patterns.associations.double_qualified_unordered_pattern;
	    else
		cxx_data_member = 
		    patterns.associations.double_qualified_ordered_pattern;
	}
    }
    
    target_class_name_replacement = language_make_qualified_name(target_class);

    // handle associations to anonymous instantiated type
    target_elaborated = class_elaborated_type(target_class);
	
    if (target_elaborated != NULL &&
	target_elaborated.type == "UmlInstantiatedClass" &&
	target_elaborated.sig != "")
	target_class_name_replacement = target_class_name_replacement +
	    "< " + target_elaborated.sig + " >";

    cxx_data_member = string_search_and_replace(cxx_data_member,
					 "${target_class.name}",
					 target_class_name_replacement);
    cxx_data_member = string_search_and_replace(cxx_data_member,
					 "${qualifier.type}",
					 qualifier_type);
    cxx_data_member = string_search_and_replace(cxx_data_member,
					 "${inverse_qualifier.type}",
					 inverse_qualifier_type);

    if (multiplicity != "")
	multiplicity = "[" + multiplicity + "]";
    cxx_data_member = string_search_and_replace(cxx_data_member,
					 "${explicit_multiplicity}",
					 multiplicity);

    cxx_data_member = string_search_and_replace(cxx_data_member,
					 "${identifier_name}",
					 name);

    return cxx_data_member;
}

string
generate_friends(ClassCodeDescriptor c)
{
    int             i;
    set             friend_classes, friend_operations;
    node            class_node, operation_node;
    string          class_name;
    UmlOperation    uml_operation;
    string          generated = "";

    friend_classes = set_select("node[UmlClass & out_links[UmlDependency & to_node_id=${c.oms_class.id} & items[UmlStereotype & value='friend'] & link_refs] & node_refs]");

    set_delete(friend_classes, c.oms_class);

    for (i = 0; i < set_count(friend_classes); i = i + 1) {
	class_node = set_get_element(friend_classes, i);
	class_name = language_make_qualified_name(class_node);
	generated = generated + 
	    generate_friend_class_declaration(class_node);
	ClassCodeVariant__AppendAssociations(c.var, c, class_node);
    }

    friend_operations = set_select("node[UmlOperation & out_links[UmlDependency & to_node_id=${c.oms_class.id} & items[UmlStereotype & value='friend'] & link_refs] & node_refs]");

    for (i = 0; i < set_count(friend_operations); i = i + 1) {
	operation_node = set_get_element(friend_operations, i);
	uml_operation = UmlOperation(operation_node);
	class_node = find_by_query("node[id=${operation_node.scope_node_id}]");
	generated = generated +
	    generate_friend_operation_declaration(class_node, 
						  uml_operation);
	ClassCodeVariant__AppendAssociations(c.var, c, class_node);
    }

    return generated;
}

void
generate_dependencies(node client_node, set dependency_set)
{
    set    servers;
    node   server;
    string server_name;
    int    i, n;
    item   stereotype;
    
    servers = set_select("node[UmlClass & in_links[UmlDependency & from_node_id=${client_node.id} & link_refs] & node_refs]");

    for (i = 0, n = set_count(servers); i < n; i = i + 1) {
	server = set_get_element(servers, i);

	// Don't generate dependency if server has stereotype of 
	// <<interface>> or <<type>>.  A dependency on an interface or
	// type actually means that the client requires that interface
	// from a class which implements the interface or type.
	stereotype = find_by_query("item[UmlStereotype & obj_id=${server.id}]");
	  //  C.L. (4/21/1999) Changed break to continue so that other 
	  //  dependencies are still processed.
	if (stereotype != NULL &&
	    (stereotype.value == "type" || stereotype.value == "interface"))
	      continue;
	
	server_name = make_dependency_name(server);
	set_add (dependency_set, server_name);
	make_transitive_dependencies(server, dependency_set);
    }
}

//////////////////////////////////////////////////////////////////////////////
string
language_replace_scope_delimiter(string the_string)
{
    return string_search_and_replace(the_string, SD, SD_REPLACEMENT);
}

string
language_file_name (string class_file_name)
{
    if (file_per_class && !use_packages_in_filenames) {
	class_file_name = uml_base_name(class_file_name);
    }

    return language_replace_scope_delimiter(class_file_name);
}

string
language_code_gen_id (UmlClass uml_class)
{
    return UmlClass__GetItemValue(uml_class, "UmlCxxCodeGenId");
}

void
language_check_options()
{
    if (interface_extension == "" || interface_extension == ".")
	interface_extension = ".h";
    if (implementation_extension == "" || implementation_extension == ".")
	implementation_extension = ".C";
    if (operation_extension == "" || operation_extension == ".")
	operation_extension = interface_extension;
    if (inlines_in_class)
        operation_extension = interface_extension;
    if (use_module)
	file_per_class = False;
    return;
}

set
language_compile_preprocessing(set class_set)
{
    //
    // given the input classes, as a set of class nodes, perform pre-processing
    //

    int  i, n;
    node class, type;
    set  classes = set_create("node");

    // filter classes
    for (i = 0, n = set_count(class_set); i < n; i = i + 1)
    {
	class = set_get_element(class_set, i);

	if (class_base_name(class) == "") {
	    ide_warning("  Ignoring unnamed class with id " + class.id + "...");
	    continue;
	}
	
	if (is_class_excluded(class) == True) {
	    ide_warning("  Ignoring excluded class '" + class_qualified_name(class) + 
			"'...");
	    continue;
	}

	type = class_elaborated_type(class);
	if (type != NULL && type.type == "UmlInstantiatedClass") {
	    // don't add Instantiated Class to set, but no need to warn.
	    // named Instantiated Class appears as typedef
	    // anonymous Instantiated Class appears in other classes
	    continue;
	}

	set_add(classes, class);
    }

    return classes;
}

list
language_compile_postprocessing(list classes)
{
    //
    // given the compiled classes, as a list of class descriptors, perform
    // post-processing
    //

    int             i, j, n, m;
    string          class_name, class_template;
    ClassCodeDescriptor c;
    list            sorted_class_names, sorted_classes, class_names;
    node            class;
    graph           G;

    // pseudo_classes
    for (i = 0, n = set_count(pseudo_classes); i < n; i = i + 1)
    {
	class = set_get_element(pseudo_classes, i);
	if (class.type == "UmlAssociation")
	{
	    ide_warning("  Processing association pseudo-class '" + class_qualified_name(class) + "'...");
	    c = ClassCodeDescriptor(class);
	    ClassCodeDescriptor__FillFromRepository(c);
	    if (ClassCodeDescriptor__IsOk(c) == False)
	    {
		global_errors = global_errors + 1;
		continue;
	    }
	    ClassCodeDescriptor__Compile(c);
	    list_append(classes, c);
	}
    }

    // filter out classes 
    for (i = 0; i < list_count(classes); i = i + 1)
    {
	c = list_get(classes, i);

	if (class_is_uml_type(c.uml_class) && 
	    !should_generate_uml_type(c.uml_class)) {
	    list_delete(classes, i);
	    i = i - 1;  // adjust loop counter for deleted item
	}
    }


    // project compiled classes' names
    class_names = list_create("string", 0);
    for (i = 0; i < list_count(classes); i = i + 1)
    {
	c = list_get(classes, i);
	list_append(class_names, class_qualified_name(c.oms_class));
    }

    // create dependency graph

    // subclasses depend on generalizations
    G = UmlClassGraph(NULL, list_select("link[UmlGeneralization && link_refs]"));

    // template classes depend on class templates
    for (i = 0, n = list_count(class_names); i < n; i = i + 1)
    {
	class_name = list_get(class_names, i);
	class_template = get_class_template_from_class_name(class_name);
	if (class_template != "")
	{
	    graph_add_node(G, class_template);
	    graph_add_node(G, class_name);
	    graph_add_arc(G, class_template, class_name);
	}
    }

    // classes with embedded instances dependency?

    // any others?

    // finally, sort them topologically for lexical ordering
    sorted_class_names = graph_topological_sort(G);
    m = list_count(class_names);
    sorted_classes = list_create("ClassCodeDescriptor", 0);
    for (i = 0, n = list_count(sorted_class_names); i < n; i = i + 1)
    {
	class_name = list_get(sorted_class_names, i);
	// only return it if it's in the compiled list
	if ((j = list_find(class_names, 0, class_name)) != m)
	{
	    c = list_get(classes, j);
	    list_append(sorted_classes, c);
	    // maintain the parallelism in the two collections
	    list_delete(classes, j);
	    list_delete(class_names, j);
	    m = m - 1;
	}
    }

    //
    // add the rest of the classes that didn't happen to be in the graph
    //
    for (i = 0, n = list_count(classes); i < n; i = i + 1)
	list_append(sorted_classes, list_get(classes, i));

    return sorted_classes;
}

///////////////////////////////////////////////////////////////////////////////

string
language_generate_declaration_list(list classes, string file)
{
    // generate a set of forward declarations and typedefs
    string          generated = "", scope, template_prefix;
    int             i, n, j, m, k, p, num_scopes;
    ClassCodeDescriptor c;
    typedef_struct  typedef;

    for (i = 0, n = list_count(classes); i < n; i = i + 1) {
	c = list_get(classes, i);
	if (file == c.file.full_path_interface_name + c.file.interface_extension) {
	    for (j=0, m=list_count(c.def.language_scope_list); j<m; j=j+1) {
		scope = list_get(c.def.language_scope_list, j);
		generated = generated + indent(j) + "namespace " + scope + " {\n";
	    }
	    num_scopes = j;

	    if (c.var.template_prefix != "")
		template_prefix = c.var.template_prefix;
	    else
		template_prefix = "";

	    generated = generated + indent(num_scopes) + template_prefix + 
		"class " + c.def.language_base_name + ";\n";

	    for (j = num_scopes; j > 0; j = j - 1)
		generated = generated + indent(j-1) + "}\n";

	    for (j=0, m=list_count(c.var.instantiated_class_typedefs); j<m; j=j+1) {
		typedef = list_get(c.var.instantiated_class_typedefs, j);
		
		for (k=0, p=list_count(typedef.scope_list); k<p; k=k+1) {
		    scope = list_get(typedef.scope_list, k);
		    generated = generated + indent(k) + "namespace " + scope + " {\n";
		}
		num_scopes = k;

		generated = generated + indent(num_scopes) + typedef.definition;

		for (k = num_scopes; k > 0; k = k - 1)
		    generated = generated + indent(k-1) + "}\n";
	    }
	}
    }
    return generated;
}

string
generate_tagged_attribute(ClassCodeDescriptor c)
{
    if (c.var.static_attribute_initializers != NULL &&
	c.var.static_attribute_initializers != "")
	return
	    START_IMPLEMENTATION_DECLS_TAG + c.id + "\n" +
	    c.var.static_attribute_initializers +
	    END_IMPLEMENTATION_DECLS_TAG + "\n";
    else
	return "";
}

string
generate_tagged_operation(ClassCodeDescriptor c, int i)
{
    return
	generate_tagged_operation_header(c, i) +
	"{\n\n" +
	generate_tagged_operation_body(c, i) +
	"\n\n}\n" +
	generate_tagged_operation_footer(c, i) +
	"\n";
}

string
generate_tagged_operation_header(ClassCodeDescriptor c, int i)
{
    return
	START_OPERATION_TAG + c.id + "::" + list_get(c.ops.ids, i) + "\n" +
	list_get(c.ops.headers, i);
}

string
generate_tagged_operation_body(ClassCodeDescriptor c, int i)
{
    return
	indent(1) + START_OP_IMPLEMENTATION_TAG + "\n" +
	list_get(c.ops.bodies, i) +
	"\n" + indent(1) + END_OP_IMPLEMENTATION_TAG;
}

string
generate_tagged_operation_footer(ClassCodeDescriptor c, int i)
{
    return
	END_OPERATION_TAG +
	"\n";
}

string
generate_tagged_class(ClassCodeDescriptor c)
{
    return
	generate_tagged_class_header(c) +
	generate_tagged_class_body(c) +
	"};\n" +
	generate_tagged_class_footer(c) + 
	"\n";
}

string
generate_tagged_class_header(ClassCodeDescriptor c)
{
    return
	START_CLASS_DEFINITION_TAG + c.id + "\n" +
	c.def.definition_header + "{\n";
}

string
generate_tagged_class_body(ClassCodeDescriptor c)
{
    return
	START_CLASS_BODY_TAG + "\n" +
	c.def.definition +
	END_CLASS_BODY_TAG + "\n";
}

string
generate_tagged_class_second_body(ClassCodeDescriptor c)
{
    return "";
}

string
generate_tagged_class_footer(ClassCodeDescriptor c)
{
    return
	END_CLASS_DEFINITION_TAG +
	"\n";
}

string
generate_tagged_class_derivatives (ClassCodeDescriptor c)
{
    return "";
}

string
generate_tagged_class_implementation (ClassCodeDescriptor c)
{
    return "";
}
 
string
generate_tagged_class_implementation_header (ClassCodeDescriptor c)
{
    return "";
}
 
string
generate_tagged_class_implementation_footer (ClassCodeDescriptor c)
{
    return "";
 
}
 
string
generate_tagged_interface_file_footer(string file)
{
    return
	START_FOOTER_TAG + "\n" +
	language_generate_interface_file_footer(file) +
	END_FOOTER_TAG + "\n";
}

string
generate_tagged_includes(ClassCodeDescriptor c)
{
    // generate all the includes for the specified class
    string          generated = "";
    int             i, n;
    set             includes;
    string          include;

    includes = list_to_set(c.var.generalizations);
    set_union(includes, list_to_set(c.var.associations));
    set_union(includes, c.var.dependencies);

    for (i = 0, n = set_count(includes); i < n; i = i + 1)
    {
	include = set_get_element(includes, i);

	generated = generated + language_generate_include(generic_generate_file_name(language_file_name(include)) + c.file.interface_extension);
    }

    if (generated != "")
	generated =
	    START_INCLUDES_TAG + c.id + "\n" +
	    generated +
	    END_INCLUDES_TAG + "\n";

    return generated;
}

string
language_generate_include(string filename)
{
    return "#include \"" + filename + "\"\n";
}

string
tag_declarations(string declarations)
{

    return
	START_CLASS_DECLARATION_TAG + "\n" +
	declarations +
	END_CLASS_DECLARATION_TAG + "\n";
}

string
generate_tagged_declarations(list classes, string file)
{
    // generate all the declarations for the specified file

    return tag_declarations(language_generate_declaration_list(classes, file));
}

string
generate_tagged_definitions(list classes, string file)
{
    string          generated = "";
    int             i, n;
    ClassCodeDescriptor       c;

    // generate all the definitions for the specified file
    for (i = 0, n = list_count(classes); i < n; i = i + 1)
    {
	c = list_get(classes, i);
	if (file == c.file.full_path_interface_name + c.file.interface_extension)
	{
	    generated = generated + generate_tagged_class(c);
	    c.written = True;
	    list_set(classes, i, c);
	}
    }
    return generated;
}

string 
language_generate_interface_file_footer(string file)
{
    return "#endif\n";
}

int
language_find_class_definition_start(string line)
{
    //
    // return an index to the start of the class definition, otherwise the
    // length of line (same as string_find())
    //
    int             i;

    i = string_find(line, 0, "{");
    // we need to try to make sure this is really the start of the class definition,
    //	and not part of a comment or anything else
    return i;
}

int
language_find_class_implementation_start(string line)
{
    return 0;
}

int
language_find_operation_header_end(string line)
{
    //
    // return an index to the end of the operation, otherwise the
    // length of line (same as string_find())
    //
    int             i;

    i = string_find(line, 0, ")");
    // we need to try to make sure this is really the end of the operation,
    // and not part of a comment or anything else
    return i;
}

int
language_find_operation_body_begin(string line)
{
    //
    // return an index to the start of the operation body, otherwise the
    // length of line (same as string_find())
    //
    int             i;

    i = string_find(line, 0, "{");
    // we need to try to make sure this is really the start of the operation body,
    //	and not part of a comment or anything else 
    return i;
}

string
language_generate_file_header(ClassCodeDescriptor c)
{
    // this is the string that is written at the top of the interface file
    string s;

    s = "// StP" + NL +
	"// Created on " + time_to_string(time_now(), NULL) + 
	" for " + user() + "@" + hostname() + NL +
	"//   from system " + current_projdir() + current_system() + NL + NL +
	"#ifndef _" + 
	language_make_identifier(c.file.name + c.file.interface_extension) + 
	"_" + NL +
	"#define _" + 
	language_make_identifier(c.file.name + c.file.interface_extension) + 
	"_" + NL + NL;

    return s;
}

void
make_transitive_dependencies(node the_node, set dependency_set)
{
    node elaborated_node;
    link refines_link;
    
    elaborated_node = class_elaborated_type(the_node);
    
    if (elaborated_node != NULL &&
	elaborated_node.type == "UmlInstantiatedClass") {
	refines_link = find_by_query("link[UmlRefines & from_node_id=${the_node.id} & items[UmlStereotype & value='bind']]");
	if (refines_link == NULL) {
	    // This means 'the_node' is an anonymous instantiation,
	    // so (indirectly) recursively find its dependencies.
	    // Note that as of now anonymous instantiations can be 
	    // the source of only dependency relationships.  If they
	    // could be the source of other relationships such as
	    // associations or generalizations, then we would have to 
	    // transitively follow them as well.
	    generate_dependencies(the_node, dependency_set);
	}
    }

    // otherwise just return and end the recursion
    return;
}

string
make_dependency_name(node target_node)
{
    // This function handles cases where an alternative node must be
    // used instead of the target_node.

    string dependency_name;
    node target_type, param_class;
    link refines_link;

    // The simple case.
    dependency_name = language_make_qualified_name(target_node);

    // Named instantiated class, which is a refinement of a 
    // parameterized class.  The named instantiation occurs in
    // the file of the parameterized class, so the name of the 
    // parameterized class must be used for the dependency.
    target_type = class_elaborated_type(target_node);
    if (target_type != NULL && 
	target_type.type == "UmlInstantiatedClass") {
	refines_link = find_by_query("link[UmlRefines & from_node_id=${target_node.id} & items[UmlStereotype & value='bind']]");
	if (refines_link != NULL) {
	    param_class = find_by_query("node[UmlClass & id=${refines_link.to_node_id}]");
	    dependency_name = language_make_qualified_name(param_class);
	}
    }

    return dependency_name;
}


const string    BAD_CXX_IDENTIFERS_TRANSLATE_TABLE = " !@#$%^&*()+-=|\\{}[],./<>?~`;:'\"\n\t";
const string    GOOD_CXX_IDENTIFERS_TRANSLATE_TABLE = string_repeat("_", string_length(BAD_CXX_IDENTIFERS_TRANSLATE_TABLE));

string
language_make_identifier(string s)
{
    //
    // given a string, translate it into a valid identifier for the language
    //
    s = language_replace_scope_delimiter(s);
    
    return string_translate(s, BAD_CXX_IDENTIFERS_TRANSLATE_TABLE, GOOD_CXX_IDENTIFERS_TRANSLATE_TABLE);
}

const string    BAD_CXX_CLASS_IDENTIFERS_TRANSLATE_TABLE = " !@#$%^&*()+-=|\\{},./<>?~`;'\"\n\t";
const string    GOOD_CXX_CLASS_IDENTIFERS_TRANSLATE_TABLE = string_repeat("_", string_length(BAD_CXX_CLASS_IDENTIFERS_TRANSLATE_TABLE));

string
language_make_base_name(node class)
{
    //
    // given a UML class, or some UML construct that is supposed to be
    // implemented as a class, translate its name into a valid class 
    // name for the language (ignore anything enclosed in <>'s, e.g.
    // template arguments, and filter out bad characters)
    //
    // also, get the fully qualified name using enclosing packages,
    // but don't worry about enclosing classes yet
    //
    string s;

    if (class.type == "UmlClass")
	s = class_base_name(class);
    else
	s = language_make_identifier(class.name);

    return translated_class_string(s);
}



list
language_make_scope_list(node class)
{
    string scope_string, one_scope;
    const string LIST_SEPARATOR = "?";
    list scope_list;
    int i, n;

    // get string containing the enclosing scopes
    scope_string = uml_class_qualified_name(class);

    // prepare for conversion to list
    scope_string = string_search_and_replace(scope_string, UML_PATH_SEPARATOR,
					     LIST_SEPARATOR); 

    // convert to list
    scope_list = string_to_list(scope_string, LIST_SEPARATOR);

    // delete the last item of the list, which is the class itself,
    // leaving only the scopes
    list_delete(scope_list, (list_count(scope_list)-1));

    // translate the names of the scopes for C++
    for (i = 0, n = list_count(scope_list); i < n; i = i + 1) {
	one_scope = list_get(scope_list, i);
	list_set(scope_list, i, translated_class_string(one_scope));
    }

    return scope_list;
}

string
language_build_qualified_name(list scope_list, string base_name)
{
    if (list_count(scope_list) == 0)
	return base_name;
    else
	return list_to_string(scope_list, SD) + SD + base_name;
}


string
language_make_qualified_name(node class)
{
    node name_class;

    // 'class_surrogate_node' is used here to handle the case of making
    // a qualified name for an anonymous instantiation.  uclassd does
    // not allow the complete qualified name to be used as a label,
    // but we can still come up with the complete qualified name by
    // finding the corresponding parameterized class.
    name_class = class_surrogate_node(class);

    return language_build_qualified_name(
	language_make_scope_list(name_class), 
	language_make_base_name(name_class));
}

string
translated_class_string(string s)
{
    // Note this ignores everything after the first "<", not just what is 
    // between "<" and ">".  In practice, for classes that is the same thing.

    int             f = string_find(s, 0, "<");
    int             l = string_length(s);
    string          t = "";

    if (f != l)
    {
	t = string_extract(s, f, l - f);
	s = string_extract(s, 0, f);
    }

    return string_translate(s, BAD_CXX_CLASS_IDENTIFERS_TRANSLATE_TABLE, GOOD_CXX_CLASS_IDENTIFERS_TRANSLATE_TABLE) + t;
}

const string    BAD_CXX_ATTR_IDENTIFERS_TRANSLATE_TABLE = "!@#$%^&*()+-=|\\{},./<>?~`;:'\"\n\t";
const string    GOOD_CXX_ATTR_IDENTIFERS_TRANSLATE_TABLE = string_repeat("_", string_length(BAD_CXX_ATTR_IDENTIFERS_TRANSLATE_TABLE));
string
language_make_attribute_identifier(string s)
{
    //
    // given a string, translate it into a valid class identifier for the language
    //
    return string_translate(s, BAD_CXX_ATTR_IDENTIFERS_TRANSLATE_TABLE, GOOD_CXX_ATTR_IDENTIFERS_TRANSLATE_TABLE);
}

const string    BAD_CXX_OPERATION_IDENTIFERS_TRANSLATE_TABLE = "@#$\\{}.?`;:'\"\n\t";
const string    GOOD_CXX_OPERATION_IDENTIFERS_TRANSLATE_TABLE = string_repeat("_", string_length(BAD_CXX_OPERATION_IDENTIFERS_TRANSLATE_TABLE));
string
make_operation_identifier(string s)
{
    return string_translate(s, BAD_CXX_OPERATION_IDENTIFERS_TRANSLATE_TABLE, GOOD_CXX_OPERATION_IDENTIFERS_TRANSLATE_TABLE);
}

string
make_attribute_name(UmlAttribute uml_attribute)
{
    string          attribute_name, attribute_type;

    attribute_type = UmlAttribute__GetItemValue(uml_attribute, "UmlAttributeType");
    attribute_name = language_make_attribute_identifier(uml_attribute.attribute.name);
    return parse_array_syntax_from_name(attribute_name, attribute_type);
}

string
make_attribute_type(UmlAttribute uml_attribute)
{
    string          attribute_type;

    attribute_type = UmlAttribute__GetItemValue(uml_attribute, "UmlAttributeType");
    return parse_array_syntax_from_type(attribute_type);
}

string
attribute_const_string(UmlAttribute uml_attribute)
{
    string  attribute_const;

    if (UmlAttribute__GetItemValue(uml_attribute, 
				   "UmlMemberCxxIsConst") == "True")
	attribute_const = "const ";
    else
	attribute_const = "";

    return attribute_const;
}

string
attribute_volatile_string(UmlAttribute uml_attribute)
{
    string  attribute_volatile;

    if (UmlAttribute__GetItemValue(uml_attribute, 
				   "UmlAttributeCxxIsVolatile") == "True")
	attribute_volatile = "volatile ";
    else
	attribute_volatile = "";

    return attribute_volatile;
}

boolean
is_operation_constructor(node class, node operation)
{

    if (class_base_name(class) == strip_whitespace(operation.name))
	return True;
    return False;
}

boolean
is_operation_type_assumed_void(node class, node operation)
{
    if (is_operation_constructor_destructor(class, operation))
	return False;
    if (is_operation_operator(class, operation))
	return False;
    return True;
}

boolean
is_operation_constructor_destructor(node class, node operation)
{
    string          operation_name;

    if (string_extract(operation.name, 0, 1) == "~")
	operation_name = string_extract(operation.name, 1, string_length(operation.name) - 1);
    else
	operation_name = operation.name;

    if (class_base_name(class) == strip_whitespace(operation_name))
	return True;
    return False;
}

boolean
is_operation_operator(node class, node operation)
{
    if (string_length(operation.name) >= 9 &&
	(string_extract(operation.name, 0, 9) == "operator " ||
	strpbrk(operation.name, "+-*/%^&|~!=<>,()[]") != 0))
	return True;
    return False;
}

string
operation_name(node class, node operation)
{

    if (is_operation_constructor_destructor(class, operation))
	return strip_whitespace(operation.name);
    return operation.name;
}

string
parse_array_syntax_from_name(string attribute_name, string attribute_type)
{
    int             array_open, array_close, i;

    if (attribute_type != "")
    {
	array_open = string_find(attribute_type, 0, "[");
	if (array_open < string_length(attribute_type))
	{
	    array_close = 0;
	    for (i = 0; i < string_length(attribute_type); i = i + 1)
		if (string_extract(attribute_type, i, 1) == "]")
		    array_close = i;
	    if (array_close < string_length(attribute_type))
		attribute_name = attribute_name + string_extract(attribute_type, array_open, (array_close - array_open) + 1);
	}
    }
    return attribute_name;
}

string
parse_array_syntax_from_type(string attribute_type)
{
    int             array_open, array_close;

    if (attribute_type != "")
    {
	array_open = string_find(attribute_type, 0, "[");
	if (array_open < string_length(attribute_type))
	{
	    array_close = string_find(attribute_type, array_open, "]");
	    if (array_close < string_length(attribute_type))
		attribute_type = string_extract(attribute_type, 0, array_open);
	}
    }
    return attribute_type;
}

string
strip_argument_list_default_values(string argument_list)
{
    int             i, j, k, n;
    string character    , string;
    string          stripped_argument_list;

    //
    // strip out default values for definitions (until we get a real c++
    // parser)
    //

    // trivial case
    if (argument_list == "" || string_find(argument_list, 0, "=") == string_length(argument_list))
	return argument_list;

    stripped_argument_list = "";
    for (i = 0, n = string_length(argument_list); i < n; i = i + 1)
    {
	character = string_extract(argument_list, i, 1);

	//
	// i don't think we have to worry about an equal sign appearing
	// before the default value equal sign, e.g., inside a string,
	// otheriwse it's a syntax error anyway
	//
	if (character == "=")
	{
	    //
	    // skip everything until next argument!  how do we find that?
	    // well, simply ship to the next argument separator (comma), but
	    // that's not trivial to find given quoted string and functions
	    //
	    for (j = i + 1; j < n; j = j + 1)
	    {
		character = string_extract(argument_list, j, 1);

		// found arg separator, so copy it and advance
		if (character == ",")
		{
		    stripped_argument_list = stripped_argument_list + character;
		    break;
		}
		//
		// found string as a default value, so skip it as a unit to
		// avoid the appearance of an arg separator and advance
		//
		if (character == "\"")
		{
		    string = get_string(argument_list, j);
		    j = (j + string_length(string)) - 1;
		    break;
		}
		//
		// found function as a default value, so skip it as a unit to
		// avoid the appearance of an arg separator and advance
		//
		if (character == "(")
		{
		    string = get_parenthesized_expression(argument_list, j);
		    j = (j + string_length(string)) - 1;
		    break;
		}
	    }
	    i = j;
	} else
	    stripped_argument_list = stripped_argument_list + character;
    }
    return stripped_argument_list;
}


string
get_string(string stream, int from)
{
    string          character, string;

    // safety
    if (stream == NULL || stream == "" || from >= string_length(stream))
	return "";

    // stream must start with a quote
    character = string_extract(stream, from, 1);
    if (character != "\"")
	return "";

    // find the end quote (don't forget about escaped ones)
    string = character;
    from = from + 1;
    while (from < string_length(stream))
    {
	character = string_extract(stream, from, 1);
	if (character == "\"")
	{
	    string = string + character;
	    from = from + 1;
	    break;
	} else if (character == qrl_parser_bug__back_slash())
	{
	    string = string + character;
	    from = from + 1;
	    if (from < string_length(stream))
	    {
		character = string_extract(stream, from, 1);
		string = string + character;
		from = from + 1;
	    }
	} else
	{
	    string = string + character;
	    from = from + 1;
	}
    }

    //
    // return full string (with end quote, otherwise not if we ran off the end)
    //
    return string;
}

string
qrl_parser_bug__back_slash()
{
    return string_extract("\\ ", 0, 1);
}

string
get_parenthesized_expression(string stream, int from)
{
    string          character, string;

    // safety
    if (stream == NULL || stream == "" || from >= string_length(stream))
	return "";

    // stream must start with a left parenthesis
    character = string_extract(stream, from, 1);
    if (character != "(")
	return "";

    //
    // find the closing parenthesis (don't forget about nested parens and
    // strings)
    //
    string = character;
    from = from + 1;
    while (from < string_length(stream))
    {
	character = string_extract(stream, from, 1);
	if (character == ")")
	{
	    string = string + character;
	    from = from + 1;
	    break;
	} else if (character == "(")
	{
	    character = get_parenthesized_expression(stream, from);
	    string = string + character;
	    from = from + string_length(character);
	} else if (character == "\"")
	{
	    character = get_string(stream, from);
	    string = string + character;
	    from = from + string_length(character);
	} else
	{
	    string = string + character;
	    from = from + 1;
	}
    }

    //
    // return the full string (with closing parenthesis, otherwise not if we
    // ran off the end)
    //
    return string;
}

string
get_class_template_from_class_name(string class_name)
{
    int             i;

    if ((i = string_find(class_name, 0, "<")) != string_length(class_name))
	return string_extract(class_name, 0, i);
    return "";
}

void
set_template_prefix_and_parameters(ClassCodeDescriptor c)
{
    c.var.template_prefix = 
	UmlClass__GetItemValue(c.uml_class, "UmlClassParameters");

    if (c.uml_class.elaborated_type != NULL && (c.uml_class.elaborated_type.type == "UmlParameterizedClass")) {
	if (c.var.template_prefix != "") {
	    c.var.is_template = True;
	    c.var.template_parameters =
		"< " +
		uml_name_type_syntax_2_type_space_name_syntax(c.var.template_prefix, "N") +
		" >";
	    c.var.template_prefix =
		"template< " +
		uml_name_type_syntax_2_type_space_name_syntax(c.var.template_prefix, "B") +
		" > ";
	} else {
	    ide_warning("  Warning: '" + c.def.language_qualified_name + "' is a parameterized class, but it has no parameters defined.");
	}
    } else {
	c.var.template_prefix = "";
    }
}

boolean
class_is_uml_type(UmlClass uml_class)
{
    string stereotype;
    
    stereotype = UmlClass__GetItemValue(uml_class, "UmlStereotype");
    
    return (stereotype == "type" || stereotype == "interface");
}

boolean
should_generate_uml_type(UmlClass uml_class)
{
    string generate_type;
    
    generate_type = UmlClass__GetItemValue(uml_class, 
					   "UmlGenerateClassIfType");

    if (generate_type == "False")
	return False;
    else if (generate_type == "True")
	return True;
    else 
	// no annotation on class, use external value
	return generate_types_and_interfaces;
}


boolean
should_generate_uml_type_attributes(UmlClass uml_class)
{
    string generate_type_attributes_item_value;
    
    generate_type_attributes_item_value = 
	UmlClass__GetItemValue(uml_class, "UmlGenerateTypeAttributes");

    if (generate_type_attributes_item_value == "False")
	return False;
    else if (generate_type_attributes_item_value == "True")
	return True;
    else 
	// no annotation on class, use external value
	return generate_type_attributes;
}


int
main()
{
    // --- START PATCH ECR 5025 ---
    // Set the local var (defined in uml.inc ) to the value of
    // the global var. This is the only way to keep the same code
    // both controlled by a prop sheet _and_ working from within
    // the gde
    //
    generate_namespace = x_generate_namespace;
    // --- END PATCH ECR 5025 ---
    return code_gen_main("C++");
}
