proc hasTransitionWithoutEventAndGuard(MState)
	if(hasSuperState([MState]))
			loop(MState->MStatemachine->SuperState as SS)
				if(hasTransitionWithoutEventAndGuard([SS]))
					return TRUE;
				else
					return FALSE;
				end if
			end loop
	else
		if( hasLoop(MState->ToState->MTransition where isAutomatic([MTransition]) ) )
			return TRUE;
		else
			return FALSE;
		end if
	end if
end proc

proc hasAutomaticTransition(MState)
	if(hasSuperState([MState]))
			loop(MState->MStatemachine->SuperState as SS)
				if(hasAutomaticTransition([SS]))
					return TRUE;
				else
					return FALSE;
				end if
			end loop
	else
		if( (hasLoop(MState->ToState->MTransition where isAutomatic([MTransition]) )) || (hasLoop(MState->ToState->MTransition where isAutomaticWithGuard([MTransition]))) )
			return TRUE;
		else
			return FALSE;
		end if
	end if
end proc

proc hasSuperState(MState)
	if( hasLoop(MState->MStatemachine->SuperState) )
		return TRUE;
	else
		return FALSE;
	end if
end proc

proc hasTransitionWithoutEventAndWithGuard(MState)
	if(hasSuperState([MState]))
		loop(MState->MStatemachine->SuperState as SS)
			if(hasTransitionWithoutEventAndWithGuard([SS]))
				return TRUE;
			else
				return FALSE;
			end if
		end loop
	else
		if( hasLoop(MState->ToState->MTransition where isAutomaticWithGuard([MTransition]) ) )
			return TRUE;
		else
			return FALSE;
		end if
	end if
end proc

proc hasTransitionWithEvent(MState)
	if(hasSuperState([MState]))
			loop(MState->MStatemachine->SuperState as SS)
				if(hasTransitionWithEvent([SS]))
					return TRUE;
				else
					return FALSE;
				end if
			end loop
	else
		if( hasLoop(MState->ToState->MTransition where isEvent([MTransition]) ) )
			return TRUE;
		else
			return FALSE;
		end if
	end if
end proc

proc isAutomatic(MTransition)
	transitionEventConditionActionExtraction([MTransition]);
	if( ([EventExpression] == "") && ([ConditionExpression] == "") )
		return TRUE;
	else
		return FALSE;
	end if
end proc

proc isAutomaticWithGuard(MTransition)
	transitionEventConditionActionExtraction([MTransition]);
	if( ([EventExpression] == "") && ([ConditionExpression] != "") )
		return TRUE;
	else
		return FALSE;
	end if
end proc

proc isEvent(MTransition)
	transitionEventConditionActionExtraction([MTransition]);
		if( [EventExpression] != "")
			return TRUE;
		else
			return FALSE;
		end if
end proc

// Extraction of event part, condition part and action part
proc transitionEventConditionActionExtraction(MTransition)
	local EventCondAction = "";
	local EventCond = "";
	[EventExpression] = "";
	[ConditionExpression] = "";
	[ActionExpression] = "";
	local saveDelim = "";
	
	[saveDelim] = delim();
	loop (MTransition->TriggerEvent)
		[EventExpression] = [TriggerEvent.name]buildEventParametersString([TriggerEvent]);
	end loop
		
	loop (MTransition->MGuard)
		[ConditionExpression] = [MGuard.expression];
	end loop
		
	loop (MTransition->SendAction; setDelim(""); setDelim("; "))
		[ActionExpression] = [ActionExpression] delim() [SendAction.name];
	end loop
	setDelim([saveDelim]);

end proc

proc buildEventParametersString(MEvent)
	local L = "";
	local saveDelim = delim();
	
	loop(MEvent->EvPara; setDelim(""); setDelim(", "))
		[L] = [L] delim() buildParaString([EvPara]);
	end loop
	
	if ([L] != "")
		[L] = "("[L]")";
	end if
	
	setDelim([saveDelim]);
	
	return [L];
end proc

// Builds the parameter string: "param" or "param : type" (if any type)
proc buildParaString(MEventPara)
	local name = "";
	
	[name] = [MEventPara.description];
	if ([MEventPara.type])
		[name] = [name] " : " [MEventPara.type];
	end if
	
	return [name];
end proc

// Return the list of all states -
proc buildStateList(MClass)
	local L = "";
	
	loop(MClass->MStatemachine->MState Where ! hasLoop(MState->MPseudoState); setDelim(""); setDelim(",\n            "))
		[L] = [L] addStateToList([MState], delim());
	end loop
	
	return [L];
end proc


// Add state (and substates if composite) to the list
proc addStateToList(MState, Delim)
	local SubL = "";
	//info = [MState.name]"\n";
	
	[SubL] = [Delim] [MState:Name];
	
	// if composite state...
	loop(MState->Submachine->MState as SubState)
		[SubL] = [SubL] addStateToList([SubState], ",\n             ");
	end loop
	//info = "result : \n" [SubL];
	return [SubL];
end proc


/******************************************************************************
initDyn(MClass)

Initialisation
Check that each state has a name - 
if not, attributes a name + store it in variable [MState:Name] + warning


Initialisations for active classes
- initialize the variable GenericFsmImplementation depending on the implementation choosen
- For each state of the SM of the given class:
	- Creation of variable [MState:Name] 
   	  Attribution of a name if not
 	- Attach to the state the given class for later
 	- Attach to the state the list of superstates id
 	- Attach to the state the entry action number, the exit action number and the activity number if any...
- For each transition, attach the condition number and the action number if any...

******************************************************************************/
proc initDyn(MClass)
	// initialization of the states
	statesInitialisationProcess([MClass]);
	
	// initialization of the transitions
	transitionsInitialisationProcess([MClass]);
end proc

// Store the correct names of states in a variable [State:Name]
// Remark: if a state has no name, then a name is attributed "State_<i>" + warning
// Attach to each state state the given class
// Attach to each state the list of superstates id
// Attach the entry action number, exit action number and the activity number if any to each state
proc statesInitialisationProcess(MClass)
	[SuffixForCreationStateName] = 0; // variable used to find state names for creation states that have no names
	[SuffixForFinalStateName] = 0; // variable used to find state names for final states that have no names
	[SuffixForStateName] = 0; // variable used to find state names for states that have no names
	
	[NbStateEntryAction] = 0; // variable used to store the number of state entry actions
	[NbStateExitAction] = 0; // variable used to store the number of state exit actions
	[NbStateActivity] = 0; // variable used to store the number of state activities
	
	// Process states one by one (+ substates)
	loop(MClass->MStatemachine->MState Where ! hasLoop(MState->MPseudoState))
		statesInitialisationProcess2([MClass], [MState], " ");
	end loop
end proc

// For a given class, and a given state - store the name of the state + if composite state do it recursively
proc statesInitialisationProcess2(MClass, MState, SuperStatesID)
	local Name = "";
	local entryAct = "";
	local exitAct = "";
	local SuperStatesIDForSubStates = "";
	
	// stores the name (attribute one if not + warning)
	[Name] = replaceBlankByUnderscore([MState.name]);
	// if no name, attribute one + warning
	if ([Name] == "")
		[Name] = giveANameToState([MClass], [MState]);
		printWarning("One state has no name in state machine of class '"[MClass.name]"'; The name '"[Name]"' is therefore attributed to it\n");
	end if
	[MState:Name] = [Name];

	// stores the reference to the class for later
	[MState:ClassID] = [MClass.id];
	
	// stores the list of superstates
	[MState:SuperStatesID] = [SuperStatesID];
	
	// stores the entry_action_number, the exit_action_number and the activity_number if any...	
	if (isEntryAction([MState]))
		[NbStateEntryAction] = add([NbStateEntryAction], 1);
		[MState:entry_action_number] = [NbStateEntryAction];
	end if
	if (isExitAction([MState]))
		[NbStateExitAction] = add([NbStateExitAction], 1);
		[MState:exit_action_number] = [NbStateExitAction];
	end if
	if (isStateActivity([MState]))
		[NbStateActivity] = add([NbStateActivity], 1);
		[MState:activity_number] = [NbStateActivity];
	end if
	
	// if  composite state...
	[SuperStatesIDForSubStates] = [SuperStatesID][MState.id]" ";
	loop(MState->Submachine->MState as SubState)
		statesInitialisationProcess2([MClass], [SubState], [SuperStatesIDForSubStates]);
	end loop
end proc

// Run through all transitions of the SM of the given class and attach to them condition number and action number if any
proc transitionsInitialisationProcess(MClass)
	[NbTransCond] = 0;
	[NbTransAction] = 0;
	
	loop(Instances->MTransition where (isTransitionBelongsToStateMachineOfClass([MTransition], [MClass])))
		transitionEventConditionActionExtraction([MTransition]);
		if ([ConditionExpression] != "")
			[NbTransCond] = add([NbTransCond], 1);
			[MTransition:condition_number] = [NbTransCond];
		end if
		if ([ActionExpression] != "")
			[NbTransAction] = add([NbTransAction], 1);
			[MTransition:action_number] = [NbTransAction];
		end if
	end loop
end proc

// Replace each blank by an underscore in str.
// ex: "toto titi tutu" -> "toto_titi_tutu"
// exception: if blank before or after then replaced by ""
proc replaceBlankByUnderscore(str)
	if (split([str], " ", "L") == "" || split([str], " ", "T") == "")
		return replace([str], " ", "");
	end if
	
	return replace([str], " ", "_");
end proc

// Return an unexisting name for a state made of either "State_" or "CreationState_" or "FinalState_" suffixed by a number i: "State_<i>"
// Rule: State1
proc giveANameToState(MClass, MState)
	local Name = [MState].stateName();
	
	// if already exist... attribute another name and check again
	if (isStateNameAlreadyExist([MClass], [Name]))
		return giveANameToState([MClass], [MState]);
	end if
	
	// an unexisting name is found => return it
	return [Name];
end proc

// Returns the entry action string corresponding to that state if any otherwise ""
proc entryAction(MState)
	loop(MState->MAction->MActionType where [MActionType.type] == "entry")
		return [MAction.name];
	end loop
   
   return "";
end proc


// Returns TRUE if there exists an entry action corresponding to that state
proc isEntryAction(MState)
	if (entryAction([MState]) != "")
		return TRUE;
	else
		return FALSE;
	end if
end proc

// Returns the exit action string corresponding to that state if any otherwise ""
proc exitAction(MState)
	loop(MState->MAction->MActionType where [MActionType.type] == "exit")
		return [MAction.name];
	end loop
   
   return "";
end proc


// Returns TRUE if there exists an exit action corresponding to that state
proc isExitAction(MState)
	if (exitAction([MState]) != "")
		return TRUE;
	else
		return FALSE;
	end if
end proc

// Returns the activity string corresponding to that state if any otherwise ""
proc stateActivity(MState)
	loop(MState->MActivity)
		return [MActivity.name];
	end loop
  
   return "";
end proc


// Returns TRUE if there exists an activity corresponding to that state
proc isStateActivity(MState)
	if (stateActivity([MState]) != "")
		return TRUE;
	else
		return FALSE;
	end if
end proc

// TRUE if the given StateName already exists i.e. there is a state or composite state that has the same name in the state machine of that class
proc isStateNameAlreadyExist(MClass, StateName)
	loop (MClass->MStatemachine->MState Where ! hasLoop(MState->MPseudoState))
		if (isStateNameAlreadyExist2([MClass], [MState], [StateName]))
			return TRUE;
		end if
	end loop
	
	// not exist
	return FALSE;
end proc

proc isStateNameAlreadyExist2(MClass, MState, StateName)
	// The state name already exists
	if ([MState:Name] == [StateName])
		return TRUE;
	end if

	// The state name already exists
	if (replaceBlankByUnderscore([MState.name]) == [StateName])
		return TRUE;
	end if

	// if  composite state... find if a component state has the same name
	loop(MState->Submachine->MState as SubState)
		if (isStateNameAlreadyExist2([MClass], [SubState], [StateName]))
			return TRUE;
		end if
	end loop
	
	// not exist
	return FALSE;
end proc

// Returns TRUE if the given transition belongs to a state machine concerning the given class (SM or sub-SM)
proc isTransitionBelongsToStateMachineOfClass(MTransition, MClass)
[MTransition].isValueOfTagEqualToIgnoreCase("Class - Transition", [MClass.id]);	
	if ([MTransition].isValueOfTagEqualToIgnoreCase("Class - Transition", [MClass.id]))
		return TRUE;
	end if
	
	return FALSE;
end proc

// Suggests a state name depending on the state type : "CreationState_<i>", "FinalState_<i>" or "State_<i>"
proc MCreationState.stateName()
	[SuffixForCreationStateName] = add([SuffixForCreationStateName], 1);
	return "CreationState_"[SuffixForCreationStateName];
end proc

proc MFinalState.stateName()
	[SuffixForFinalStateName] = add([SuffixForFinalStateName], 1);
	return "FinalState_"[SuffixForFinalStateName];
end proc

proc MState.stateName()
	[SuffixForStateName] = add([SuffixForStateName], 1);
	return "State_"[SuffixForStateName];
end proc

// Return TRUE if there exists a tagged value for the given tag type and the given tag value for the given element, otherwise FALSE
// Does not take into account the difference of case for the comparison
proc MElement.isValueOfTagEqualToIgnoreCase(TagType, TagVal)
	loop(MElement->TaggedValue)
	info = "tag  :"[TaggedValue.tag]"\n";
	end loop
	loop(MElement->TaggedValue Where (toLower([TaggedValue.tag]) == toLower([TagType]) && toLower([TaggedValue.value]) == toLower([TagVal])))
		return TRUE;
	end loop
	
	return FALSE;
end proc

/*-----------------------------------------------------------------------------
printWarning(String)

Display in the output window the String

-----------------------------------------------------------------------------*/
proc printWarning(Str)
	info = "***WARNING***   " [Str];
end proc

// Return the list of events - form: "(evt1, evt2, ..., evtn, null_event)"
// Remark: if a transition has no event (e.g. automatic transition), then not stored in the list
// Remark: if 2 transitions have the same event name, then stored only once in the list
// Rule: Event1, EventGen1
proc buildEventList(MClass)
	local L = "";
	local L2 = "";
	local Name = "";
	
	
	setDelim("");
	loop(Instances->MTransition where (/*isTransitionBelongsToStateMachineOfClass([MTransition], [MClass]) &&*/ existTransitionEvent([MTransition])))
		[Name] = transitionEventName([MTransition]);
		//info = "nom evenement : "[Name]"\n";
		if ([Name] != "" && (!alreadyInList([Name], [L2])))
			[L] = [L] delim() [Name];
			[L2] = [L2] " " [Name] " "; 
			setDelim(",\n            ");
		end if
	end loop
	
	//info = "liste : "[L]"\n";
	return [L];
end proc

// True if the given string is already in the list
// lst form: " st1 st2 ... stn "
// str form: "sti"
proc alreadyInList(str, lst)
	if (regexp([lst], " "[str]" ") != "")
		return TRUE;
	end if
	return FALSE;
end proc

// Return TRUE if there is an event for the given transition
proc existTransitionEvent(MTransition)
	if (transitionEvent([MTransition]) != "")
		return TRUE;
	else 
		return FALSE;
	end if
end proc

// Return the event expression for the given transition
proc transitionEvent(MTransition)
	transitionEventConditionActionExtraction([MTransition]);
	//info = "evenement : "[EventExpression]"\n";
	return [EventExpression];
end proc


// Return the event name (only) for the given transition
proc transitionEventName(MTransition)
	return replaceBlankByUnderscore(split(transitionEvent([MTransition]), "\(", "L"));
end proc

// Returns a string corresponding to the state type: "creation state" (pseudo or not), "final state" (pseudo or not), "normal state" or "other state"
// WARNING: A MNormalState may be a creation state if it is a non composite state with no entry external transitions
// or may be a final state if it is a non composite state with no exit external transitions
proc MCreationState.stateType()
	return "creation state";
end proc

proc MFinalState.stateType()
	return "final state";
end proc

proc MNormalState.stateType()
	// if not composite and if no entry external transitions => creation state (not pseudo)
	if ((!hasLoop(MNormalState->FromState->MTransition where !isInternalTransition([MTransition]))) && (!isCompositeState([MNormalState])))
		return "creation state";
	end if

	// if not composite and if no exit external transitions => final state (not pseudo)
	if ((!hasLoop(MNormalState->ToState->MTransition where !isInternalTransition([MTransition]))) && (!isCompositeState([MNormalState])))
		return "final state";
	end if	
	
	return "normal state";
end proc

proc MState.stateType()
	return "other state";
end proc

// Returns TRUE if the given state is a creation state (pseudo or not), otherwise FALSE
proc isCreationState(MState)
	if ([MState].stateType() == "creation state")
		return TRUE;
	end if
	
	return FALSE;
end proc


// Returns TRUE if the given state is a pseudo creation state (MCreationState), otherwise FALSE
proc isPseudoCreationState(MState)
	if ([MState].stateType() == "creation state" && [MState].pseudoStateType())
		return TRUE;
	end if
	
	return FALSE;
end proc


// Return TRUE if it is a MCreationState or a MFinalState otherwise FALSE
proc MCreationState.pseudoStateType()
	return TRUE;
end proc

proc MFinalState.pseudoStateType()
	return TRUE;
end proc

proc MNormalState.pseudoStateType()
	return FALSE;
end proc


// Returns TRUE if the given state is a final state (pseudo or not), otherwise FALSE
proc isFinalState(MState)
	if ([MState].stateType() == "final state")
		return TRUE;
	end if
	
	return FALSE;
end proc


// Returns TRUE if the given state is a pseudo final state, otherwise FALSE
proc isPseudoFinalState(MState)
	if ([MState].stateType() == "final state" && [MState].pseudoStateType())
		return TRUE;
	end if
	
	return FALSE;
end proc


// Returns TRUE if the given state is a normal state, i.e. not creation nor final (even not pseudo) otherwise FALSE
proc isNormalState(MState)
	if ([MState].stateType() == "normal state")
		return TRUE;
	end if
	
	return FALSE;
end proc

// Returns TRUE if the given state is a composite state
proc isCompositeState(MState)
	loop(MState->Submachine->MState as SubState)
		return TRUE;
	end loop
	
	return FALSE;
end proc


// Returns TRUE if the given state is a component state
proc isComponentState(MState)
	loop(MState->MStatemachine->SuperState Where ! hasLoop(MState->MPseudoState))
		return TRUE;
	end loop
	
	return FALSE;
end proc

// Returns TRUE if the given transition is an internal one
proc isInternalTransition(MTransition)
	if ([MTransition].isValueOfTagEqualToIgnoreCase("Internal transition", "Internal"))
		return TRUE;
	end if
	
	return FALSE;
end proc

proc SuperStatesIDListOfSourceAndTargetStatesForActionsToExecute(MState as SourceS, MState as TargetS)
	[SourceSuperStatesIDForExitActions] = "";
	[TargetSuperStatesIDForEntryActions] = "";
	SuperStatesIDListOfSourceAndTargetStatesForActionsToExecute2([SourceS:SuperStatesID], [TargetS:SuperStatesID]);
end proc

proc SuperStatesIDListOfSourceAndTargetStatesForActionsToExecute2(SourceSuperSIDList, TargetSuperSIDList)
	if (getLength([SourceSuperSIDList]) <= 1)
		[TargetSuperStatesIDForEntryActions] = [TargetSuperSIDList];	
	else if (getLength([TargetSuperSIDList]) <= 1)
		[SourceSuperStatesIDForExitActions] = invIdOrder([SourceSuperSIDList]);
	else
		SuperStatesIDListOfSourceAndTargetStatesForActionsToExecute3([SourceSuperSIDList], [TargetSuperSIDList]);
	end if end if
end proc

proc SuperStatesIDListOfSourceAndTargetStatesForActionsToExecute3(SourceSuperSIDList, TargetSuperSIDList)
	local ID1 = "";
	local IDLQueue1 = "";
	local IDLQueue2 = "";
	
	if (getLength([SourceSuperSIDList]) > 1)
		[ID1] = split([SourceSuperSIDList], " ", 1);
		if (regexp([TargetSuperSIDList], " "[ID1]" ") != "")
			[IDLQueue1] = replace([SourceSuperSIDList], " "[ID1], "");
			[IDLQueue2] = replace([TargetSuperSIDList], " "[ID1], "");
			 SuperStatesIDListOfSourceAndTargetStatesForActionsToExecute3([IDLQueue1], [IDLQueue2]);
			return;
		end if
	end if
	[SourceSuperStatesIDForExitActions] = invIdOrder([SourceSuperSIDList]);
	[TargetSuperStatesIDForEntryActions] = [TargetSuperSIDList];
end proc

proc nextNonIsCompositeStateName(MTransition, MState as CurrentState)
	if(isInternalTransition([MTransition]))
		[NextStateID] = [CurrentState.id];
		[NextStateName] = [CurrentState:Name];
		return;
	end if
	loop(MTransition->ToState)
		if (hasLoop(ToState->Submachine))
			// composite state
			loop(ToState->Submachine->MState->MCreationState)
				[NextStateID] = [MCreationState.id];
				[NextStateName] = [MCreationState:Name];
				return;
			end loop
			loop(ToState->Submachine->MState->MNormalState where isCreationState([MNormalState]))
				[NextStateID] = [MNormalState.id];
				[NextStateName] = [MNormalState:Name];
				return;
			end loop
			// should never happen => warning + return the composite state name
			printWarning("The composite state '" [ToState:Name] "' does not have any creation state !!!\n");
			[NextStateID] = [ToState.id];
			[NextStateName] = "???("[ToState:Name]")";
			return;
		else
			// leaf state
			[NextStateID] = [ToState.id];
			[NextStateName] = [ToState:Name];
			return;
		end if
	end loop
end proc

proc genereAutomaticTransition( MState,MClass)

end proc


