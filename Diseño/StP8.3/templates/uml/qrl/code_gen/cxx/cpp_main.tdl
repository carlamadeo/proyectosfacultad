//*****************************************************************************
// $RCSfile: cpp_main.tdl,v $
// $Revision: 1.9 $
// $Date: 2002/04/08 13:19:13 $
// Author: Markus Kern
//*****************************************************************************
/*
Contains the main routine of the CPP code generator.

Generates for each class in the model:
     - header file (template genH, defined in cpp_genh.tdl)
     - a body (template genCPP, defined in cpp_gencpp.tdl)

Generates the main routine of the generated application 
(template genMain, defined below).

Generates one file (classes.h) containing all forward declarations 
(template genClassesH, defined below).

Generates one file (baseclasses.h) containing the base classes 'ActiveInstance' 
and 'InactiveInstance'. Every generated class is directly or indirectly inherited
from either 'ActiveInstance' or 'InactiveInstance'
(template genBaseClasses, defined below).

The mapping of metatypes and StP/Uml types is documented in the ACD manual.
*/



/*
imports other template files
*/
USES cpp_std;
USES cpp_genh;
USES cpp_gencpp;
USES cpp_gensm;

/******************************************************************************
This is the entry procedure of the cpp code generator.
******************************************************************************/
proc main()

    
    /* Initializes language specific settings. (defined in cpp_std.tdl) */
    init();

    /* Whether or not, a default return value for operations is generated. 
       NOTE!! Setting this variable to "FALSE" probably prevents 
       compiling, if you didn't provide an implementation code 
       either in the user-defined section or as a source code 
       annotation! On the other hand, you have 100% control over 
       the method implementation this way! */
    [CREATE_DEF_RETURN] = "TRUE";

    /* Redirect output to generated file <[srcdir]"/<fileName.ext>">. 
       srcdir is a global variable which is provided by the code generation 
       dialog srcdir will be generated, if it is necessary.
       info redirects output to message log.
       out redirects output to the file, which is defined by output. */
    output([srcdir] "/classes.h");
    info = "generate " getOutput() "\n";
    /* calls the template genClassesH (defined in cpp_main.tdl)*/
    out = genClassesH();            

    output([srcdir] "/baseclasses.h");
    info = "generate " getOutput() "\n";
    /* calls the template genBaseClasses (defined in cpp_main.tdl)*/
    out = genBaseClasses();         

    output([srcdir] "/main.cpp");
    info = "generate " getOutput() "\n";
    /* calls the template genMain (defined in cpp_main.tdl)*/
    out = genMain();                
    
    /* loop over all MNormalClasses in the model.
       MNormalClass is a metaclass which represents classes in StP */
    if ([class_id_list] == "")
    loop(Instances->MClass->MNormalClass Where ! [MNormalClass:isExternal])
        /* Generates a header file for each instance of MClass */
        output([srcdir] "/" [MNormalClass.name] ".h");
        info = "generate " getOutput() "\n";
            out = genH([MNormalClass]);

        /* Generates a body file for each instance of MClass */
        output([srcdir] "/" [MNormalClass.name] ".cpp");
        info = "generate " getOutput() "\n";
            out = genCPP([MNormalClass]);           
    end loop  
    else
      loop(Instances->MClass([class_id_list])->MNormalClass Where ! [MNormalClass:isExternal])
        /* Generates a header file for each instance of MClass */
        output([srcdir] "/" [MNormalClass.name] ".h");
        info = "generate " getOutput() "\n";
            out = genH([MNormalClass]);

        /* Generates a body file for each instance of MClass */
        output([srcdir] "/" [MNormalClass.name] ".cpp");
        info = "generate " getOutput() "\n";
            out = genCPP([MNormalClass]);           
      end loop
    end if
end proc

/******************************************************************************
generates main.cpp which contains the main routine of the application.
This is just an example of what the main routine could look like.
******************************************************************************/
template genMain()
#include <stdio.h>
#include <string.h>

[/* Generates a marked section in the output. The content of this section can 
be changed by the user in the generated file. These changes will not be 
overwritten in subsequent cycles of code generation */]
[mergeOut("UDIF","Include Files")]

void Applic_Init() {

    [mergeOut("UDSC","StartUp Code")]
}

int main(int argc, char * argv[]) {

    Applic_Init();

    [mergeOut("UDMC", "Main Program Code")]
    return 0;
}
end template

/******************************************************************************
generates classes.h which contains a forward declaration for each class
in the model. Every generated class file includes classes.h
******************************************************************************/
template genClassesH()
#ifndef _classes_h
#define _classes_h

[if ([class_id_list] == "")]
[loop(Instances->MNormalClass)]
class [MNormalClass.name];
[end loop]
[else]
  [loop(Instances->MNormalClass([class_id_list]))]
class [MNormalClass.name];  
  [end loop]
[end if]

#endif
end template

/******************************************************************************
generates baseclasses.h which contains the base classes ActiveInstance and
InactiveInstance.
******************************************************************************/
template genBaseClasses()
#ifndef _baseclasses_h
#define _baseclasses_h

class ActiveInstance {
protected:
    int currentState;
    ActiveInstance(int st): currentState(st){};

[mergeOut("UDAI", "Active Instance Declarations")]
};

class InactiveInstance {

[mergeOut("UDII", "Inactive Instance Declarations")]

};

#endif
end template
