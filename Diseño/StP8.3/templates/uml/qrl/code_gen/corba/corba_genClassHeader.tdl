//*****************************************************************************
// $RCSfile: corba_genClassHeader.tdl,v $
// $Revision: 1.3 $
// $Date: 2001/12/04 12:59:55 $
// Author: Oliver Maus
//*****************************************************************************

/*
   Generates a header file for each metamodel type MClass which 
   represents an implementation class for interface.
*/

/*
import other template files
*/
USES corbaidl_genClassBody;
USES ../tdl/std;

proc genClassHeader(MInterface)
	/* local variables */
	local packageName;
	local fileName;
	local implementationFilename;

	loop(MInterface->Implementation)
		loop(MInterface->MPackage)
			[packageName] = [MPackage.name];
		end loop
		[implementationFilename] = [Implementation.name];

		/* Build the final filename for MClass */
		[fileName] = [srcdir] "/" [packageName] "/" [implementationFilename] ".hpp";
		/* Redirect output to standard output */
		info = "generate " [fileName] "\n";
		/* make subdirectory if necessary. lsdir is a Tcl procedure (defined 
		   in std.tdl) */
		mkdir(lsdir( [fileName]));
		
		/* Set the output redirection to [fileName]. output is a predefined
		   function */
		output( [fileName] );
		/* insert package id that is used inside the templates by the procedure
		   provided as the second parameter to the mark function */
//		insert("package",[Class_[MInterface.name]]);
	
		/* Call the appropriate template for generation of header file */
		out = [Implementation].genClassHeader([MInterface]);
		genClassBody([MInterface]);
	end loop
end proc

/*	start template
*/
template MClass.genClassHeader(MInterface)
[loop (MClass->MPackage)]
#include "[MPackage.name]_S.hpp"	[// header generated by corba compiler]
[end loop]

[mergeOut("UDIF","user includes")]

class [MClass.name] 
{
	[genFriendFactory([MInterface])]	[// declare factory (if exists) as friend]
	// Constructors, destructor
	public:
	[MClass.name](); 
	virtual ~[MClass.name](); 
	
	[genLifeCycleOperationsHeader([MInterface])]	[// generate lifecycle operations, s. below]
	
	[genAccessorForIDLAttribsHeader([MClass])]		[// does what it says]
	[genIDLOperations([MClass])]					[// dito]
	
	[genPointer2TieObject([MInterface])]			[// dito]
};
end template

/*	generate lifecycle operations for the case, that 
	factory has to be generated
*/
template genLifeCycleOperationsHeader(MInterface)
[// first check, whether Factory should be generated]
[if (getFactoryNameFromInterface([MInterface], "FALSE") != "")]
// IDL Lifecycle operations
virtual void remove();
[end if]	
end template

/*	generate pointer to TIE object, if factory should be generated
*/
template genPointer2TieObject(MInterface)
[// first check, whether Factory should be generated]
[if (getFactoryNameFromInterface([MInterface], "FALSE") != "")]
private:
// As a convention, we store the pointer to our TIE object in the implementation object.
// This pointer has to be provided by the factory.
// This pointer is deleted in my destructor.
//
[loop (MInterface->MPackage)]
[MPackage.name]::[MInterface.name]_var myTie;
[end loop]
[end if]
end template

/*	declare factory (if exists) as friend
*/
template genFriendFactory(MInterface)
[// first check, whether Factory should be generated]
[if (getFactoryNameFromInterface([MInterface], "FALSE") != "")]
friend class [getFactoryNameFromInterface([MInterface], "FALSE")]_i;
[end if]
end template

/*	generate operation declarations from interface file
	That operations have to be implemented in the class body.
*/
template genIDLOperations(MClass)
[setLanguage("CPP")]
[loop(MClass->Implement)]
public:
// IDL operations
[loop(Implement->MOperation)]
[// exclude operations declared as static, because they have a different semantic]
[if (operationIsStatic([MOperation]) != "TRUE")]
[getDataType([MOperation.returnType])] [MOperation.name]([getOpTypeList([MOperation])]);
[end if]
[end loop]
[end loop]
end template

/*	check whether operation of interface is declared as static
*/
proc operationIsStatic(MElement)
	loop(MElement->Note->Item Where [Item.type] == "UmlMemberIsClass" && [Item.value] == "True")
		return "TRUE";
	end loop
	return "FALSE";
end proc

/*	declare accessor methods for operations from interface attributes
*/
template genAccessorForIDLAttribsHeader(MClass)
[setLanguage("CPP")]
[loop(MClass->Implement)]
[if (hasLoop(Implement->MAttribute))]
// IDL Attribute setters and getters
public:
[end if]
[loop(Implement->MAttribute)]
virtual [getDataType([MAttribute.type])] [MAttribute.name]();
virtual void [MAttribute.name](const [getDataType([MAttribute.type])] _[MAttribute.name]);
[end loop]
[end loop]


[loop(MClass->Implement)]
[if (hasLoop(Implement->MAttribute))]
// Storage for IDL attributes
private:
[end if]
[loop(Implement->MAttribute)]
[getDataType([MAttribute.type])] _[MAttribute.name];
[end loop]
[end loop]

end template





















