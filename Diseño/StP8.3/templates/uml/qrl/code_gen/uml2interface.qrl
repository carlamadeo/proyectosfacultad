//*****************************************************************************
// $RCSfile: uml2interface.qrl,v $
// $Revision: 1.33 $
// $Date: 2002/04/05 16:09:34 $
// Author:
//*****************************************************************************
#include "uml/rules/qrl/oper_parse.inc"
#include "ct/rules/qrl/commands.inc"

external boolean with_dynamic_model = True;
external boolean with_use_cases = True;

//////////////////////////////////////////////////////////////////////////////////

list    annotIds = NULL;
int     annotIdsCount = 0;
boolean annotIdFound = False;

int
find_annot_id_index(int id)
{
    int l, r, m, v;

    annotIdFound = False;

    l = 0;
    r = annotIdsCount - 1;
    m = (l + r + 1) / 2;
    while (m <= r)
    {
        v = list_get(annotIds, m);

        if (id < v)
            r = m - 1;
        else if (id > v)
            l = m + 1;
        else
        {
            annotIdFound = True;
            break;
        }
        m = (l + r + 1) / 2;
    }

    return m;
}

boolean
annot_id_is_valid(int id)
{
    find_annot_id_index(id);
    return annotIdFound;
}

void
add_annot_id(int id)
{
    int i;

    i = find_annot_id_index(id);
    if (annotIdFound)
        return;

    if (annotIdsCount <= i)
        list_append(annotIds, id);
    else
        list_insert(annotIds, i, id);

    annotIdsCount++;
}

//////////////////////////////////////////////////////////////////////////////////

int    indentCount = 0;
int    lastIndentCount = 0;
string lastIndentString = "";

void
output(string tag, string value)
{
    if (value != NULL && string_length(value) != 0)
    {
        if (lastIndentCount != indentCount)
        {
            lastIndentCount = indentCount;
            lastIndentString = string_repeat(" ", 2 * lastIndentCount);
        }

        if (tag != NULL)
            print_line(lastIndentString + tag + value);
        else
            print_line(lastIndentString + value);
    }
}

void
outpId(string tag, int id)
{
    output(tag, to_string(id));
    add_annot_id(id);
}

//////////////////////////////////////////////////////////////////////////////////

string
getStereotype(int obj_id)
{
    cache_iterator  items;
    item            it;

    items = cache_find_items_by_obj(obj_id);
    it = cache_find_first_by_attrs(items, "type", "UmlStereotype");
    if (it != NULL)
        return it.value;

    return "";
}

//////////////////////////////////////////////////////////////////////////////////

string
getLine(string line)
{
    if (line == NULL)
        return "";
    return string_search_and_replace(line, "\n", "\1");
}

//////////////////////////////////////////////////////////////////////////////////

string
getDescription(int obj_id)
{
    cache_iterator  notes;
    note            nt;
    string          desc;

    notes = cache_find_notes_by_obj(obj_id);
    nt = cache_find_first_by_attrs(notes, "type", "GenericObject");
    if (nt != NULL)
        return getLine(nt.desc);

    return "";
}

//////////////////////////////////////////////////////////////////////////////////

string
getAction(string line)
{
    if (line == NULL)
        return "";

    line = getLine(line);
    line = string_search_and_replace(line, "{", "{\1");
    line = string_search_and_replace(line, ";", ";\1");

    return line;
}

//////////////////////////////////////////////////////////////////////////////////

list VisibilityTypes  = NULL;
list VisibilityValues = NULL;

string
getVisibility(int obj_id)
{
    int             i, len;
    boolean         dirty;
    cache_iterator  items;
    item            it;
    string          visibility = "";

    if (VisibilityTypes == NULL)
    {
        VisibilityTypes  = list_create("string", 0);
        VisibilityValues = list_create("string", 0);

        list_append(VisibilityTypes, "UmlMemberJavaVisibility");
        list_append(VisibilityValues, "Java:");

        list_append(VisibilityTypes, "UmlMemberCxxVisibility");
        list_append(VisibilityValues, "Cpp:");

        list_append(VisibilityTypes, "UmlMemberAda95Visibility");
        list_append(VisibilityValues, "Ada:");

        list_append(VisibilityTypes, "UmlMemberVisibility");
        list_append(VisibilityValues, "");
    }

    items = cache_find_items_by_obj(obj_id);
    dirty = False;

    len = list_count(VisibilityTypes);
    for (i = 0; i < len; i++)
    {
        it = cache_find_first_by_attrs(items, "type", list_get(VisibilityTypes, i));
        if (it != NULL && it.value != NULL && string_length(it.value) != 0)
        {
            if (dirty)
                visibility += ",";
            visibility += list_get(VisibilityValues, i);
            visibility += it.value;

            dirty = True;
        }
    }

    return visibility;
}

//////////////////////////////////////////////////////////////////////////////////

struct acd_argument {
    string argName;
    string argType;
    string argKind;
    string argDefValue;
    string argMultiplicity;
};

acd_argument
getPara(string thePara)
{
    int pos, npos;
    string argName, argType, argKind, argDefValue, argMultiplicity;
    uml_argument uml_arg;
    acd_argument acd_arg;
    list nameList;
    list typeList;

    argDefValue = "";

    pos = string_find(thePara, 0, "=");
    if (pos < string_length(thePara))
    {
        argDefValue = string_extract(thePara, pos + 1, string_length(thePara) - pos - 1);
        argDefValue = string_strip(argDefValue, "B", " ");
    }

    pos = string_find(thePara, 0, "[");
    npos = string_find(thePara,0,"]");
    if (pos < string_length(thePara))
    {
        argMultiplicity = string_strip(string_extract(thePara, pos + 1, npos - pos - 1), "B", " ");
        thePara = string_strip(string_extract(thePara, 0, pos), "B", " ");
    }
    else
        argMultiplicity = "";

    if ((npos - pos) == 1)
        argMultiplicity = "NONE"; //we have only [] so fill multiplicity with zero to know that "[]" should be added later

    uml_arg = uml_arg_string_to_struct(thePara);
    nameList = string_to_list(uml_arg.argName, "=");

    if (list_count(nameList) > 1)
        acd_arg.argName = list_get(nameList,0);
    else
        acd_arg.argName = uml_arg.argName;

    acd_arg.argDefValue = argDefValue;
    acd_arg.argType = uml_arg.argType;

    acd_arg.argKind = "";
    if (uml_arg.argKind == "")
    {
        typeList = string_to_list(uml_arg.argType," ");
        if (list_count(typeList) > 1)
        {
            argKind = to_lower(list_get(typeList,0));
            if (argKind == "in" || argKind == "out" || argKind == "inout")
            {
                acd_arg.argKind = argKind;
                pos = string_length(argKind);
                npos = string_length(uml_arg.argType);
                acd_arg.argType = string_strip(string_extract(uml_arg.argType,pos,npos-pos),"L"," ");
            }
        }
        list_clear(typeList);
    }
    else
        acd_arg.argKind = uml_arg.argKind;

    acd_arg.argMultiplicity = argMultiplicity;

    list_clear(nameList);

    return acd_arg;
}

//////////////////////////////////////////////////////////////////////////////////

void
generatePara(string id, string guid, string paraType, string paraValue)
{
    uml_argument uml_arg;
    acd_argument acd_arg;
    string thePara;
    list argList;
    list paras;
    list onePara;
    int i, len;

    if (paraValue == NULL || paraValue == "")
        return;

    argList = list_create("string", 0);

    if (uml_split_arguments(paraValue, argList))
    {
        len = list_count(argList);
        for (i = 0; i < len; i++)
        {
            thePara = list_get(argList, i);

            acd_arg = getPara(thePara);

            output("{ ", paraType);
            output("  Id ", to_string(id) + "_Para_" + to_string(i));
            output("  GUID ", guid + "_Para_" + to_string(i));
            output("  Name ", acd_arg.argName);
            output("  Type ", acd_arg.argType);
            output("  DefaultValue ", acd_arg.argDefValue);
            output("  Multiplicity ", acd_arg.argMultiplicity);

            if (paraType == "OpPara" && acd_arg.argKind != "")
                output("  Mechanism ", acd_arg.argKind);

            output("", "}");
        }
    }
    else
    { // Hmm, there seems to be a problem with the arguments, fall back to some dumb routine
        paras = string_to_list(paraValue, ",");

        len = list_count(paras);
        for (i = 0; i < len; i++)
        {
            output("{ ", paraType);
            output("  Id ", to_string(id) + "_Para_" + to_string(i));
            output("  GUID ", guid + "_Para_" + to_string(i));

            onePara = string_to_list(list_get(paras, i), ":");

            if (list_count(onePara) == 1)
                output("  Type ", list_get(onePara, 0));
            else {
                output("  Name ", list_get(onePara, 0));
                output("  Type ", list_get(onePara, 1));
            }

            output("", "}");
        }
    }
    list_clear(argList);
}

//////////////////////////////////////////////////////////////////////////////////

void
generateTemplateBindings()
{
    cache_iterator  node_InstTemplateIter;
    cache_iterator  node_TemplateIter;
    cache_iterator  link_bindlist;
    cache_iterator  iter;
    link            link_bind;
    node            node_Template, node_InstTemplate;
    int             templateId = 0;

    link_bindlist = cache_find_links_by_type("UmlRefines");
    while (link_bindlist)
    {
        link_bind = cache_get_next(link_bindlist);
        node_InstTemplate = cache_find_node_by_id(link_bind.from_node_id);
        if (node_InstTemplate.type != "UmlClass")
            continue;

        // special case, a refine link between two parameterized classes is a generalization
        // ECR 3957
        iter = cache_find_nodes_by_name(node_InstTemplate.name);
        if (cache_find_first_by_attrs(iter, "type", "UmlParameterizedClass") == NULL)
        {
            output("{ ", "MTemplateBinding");
            outpId("  Id ", link_bind.id);
            output("  GUID ", link_bind.guid);
            output("  MTemplateClassId ", to_string(link_bind.to_node_id));
            output("  MInstantiatedClassId ", to_string(link_bind.from_node_id));
            output("", "}");
        }
    }

    node_InstTemplateIter = cache_find_nodes_by_type("UmlClass");
    node_InstTemplateIter = cache_find_all_by_diff_attrs(node_InstTemplateIter, "sig", "");
    while (node_InstTemplateIter)
    {
        node_InstTemplate = cache_get_next(node_InstTemplateIter);

        node_TemplateIter = cache_find_nodes_by_name(node_InstTemplate.name);
        if (cache_find_first_by_attrs(node_TemplateIter, "type", "UmlInstantiatedClass") == NULL)
            continue;

        node_TemplateIter = cache_find_nodes_by_name(node_InstTemplate.name);
        node_TemplateIter = cache_find_all_by_attrs(node_TemplateIter, "type", "UmlClass");
        while (node_TemplateIter)
        {
            node_Template = cache_get_next(node_TemplateIter);

            iter = cache_find_items_by_obj(node_InstTemplate.id);
            if (cache_find_first_by_attrs(iter, "type", "UmlClassParameters") == NULL)
                continue;

            output("{ ", "MTemplateBinding");
            output("  Id ", to_string(node_InstTemplate.id) + "_TB" + to_string(templateId));
            output("  GUID ", node_InstTemplate.guid + "_TB" + to_string(templateId++));
            output("  MTemplateClassId ", to_string(node_Template.id));
            output("  MInstantiatedClassId ", to_string(node_InstTemplate.id));
            output("", "}");
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////

void
generateClassInfo(node cls, string clsType)
{
    cache_iterator  items;
    item            it;

    output("{ ", clsType);
    outpId("  Id ", cls.id);
    output("  GUID ", cls.guid);
    output("  Name ", cls.name);

    items = cache_find_items_by_obj(cls.id);
    it = cache_find_first_by_attrs(items, "type", "UmlClassIsAbstract");
    if (it != NULL)
        output("  IsAbstract ", it.value);

    output("  Desc ", getDescription(cls.id));
}

//////////////////////////////////////////////////////////////////////////////////

void
generateClassHeader(node cls)
{
    cache_iterator  nodes;
    cache_iterator  links;
    cache_iterator  items;
    link            link_para;
    item            item_para;
    string          stereotype;

    nodes = cache_find_nodes_by_name(cls.name);

    links = cache_find_links_by_from_node(cls.id);
    link_para = cache_find_first_by_attrs(links, "type", "UmlRefines");

    if (cache_find_first_by_attrs(nodes, "type", "UmlInstantiatedClass",
                                         "sig", cls.sig,
                                         "scope_node_id", cls.scope_node_id) != NULL)
    {
        generateClassInfo(cls, "MInstantiatedClass");

        if (link_para != NULL)
        {
            items = cache_find_items_by_obj(link_para.id);
            item_para = cache_find_first_by_attrs(items, "type", "UmlRefineArgs");
            if (item_para != NULL)
            {
                indentCount++;
                generatePara(to_string(cls.id), cls.guid, "MTemplatePara", item_para.value);
                indentCount--;

                return;
            }
        }

        if (cls.sig != "")
        {
            indentCount++;
            generatePara(to_string(cls.id), cls.guid, "MTemplatePara", cls.sig);
            indentCount--;
        }

        return;
    }

    items = cache_find_items_by_obj(cls.id);
    item_para = cache_find_first_by_attrs(items, "type", "UmlClassParameters");

    if (cache_find_first_by_attrs(nodes, "type", "UmlParameterizedClass") != NULL)
    {
        generateClassInfo(cls, "MTemplateClass");

        if (item_para != NULL)
        {
            indentCount++;
            generatePara(to_string(cls.id), cls.guid, "MTemplatePara", item_para.value);
            indentCount--;
        }

        return;
    }

    if (item_para != NULL)
    {
        // ?? wf: another way to model an instantiated class, but not 100% sure ??
        if (link_para != NULL)
        {
            generateClassInfo(cls, "MInstantiatedClass");
            indentCount++;
            generatePara(to_string(cls.id), cls.guid, "MTemplatePara", item_para.value);
            indentCount--;
            return;
        }

        // ?? wf: isn't that an instantiated class with only default parameters ??
        generateClassInfo(cls, "NormalClass");
        return;
    }

    stereotype = getStereotype(cls.id);
    if (cache_find_first_by_attrs(nodes, "type", "UmlInterface") != NULL)
        generateClassInfo(cls, "MInterface");
    else if (stereotype != NULL && to_lower(stereotype) == "interface")
        generateClassInfo(cls, "MInterface");
    else if(stereotype != NULL && to_lower(stereotype) == "datatype")
        generateClassInfo(cls, "MDataType");
    else
        generateClassInfo(cls, "NormalClass");
}

////////////////////////////////////////////////////////////////////////////////

void
generateActionBlock(node cls)
{
    int             i, j, len;
    cache_iterator  nodes;
    node            nd;
    set             states;
    node            state;
    node            stateMachine;
    cache_iterator  links;
    link            ln;
    set             stateTypes;
    string          str;

    stateTypes = set_create("string");
    set_add(stateTypes, "UmlState");
    set_add(stateTypes, "UmlInitialState");
    set_add(stateTypes, "UmlFinalState");
    set_add(stateTypes, "UmlHistoryState");

    nodes = cache_find_nodes_by_name(cls.name);
    stateMachine = cache_find_first_by_attrs(nodes, "type", "UmlStateMachine");
    if (stateMachine == NULL)
        return;

    states = set_create("int");

    nodes = cache_find_nodes_by_scope_node(stateMachine.id);
    while (nodes)
    {
        state = cache_get_next(nodes);
        set_add(states, state.id);
    }

    for (i = 0; i < set_count(states); i++)
    {
        state = cache_find_node_by_id(set_get_element(states, i));

        if (!set_is_member(stateTypes, state.type))
            continue;

        links = cache_find_links_by_from_node(state.id);
        links = cache_find_all_by_attrs(links, "type", "UmlStateActivity");
        while (links)
        {
            ln = cache_get_next(links);
            nd = cache_find_node_by_id(ln.to_node_id);

            output("{ ", "MActivity");
            outpId("  Id ", ln.id);
            output("  GUID ", ln.guid);
            output("  Name ", getAction(nd.name));
            output("", "}");
        }

        links = cache_find_links_by_from_node(state.id);
        links = cache_find_all_by_attrs(links, "type", "UmlStateEntryAction");
        while (links)
        {
            ln = cache_get_next(links);
            nd = cache_find_node_by_id(ln.to_node_id);

            output("{ ", "MAction");
            outpId("  Id ", ln.id);
            output("  GUID ", ln.guid);
            output("  Name ", getAction(nd.name));
            output(NULL, "}");
        }

        links = cache_find_links_by_from_node(state.id);
        links = cache_find_all_by_attrs(links, "type", "UmlStateExitAction");
        while (links)
        {
            ln = cache_get_next(links);
            nd = cache_find_node_by_id(ln.to_node_id);

            output("{ ", "MAction");
            outpId("  Id ", ln.id);
            output("  GUID ", ln.guid);
            output("  Name ", getAction(nd.name));
            output(NULL, "}");
        }

        nodes = cache_find_nodes_by_scope_node(state.id);
        while (nodes)
        {
            state = cache_get_next(nodes);
            set_add(states, state.id);
        }
    }

    set_clear(states);
}

//////////////////////////////////////////////////////////////////////////////////
// struct for sorting attributes

struct AT {
    node N;
    int ycoord;
};

// sorter callback function, remember to sort in reverse order
int
cmp_attributes(AT A1, AT A2)
{
    if (A1.ycoord != NULL || A2.ycoord != NULL)
    {
        if (A1.ycoord == NULL)
            return 1;

        if (A2.ycoord == NULL)
            return -1;

        if (A1.ycoord < A2.ycoord)
            return 1;

        if (A1.ycoord > A2.ycoord)
            return -1;
    }

    if (A1.N.name < A2.N.name)
        return 1;

    if (A1.N.name > A2.N.name)
        return -1;

    return 0;
}

void
generateAttributes(node cls)
{
    cache_iterator  iter;
    cache_iterator  items;
    cache_iterator  nodeRefs;
    file            f;
    node_ref        nodeRef;
    item            I;
    int             pos, len;
    int             idx;
    list            S_ATs;
    AT              AT;
    string          multiplicity;

    S_ATs = list_create("AT", 0);

    iter = cache_find_nodes_by_scope_node(cls.id);
    iter = cache_find_all_by_attrs(iter, "type", "UmlAttribute");
    while (iter)
    {
        AT.N = cache_get_next(iter);
        AT.ycoord = NULL;

        nodeRefs = cache_find_node_refs_by_node(AT.N.id);
        while (nodeRefs)
        {
            nodeRef = cache_get_next(nodeRefs);
            f = cache_find_file_by_id(nodeRef.file_id);
            if (f.type == "UmlClassTable")
            {
                AT.ycoord = nodeRef.ycoord;
                break;
            }
        }

        list_append(S_ATs, AT);
    }

    // compare in reverse order
    S_ATs = list_sort(S_ATs, "cmp_attributes");

    for(idx = list_count(S_ATs) - 1; idx >= 0; idx--)
    {
        AT = list_get(S_ATs, idx);
        output("{ ", "MAttribute");
        outpId("  Id ", AT.N.id);
        output("  GUID ", AT.N.guid);
        output("  Name ", AT.N.name);

        items = cache_find_items_by_obj(AT.N.id);

        // Type
        I = cache_find_first_by_attrs(items, "type", "UmlAttributeType");
        if (I != NULL && I.value != NULL && string_length(I.value))
        {
            pos = string_find(I.value, 0, "[");
            len = string_length(I.value);

            if (pos < len)
            {
                output("  Type ", string_extract(I.value, 0, pos));

                multiplicity = string_strip(string_extract(I.value, pos + 1, len - pos - 2), "B", " ");
                if(multiplicity == "") // special case for C/C++: 'char []'
                    output("  Multiplicity ", "NONE");
                else
                    output("  Multiplicity ", multiplicity);
            }
            else
                output("  Type ", I.value);
        }

        // Access
        output("  Access ", getVisibility(AT.N.id));

        // DefaultValue
        I = cache_find_first_by_attrs(items, "type", "UmlAttributeDefaultValue");
        if (I != NULL)
            output("  DefaultValue ", I.value);

        // Key
        I = cache_find_first_by_attrs(items, "type", "UniqueID");
        if (I != NULL && I.value != NULL && string_length(I.value))
            output("  Key ", "True");
        else
            output("  Key ", "False");

        // Binding
        I = cache_find_first_by_attrs(items, "type", "UmlMemberIsClass");
        if (I != NULL && I.value == "True")
            output("  Binding ", "static");
        else
            output("  Binding ", "normal");

        // Derived
        I = cache_find_first_by_attrs(items, "type", "UmlAttributeIsDerived");
        if (I != NULL && I.value == "True")
            output("  Derived ", "True");
        else
            output("  Derived ", "False");

        // Description
        output("  Desc ", getDescription(AT.N.id));

        output("", "}");
    }
    list_clear(S_ATs);
}

//////////////////////////////////////////////////////////////////////////////////
// struct for sorting operations
struct OP {
    node N;
    int is_constructor; // 0 = default-constr, 1 = constr, 2 = destruct, 3 = other
    int visibility; // 0 = public, 1 = protected, 2 = private
    int is_virtual;
    int ycoord;
};

// sorter callback function, remember to sort in reverse order
// ECR 6372
int
cmp_operations(OP O1, OP O2)
{
    if (O1.visibility < O2.visibility)
        return 1;

    if (O1.visibility > O2.visibility)
        return -1;

    if (O1.is_constructor < O2.is_constructor)
        return 1;

    if (O1.is_constructor > O2.is_constructor)
        return -1;

    if (O1.is_virtual > O2.is_virtual)
        return 1;

    if (O1.is_virtual < O2.is_virtual)
        return -1;

    if (O1.ycoord != NULL || O2.ycoord != NULL)
    {
        if (O1.ycoord == NULL)
            return 1;

        if (O2.ycoord == NULL)
            return -1;

        if (O1.ycoord < O2.ycoord)
            return 1;

        if (O1.ycoord > O2.ycoord)
            return -1;
    }

    if (O1.N.name < O2.N.name)
        return 1;

    if (O1.N.name > O2.N.name)
        return -1;

    return 0;
}

// ECR 6372
void
generateOperations(node cls)
{
    cache_iterator  opers;
    cache_iterator  items;
    cache_iterator  notes;
    cache_iterator  nodeRefs;
    file            f;
    note            N;
    item            I;
    node_ref        nodeRef;
    int             idx;
    list            S_OPs;
    OP              OP;

    S_OPs = list_create("OP", 0);

    opers = cache_find_nodes_by_scope_node(cls.id);
    opers = cache_find_all_by_attrs(opers, "type", "UmlOperation");
    while (opers)
    {
        OP.N = cache_get_next(opers);
        OP.ycoord = NULL;

        if (OP.N.name == cls.name)
        {
            if(OP.N.sig == "")
                OP.is_constructor = 0;
            else
                OP.is_constructor = 1;
        }
        else if (string_extract(OP.N.name, 0, 1) == "~")
            OP.is_constructor = 2;
        else
            OP.is_constructor = 3;

        items = cache_find_items_by_obj(OP.N.id);

        I = cache_find_first_by_attrs(items, "type", "UmlOperationCxxIsVirtual");
        if (I != NULL && I.value == "True")
            OP.is_virtual = 1;
        else
        {
            I = cache_find_first_by_attrs(items, "type", "UmlOperationIsAbstract");
            if (I != NULL && I.value == "True")
                OP.is_virtual = 1;
            else
                OP.is_virtual = 0;
        }

        I = cache_find_first_by_attrs(items, "type", "UmlMemberCxxVisibility");
        if (I == NULL)
            I = cache_find_first_by_attrs(items, "type", "UmlMemberVisibility");
        if (I != NULL)
        {
            if (I.value == "public")
                OP.visibility = 0;
            else if (I.value == "protected")
                OP.visibility = 1;
            else
                OP.visibility = 2;
        }
        else
            OP.visibility = 2;

        nodeRefs = cache_find_node_refs_by_node(OP.N.id);
        while (nodeRefs)
        {
            nodeRef = cache_get_next(nodeRefs);
            f = cache_find_file_by_id(nodeRef.file_id);
            if (f.type == "UmlClassTable")
            {
                OP.ycoord = nodeRef.ycoord;
                break;
            }
        }

        list_append(S_OPs, OP);
    }

    S_OPs = list_sort(S_OPs, "cmp_operations"); // compare in reverse order

    for (idx = list_count(S_OPs) - 1; idx >= 0; idx--)
    {
        OP = list_get(S_OPs, idx);

        items = cache_find_items_by_obj(OP.N.id);

        output("{ ", "MOperation");
        outpId("  Id ", OP.N.id);
        output("  GUID ", OP.N.guid);
        output("  Name ", OP.N.name);

        // ReturnType
        I = cache_find_first_by_attrs(items, "type", "UmlOperationReturnType");
        if (I != NULL)
            output("  ReturnType ", I.value);

        // Access
        output("  Access ", getVisibility(OP.N.id));

        // Binding
        I = cache_find_first_by_attrs(items, "type", "UmlOperationCxxIsVirtual");
        if (I != NULL && I.value == "True")
            output("  Binding ", "virtual");
        else
        {
            I = cache_find_first_by_attrs(items, "type", "UmlMemberIsClass");
            if (I != NULL && I.value == "True")
                output("  Binding ", "static");
            else
                output("  Binding ", "normal");
        }

        // Description
        output("  Desc ", getDescription(OP.N.id));

        // ActionBlock
        notes = cache_find_notes_by_obj(OP.N.id);
        N = cache_find_first_by_attrs(notes, "type", "UmlExtensibilityDefinition");
        if (N != NULL)
            output("  ActionBlock ", getLine(N.desc));

        // Parameters
        indentCount++;
        generatePara(to_string(OP.N.id), OP.N.guid, "OpPara", OP.N.sig);
        indentCount--;

        output("", "}");
    }

    list_clear(S_OPs);
}

// ECR 4653, 4661 begin
set cnc_state_ids; // Composite states without concurrent subregions inside
set cc_state_ids;  // Composite states with concurrent subregions inside
set region_ids;    // Concurrent subregions
set state_types;   // Application types of states


void
allocateCompositesInfoStructures()
{
    cnc_state_ids = set_create("int");
    cc_state_ids  = set_create("int");
    region_ids    = set_create("int");
    state_types   = set_create("string");
    set_add(state_types, "UmlState");
    set_add(state_types, "UmlInitialState");
    set_add(state_types, "UmlFinalState");
    set_add(state_types, "UmlHistoryState");
    set_add(state_types, "UmlJunctionPoint");
    set_add(state_types, "UmlDynamicChoicePoint");
    // ECR 7967 begin
    set_add(state_types, "UmlSplitControl");
    set_add(state_types, "UmlMergeControl");
    // ECR 7967 end
}

void
deallocateCompositesInfoStructures()
{
    set_clear(cnc_state_ids);
    set_clear(cc_state_ids);
    set_clear(region_ids);
    set_clear(state_types);
}

void
retrieveCompositesInfo()
{
    cache_iterator  iter;
    cache_iterator  states;
    int             cnt, idx;
    string          query;
    item            I;
    node            N;
    file            f;
    node_ref        nodeRef;
    list            scope_ids;     // Contains scope ids of concurrent regions
    list            state_ids;     // Temporary used list
    list            state_types;     // Temporary used list

    allocateCompositesInfoStructures();

    scope_ids = list_create("int", 0);
    state_ids = list_create("int", 0);

    iter = cache_find_items_by_type("UmlConcurrentState");
    while (iter)
    {
        I = cache_get_next(iter);
        set_add(region_ids, I.obj_id);
    }

    state_types = list_create("string", 0);
    list_append(state_types, "UmlState");
    list_append(state_types, "UmlInitialState");
    list_append(state_types, "UmlFinalState");
    list_append(state_types, "UmlHistoryState");

    cnt = list_count(state_types);
    for (idx = 0; idx < cnt; idx++)
    {
        states = cache_find_nodes_by_type(list_get(state_types, idx));
        while (states)
        {
            N = cache_get_next(states);

            iter = cache_find_node_refs_by_node(N.id);
            while (iter)
            {
                nodeRef = cache_get_next(iter);
                f = cache_find_file_by_id(nodeRef.file_id);
                if (f.type == "UmlStateDiagram")
                {
                    list_append(state_ids, N.id);
                    list_append(scope_ids, N.scope_node_id);
                    break;
                }
            }
        }
    }

    list_clear(state_types);

    cnt = list_count(state_ids);
    for (idx = 0; idx < cnt; ++idx)
    {
        if (set_is_member(region_ids, list_get(state_ids, idx)))
        {
            set_add(cc_state_ids, list_get(scope_ids, idx));
        }
        else if (cnt != list_find(state_ids, 0, list_get(scope_ids, idx)))
        {
            set_add(cnc_state_ids, list_get(scope_ids, idx));
        }
    }

    list_clear(scope_ids);
    list_clear(state_ids);
}
// ECR 4653, 4661 end


void
parse_transition_label(string label, list event_list, list guard_list, list action_list, list target_list)
{
    // form of label is:
    // event-signature '[' guard-condition ']' '/' action-expression '^' target-list

    int len, pos;
    string currstr;

    len = string_length(label);

    // first, process target-list
    pos = string_find(label, 0, "^");
    if (pos < len)
    {
        // found '^' character
        currstr = string_extract(label, pos + 1, len - pos - 1);
        label = string_extract(label, 0, pos);
        len = string_length(label);

        currstr = string_strip(currstr, "B", " ");
        if (currstr != "")
            parseActionList(target_list, currstr);
    }

    // then, process action-expression
    pos = string_find(label, 0, "/");
    if (pos < len)
    {
        // found '/' character
        currstr = string_extract(label, pos + 1, len - pos - 1);
        label = string_extract(label, 0, pos);
        len = string_length(label);

        currstr = string_strip(currstr, "B", " ");
        if (currstr != "")
            parseActionList(action_list, currstr);
    }

    // then, process guard-condition
    pos = string_find(label, 0, "[");
    if (pos < len)
    {
        // found '[' character
        currstr = string_extract(label, pos + 1, len - pos - 1);
        label = string_extract(label, 0, pos);
        len = string_length(label);

        pos = string_find(currstr, 0, "]");
        if (pos < string_length(currstr))
            currstr = string_extract(currstr, 0, pos);

        currstr = string_strip(currstr, "B", " ");
        if (currstr != "")
            list_append(guard_list, currstr);
    }

    // the rest is event-signature
    currstr = string_strip(label, "B", " ");
    if (currstr != "")
// ECR 6369 begin
//        list_append(event_list, currstr);
    {
        parseActionList(event_list, currstr);
        if (list_count(event_list) > 1)
        {
            // UML allows only 0 or 1 event per transition link
            print_error("Transition link '" + label + "' has " + list_count(event_list) + " events!");
        }
    }
// ECR 6369 end
}

int junction_point_counter = 0;
int dynamic_choice_point_counter = 0;
int split_control_counter = 0;
int merge_control_counter = 0;

void
generateStateMachine(node cls, node EnclosingSM, node SM, set events, set eventIds)
{
    node            stateScope, node_state, N;
    link            L;
    string          stateType;
    string          stateKind = "";
    set             doubles;
    cache_iterator  transitions;
    cache_iterator  states;
    cache_iterator  items;
    cache_iterator  eventsIter;
    cache_iterator  iter;
    string          eventName;
    string          eventPara;
    list            eventNameList;
    int             i;
    item            it;
    boolean         isEntryLevel;
    boolean         found;
    node_ref        NR;
    file            F;
    cache_iterator  refs;
    boolean         isConcurrent;
    boolean         isRegion;

    if (EnclosingSM == NULL)
    {
        stateScope = SM;
        EnclosingSM = stateScope;

        isEntryLevel = True;
    }
    else
    {
        states = cache_find_nodes_by_scope_node(cls.id);
        if (cache_find_first_by_attrs(states, "type", "UmlState") == NULL &&
            cache_find_first_by_attrs(states, "type", "UmlInitialState") == NULL &&
            cache_find_first_by_attrs(states, "type", "UmlFinalState") == NULL &&
            cache_find_first_by_attrs(states, "type", "UmlHistoryState") == NULL)
        {
            return;
        }

        stateScope = cls;

        isEntryLevel = False;
    }

    if (!isEntryLevel)
    {
        output("{ ", "StateMachine");
        indentCount++;
    }

    // Transitions puffern; all transitions belong to
    // EnclosingSM

    transitions = cache_find_links_by_scope_node(EnclosingSM.id);
    transitions = cache_find_all_by_attrs(transitions, "type", "UmlTransition");

    while (transitions)
    {
        L = cache_get_next(transitions);

        //mel:commented out: do you need the item or the node?
        items = cache_find_items_by_obj(L.id);
        it = cache_find_first_by_attrs(items, "type", "UmlTransitionEvent");

        if (it == NULL)
            continue;
        if (set_is_member(events, it.value))
            continue;
        if (it.value == "")
            continue;

        set_add(events, it.value);
        set_add(eventIds, to_string(L.id) + "_ReceiveEvent");

        if (stateScope == EnclosingSM)
        {
            eventNameList = string_to_list(it.value, "()");

            if (list_count(eventNameList) == 2)
            {
                eventName = list_get(eventNameList, 0);
                eventPara = list_get(eventNameList, 1);
            }
            else
            {
                eventName = list_get(eventNameList, 0);
                eventPara = "";
            }

            output("{ ", "ReceiveEvent");
            output("  Id ", to_string(L.id) + "_ReceiveEvent");
            output("  GUID ", L.guid + "_ReceiveEvent");
            output("  Name ", eventName);

            indentCount++;
            generatePara(L.id + "_ReceiveEvent", L.guid + "_ReceiveEvent", "EvPara", eventPara);
            indentCount--;

            output("", "}");
        }
    }

    // Ignore Events without corresponding Receive Event
    eventsIter = cache_find_nodes_by_type("UmlDeferredEvent");
    while (eventsIter)
    {
        N = cache_get_next(eventsIter);
        if (set_is_member(events, N.name))
            continue;

        found = False;
        iter = cache_find_links_by_to_node(N.id);
        iter = cache_find_all_by_attrs(iter, "type", "UmlDeferredEventLink");
        while (iter)
        {
            L = cache_get_next(iter);

            node_state = cache_find_node_by_id(L.from_node_id);

            if (node_state.scope_node_id != stateScope.id)
                continue;

            if (!set_is_member(state_types, node_state.type))
                continue;

            refs = cache_find_node_refs_by_node(node_state.id);
            while (refs)
            {
                NR = cache_get_next(refs);
                F = cache_find_file_by_id(NR.file_id);
                if (F.type == "UmlStateDiagram")
                {
                    found = True;
                    break;
                }
            }
            if (!found)
                continue;

            break;
        }
        if (!found)
            continue;

        eventNameList = string_to_list(N.name,"()");
        eventName = "";
        eventPara = "";
        if (list_count(eventNameList) == 2)
        {
            eventName = list_get(eventNameList, 0);
            eventPara = list_get(eventNameList, 1);
        }
        else
        {
            eventName = list_get(eventNameList, 0);
            eventPara = "";
        }

        set_add(events, eventName);
        set_add(eventIds, to_string(N.id));

        output("{ ", "ReceiveEvent");
        outpId("  Id ", N.id);
        output("  GUID ", N.guid);
        output("  Name ",eventName);

        // Parameters
        indentCount++;
        generatePara(to_string(N.id), N.guid, "EvPara", eventPara);
        indentCount--;

        output("", "}");
    }

    // States and actions
    doubles = set_create("string");

    states = cache_find_nodes_by_scope_node(stateScope.id);
    while (states)
    {
	stateKind = "";
        node_state = cache_get_next(states);

        if (!set_is_member(state_types, node_state.type))
            continue;

        found = False;
        refs = cache_find_node_refs_by_node(node_state.id);
        while (refs)
        {
            NR = cache_get_next(refs);
            F = cache_find_file_by_id(NR.file_id);
            if (F.type == "UmlStateDiagram")
            {
                found = True;
                break;
            }
        }

        if (!found)
            continue;

        if ( node_state.name != "")
        {
            if (set_is_member(doubles, node_state.name + "_" + node_state.type))
            {
                print_error("ERROR uml2Interface: state  " + node_state.name + " does already exist !");
                continue;
            }

            set_add(doubles, node_state.name + "_" + node_state.type);
        }

        if (node_state.type == "UmlState" && set_is_member(region_ids, node_state.id))
        {
            // Concurrent subregions are mapped to 'CompositeState'
            // with 'isConcurrent' == FALSE and 'isRegion' == TRUE
            stateType = "CompositeState";
            isConcurrent = False;
            isRegion = True;
        }
        else if (node_state.type == "UmlState" && set_is_member(cc_state_ids, node_state.id))
        {
            stateType = "CompositeState";
            isConcurrent = True;
            isRegion = False;
        }
        else if (node_state.type == "UmlState" && set_is_member(cnc_state_ids, node_state.id))
        {
            stateType = "CompositeState";
            isConcurrent = False;
            isRegion = False;
        }
        else
        {
            // State
            stateType = "PseudoState";
            if (node_state.type == "UmlState")
                stateType = "NormalState";
            else if (node_state.type == "UmlInitialState")
                stateType = "CreationState";
            else if (node_state.type == "UmlFinalState")
                stateType = "FinalState";
            else if (node_state.type == "UmlHistoryState")
                stateKind = "HistoryState";
            else if (node_state.type == "UmlJunctionPoint")
                stateKind = "JunctionPoint";
            else if (node_state.type == "UmlDynamicChoicePoint")
                stateKind = "DynamicChoicePoint";
            // ECR 7967 begin
            else if (node_state.type == "UmlSplitControl")
                stateKind = "SplitControl";
            else if (node_state.type == "UmlMergeControl")
                stateKind = "MergeControl";
            // ECR 7967 end
        }

        output("{ ", stateType);
        output("  Kind ", stateKind);
        outpId("  Id ", node_state.id);
        output("  GUID ", node_state.guid);

        if (stateKind == "JunctionPoint")
            output("  Name ", "JunctionPoint_" + to_string(junction_point_counter++));
        else if (stateKind == "DynamicChoicePoint")
            output("  Name ", "DynamicChoicePoint_" + to_string(dynamic_choice_point_counter++));
        // ECR 7967 begin
        else if (stateKind == "SplitControl")
            output("  Name ", "SplitControl_" + to_string(split_control_counter++));
        else if (stateKind == "MergeControl")
            output("  Name ", "MergeControl_" + to_string(merge_control_counter++));
        // ECR 7967 end
        else
            output("  Name ", node_state.name);

        if (stateType == "CompositeState")
        {
            if (isConcurrent)
                output("  IsConcurrent ", "TRUE");
            if (isRegion)
                output("  IsRegion ", "TRUE");
        }

        indentCount++;

        generateStateMachine(node_state, EnclosingSM, NULL, events, eventIds);
        eventsIter = cache_find_nodes_by_type("UmlDeferredEvent");
        while (eventsIter)
        {
            N = cache_get_next(eventsIter);

            iter = cache_find_links_by_from_node(node_state.id);
            if (cache_find_first_by_attrs(iter, "to_node_id", N.id,
                                          "type", "UmlDeferredEventLink") == NULL)
            {
                continue;
            }

            eventNameList = string_to_list(N.name,"()");
            eventName = list_get(eventNameList,0);

            for (i = 0; i < set_count(events); i++)
            {
                if (set_get_element(events,i) == eventName)
                {
                    output("{ ", "IgnoreEvent");
                    output("  MEventId ", to_string(set_get_element(eventIds,i)));
                    output("", "}");
                    break;
                }
            }
        }

        indentCount--;

        // ActionBlock
        eventsIter = cache_find_links_by_from_node(node_state.id);
        eventsIter = cache_find_all_by_attrs(eventsIter, "type", "UmlStateActivity");
        while (eventsIter)
        {
            L = cache_get_next(eventsIter);
            output("  ActivityId ", to_string(L.id));
        }

        eventsIter = cache_find_links_by_from_node(node_state.id);
        eventsIter = cache_find_all_by_attrs(eventsIter, "type", "UmlStateEntryAction");
        while (eventsIter)
        {
            L = cache_get_next(eventsIter);
            output("  EntryActionId ", to_string(L.id));
        }

        eventsIter = cache_find_links_by_from_node(node_state.id);
        eventsIter = cache_find_all_by_attrs(eventsIter, "type", "UmlStateExitAction");
        while (eventsIter)
        {
            L = cache_get_next(eventsIter);
            output("  ExitActionId ", to_string(L.id));
        }

        output("", "}"); // End of state
    }

    if (!isEntryLevel)
    {
        indentCount--;
        output("", "}"); // End of state machine
    }
}

void
generateStateMachineTransitions(node SM, set events, set eventIds)
{
    link            L;
    string          guard, event, target;
    cache_iterator  refs;
    cache_iterator  transitions;
    string          eventName;
    string          eventPara;
    list            eventNameList;
    list            list_event_target;
    int             s, pos;
    list            event_list;
    list            guard_list;
    list            action_list;
    list            target_list;
    boolean         found;
    link_ref        LR;
    file            F;

    transitions = cache_find_links_by_scope_node(SM.id);
    transitions = cache_find_all_by_attrs(transitions, "type", "UmlTransition");
    while (transitions)
    {
        L = cache_get_next(transitions);

        found = False;
        refs = cache_find_link_refs_by_link(L.id);
        while (refs)
        {
            LR = cache_get_next(refs);
            F = cache_find_file_by_id(LR.file_id);
            if (F.type == "UmlStateDiagram")
            {
                found = True;
                break;
            }
        }

        if (!found)
            continue;

        output("{ ", "MTransition");
        outpId("  Id ", L.id);
        output("  GUID ", L.guid);
        output("  fromStateId ", to_string(L.from_node_id));
        output("  toStateId ", to_string(L.to_node_id));

        if (L.name != "")
        {
            event_list = list_create("string", 0);
            guard_list = list_create("string", 0);
            action_list = list_create("string", 0);
            target_list = list_create("string", 0);

            parse_transition_label(L.name, event_list, guard_list, action_list, target_list);

            if (list_count(event_list) > 0)
            {
                event = list_get(event_list, 0);
                event = string_strip(event, "B", " ");
                for (s = 0; s < set_count(events); s++)
                {
                    if (set_get_element(events, s) == event)
                    {
                        output("  MEventId ", to_string(set_get_element(eventIds, s)));
                        break;
                    }
                }
            }

            indentCount++;
            if (list_count(guard_list) > 0)
            {
                guard = list_get(guard_list, 0);
                guard = string_strip(guard, "B", " ");
                output("{ ", "MGuard");
                output("  Id ", L.id + "_GUARD");
                output("  GUID ", L.guid + "_GUARD");
                output("  Expression ", guard);
                output("", "}");
            }

            for (pos = 1; pos <= list_count(action_list); pos++)
            {
                output("{ ", "MAction");
                output("  Id ", L.id + "_TA_" + to_string(pos));
                output("  GUID ", L.guid + "_TA_" + to_string(pos));
                output("  Name ", string_strip(list_get(action_list, pos-1), "B", " \t"));
                output("", "}");  // End of action
            }

            // Extract Targets
            for (pos = 1; pos <= list_count(target_list); pos++)
            {
                list_event_target = string_to_list(list_get(target_list, pos-1), ".");
                target = "";
                event = "";

                if (list_count(list_event_target) > 1)
                {
                    target = list_get(list_event_target, 0);
                    event = list_get(list_event_target, 1);
                }
                else if (list_count(list_event_target) == 1)
                {
                    event = list_get(list_event_target, 0);
                }
                output("{ ", "MTarget");
                output("  Id ", L.id + "_TARGET_" + to_string(pos));
                output("  GUID ", L.guid + "_TARGET_" + to_string(pos));
                output("  Target ", target);

                eventNameList = string_to_list(event,"()");
                eventName = "";
                eventPara = "";

                if(list_count(eventNameList) > 1)
                {
                    eventName = list_get(eventNameList,0);
                    eventPara = list_get(eventNameList,1);
                }
                else if (list_count(eventNameList) == 1)
                {
                    eventName = list_get(eventNameList,0);
                    eventPara = "";
                }

                indentCount++;
                output("{ ", "SendEvent");
                output("  Id ", "SE_" + L.id + "_" + to_string(pos));
                output("  GUID ", "SE_" + L.guid + "_" + to_string(pos));
                output("  Name ",eventName);

                indentCount++;
                generatePara("SE_" + L.id + "_" + pos, "SE_" + L.guid + "_" + pos, "EvPara", eventPara);
                indentCount--;

                output("", "}");
                indentCount--;

                output("", "}");  // End of target
            }
            indentCount--;

            list_clear(event_list);
            list_clear(guard_list);
            list_clear(action_list);
            list_clear(target_list);
        }
        output("", "}");  // End of transition
    }
}

void
generateStateMachineEx(node cls, node SM)
{
    output("{ ", "StateMachine");
    outpId("  Id ", SM.id);
    output("  GUID ", SM.guid);
    output("  Desc ", getDescription(SM.id));

    set events;
    set eventIds;

    events = set_create("string");
    eventIds = set_create("string");

    indentCount++;

    generateStateMachine(cls, NULL, SM, events, eventIds);  // process everything but transitions and collect events, then
    generateStateMachineTransitions(SM, events, eventIds);  // process transitions

    indentCount--;

    set_clear(events);
    set_clear(eventIds);

    output("", "}");
}

//////////////////////////////////////////////////////////////////////////////////

void
parseActionList(list list_action, string actions)
{
    string action = "", char;
    int pos = 0;
    int length = string_length(actions);
    int parse_state = 0;

    while (pos < length)
    {
        char = string_extract(actions, pos, 1);
        if (parse_state == 0)
        {
            if (char == ",")
            {
                list_append(list_action, action);
                action = "";
            }
            else if (char == "(")
            {
                action += char;
                parse_state++;
            }
            else
                action += char;
        }
        else if (parse_state == 1)
        {
            action += char;
            if (char == ")")
                parse_state--;
        }

        pos++;
    }

    if (action != "")
        list_append(list_action, action);
}

//////////////////////////////////////////////////////////////////////////////////

void
generateAssociations()
{
    list            assocList;
    cache_iterator  nodeAssociations;
    node            nodeAssociation;
    node            nodeAssocClass;
    cache_iterator  linkRoles;
    link            linkRole;
    cache_iterator  items;
    item            I;
    boolean         anyExplicitNavigable;

    nodeAssociations = cache_find_nodes_by_type("UmlAssociation");
    while (nodeAssociations)
    {
        nodeAssociation = cache_get_next(nodeAssociations);

        output("{ ", "MAssociation");
        outpId("  Id ", nodeAssociation.id);
        output("  GUID ", nodeAssociation.guid);

        assocList = string_to_list(nodeAssociation.name, ":");
        if (list_count(assocList) == 2)
            output("  Name ", list_get(assocList, 0));

        output("  Desc ", getDescription(nodeAssociation.id));

        nodeAssocClass = NULL;
        linkRoles = cache_find_links_by_from_node(nodeAssociation.id);
        linkRoles = cache_find_all_by_attrs(linkRoles, "type", "UmlAssociationClassLink");
        while (linkRoles)
        {
            linkRole = cache_get_next(linkRoles);
            nodeAssocClass = cache_find_node_by_id(linkRole.to_node_id);
            if (nodeAssocClass.type == "UmlClass")
                break;
            nodeAssocClass = NULL;
        }

        if (nodeAssocClass != NULL)
            output("  AssocClassId ", to_string(nodeAssocClass.id));

        anyExplicitNavigable = False;
        linkRoles = cache_find_links_by_to_node(nodeAssociation.id);
        linkRoles = cache_find_all_by_attrs(linkRoles, "type", "UmlRole");
        while (linkRoles)
        {
            linkRole = cache_get_next(linkRoles);

            items = cache_find_items_by_obj(linkRole.id);
            I = cache_find_first_by_attrs(items, "type", "UmlRoleNavigability");
            if (I != NULL && I.value == "True")
            {
                anyExplicitNavigable = True;
                break;
            }
        }

        indentCount++;
        linkRoles = cache_find_links_by_to_node(nodeAssociation.id);
        linkRoles = cache_find_all_by_attrs(linkRoles, "type", "UmlRole");
        while (linkRoles)
        {
            linkRole = cache_get_next(linkRoles);

            output("{ ", "MAssociationEnd");
            outpId("  Id ", linkRole.id);
            output("  GUID ", linkRole.guid);
            output("  MClassId ", to_string(linkRole.from_node_id));

            if (linkRole.name != "")
                output("  Name ", linkRole.name);

            output("  Desc ", getDescription(linkRole.id));

            items = cache_find_items_by_obj(linkRole.id);

            I = cache_find_first_by_attrs(items, "type", "UmlRoleNavigability");
            if (I != NULL && I.value != "")
            {
                if (anyExplicitNavigable)
                    output("  isNavigable ", to_upper(I.value));
            }
            else
            {
                if (anyExplicitNavigable)
                    output("  isNavigable ", "FALSE");
            }

            I = cache_find_first_by_attrs(items, "type", "UmlAggregationType");
            if (I != NULL && I.value != "")
                output("  Aggregation ", I.value);
            else
                output("  Aggregation ", "None");


            I = cache_find_first_by_attrs(items, "type", "UmlMultiplicity");
            if (I != NULL)
                output("  Multiplicity ", I.value);

            I = cache_find_first_by_attrs(items, "type", "UmlRoleIsOrdered");
            if (I != NULL && I.value != "")
                output("  Ordering ", I.value);
            else
                output("  Ordering ", "FALSE");

            I = cache_find_first_by_attrs(items, "type", "UmlRoleQualifier");
            if (I != NULL)
            {
                indentCount++;
                generatePara(to_string(linkRole.id), linkRole.guid, "MAttribute", I.value);
                indentCount--;
            }

            output("", "}"); // end of association role
        }
        indentCount--;

        output("", "}"); // end of association
    }
}

////////////////////////////////////////////////////////////////////////////////

void
generateNestedClasses()
{
    cache_iterator  myScopes;
    item            myScope;
    cache_iterator  myClasses;
    node            myClass;
    note            note_claInf;

    //mel:  *one* nested Class or all???  if( myScope = find_by_query("item[UmlEnclosingScope]"))
    myScopes = cache_find_items_by_type("UmlEnclosingScope");
    myScopes = cache_find_all_by_diff_attrs(myScopes, "value", "");
    while (myScopes)
    {
        myScope = cache_get_next(myScopes);

        myClasses = cache_find_nodes_by_name(myScope.value);
        myClass = cache_find_first_by_attrs(myClasses, "type", "UmlClass");
        if (myClass == NULL)
        {
            myClass = cache_find_node_by_id(myScope.obj_id);
            message("Error: Could not find class scope with name " + myScope.value + " for class " + myClass.name + "!");
            message("Generating no nested class information for that class...");
            continue;
        }

        output("{ ", "MNested");
        output("  Id ", to_string(myClass.id) + "_" + to_string(myScope.obj_id));
        output("  NestedClassId ", to_string(myScope.obj_id));
        output("  EnclosingClassId ", to_string(myClass.id));

        // mel: Description
        // wf: not the description of the nested class, but the description of the nesting because
        // the description of the nested class is already part of that class
        note_claInf = cache_find_note_by_id(myScope.note_id);
        output("  Desc ", getLine(note_claInf.desc));
        output("", "}");
    }
}

//////////////////////////////////////////////////////////////////////////////////

void
generateInheritances()
{
    int             i;
    link            L;
    node            N;
    cache_iterator  Ls;
    cache_iterator  iter;
    list            link_types;

    link_types = list_create("string", 0);
    list_append(link_types, "UmlRefines");
    list_append(link_types, "UmlGeneralization");

    for (i = list_count(link_types) - 1; i >= 0; i--)
    {
        Ls = cache_find_links_by_type(list_get(link_types, i));
        while (Ls)
        {
            L = cache_get_next(Ls);

            // special case: refine between two templates is generated as a generalization
            if (L.type == "UmlRefines")
            {
                N = cache_find_node_by_id(L.from_node_id);
                if (N.type != "UmlClass")
                    continue;

                iter = cache_find_nodes_by_name(N.name);
                if (cache_find_first_by_attrs(iter, "type", "UmlParameterizedClass") == NULL)
                {
                    // a link between a parameterized and some different class, no generalization
                    continue;
                }
            }

            // Inheritance between Use Cases are treated different
            N = cache_find_node_by_id(L.from_node_id);
            if (N.type == "UmlUseCase")
            {
                output("{ ", "UseCaseSpecialize");
                output("  SpecializeId ", to_string(L.from_node_id));
                output("  GeneralId ", to_string(L.to_node_id));
                output("", "}");
            }
            else if (N.type == "UmlPackage")
            {
                output("{ ", "MPackageInheritance");
                outpId("  Id ", L.id);
                output("  GUID ", L.guid);
                output("  childPackageId ", to_string(L.from_node_id));
                output("  parentPackageId ", to_string(L.to_node_id));
                output("  Name ", L.name);
                output("  Desc ", getDescription(L.id));
                output("", "}");
            }
            else if (N.type != "UmlActor" && N.type != "UmlEllipsis")
            {
                output("{ ", "MInheritance");
                outpId("  Id ", L.id);
                output("  GUID ", L.guid);
                output("  subClassId ", to_string(L.from_node_id));
                output("  superClassId ", to_string(L.to_node_id));
                output("  Name ", L.name); // ECR 6649
                output("  Desc ", getDescription(L.id));
                output("", "}");
            }
        }
    }

    list_clear(link_types);
}

//////////////////////////////////////////////////////////////////////////////////
void
generateDependencies()
{
    node            N;
    link            L;
    cache_iterator  Ls;
    set             dependent_types;

    dependent_types = set_create("string");
    set_add(dependent_types, "UmlPackage");
    set_add(dependent_types, "UmlClass");
    set_add(dependent_types, "UmlAttribute");
    set_add(dependent_types, "UmlOperation");

    Ls = cache_find_links_by_type("UmlDependency");
    while (Ls)
    {
        L = cache_get_next(Ls);

        N = cache_find_node_by_id(L.from_node_id);
        if (!set_is_member(dependent_types, N.type))
            continue;

        N = cache_find_node_by_id(L.to_node_id);
        if (!set_is_member(dependent_types, N.type))
            continue;

        output("{ ", "Dependency");
        outpId("  Id ", L.id);
        output("  GUID ", L.guid);
        output("  supplierId ", to_string(L.to_node_id));
        output("  clientId ", to_string(L.from_node_id));
        output("  Name ", L.name);
        output("  Desc ", getDescription(L.id));
        output("", "}");
    }

    set_clear(dependent_types);
}

//////////////////////////////////////////////////////////////////////////////////

void
generateInterfaces()
{
    node            N;
    cache_iterator  Ls;
    link            L;
    cache_iterator  items;
    item            target_type;

    Ls = cache_find_links_by_type("UmlImplements");
    while (Ls)
    {
        L = cache_get_next(Ls);

        // ECR 6595 begin
        N = cache_find_node_by_id(L.from_node_id);
        if (N.type == "UmlPackage")
            continue;
        // ECR 6595 end
        items = cache_find_items_by_obj(L.to_node_id);
        target_type = cache_find_first_by_attrs(items, "type", "UmlStereotype");
        if (target_type && (target_type.value == "type" || target_type.value == "implementationClass"))
            continue;

        output("{ ", "Implementation");
        output("  InterfaceId ", to_string(L.to_node_id));
        output("  ClassId ", to_string(L.from_node_id));
        output("", "}");
    }
}

//////////////////////////////////////////////////////////////////////////////////

void
generateActors()
{
    node            N;
    cache_iterator  Ns;

    Ns = cache_find_nodes_by_type("UmlActor");
    while (Ns)
    {
        N = cache_get_next(Ns);

        output("", "{ MActor");
        outpId("  Id ", N.id);
        output("  GUID ", N.guid);
        output("  Name ", N.name);
        // output("  Desc ", getDescription(N.id)); ??? <<ivan>> actor does not have a description?
        output("", "}");
    }
}

//////////////////////////////////////////////////////////////////////////////////

void
generateRequirements()
{
    node            N;
    note            RT;
    cache_iterator  Ns, RaNs, RaIs;
    item            RaI;
    string          phase;

    Ns = cache_find_nodes_by_type("REQRequirement");
    while (Ns)
    {
        N = cache_get_next(Ns);

        output("{ ", "MRequirement");
        outpId("  Id ", N.id);
        output("  GUID ", N.guid);
        output("  Name ", N.name);

        RaNs = cache_find_notes_by_obj(N.id);
        RT = cache_find_first_by_attrs(RaNs, "type", "REQDefinitionNote");
        if (RT != NULL)
            output("  Desc ", getLine(RT.desc));
        output("", "}");
    }

    RaNs = cache_find_notes_by_type("REQAssignmentNote");
    while (RaNs)
    {
        RT = cache_get_next(RaNs);
        RaIs = cache_find_items_by_note(RT.id);
        while (RaIs)
        {
            RaI = cache_get_next(RaIs);
            Ns = cache_find_nodes_by_name(RaI.value);
            N = cache_find_first_by_attrs(Ns, "type", "REQRequirement");
            if (N != NULL)
            {
                output("{ ", "MReqAssign");
                output("  Id ", to_string(RaI.id));
                output("  MElementId ", to_string(RaI.obj_id));
                if (RaI.type == "REQAnalysisAssignmentItem")
                    phase = "Analysis";
                else if (RaI.type == "REQDesignAssignmentItem")
                    phase = "Design";
                else if (RaI.type == "REQImplementationAssignmentItem")
                    phase = "Implementation";
                else if (RaI.type == "REQTestAssignmentItem")
                    phase = "Test";
                else
                    phase = "";
                output("  Phase ", phase);
                output("  ReqId ", to_string(N.id));
                output("", "}");
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////

void
generateUseCases()
{
    node            N;
    node            P;
    cache_iterator  Ns;
    link            L;
    cache_iterator  Ls;

    Ns = cache_find_nodes_by_type("UmlUseCase");
    while (Ns)
    {
        N = cache_get_next(Ns);

        output("{ ", "MUseCase");
        outpId("  Id ", N.id);
        output("  GUID ", N.guid);

        // ECR 4797
        Ls = cache_find_links_by_to_node(N.id);
        Ls = cache_find_all_by_attrs(Ls, "type", "UmlContains");
        while (Ls)
        {
            L = cache_get_next(Ls);
            P = cache_find_node_by_id(L.from_node_id);
            if (P.type == "UmlPackage")
            {
                output("  MPackageId ", to_string(P.id));
                break;
            }
        }

        Ls = cache_find_links_by_to_node(N.id);
        Ls = cache_find_all_by_attrs(Ls, "type", "UmlUseCaseInteraction");
        while (Ls)
        {
            L = cache_get_next(Ls);
            output("  MActorId ", to_string(L.from_node_id));
        }

        output("  Name ", N.name);
        output("  Desc ", getDescription(N.id));
        output("", "}");
    }
}

//////////////////////////////////////////////////////////////////////////////////

void
generateUseCaseIncludesAndExtends()
{
    link            L;
    cache_iterator  Ls;
    int             i;
    list            link_types;

    link_types = list_create("string", 0);
    list_append(link_types, "UmlUseCaseUses");
    list_append(link_types, "UmlUseCaseExtends");

    for (i = list_count(link_types) - 1; i >= 0; i--)
    {
        Ls = cache_find_links_by_type(list_get(link_types, i));
        while (Ls)
        {
            L = cache_get_next(Ls);
            if (L.type == "UmlUseCaseUses")
            {
                output("{ ", "UseCaseInclude");
                output("  AdditionId ", to_string(L.from_node_id));
                output("  Include_BaseId ", to_string(L.to_node_id));
                output("", "}");
            }
            else
            {
                output("{ ", "MExtend");
                outpId("  Id ", L.id);
                output("  GUID ", L.guid);
                output("  ExtensionId ", to_string(L.from_node_id));
                output("  Extend_BaseId ", to_string(L.to_node_id));
                output("", "}");
            }
        }
    }

    list_clear(link_types);
}

//////////////////////////////////////////////////////////////////////////////////

void
generateAnnotations()
{
    cache_iterator  Ns;
    note            N;
    cache_iterator  Is;
    item            I;
    string          annot_filter;
    list            annot_filter_list;
    string          excl;
    list            excl_note, excl_item;
    int             excl_note_len, excl_item_len;
    int             i, j;

    // get annot list
    annot_filter = "item:UmlEnclosingScope;item:ObjectName;item:UmlTaggedValue;item:UmlCxxCodeGenId;" +
                    toolinfo_variable("tdl_annot_filter");
    annot_filter_list = string_to_list(annot_filter, ";");

    excl_note = list_create("string", 0);
    excl_item = list_create("string", 0);

    for (i = list_count(annot_filter_list) - 1; i >= 0; i--)
    {
        excl = list_get(annot_filter_list, i);
        if (string_length(excl) > 5)
        {
            if (string_extract(excl, 0, 5) == "note:")
                list_append(excl_note, string_extract(excl, 5, string_length(excl) - 5));
            else if (string_extract(excl, 0, 5) == "item:")
                list_append(excl_item, string_extract(excl, 5, string_length(excl) - 5));
        }
    }

    list_clear(annot_filter_list);

    excl_note_len = list_count(excl_note);
    excl_item_len = list_count(excl_item);

    for (i = 0; i < annotIdsCount; i++)
    {
        Ns = cache_find_notes_by_obj(list_get(annotIds, i));
        for (j = 0; j < excl_note_len; j++)
            Ns = cache_find_all_by_diff_attrs(Ns, "type", list_get(excl_note, j));

        while (Ns)
        {
            N = cache_get_next(Ns);

            Is = cache_find_items_by_note(N.id);
            Is = cache_find_all_by_diff_attrs(Is, "value", "");
            for (j = 0; j < excl_item_len; j++)
                Is = cache_find_all_by_diff_attrs(Is, "type", list_get(excl_item, j));

            if (N.desc == "" && !Is)
                continue;

            output("{ ", "MAnnotNote");
            output("  Id ", to_string(N.id));
            output("  MElementId ", to_string(N.obj_id));
            output("  Name ", N.name);
            output("  Type ", N.type);
            output("  Desc ", getLine(N.desc));

            indentCount++;
            while (Is)
            {
                I = cache_get_next(Is);

                output("{ ", "MAnnotItem");
                output("  Id ", to_string(I.id));
                output("  Type ", I.type);
                output("  Value ", getLine(I.value));
                output("", "}");
            }
            indentCount--;

            output("", "}");
        }
    }

    list_clear(excl_note);
    list_clear(excl_item);
}

//////////////////////////////////////////////////////////////////////////////////

void
generateTaggedValues()
{
    cache_iterator  Is;
    item            I;
    int             i, tvidx;
    string          tv;
    int             equalpos;
    list            taggedValueLs;

    for (i = 0; i < annotIdsCount; i++)
    {
        Is = cache_find_items_by_obj(list_get(annotIds, i));
        Is = cache_find_all_by_attrs(Is, "type", "UmlTaggedValue");
        while (Is)
        {
            I = cache_get_next(Is);

            taggedValueLs = string_to_list(I.value, "\12\15");
            for (tvidx = list_count(taggedValueLs) - 1; tvidx >= 0; tvidx--)
            {
                tv = list_get(taggedValueLs, tvidx);
                if(tv == "=")
                    continue;

                output("{ ", "MTaggedValue");
                output("  Id ", I.id + "_" + to_string(tvidx));
                output("  MElementId ", to_string(I.obj_id));

                equalpos = string_find(tv, 0, "=");
                if (equalpos < string_length(tv))
                {
                    output("  Tag ", string_strip(string_extract(tv, 0, equalpos), "B", " \t"));
                    output("  Value ", string_strip(string_extract(tv, equalpos + 1, string_length(tv) - equalpos - 1), "B", " \t"));
                }
                else
                {
                    output("  Tag ", string_strip(tv, "B", " \t"));
                    output("  Value ", "true");
                }
                output("", "}");
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////

void
generatePackage(node pkg)
{
    node            N;
    link            L;
    cache_iterator  links;

    output("{ ", "Package");
    outpId("  Id ", pkg.id);
    output("  GUID ", pkg.guid);
    output("  Name ", pkg.name);
    output("  Desc ", getDescription(pkg.id));

    indentCount++;

    links = cache_find_links_by_from_node(pkg.id);
    links = cache_find_all_by_attrs(links, "type", "UmlContains");
    while (links)
    {
        L = cache_get_next(links);
        N = cache_find_node_by_id(L.to_node_id);
        if (N.type == "UmlClass")
            generateClass(N);
        else if (N.type == "UmlPackage")
            generatePackage(N);
    }

    indentCount--;

    output("", "}");
}

void
generateClass(node cls)
{
    cache_iterator  nodes;
    node            SM;

    generateClassHeader(cls);

    indentCount++;

    if (with_dynamic_model)
        generateActionBlock(cls);

    generateAttributes(cls);
    generateOperations(cls);

    if (with_dynamic_model)
    {
        nodes = cache_find_nodes_by_name(cls.name);
        SM = cache_find_first_by_attrs(nodes, "type", "UmlStateMachine");
        if (SM != NULL)
            generateStateMachineEx(cls, SM);
    }

    indentCount--;

    output("", "}");
}

void
generatePackagesAndClasses()
{
    node            N;
    node            P;
    link            L;
    cache_iterator  nodes;
    cache_iterator  links;
    boolean         found;
    list            app_types;
    int             i;

    app_types = list_create("string", 0);
    list_append(app_types, "UmlClass");
    list_append(app_types, "UmlPackage");

    for (i = list_count(app_types) - 1; i >= 0; i--)
    {
        nodes = cache_find_nodes_by_type(list_get(app_types, i));
        while (nodes)
        {
            N = cache_get_next(nodes);

            found = False;
            links = cache_find_links_by_to_node(N.id);
            links = cache_find_all_by_attrs(links, "type", "UmlContains");
            while (links)
            {
                L = cache_get_next(links);
                P = cache_find_node_by_id(L.from_node_id);
                if (P.type == "UmlPackage")
                {
                    found = True;
                    break;
                }
            }

            if (!found)
            {
                if (N.type == "UmlPackage")
                    generatePackage(N);
                else if (N.type == "UmlClass")
                    generateClass(N);
            }
        }
    }

    list_clear(app_types);
}

///////////////////////////////////////////////////////////////////////////////////////////////

void
generateObjectInstances()
{
    node            myObject, myScope, myAttribute, myClass;
    cache_iterator  myScopes;
    cache_iterator  myObjects;
    cache_iterator  myAttributes;
    cache_iterator  iter;
    note            myNote;
    boolean         isAnonymous, withoutType;

    // for all instances, ignoring the anonymous ones

    myScopes = cache_find_nodes_by_type("UmlObjectClassScope");
    while (myScopes)
    {
        myScope = cache_get_next(myScopes);

        withoutType = False;
        if (string_length(myScope.name) >= 9 && string_extract(myScope.name, 0, 9) == "%%class%%")
            withoutType = True;

        if (!withoutType)
        {
            // look if the class is a known one
            iter = cache_find_nodes_by_name(myScope.name);
            myClass = cache_find_first_by_attrs(iter, "type", "UmlClass");
            if (myClass == NULL)
                continue;
        }

        myObjects = cache_find_nodes_by_scope_node(myScope.id);
        myObjects = cache_find_all_by_attrs(myObjects, "type", "UmlObjectInstance");
        while (myObjects)
        {
            myObject = cache_get_next(myObjects);

            isAnonymous = False;
            if (string_length(myObject.name) >= 10 && string_extract(myObject.name, 0, 10) == "%%object%%")
                isAnonymous = True;

            if (withoutType && isAnonymous)
                continue;

            output("{ ", "MObject");
            outpId("  Id ", myObject.id);
            output("  GUID ", myObject.guid);

            if (!withoutType)
                output("  MClassId ", to_string(myClass.id));

            if (!isAnonymous)
                output("  Name ", myObject.name);

            output("  Desc ", getDescription(myObject.id));

            indentCount++;
            myAttributes = cache_find_nodes_by_scope_node(myObject.id);
            myAttributes = cache_find_all_by_attrs(myAttributes, "type", "UmlObjectInstanceAttribute");
            while (myAttributes)
            {
                myAttribute = cache_get_next(myAttributes);

                output("{ ", "MAttribute");
                outpId("  Id ", myAttribute.id);
                output("  GUID ", myAttribute.guid);
                output("  Name ", myAttribute.name);
                output("  DefaultValue ", myAttribute.sig);
                output("  Desc ", getDescription(myAttribute.id));
                output("", "}");
            }
            indentCount--;

            output("", "}");
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////

void
generateCBExtensionsTaggedValues()
{
    cache_iterator  items;
    item            I;

    items = cache_find_items_by_type("UmlAttributeIDLIsReadOnly");
    items = cache_find_all_by_diff_attrs(items, "value", "");
    while (items)
    {
        I = cache_get_next(items);

        output("{ ", "MTaggedValue");
        output("  Id ", to_string(I.id));
        output("  MElementId ", to_string(I.obj_id));
        output("  Tag ", "UmlAttributeIDLDefinition:UmlAttributeIDLIsReadOnly");
        output("  Value ", I.value);
        output("", "}");
    }

    items = cache_find_items_by_type("UmlOperationThrows");
    items = cache_find_all_by_diff_attrs(items, "value", "");
    while (items)
    {
        I = cache_get_next(items);

        output("{ ", "MTaggedValue");
        output("  Id ", to_string(I.id));
        output("  MElementId ", to_string(I.obj_id));
        output("  Tag ", "UmlOperationDefinition:UmlOperationThrows");
        output("  Value ", I.value);
        output("", "}");
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////

void
generateStereotypes()
{
    int             i;
    item            I1, I2;
    node            N;
    link            L;
    set             setStereotypeName;
    cache_iterator  Node_StereoTypes;
    cache_iterator  Item_StereoTypes;
    cache_iterator  iter;
    boolean         generated;

    Item_StereoTypes = cache_find_items_by_type("UmlStereotype");
    Item_StereoTypes = cache_find_all_by_diff_attrs(Item_StereoTypes, "value", "");

    setStereotypeName = set_create("string");

    while (Item_StereoTypes)
    {
        I1 = cache_get_next(Item_StereoTypes);
        if (set_is_member(setStereotypeName, I1.value))
            continue;

        set_add(setStereotypeName, I1.value);
        generated = False;

        Node_StereoTypes = cache_find_nodes_by_name(I1.value);
        N = cache_find_first_by_attrs(Node_StereoTypes, "type", "UmlStereotype");
        if (N != NULL)
        {
            output("{ ", "MStereotype");
            outpId("  Id ", N.id);
            output("  Name ", getLine(N.name));
            output("  Desc ", getDescription(N.id));
            generated = True;
        }

        iter = cache_find_items_by_value(I1.value);
        iter = cache_find_all_by_attrs(iter, "type", "UmlStereotype");
        while (iter)
        {
            I2 = cache_get_next(iter);
            if (!annot_id_is_valid(I2.obj_id))
                continue;

            if (!generated)
            {
                output("{ ", "MStereotype");
                output("  Id ", I1.id + "_ST");
                output("  Name ", getLine(I1.value));
                generated = True;
            }

            output("  SemElementId ", to_string(I2.obj_id));
        }

        if (generated)
            output("", "}");
    }

    // Export stereotype nodes that don't have corresponding items.
    // They do not have semantic elements IDs (otherwise there would be some items)

    Node_StereoTypes = cache_find_nodes_by_type("UmlStereotype");
    for (i = set_count(setStereotypeName) - 1; i >= 0; i--)
        Node_StereoTypes = cache_find_all_by_diff_attrs(Node_StereoTypes, "name", set_get_element(setStereotypeName, i));

    while (Node_StereoTypes)
    {
        N = cache_get_next(Node_StereoTypes);

        output("{ ", "MStereotype");
        outpId("  Id ", N.id);
        output("  Name ", getLine(N.name));
        output("  Desc ", getDescription(N.id));
        output("", "}");
    }

    set_clear(setStereotypeName);

    // print Stereotype Inheritance
    iter = cache_find_links_by_type("UmlStereotypeInheritance");
    while (iter)
    {
        L = cache_get_next(iter);

        output("{ ", "MStereoInheritance");
        output("  ChildId ", to_string(L.from_node_id));
        output("  ParentId ", to_string(L.to_node_id));
        output("", "}");
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////

void
initCache()
{
    cache_add_by_query("node[node_refs]");
    cache_add_by_query("link[link_refs]");
    cache_add_by_query("cntx[cntx_refs]");
    cache_add_by_query("file[type != ObjectAnnotation]");
    cache_add_by_query("node_ref");
    cache_add_by_query("link_ref");
    cache_add_by_query("cntx_ref");
    cache_add_by_query("note[node[node_refs]]");
    cache_add_by_query("note[link[link_refs]]");
    cache_add_by_query("note[cntx[cntx_refs]]");
    cache_add_by_query("item[node[node_refs]]");
    cache_add_by_query("item[link[link_refs]]");
    cache_add_by_query("item[cntx[cntx_refs]]");
}

///////////////////////////////////////////////////////////////////////////////////////////////

void main()
{
    int now = time_now();

    message("Starting ... " + time_to_string(now, NULL));

    enable_oms_cache(False);

    initCache();

    annotIds = list_create("int", 0);

    retrieveCompositesInfo();

    // generate all packages not contained in other packages (top level packages)
    message("Packages ... " + time_to_string(time_now(), NULL) + " (" + to_string(time_now() - now) + ")");
    generatePackagesAndClasses();

    // Class Information
    message("Class Information ... " + time_to_string(time_now(), NULL) + " (" + to_string(time_now() - now) + ")");
    generateNestedClasses();
    generateInterfaces();
    if(with_dynamic_model == True)
        generateObjectInstances();
    generateTemplateBindings();
    if(with_use_cases == True)
    {
        generateActors();
        // if there are no Use Cases, there sure will be no Includes and Extends
        generateUseCases();
        generateUseCaseIncludesAndExtends();
    }

    generateAssociations();
    generateInheritances();
    generateDependencies();
    generateStereotypes();

    message("Annotations ... (" + list_count(annotIds) + ") " + time_to_string(time_now(), NULL) + " (" + to_string(time_now() - now) + ")");
    generateAnnotations();
    generateTaggedValues();
    generateCBExtensionsTaggedValues();

    generateRequirements();

    deallocateCompositesInfoStructures();

    list_clear(annotIds);

    message("Finished ... " + time_to_string(time_now(), NULL) + " (" + to_string(time_now() - now) + ")");
    message("Time used: " + to_string(time_now() - now));
}

