//*****************************************************************************
// $RCSfile: corbaidl_std.tdl,v $
// $Revision: 1.5 $
// $Date: 2002/04/04 14:48:44 $
// Author: Oliver Maus, Markus Kern
//*****************************************************************************

USES ../tdl/std;

////////////////////////////////////////////////////////////////////////////////
// standard functions
////////////////////////////////////////////////////////////////////////////////

/* Generates a marked section in the output. The content of this section can 
be changed by the user in the generated file. These changes will not be 
overwritten in subsequent cycles of code generation */
template mergeOut(uniqueId,desc)
//#ACD# M([uniqueId]) [desc]

	// [desc] to be added here ...

//#end ACD#
end template


/* this procedure is called once by main (defined in cpp_main.tdl) before
   any other procedure or template. It sets up the merge mechanism for 
   incremental code generation (delMergeFile and appendMergeFile).
   The current language for type mapping is defined (setLanguage) */
proc init()
	delMergeFile();
	appendMergeFile("merge_config_JAVA.txt");
	setLanguage("Java");
end proc	

template outDesc(Description)
[loop(Instances->TokenSet([Description]))]
[TokenSet.line]
[end loop]
end template

/*	write the description commented
*/
template commentedOutDesc(Description)
[loop(Instances->TokenSet([Description]))]
// [TokenSet.line]
[end loop]
end template

/* return tag of tagged value with tag==str */
proc getTaggedValueTag(MElement, str)
	loop(MElement->TaggedValue AS TG Where [TG.tag] == [str])
	return [TG.tag];
	end loop
end proc

/* return value of tagged value with tag==str */
proc getTaggedValueValue(MElement, str)
	loop(MElement->TaggedValue AS TG Where [TG.tag] == [str])
	return [TG.value];
	end loop
end proc

/*	Generates a list of all operation parameters for the
	following case:
	the marshalling information IN, OUT, INOUT is explicitely set
	for each operation paramter in the class table.
	Thus the marshalling information is explicitely generated
*/
template getOpTypeList(MOperation)
[loop(MOperation->OpPara;setDelim("");setDelim(","))]
[insert("import",[Class_[OpPara.type]])]
[delim()] [getMechanism([OpPara.mechanism])] [getDataType([OpPara.type])] [OpPara.name]\
[end loop]
end template

proc getMechanism(str)
    if ([str] == "")
        return "IN";
    else
        return [str];
    end if
end proc
        
/*	Generates a list of all operation parameters for the 
	following case:
	the marshalling information IN, OUT, INOUT is not explicitely
	set for the operation paramters in the class table.
	The marshalling information is generated by using the type
	mapping meschanism.
	For an example see the system Millennium_Clock_CORBA,
	all classes with stereotype <<MDataType>> are used for 
	type mapping.
*/
template getOpTypeListForTypeMapping(MOperation)
[loop(MOperation->OpPara;setDelim("");setDelim(","))]
[insert("import",[Class_[OpPara.type]])]
[delim()] [getDataType([OpPara.type])] [OpPara.name]\
[end loop]
end template

proc myHelp (schtring)
	info = "---> "[schtring]"\n";
end proc
proc getTheIdListRec(MClass)
[ID_LIST] = getIdListRec(MClass->Implement->SuperClass);
end proc

proc helpOutput()
info = getCount()"\n";
end proc



//--------------------------------------------------------------------------------------------

proc InterfaceHasStaticOps(MInterface, debug)
	if (hasLoop(MInterface->MOperation WHERE [MOperation.binding] == "static"))
		return "TRUE";
	end if
	return "FALSE";
end proc

template genStaticOperationsOfInterfaceHeader(MInterface, lang)
[//# LOOP for all static operations of Time Interface class:]
[loop (MInterface->MPackage)]
	[MPackage.name]::[genStaticInterfaceOp([MInterface], [lang])]
[end loop]
[//# ENDLOOP]
end template

// extract static operations from interface, 
// with type mapping of return value and signatures according to paramter lang
proc genStaticInterfaceOp(MInterface, lang)
	local retVal;
	setLanguage([lang]);	/* sets the tag for typemapping. See TDL documentation for further information */
	loop(MInterface->MOperation WHERE [MOperation.binding] == "static")
		[retVal] = getDataType([MOperation.returnType]) " ";
		[retVal] = [retVal] [MOperation.name]"("getOpTypeList([MOperation])")";
	end loop
	return [retVal];
end proc

/*	analyze the multiplicity at the opposite end of the association
	example: A-------->B
	                  *
	in the above example we have a many relation between class A and class B
	in this procedure we find out the multiplicity marked with * (many)
*/
proc getCorbaMultiplicity(MClass, MAssociationEnd AS FromRole, MAssociationEnd AS ToRole, MClass AS Partner)
	local schtring = "";
	
	// some meta properties, used below
//	[ToRole:Cardinality] = "";
	[ToRole:LowerValue] = "";
	[ToRole:UpperValue] = "";
	[ToRole:Instantiation] = "";
	
	// In case of composition and bidirectional relation there is past a this reference 
	// to the opposite instance, thus that needs an additional constructor
	local ptr_this = "";
	if ([FromRole.aggregation]=="Composition" && isBidirectional([FromRole], [ToRole])=="True")
		[ptr_this] = "this";
	end if
		
	switch([ToRole.multiplicity])

	case "":
	case "1":
	case "0..1":
	case "1..0":
	case "1..1":
	case "0..0":
		[ToRole:Instantiation] = "";
//		info = "One: \n";
		return "One";

	case "*":
	case "0..*":
	case "n":
	case "N":
		[ToRole:Instantiation] = "typedef sequence <"[Partner.name]"> "[ToRole.name]"_def;";
//		info = "Many1: \n";
		return "Many";

	case "1..*":
		[ToRole:LowerValue] = split([multiplicity],".","L");
		[ToRole:Instantiation] = "typedef sequence <"[Partner.name]"> "[ToRole.name]"_def;";
//	info = "Many2: \n";
		return "Many";
		
	case regexp([ToRole.multiplicity],"[2-9]+\.\.\n"):	
	case regexp([ToRole.multiplicity],"[2-9]+\.\.\N"):	
	case regexp([ToRole.multiplicity],"[2-9]+\.\.\*"):	
		[ToRole:LowerValue] = split([ToRole.multiplicity],".","L");
		[ToRole:Instantiation] = "typedef sequence <"[Partner.name]"> "[ToRole.name]"_def;";
//		info = "Many3: "[ToRole:LowerValue]"\n";
		return "Many";
		
	case regexp([ToRole.multiplicity],"[0-9]+"):
		[ToRole:UpperValue] = [ToRole.multiplicity];
		if (itemValueForType([ToRole],"UmlRoleIDLPatternFamily", "") == "array")
			[ToRole:Instantiation] = "typedef "[Partner.name]" "[ToRole.name]"_def["[ToRole:UpperValue]"];";
		else
			[ToRole:Instantiation] = "typedef sequence <"[Partner.name]", "[ToRole:UpperValue]"> "[ToRole.name]"_def;";
		end if
//		info = "Fix - UpperValue: " [ToRole:UpperValue]"\n";
		return "Fix";

	case regexp([ToRole.multiplicity],"[0-9]+\.\.[0-9]+"):
		[ToRole:LowerValue] = split([ToRole.multiplicity],".","L");
		[ToRole:UpperValue] = split([ToRole.multiplicity],".","T");
		if (itemValueForType([ToRole],"UmlRoleIDLPatternFamily", "") == "array")
			[ToRole:Instantiation] = "typedef "[Partner.name]" "[ToRole.name]"_def["[ToRole:UpperValue]"];";
		else
			[ToRole:Instantiation] = "typedef sequence <"[Partner.name]", "[ToRole:UpperValue]"> "[ToRole.name]"_def;";
		end if
//		info = "Range - UpperValue: " [ToRole:UpperValue]"\n";
		return "Range";

	default:
//		info = "default: \n";
		return "Many";
	end switch
end proc

/*	is relation between classes bidirectional?
*/
proc isBidirectional(MAssociationEnd AS FromRole, MAssociationEnd AS ToRole)
	if ([FromRole.isNavigable] == [ToRole.isNavigable])
		return "True";
	end if
	return "False";
end proc

/*	get value for passed type of annotation item
*/
proc itemValueForType(MElement, type, defaultVal)
	loop(MElement->Note->Item)
		if ([Item.type]==[type])
			return [Item.value];
		end if
	end loop
	return [defaultVal];
end proc