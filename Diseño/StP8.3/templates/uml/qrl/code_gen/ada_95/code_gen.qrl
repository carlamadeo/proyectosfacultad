///////////////////////////////////////////////////////////
//
//
//      StP/UML
//      Confidential property of Aonix
//      Copyright (c) 1998
//      All rights reserved

//
//  Ada_95 code generation for UML
//

#include "qrl/code_gen/pkg_code_gen.inc"
#include "qrl/code_gen/ada_95/customize.inc"
#include "qrl/code_gen/ada_95/association_patterns.inc"
#include "rules/qrl/oper_parse.inc"
#include "rules/qrl/uml.inc"

//
//  Functions for use by uml_data_model.inc
//


list
UmlAttributeItems(node attribute)
{
    return list_select("item[obj_id=${attribute.id} & note[UmlAttributeAda95Definition]]");
}

list
UmlOperationItems(node operation)
{
    return list_select("item[obj_id=${operation.id} & note[UmlOperationAda95Definition]]");
}

note
UmlOperationCode(node operation)
{
    return find_by_query("note[obj_id=${operation.id} & UmlOperationAda95Code]");
}

list
UmlRoleItems(link role)
{
    return list_select("item[obj_id=${role.id} & note[UmlRoleAda95Definition]]");
}

list
UmlAssociationItems(node association)
{
    return list_create("item", 0);
}

list
UmlGeneralizationItems(link generalization)
{
  return list_create("item", 0);
}

list
UmlClassItems(node class)
{
    list l = list_select("item[obj_id=${class.id} & note[UmlClassAda95Definition | UmlClassAda95Declarations | UmlClassCxxTableNote ]]");

    return l;
}


// ada_95 specific items (none currently for packages)
list
UmlPackageItems(node package)
{
    return list_create("item", 0); 
}

void
LanguageUmlGeneralizations(list generalizations, node class)
{
}

//
//  External variables specific to Ada_95
//
external string ada_file_name_base = "Full Ada Unit Name";
external_help = "A string variable to specify what to use as the base name of the output files when one file per class is generated.  The possible values are Class Name and Full Ada Unit Name.  The Full Ada Unit Name is the fully qualified package or subprogram name which includes all of the unit's parents in the hierarchical library.  The customizable file name prefix and suffix is not added to the file name base if the Full Ada Unit Name option is chosen.";

external string ada_root_class_type_privacy = "tagged private";
external_help = "A string variable to specify for root classes the privacy of the class type within the class package.  Possible values are public, tagged private, private and implementation.";

external string ada_subclass_type_privacy = "private extension";
external_help = "A string variable to specify for subclasses the privacy of the class type within the class package.  Possible values are public, private extension, tagged private, private and implementation.";

external boolean ada_class_type_is_limited = False;
external_help = "A boolean variable to specify whether or not to designate the generated class tagged type as limited.";

external boolean ada_gen_class_access_type = True;
external_help = "A boolean variable to specify whether or not to generate the access type to the class type for all generated class packages.";

external boolean ada_gen_classwide_access_type = True;
external_help = "A boolean variable to specify whether or not to generate the access type to the class-wide type associated with the class (tagged) type for all generated class packages.";

external boolean ada_implement_associations = True;
external_help = "A boolean variable to specify whether or not to implement associations.";

external boolean ada_subprograms_use_subunits = False;
external_help = "A boolean variable to specify whether or not to implement subprograms generated for operations as subunits.";

external boolean ada_subprograms_use_null_code = False;
external_help = "A boolean variable to specify whether or not to generate null code for operation subprograms which do not have source code note descriptions.  For procedures, this is just 'null;'.  For functions, it is returning a local variable with the same type as the function return type.";

//
//  Global declarations
//

const string  SD     = ".";         // scope delimiter
const string  SD_REPLACEMENT = "_"; 

const string  GENERALIZATION_QUERY = "link[UmlGeneralization & from_node_id=${class_node_id} & link_refs]";

struct all_attr_type
{
    string attr;
    string class_attr_public;
    string class_attr_private;
    string class_attr_implementation;
};

struct instantiation
{
  string  start_tag;
  string  end_tag;
  node    class;
  string  name;                         
  string  generic;
  string  args;
  list    withs;                 // list<string>
};

struct unit_code_block
{
  string  name;
  boolean private;

  set     class_withs;           // set<string>
  set     specification_withs;   // set<string>
  set     body_withs;            // set<string>
  list    subunit_declarations;  // list<string>
  list    instantiations;        // list<instantiation>
  list    generic_parameters;    // list<string>
  boolean inside_generic_package;
};

struct package_code_block
{
    string  name;

    list    public_forward;                   // list<string>
    list    public_declarations;              // list<string>
    list    private_forward;                  // list<string>
    list    private_declarations;             // list<string>
    list    implementation_declarations;      // list<string>
    list    operations;                       // list<string>

    int     public_forward_index;        
    int     public_declarations_index;   
    int     private_forward_index;       
    int     private_declarations_index;  
    int     implementation_declarations_index;     

    // for checking of duplicate declarations
    list    class_attribute_names;           // list<string>
    list    operation_headers;               // list<string>
    
};

//  Dependency graph for ordering multiple packages in one file
//
graph dependency_graph;


//
//  Main program
//
int
main()
{
    return code_gen_main ("Ada_95");
}

void
language_compile (PackageCodeDescriptor self)
{
  int                i,j,m,n;
  instantiation      inst;
  list               instantiations_seen;   // list<string>
  list               withs;
  string             with, parent_name;
  list               package_body;
  unit_code_block    ucb;
  UmlPackage         uml_package;

  uml_package = self.uml_package;

  ucb.subunit_declarations = list_create("string",0);
  ucb.instantiations = list_create("instantiation",0);
  ucb.generic_parameters = list_create("string",0);
  ucb.inside_generic_package = False;
  ucb.class_withs = set_create("string");
  ucb.specification_withs = set_create("string");
  ucb.body_withs = set_create("string");
  ucb.name = library_unit_name(uml_package.package);
  ucb.private = library_unit_private(uml_package.package);

  parent_name = library_unit_parent_name(uml_package.package);

  compile_package(ucb, uml_package,
		  self.interface_code, self.implementation_code, 0);

  // interface code
  withs = set_to_list(ucb.specification_withs);

  for (i = 0, n = list_count(withs); i < n; i = i + 1)
    {
      with = list_get(withs, i);

      // No need to "with" any parent packages or the package itself
      if (with != NULL && with != "" &&
	  string_find(ucb.name, 0, with) != 0)
	// insert withs starting at 1 to ensure they are within
	// the package scope tag
	{
	  list_insert(self.interface_code, 1, "with " + with + ";");
	  graph_add_arc(dependency_graph, with, ucb.name);
	}
    }
  // no need to with a parent package but we do want to add
  // a dependency so that the units get correctly ordered in
  // the file
  if (parent_name != "")
    graph_add_arc(dependency_graph, parent_name, ucb.name);

  instantiations_seen = list_create("string", 0);

  for (i = 0, n = list_count(ucb.instantiations); i < n; i = i + 1)
    {
      inst = list_get(ucb.instantiations, i);
      if (list_find(instantiations_seen, 0, inst.name) ==
          list_count(instantiations_seen))
      {
          list_append(instantiations_seen, inst.name);
          
          append_begin_tag(self.interface_code, 
                           inst.start_tag, inst.class);
      
          for (j = 0, m = list_count(inst.withs); j < m; j = j + 1)
          {
              with = list_get(inst.withs, j);
              if (with != NULL && with != "")
              {
                  graph_add_arc(dependency_graph, with, inst.name);
                  list_append(self.interface_code, "with " + with + ";");
              }
          }

          list_append (self.interface_code,
                       "package " + inst.name + " is new " + 
                       inst.generic + " (" + inst.args + ");");

          append_end_tag(self.interface_code, 
                         inst.end_tag);
      }
    }

  // implementation code
  if (list_count (self.implementation_code) != 0)
    {
      withs = set_to_list(ucb.body_withs);

      for (i = 0, n = list_count(withs); i < n; i = i + 1)
	{
	  with = list_get(withs, i);

	  // No need to "with" any parent packages or the package itself
	  if (with != NULL && with != "" &&
	      string_find(ucb.name, 0, with) != 0)
	    // insert withs starting at 1 to ensure they are within
	    // the package scope tag
	    list_insert(self.implementation_code, 1, "with " + with + ";");
	}
    }

  // operation code
  list_concatenate (self.operation_code, ucb.subunit_declarations);
}		   

void
compile_package (unit_code_block ucb, UmlPackage p, 
		 list package_specification, list package_body,
		 int level)
{
  package_code_block   pcb;
  string               name, private_string, separator;
  string               generic_qualified_name, instance_qualified_name;
  list                 packages, classes;
  int                  i,n, index;
  link                 generic_instantiation_link;
  boolean              is_generic, old_inside_generic_package;
  node                 generic_package;
  list                 generic_arguments;

  pcb.public_forward = list_create("string",0);
  pcb.public_declarations = list_create("string",0);
  pcb.private_forward = list_create("string",0);
  pcb.private_declarations = list_create("string",0);
  pcb.implementation_declarations = list_create("string",0);
  pcb.operations = list_create("string",0);
  pcb.operation_headers = list_create("string",0);
  pcb.class_attribute_names = list_create("string",0);

  generic_arguments = list_create("string",0);

  name = p.package.name;
  private_string = "";
  
  if (name == "")
    {
      ide_warning("  Warning: Ignoring unnamed package with id " + 
		  p.package.id + "...");
      return;
    }

  if (is_object_excluded(p.package) == True)
    {
      ide_warning("  Warning: Ignoring excluded package '" + 
		  name + "'...");
      return;
    }

  ide_warning(spaces(level) +
	      "Compiling package '" + name + "'...");

  generic_instantiation_link = 
    find_by_query("link[UmlDependency && link_refs && items[UmlStereotype && value = 'generic instantiation'] && from_node_id=${p.package.id}]");

  if (generic_instantiation_link != NULL)
      generate_generic_arguments (generic_arguments, p);
  else
  {
      if (is_generic = (UmlPackage__GetItemValue(p, "UmlStereotype") == "generic"))
      {
          old_inside_generic_package = ucb.inside_generic_package;
          ucb.inside_generic_package = True;
      }
            
      packages = p.UmlContentPackages;
      classes = p.UmlContentClasses;

      for (i = 0, n = list_count(packages); i < n; i = i + 1)
      {
	  compile_package(ucb, list_get (packages, i),
			  pcb.public_declarations, 
			  pcb.implementation_declarations,
			  level + 1);
      }

      for (i = 0, n = list_count(classes); i < n; i = i + 1)
      {
	  compile_class(ucb, pcb, list_get(classes, i), p, level + 1);
      }

      if (is_generic)
      {
          ucb.inside_generic_package = old_inside_generic_package;
      }
  }
  
  // handle any explicit user dependencies for this package
  generate_object_dependencies (ucb, p.package);

  // special handling for outermost package for child packages
  if (level == 0)
  {
    name = ucb.name;
    if (ucb.private)
      private_string = "private ";
  }

  if (generic_instantiation_link != NULL)
    {
      generic_package = find_by_query("node[id = ${generic_instantiation_link.to_node_id}]");

      generic_qualified_name = uml_class_qualified_name(generic_package);
      instance_qualified_name = uml_class_qualified_name(p.package);
      
      if (string_find(instance_qualified_name, 0, generic_qualified_name) == 0)
      {
          ide_warning("  Warning: The package '" + p.package.name +
                      "' is contained within the generic package '" + generic_package.name +
                      "' of which it is a generic instantiation.");
      }

      if (string_find(generic_qualified_name, 0, instance_qualified_name) == 0)
      {
          ide_warning("  Warning: The package '" + p.package.name +
                      "' contains the generic package '" + generic_package.name +
                      "' of which it is a generic instantiation.");
      }
      
      set_add(ucb.specification_withs, 
	      library_unit_name(generic_package));

      append_begin_tag(package_specification, 
		       START_PACKAGE_INSTANTIATION_TAG, p.package);

      if (list_count(generic_arguments) == 0)
	separator = ";";
      else
	separator = "(";

      list_append (package_specification,
		   private_string + "package " + name + " is new " + 
		   full_qualified_name(generic_package) + separator);

      for (i = 0, n = list_count(generic_arguments); i < n; i = i + 1)
	{
	  if (i == (n - 1))
	    separator = ");";
	  else
	    separator = ",";
	  list_append(package_specification,
		      INDENT + list_get(generic_arguments, i) + separator);
	}

      append_end_tag(package_specification, 
		     END_PACKAGE_INSTANTIATION_TAG);
    }
  else
    {
      // concatenate package specification

      append_begin_tag(package_specification, 
		       START_PACKAGE_SPECIFICATION_TAG, p.package);

      if (is_generic)
	{
	  list_append (package_specification, "generic");
	  list_concatenate_with_indent (package_specification, 
					ucb.generic_parameters);
	  list_clear(ucb.generic_parameters);
	}

      list_append (package_specification,
		   private_string + "package " + name + " is");
      list_concatenate_with_indent (package_specification,
				    pcb.public_forward);
      list_concatenate_with_indent (package_specification,
				    pcb.public_declarations);

      if (list_count(pcb.private_forward) != 0 ||
	  list_count(pcb.private_declarations) != 0)
	{
	  list_append (package_specification, "private");
	  list_concatenate_with_indent (package_specification, 
					pcb.private_forward);
	  list_concatenate_with_indent (package_specification, 
					pcb.private_declarations);
	}
      
      list_append (package_specification, "end " + name + ";");

      append_end_tag(package_specification, 
		     END_PACKAGE_SPECIFICATION_TAG);
    }

  // concatenate package body

  if (list_count(pcb.implementation_declarations) != 0 ||
      list_count(pcb.operations) != 0)
    {
      append_begin_tag(package_body, 
		       START_PACKAGE_BODY_TAG, p.package);

      list_append (package_body, 
		   "package body " + name + " is");
      list_concatenate_with_indent (package_body, pcb.implementation_declarations);
      list_concatenate_with_indent (package_body, pcb.operations);
      list_append (package_body, "end " + name + ";");

      append_end_tag(package_body,
		     END_PACKAGE_BODY_TAG);
    }
}

void
compile_class(unit_code_block ucb, package_code_block pcb,
	      UmlClass c, UmlPackage p, int level)
{
    all_attr_type   all_attr;
    string          the_super, asc;

    if (c.elaborated_type != NULL &&
	c.elaborated_type.type == "UmlInstantiatedClass")
      {
	ide_warning ("  Warning: Ignoring the instantiated class '" + c.class.name + 
		     "' as it is outside of any instantiated package");
	return;
      }

    if (c.class.name == "")
    {
      ide_warning("  Warning: Ignoring unnamed class with id " + 
		  c.class.id + "...");
      return;
    }

    if (is_object_excluded(c.class) == True)
    {
      ide_warning("  Warning: Ignoring excluded class '" + 
		  c.class.name + "'...");
      return;
    }

    ide_warning(spaces(level) + 
		"Compiling class '" + c.class.name + "'...");

    if (is_class_table_defined(c.class) == False)
    {
        ide_warning("  Warning: Class '" + c.class.name +
		    "' does not have a class table definition.");
    }

    if (c.elaborated_type != NULL &&
	c.elaborated_type.type == "UmlParameterizedClass")
    {
        if (!ucb.inside_generic_package)
        {
            ide_warning ("  Warning:  Parameterized class '" + c.class.name +
                         "' is not inside a generic package, parameters will be ingored.");
        }
        generate_generic_parameters(ucb, c);
    }
    
    set_clear(ucb.class_withs);

    pcb.public_forward_index = list_count(pcb.public_forward);
    pcb.public_declarations_index = list_count(pcb.public_declarations);
    pcb.private_forward_index = list_count(pcb.private_forward);
    pcb.private_declarations_index = list_count(pcb.private_declarations);
    pcb.implementation_declarations_index = list_count(pcb.implementation_declarations);

    the_super = generate_the_superclass(ucb, c);
    
    all_attr = generate_attributes (pcb, c);

    if (ada_implement_associations)
      asc = generate_associations (ucb, c) +
	generate_associations_for_association_class (ucb, c);
    else
      asc = "";

    if (comment_classes == True)
      add_multiline(pcb.public_forward,
		    generic_generate_object_comment (c.class, "Class", NL,
						     COMMENT_PREFIX, "", ""));

    generate_class_type(pcb, c, the_super, all_attr.attr, asc);

    // append the class attributes
			
    add_multiline(pcb.public_declarations,
		  all_attr.class_attr_public);

    add_multiline(pcb.private_declarations,
		  all_attr.class_attr_private);
    
    add_multiline(pcb.implementation_declarations,
		  all_attr.class_attr_implementation);

    generate_operations(ucb, pcb, c, p);

    // handle any explicit user dependencies for this class
    generate_object_dependencies (ucb, c.class);

    if (uml_class_type_privacy(c) == "implementation")
      set_union(ucb.body_withs, ucb.class_withs);
    else
      set_union(ucb.specification_withs, ucb.class_withs);

    append_tag_pair(pcb.public_forward, pcb.public_forward_index, c.class,
		    START_PACKAGE_PUBLIC_FORWARD_TAG,
		    END_PACKAGE_PUBLIC_FORWARD_TAG);

    append_tag_pair(pcb.public_declarations, pcb.public_declarations_index, c.class,
		    START_PACKAGE_PUBLIC_TAG,
		    END_PACKAGE_PUBLIC_TAG);

    append_tag_pair(pcb.private_forward, pcb.private_forward_index, c.class,
		    START_PACKAGE_PRIVATE_FORWARD_TAG,
		    END_PACKAGE_PRIVATE_FORWARD_TAG);

    append_tag_pair(pcb.private_declarations, pcb.private_declarations_index, c.class,
		    START_PACKAGE_PRIVATE_TAG,
		    END_PACKAGE_PRIVATE_TAG);

    append_tag_pair(pcb.implementation_declarations,
		    pcb.implementation_declarations_index, c.class,
		    START_PACKAGE_IMPLEMENTATION_TAG,
		    END_PACKAGE_IMPLEMENTATION_TAG);
}

string
class_type_name (string class_name)
{
    return CLASS_TYPE_NAME_PREFIX + class_name + CLASS_TYPE_NAME_SUFFIX;
}

string
class_access_type_name (string class_name)
{
    return ACCESS_TYPE_NAME_PREFIX + class_name + ACCESS_TYPE_NAME_SUFFIX;
}

string
classwide_access_type_name (string class_name)
{
    return
	CLASSWIDE_ACCESS_TYPE_NAME_PREFIX + class_name +
	CLASSWIDE_ACCESS_TYPE_NAME_SUFFIX;
}

string
association_reference_name (string class_name)
{
    return
       ASSOCIATION_REFERENCE_PREFIX + class_name + ASSOCIATION_REFERENCE_SUFFIX;
}

string
aggregation_whole_reference_name (string class_name)
{
    return
	AGGREGATION_WHOLE_REFERENCE_PREFIX + class_name +
	AGGREGATION_WHOLE_REFERENCE_SUFFIX;
}

string
aggregation_part_reference_name (string class_name)
{
    return
	AGGREGATION_PART_REFERENCE_PREFIX + class_name +
	AGGREGATION_PART_REFERENCE_SUFFIX;
}

string
composition_whole_reference_name (string class_name)
{
    return
	COMPOSITION_WHOLE_REFERENCE_PREFIX + class_name +
	COMPOSITION_WHOLE_REFERENCE_SUFFIX;
}

string
composition_part_reference_name (string class_name)
{
    return
	COMPOSITION_PART_REFERENCE_PREFIX + class_name +
	COMPOSITION_PART_REFERENCE_SUFFIX;
}

void
generate_class_type(package_code_block pcb, 
		    UmlClass c,
		    string the_super, string attr, string asc)
{
    string    class_name = c.class.name;
    string    partial_view_limited_string;
    string    partial_view_abstract_string;
    string    full_view_limited_string;
    string    full_view_abstract_string;
    boolean   gen_classwide_access_type, gen_class_access_type;
    string    class_type_privacy;
    
    partial_view_limited_string =
	class_type_partial_view_limited_string(c);
    partial_view_abstract_string =
	class_type_partial_view_abstract_string(c);
    full_view_limited_string =
	class_type_full_view_limited_string(c, partial_view_limited_string);
    full_view_abstract_string =
	class_type_full_view_abstract_string(c,partial_view_abstract_string);
    
    gen_classwide_access_type =	uml_gen_classwide_access_type(c);
    gen_class_access_type = uml_gen_class_access_type(c);

    class_type_privacy = uml_class_type_privacy(c);

    if (class_type_privacy == "public") {

      list_append(pcb.public_forward,
		  class_record_first_part(class_name) + ";");
      
      generate_class_record_full (pcb.public_declarations,
				  class_name, the_super, attr, asc,
				  full_view_limited_string,
				  full_view_abstract_string);

      if (gen_classwide_access_type)
	list_append(pcb.public_forward,
		    classwide_access_type_full (class_name));

      if (gen_class_access_type)
	list_append(pcb.public_forward,
		    class_access_type_full (class_name));
    }
    
    else if (class_type_privacy == "private extension") {

      list_append(pcb.public_forward,
		  class_record_first_part(class_name) + ";");

      list_append(pcb.public_declarations,
		  class_record_first_part(class_name) + " is" +
		  partial_view_abstract_string + " new " + the_super + " with" +
		  partial_view_limited_string + " private;");
      
      generate_class_record_full (pcb.private_declarations,
				  class_name, the_super, attr, asc,
				  full_view_limited_string,
				  full_view_abstract_string);

      if (gen_classwide_access_type)
	list_append(pcb.public_forward,
		    classwide_access_type_full (class_name));

      if (gen_class_access_type)
	list_append(pcb.public_forward,
		    class_access_type_full (class_name));
    }
    
    else if (class_type_privacy == "tagged private") {

      list_append(pcb.public_forward,
		  class_record_first_part(class_name) + " is" +
		  partial_view_abstract_string + " tagged" +
		  partial_view_limited_string + " private;");
	
      generate_class_record_full (pcb.private_declarations,
				  class_name, the_super, attr, asc,
				  full_view_limited_string,
				  full_view_abstract_string);

      if (gen_classwide_access_type)
	list_append(pcb.public_forward,
		    classwide_access_type_full (class_name));

      if (gen_class_access_type)
	list_append(pcb.public_forward,
		    class_access_type_full (class_name));
    }
    else if (class_type_privacy == "private") {

      list_append(pcb.public_forward,
		  class_record_first_part(class_name) + " is" +
		  partial_view_limited_string + " private;");
	
      generate_class_record_full (pcb.private_declarations,
				  class_name, the_super, attr, asc,
				  full_view_limited_string,
				  full_view_abstract_string);

      if (gen_classwide_access_type) {
	list_append(pcb.public_forward,
		    classwide_access_type_first_part(class_name) + " private;");
	list_append(pcb.private_forward,
		    classwide_access_type_full (class_name));
	}

      if (gen_class_access_type)
	list_append(pcb.public_forward,
		    class_access_type_full (class_name));
    } 
    else { // "implementation"

      list_append(pcb.private_forward,
		  class_record_first_part(class_name) + ";");
	
      generate_class_record_full (pcb.implementation_declarations,
				  class_name, the_super, attr, asc,
				  full_view_limited_string,
				  full_view_abstract_string);

      if (gen_classwide_access_type) {
	list_append(pcb.public_forward,
		    classwide_access_type_first_part(class_name) + " private;");
	list_append(pcb.private_forward,
		    classwide_access_type_full (class_name));
	}

      if (gen_class_access_type) {
	list_append(pcb.public_forward,
		    class_access_type_first_part(class_name) + " private;");
	list_append(pcb.private_forward,
		    class_access_type_full (class_name));
	}
    }
}

string
class_record_first_part (string class_name)
{
    return "type " + class_type_name (class_name);
}

void
generate_class_record_full (list declarations,
			    string class_name, string the_super,
			    string attr, string asc,
			    string full_view_limited_string,
			    string full_view_abstract_string)
{
    string beginning, tagged_part, components;

    beginning = class_record_first_part (class_name) + " is" +
	full_view_abstract_string;

    if (the_super == "")
	tagged_part = " tagged" + full_view_limited_string;
    else
 	tagged_part = " new " + the_super + " with"; // can't be 'limited'

    components = attr + asc;

    if (components == "")
      {
	list_append (declarations,
		     beginning + tagged_part + " null record;");
      }
    else
      {
	list_append (declarations,
		     beginning + tagged_part + " record");
	add_multiline_with_indent(declarations, components);
	list_append (declarations, "end record;") ;
      }
}
        
string
class_access_type_first_part (string class_name)
{
    return "type " + class_access_type_name(class_name) + " is";
}

string
class_access_type_full (string class_name)
{
    return 
        class_access_type_first_part (class_name) +
        " access all " + class_type_name (class_name) + ";";
}

string
classwide_access_type_first_part (string class_name)
{
    return "type " +
	classwide_access_type_name(class_name) + " is";
}

string
classwide_access_type_full (string class_name)
{
    return 
        classwide_access_type_first_part (class_name) +
        " access all " + class_type_name (class_name) + "'class" + ";";
}

boolean
uml_class_is_root (UmlClass uml_class)
{
    return (list_count(uml_class.UmlGeneralizations) == 0);
}

boolean
node_class_is_root (node class_node)
{
    link generalization_link;
    int  class_node_id;

    class_node_id = class_node.id;
    
    generalization_link = find_by_query(GENERALIZATION_QUERY);

    return (generalization_link == NULL);
    
}

string
uml_class_type_privacy (UmlClass uml_class)
{
    boolean class_is_root;
    string  the_class_type_privacy;

    class_is_root = uml_class_is_root(uml_class);

    the_class_type_privacy = UmlClass__GetItemValue 
        (uml_class, "UmlClassAda95TypePrivacy");
    
    return adjusted_class_type_privacy(class_is_root, the_class_type_privacy);
}

string
node_class_type_privacy (node class)
{
    boolean class_is_root;
    item    the_class_type_privacy_item;
    string  the_class_type_privacy = "";

    class_is_root = node_class_is_root(class);
    
    the_class_type_privacy_item = find_by_query (
	"item[obj_id=${class.id} & type = UmlClassAda95TypePrivacy]");

    if (the_class_type_privacy_item != NULL)
	the_class_type_privacy = the_class_type_privacy_item.value;
    
    return adjusted_class_type_privacy(class_is_root, the_class_type_privacy);
}

string
adjusted_class_type_privacy (boolean class_is_root,
			     string class_type_privacy_in)
{
    string the_class_type_privacy;
    
    if (class_type_privacy_in == "") {
	if (class_is_root)
	    the_class_type_privacy = ada_root_class_type_privacy;
	else
	    the_class_type_privacy = ada_subclass_type_privacy;
    }
    else if (class_type_privacy_in == "private extension" && class_is_root)
	the_class_type_privacy = "tagged private";
    else
	the_class_type_privacy = class_type_privacy_in;

    return the_class_type_privacy;
}

node
node_root_class_node(node class_node)
{
    list   generalizations;
    link   generalization_link;
    node   generalization_node;

    generalizations = node_generalizations(class_node.id);

    if (list_count(generalizations) == 0)
	return class_node;
    else {
	generalization_link = list_get(generalizations,0);
	generalization_node =
	    find_by_query("node[id=${generalization_link.to_node_id}]");
	return node_root_class_node(generalization_node);
    }
}

boolean
node_class_is_limited(node class_node)
{
    item class_is_limited_item;
    string class_is_limited_item_value = "";

    class_is_limited_item = find_by_query (
	"item[obj_id=${class_node.id} & type = UmlClassAda95IsLimited]");

    if (class_is_limited_item != NULL)
	class_is_limited_item_value = class_is_limited_item.value;

    return
	class_is_limited_item_value == "True" ||
	(class_is_limited_item_value == "" &&
	 ada_class_type_is_limited);
}

boolean
uml_class_is_limited(UmlClass uml_class)
{
    string  class_is_limited_item_value;
    
    class_is_limited_item_value = UmlClass__GetItemValue(
	uml_class, "UmlClassAda95IsLimited");

    return
	class_is_limited_item_value == "True" ||
	(class_is_limited_item_value == "" &&
	 ada_class_type_is_limited);
}

string
class_type_partial_view_limited_string (UmlClass c)
{
    boolean partial_view_use_limited;
    node    its_root_class_node;
    string  class_type_privacy;
    
    if (uml_class_is_root(c)) {
	partial_view_use_limited = uml_class_is_limited(c);
    }
    else {
	its_root_class_node = node_root_class_node(c.class);
	class_type_privacy = uml_class_type_privacy(c);

	partial_view_use_limited = node_class_is_limited(its_root_class_node) &&
	    (class_type_privacy == "tagged private" ||
	     class_type_privacy == "private");
    }

    if (partial_view_use_limited)
	return " limited";
    else
	return "";
}

string
class_type_full_view_limited_string (UmlClass c,
				     string partial_view_limited_string)
{
    boolean full_view_use_limited;
    string  full_view_not_limited_item_value;
    
    if (uml_class_is_root(c)) {
	if (partial_view_limited_string == "")
	    full_view_use_limited = False;
	else {
	    full_view_use_limited = True;

	    full_view_not_limited_item_value = UmlClass__GetItemValue(
		c, "UmlClassAda95FullViewNotLimited");

	    if (full_view_not_limited_item_value == "True" &&
		uml_class_type_privacy(c) == "private")
		full_view_use_limited = False;
	}
    }
    else
	full_view_use_limited = False;
    
    if (full_view_use_limited)
	return " limited";
    else
	return "";
}

boolean
uml_class_is_abstract (UmlClass uml_class)
{
    string  class_type_is_abstract_item_value;
    
    class_type_is_abstract_item_value = UmlClass__GetItemValue 
        (uml_class, "UmlClassIsAbstract");

    return
	class_type_is_abstract_item_value == "True";
}

string
class_type_partial_view_abstract_string (UmlClass c)
{
    if (uml_class_is_abstract(c))
	return " abstract";
    else
	return "";
}

string
class_type_full_view_abstract_string (UmlClass c,
				      string partial_view_abstract_string)
{
    boolean full_view_use_abstract;
    string  full_view_not_abstract_item_value;
    string  class_type_privacy;

    if (partial_view_abstract_string == "")
	full_view_use_abstract = False;
    else {
	full_view_use_abstract = True;

	full_view_not_abstract_item_value = UmlClass__GetItemValue(
	    c, "UmlClassAda95FullViewNotAbstract");
	
	class_type_privacy = uml_class_type_privacy(c);

	if (full_view_not_abstract_item_value == "True" &&
	    (class_type_privacy == "private extension" ||
	     class_type_privacy == "tagged private"))
	    full_view_use_abstract = False;

	if (class_type_privacy == "private") {
	   full_view_use_abstract = False;
	   ide_warning ("  Warning: Class '" + class_qualified_name(c.class) + "' cannot be both private and abstract." + NL + "           Ignoring abstract designation.");
	}

    }

    if (full_view_use_abstract)
	return " abstract";
    else
	return "";
}

boolean
uml_gen_class_access_type (UmlClass uml_class)
{
    string gen_class_access_type_item_value;

    gen_class_access_type_item_value = UmlClass__GetItemValue 
        (uml_class, "UmlClassAda95GenAccessType");

    return
        gen_class_access_type_item_value == "True" ||
        (gen_class_access_type_item_value == "" &&
        ada_gen_class_access_type);
}

boolean
uml_gen_classwide_access_type (UmlClass uml_class)
{
    string gen_classwide_access_type_item_value;

    gen_classwide_access_type_item_value = UmlClass__GetItemValue 
        (uml_class, "UmlClassAda95GenWideAccessType");

    return
        gen_classwide_access_type_item_value == "True" ||
        (gen_classwide_access_type_item_value == "" &&
        ada_gen_classwide_access_type);
}

list
node_generalizations(int class_node_id)
{
    return order_generalizations (list_select (GENERALIZATION_QUERY));
}

void
generate_generic_parameters(unit_code_block ucb, UmlClass c)
{
  int    i,n;
  string parameters, name, type;
  list   parameter_list, names, types;
  
  parameters = UmlClass__GetItemValue(c, "UmlClassParameters");
  
  // if the parameter list includes a semicolon then treat this
  // directly as an Ada95 generic parameter specification

  if (string_find(parameters,0,";") != string_length(parameters))
    {
      parameter_list = string_to_list(parameters, ";");
      for (i = 0, n = list_count(parameter_list); i < n; i = i + 1)
	{
	  list_append(ucb.generic_parameters,
		      trim(list_get(parameter_list, i)) + ";");
	}
    }
  else
    {      
      names = string_to_list (uml_name_type_syntax_2_type_space_name_syntax(parameters,
									    "N", ""),
			      ",");

      types = string_to_list (uml_name_type_syntax_2_type_space_name_syntax(parameters,
									    "T", "class"),
			      ",");

      for (i = 0, n = list_count(names); i < n; i = i + 1)
	{
	  name = trim(list_get(names, i));
	  type = trim(list_get(types, i));
	  
	  if (to_lower(type)== "class")
	    list_append(ucb.generic_parameters,
			"type " + name + " is private;");
	  else
	    list_append(ucb.generic_parameters,
			name + ": " + type + ";");
	}
    }
}

// recurse down subpackages looking for anonymous instantiations
void
generate_generic_arguments (list generic_arguments, UmlPackage p)
{
  int      i,n;
  UmlClass c;
  node     param_class;
  item     param_item;
  string   arg;
  list     arguments, names;
  list     packages, classes;

  packages = p.UmlContentPackages;
  classes = p.UmlContentClasses;

  for (i = 0, n = list_count(packages); i < n; i = i + 1)
    {
      generate_generic_arguments(generic_arguments, list_get (packages, i));
    }

  for (i = 0, n = list_count(classes); i < n; i = i + 1)
    {
      c = list_get(classes, i);
      if (c.elaborated_type != NULL &&
	  c.elaborated_type.type == "UmlInstantiatedClass")
	{
	  param_class = class_surrogate_node(c.class);
	  param_item = find_by_query("item[obj_id=${param_class.id} & note[UmlClassDefinition] & UmlClassParameters]");

	  if (param_item != NULL)
	    names = string_to_list (uml_name_type_syntax_2_type_space_name_syntax
				    (param_item.value, "N", ""), ",");	  

	  arguments  = string_to_list(c.elaborated_type.sig, ",");
	  
	  for (i = 0, n = list_count(arguments); i < n; i = i + 1)
	    {
	      
	      arg = trim(list_get(arguments, i));
		  
	      // If arg not already in Ada95 syntax work out the
	      // name based on position in corresponding param list (if
	      // it exists)
	      if (string_find (arg, 0, "=>") == string_length(arg) &&
		  param_item != NULL)
		arg = trim(list_get(names, i)) + " => " + arg;
	  
	      list_append(generic_arguments, arg);
	    }
	}
      else
	ide_warning ("  Warning: Ignoring the non-instantiated class '" + c.class.name +
                     "' inside of an instantiated package");

    }
}


string
generate_the_superclass (unit_code_block ucb, UmlClass c)
{
    list               uml_generalizations = c.UmlGeneralizations;
    UmlGeneralization  uml_generalization;
    string             generalization_name = "";
    string             generalization_package;
    string             generalization_type = "";
    string             generalization_type_privacy;

    if (list_count(uml_generalizations) > 0) {
	uml_generalization = list_get(uml_generalizations, 0);

	generalization_name =
	    language_make_identifier (uml_generalization.class.name);
	generalization_type_privacy =
	    node_class_type_privacy(uml_generalization.class);
	
	generalization_package = 
	  library_unit_name(uml_generalization.class);

	set_add(ucb.class_withs, generalization_package);
	generalization_type =
	  full_scope_list(uml_generalization.class) + "." + 
	  class_type_name(generalization_name);

	if (!is_object_imported(uml_generalization.class) &&
	    (generalization_type_privacy == "implementation" ||
	     generalization_type_privacy == "private"))
	  {
	    ide_warning ("  Warning: Class type privacy of generalization '" + generalization_name + "'" + NL + "           may be '" + generalization_type_privacy + "'.  If so, it cannot be inherited from.");
	}
    }
    
    if (list_count(uml_generalizations) > 1)
      ide_warning ("  Warning: Class '" + class_name + "' inherits from more than one superclass." + NL + "           Using '" + generalization_type + "'.");

    return generalization_type;
}

all_attr_type
generate_attributes (package_code_block pcb, UmlClass c)
{
    list            UmlAttributes = c.UmlAttributes;
    all_attr_type   generated;
    int             i, n;
    UmlAttribute    uml_attribute;
    boolean         is_class_attr;
    string          class_attr_privacy;

    generated.attr = "";
    generated.class_attr_public = "";
    generated.class_attr_private = "";
    generated.class_attr_implementation = "";


    for (i = 0, n = list_count(UmlAttributes); i < n; i = i + 1)
    {
        uml_attribute = list_get(UmlAttributes, i);

        is_class_attr = 
            (UmlAttribute__GetItemValue (uml_attribute, "UmlMemberIsClass") ==
            "True");

        if (is_class_attr) {
	    class_attr_privacy = UmlAttribute__GetItemValue(
		uml_attribute, "UmlMemberAda95Visibility");
	    
	    if (class_attr_privacy == "")
		class_attr_privacy = "public";

	    if (class_attr_privacy == "public")
		generated.class_attr_public = generated.class_attr_public +
		    generate_attribute(pcb, c, uml_attribute, True);
	    else if (class_attr_privacy == "private")
		generated.class_attr_private = generated.class_attr_private +
		    generate_attribute(pcb, c, uml_attribute, True);
	    else if (class_attr_privacy == "implementation")
		generated.class_attr_implementation =
		    generated.class_attr_implementation +
		    generate_attribute(pcb, c, uml_attribute, True);
	}
        else
            generated.attr = generated.attr + 
                generate_attribute(pcb, c, uml_attribute, False);
    }

    return generated;
}

string
generate_attribute (package_code_block pcb, UmlClass c,
                    UmlAttribute uml_attribute, 
		    boolean is_class_attribute)
{
    string          attribute_name, attribute_type, attribute_comment;
    item            default_value_item;
    string          default_value = "";
    string          aliased_value, aliased_string = "";

    attribute_name = make_attribute_name(uml_attribute);
    attribute_type = make_attribute_type(uml_attribute);

    if (is_class_attribute)
      {
	if (list_find(pcb.class_attribute_names, 0, to_lower(attribute_name)) ==
	    list_count(pcb.class_attribute_names))
	  list_append(pcb.class_attribute_names, to_lower(attribute_name));
	else
	  ide_warning("  Warning: variable declaration for class attribute '" + 
		      attribute_name + "' in class '" + c.class.name +
		      "' overrides existing declaration in same region.");
      }

    if (comment_attributes == True)
        attribute_comment = generic_generate_object_comment (
            uml_attribute.attribute, "Attribute", NL, 
	    COMMENT_PREFIX, "", "");
    else
        attribute_comment = "";

    default_value_item = 
	UmlAttribute__GetItem(uml_attribute, "UmlAttributeDefaultValue");

    if (default_value_item != NULL)
	default_value = " := " + default_value_item.value;

    aliased_value =
	UmlAttribute__GetItemValue(uml_attribute, "UmlAttributeAda95IsAliased");

    if (aliased_value == "True")
	aliased_string = "aliased ";

    return
        attribute_comment +
        attribute_name + " : " + aliased_string +
	attribute_type + default_value + ";" + NL;
}

void
generate_operations(unit_code_block ucb, package_code_block pcb,
		    UmlClass c, UmlPackage p)
{
    list            UmlOperations = c.UmlOperations;
    list            UmlClassOperations = list_create("UmlOperation", 0);
    string          ops = "", class_ops = "";
    int             i, n;
    UmlOperation    uml_operation;

    for (i = 0, n = list_count(UmlOperations); i < n; i = i + 1)
    {
        uml_operation = list_get(UmlOperations, i);

	if (UmlOperation__GetItemValue (uml_operation, "UmlMemberIsClass") ==
	    "True")
	  list_append(UmlClassOperations, uml_operation);
	else
	  generate_operation(ucb, pcb, c, p, uml_operation, False);
    }

    // do the class operations after all the regular operations
    for (i = 0, n = list_count(UmlClassOperations); i < n; i = i + 1)
    {
        uml_operation = list_get(UmlClassOperations, i);
	generate_operation(ucb, pcb, c, p, uml_operation, True);
    }
}

void
generate_operation (unit_code_block ucb, package_code_block pcb,
		    UmlClass c, UmlPackage p,
		    UmlOperation uml_operation,
		    boolean is_class_operation)
{
    int             i, n;
    string          operation_specification; 
    string          operation_comment; 
    string          operation_header;
    string          operation_return, operation_kind; 
    string          operation_name;
    string          operation_body_header, operation_body;
    string          operation_footer = "";
    string          operation_stub = "";
    string          op_class_name;
    string          operation_abstract;
    string          operation_privacy;
    string          operation_subunit;
    string          operation_inline;
    boolean         make_abstract, make_subunit, make_inline = False;
    string          abstract_string = "", inline_string;

    if (comment_operations == True)
        operation_comment = generic_generate_object_comment (
            uml_operation.operation, "Operation", NL, COMMENT_PREFIX, 
	    "", "");
    else
        operation_comment = "";
    
    operation_return = 
        UmlOperation__GetItemValue(uml_operation, "UmlOperationReturnType");

    if (operation_return == "" )
        operation_kind = "procedure";
    else
        operation_kind = "function";

    operation_header = generate_operation_header (c, uml_operation.operation, 
        operation_kind, operation_return);

    operation_name = make_operation_identifier(uml_operation.operation.name);

    if (list_find(pcb.operation_headers, 0, to_lower(operation_header)) ==
        list_count(pcb.operation_headers))
    {
        list_append(pcb.operation_headers, to_lower(operation_header));
    }
    else
    {
        ide_warning("  Warning: " + operation_kind + " declaration for operation '" +
                    operation_name + "' in class '" + c.class.name +
                    "' overrides existing declaration in same region.");
    }
    
    operation_abstract =
	UmlOperation__GetItemValue(uml_operation, "UmlOperationIsAbstract");

    make_abstract = operation_abstract == "True";

    op_class_name = class_type_name(class_base_name(c.class));

    operation_privacy =
	UmlOperation__GetItemValue (uml_operation, "UmlMemberAda95Visibility");

    if (is_class_operation && make_abstract) {
	ide_warning("  Warning: Abstract designation for operation '" + operation_name + "' ignored," + NL + "           because it has been designated as a class operation.");
	make_abstract = False;
    }

    if (is_class_operation && operation_return == op_class_name &&
	operation_privacy != "implementation")
	ide_warning("  Warning: Function '" + operation_name + "' with return type '" + op_class_name + "'" + NL + "           has been designated as a class operation, so it should not be" + NL + "           a primitive operation of the class type.");
    
    if (uml_class_is_abstract(c)) {
        if (!make_abstract && operation_return == op_class_name) {
	    make_abstract = True;
	    ide_warning("  Warning: Function '" + operation_name + "' is being generated as abstract," + NL + "           because its controlling return type '" + op_class_name + "' is abstract.");
	}
    }
    else {
        if (make_abstract) {
	    make_abstract = False;
	    ide_warning("  Warning: Abstract designation for operation  '" + operation_name + "' ignored," + NL + "           because class '" + class_qualified_name(c.class) + "' is not abstract.");
	}
    }
    
    if (make_abstract) {
	abstract_string = " is abstract";
	operation_body_header = "";
	operation_body = "";
	operation_footer = "";
	operation_stub = "";
	make_subunit = False;
    }
    else {

	operation_body_header = 
	  operation_header + " is" + NL + "begin" + NL;

	operation_subunit =
	    UmlOperation__GetItemValue (uml_operation,
					"UmlOperationAda95IsSubunit");

	make_subunit =  operation_subunit == "True" || 
	    (operation_subunit == "" && ada_subprograms_use_subunits);

	operation_inline =
	    UmlOperation__GetItemValue (uml_operation, 
					"UmlOperationAda95IsInline");

	make_inline = (operation_inline == "True");

	if (uml_operation.UmlOperationCode == NULL) {
	    if (ada_subprograms_use_null_code) {
		if (operation_kind == "procedure")
		    operation_body = "null;";
		else {
		    operation_body = 
			"declare" + NL +
			INDENT + "return_value : " + operation_return + ";" + NL +
			"begin" + NL +
			INDENT + "return return_value;" + NL +
			"end;";
		}
	    }
	    else
		operation_body = "";
	}
	else
	    operation_body = 
	      string_strip(uml_operation.UmlOperationCode.desc, "B", NL);

	operation_body =
	  START_OPERATION_CODE_TAG + NL +
	  operation_body + NL +
	  END_OPERATION_CODE_TAG;

	if (make_subunit) {

	    operation_body_header = 
		NL + "separate (" + library_unit_name(p.package) + ")" + NL + 
		operation_body_header;

	    operation_stub = operation_header + " is separate;";
	}

	operation_footer = "end " + operation_name + ";" +
	    operation_footer;
    }
    
    if (make_subunit)
      {
	append_begin_tag(pcb.operations, START_OPERATION_STUB_TAG, 
			 uml_operation.operation);
	add_multiline(pcb.operations, operation_stub);
	append_end_tag(pcb.operations, END_OPERATION_STUB_TAG);

	append_begin_tag(ucb.subunit_declarations, START_OPERATION_TAG, 
			 uml_operation.operation);
	add_multiline(ucb.subunit_declarations, operation_body_header);
	add_multiline_with_indent(ucb.subunit_declarations, operation_body);
	add_multiline(ucb.subunit_declarations, operation_footer);
	append_end_tag(ucb.subunit_declarations, END_OPERATION_TAG);
      }
    else
      {
	append_begin_tag(pcb.operations, START_OPERATION_TAG, 
			 uml_operation.operation);
	add_multiline(pcb.operations, operation_body_header);
	add_multiline_with_indent(pcb.operations, operation_body);
	add_multiline(pcb.operations, operation_footer);
	append_end_tag(pcb.operations, END_OPERATION_TAG);
      }

    operation_specification = operation_comment +
        operation_header + abstract_string + ";" + NL;
    
    if (make_inline) {
	inline_string = "pragma inline (" + operation_name + ");" + NL;
	operation_specification = operation_specification + inline_string;
    }
     
    if (operation_privacy == "public") 
      add_multiline(pcb.public_declarations, operation_specification);
    else if (operation_privacy == "private")
      add_multiline(pcb.private_declarations, operation_specification);
    else // "implementation"
      add_multiline(pcb.implementation_declarations, operation_specification);


    // handle any explicit user dependencies for this operation
    generate_object_dependencies (ucb, uml_operation.operation);
}

string
generate_operation_header (UmlClass c, node operation, 
    string operation_kind, string operation_return)
{
    string operation_end  = "";
    string operation_args = "";

    if (operation_kind == "function")
        operation_end = " return " + operation_return;

    return
        operation_kind + " " + 
        generate_operation_name_and_args (c, operation) + 
        operation_end;
}

string
generate_operation_name_and_args (UmlClass c, node operation)
{
    string operation_name, operation_args = "";

    operation_name = make_operation_identifier(operation.name);

    if (operation.sig != "")
        operation_args = " (" + uml_args_to_format(operation.sig, Ada95) + ")";

    return operation_name + operation_args;
}
    
string
generate_associations (unit_code_block ucb, UmlClass c)
{
    list            UmlAssociations = c.UmlAssociations;
    string          generated = "";
    int             i, j, m, n;
    UmlRole         source, target;
    UmlAssociation  uml_association;
    boolean         is_reflexive = False;


    for (i = 0, n = list_count(UmlAssociations); i < n; i = i + 1)
    {
        uml_association = list_get(UmlAssociations, i);

        source = uml_association.UmlSourceRole;

        if (list_count(uml_association.UmlTargetRoles) == 0)
            target = source;
        else
            target = list_get(uml_association.UmlTargetRoles, 0);

        if (source.role.from_node_id == target.role.from_node_id)
            is_reflexive = True;

        generated = generated + generate_association (ucb, c, uml_association,
            source, target, uml_association.class, is_reflexive);

        // do the 'other_direction' for reflexive associations 
        for (j=0, m=list_count(uml_association.UmlTargetRoles); j<m; j=j+1)
        {
            target = list_get(uml_association.UmlTargetRoles, j);

            if (source.role.from_node_id == target.role.from_node_id)
	    {
                generated = generated + generate_association (ucb, c,
                    uml_association, target, source, uml_association.class,
                    True);
	    }
        }
    }
    return generated;
}

string
generate_association (unit_code_block ucb,
		      UmlClass c, UmlAssociation uml_association, 
		      UmlRole source, UmlRole target, 
		      node link_attribute_or_target_class, 
		      boolean is_reflexive)
{
    string     association_type, association_identifier;
    boolean    is_binary;
    boolean    is_source_aggregation, is_target_aggregation;
    boolean    is_source_composition, is_target_composition;
    boolean    is_traversed_forward, is_traversed_backward;
    string     role_pattern_family = "Default";
    boolean    association_class_exists;
    pattern_descriptor pattern;
    string     source_class_name, target_class_name;

    is_traversed_forward = 
	(UmlRole__GetItemValue(target, "UmlRoleNavigability") == "True");

    is_traversed_backward =  
	(UmlRole__GetItemValue(source, "UmlRoleNavigability") == "True");

    is_source_aggregation = 
      (UmlRole__GetItemValue(source, "UmlAggregationType") == "Aggregation");
    is_target_aggregation =
      (UmlRole__GetItemValue(target, "UmlAggregationType") == "Aggregation");

    is_source_composition = 
      (UmlRole__GetItemValue(source, "UmlAggregationType") == "Composition");
    is_target_composition =
      (UmlRole__GetItemValue(target, "UmlAggregationType") == "Composition");

    pattern = create_association_pattern (role_pattern_family);

    is_binary = (list_count(uml_association.UmlTargetRoles) < 2);

    if (link_attribute_or_target_class == NULL)
        association_class_exists = False;
    else
        association_class_exists = True;


    if (is_binary)
    {
        if (link_attribute_or_target_class == NULL)
            link_attribute_or_target_class = find_by_query
                ("node[id=${target.role.from_node_id} & node_refs]");

        association_identifier = language_make_identifier (target.role.name);

        if (association_identifier == "")
	  {
            association_identifier = 
	      language_make_identifier 
	      (class_base_name (link_attribute_or_target_class));

	    if (is_target_aggregation)
	      association_identifier = 
		aggregation_whole_reference_name(association_identifier);
	    else if (is_source_aggregation)
	      association_identifier = 
		aggregation_part_reference_name(association_identifier);
	    else if (is_target_composition)
	      association_identifier = 
		composition_whole_reference_name(association_identifier);
	    else if (is_source_composition)
	      association_identifier = 
		composition_part_reference_name(association_identifier);
	    else // regular association
	      association_identifier = 
		association_reference_name(association_identifier);
	  }
    } else
    {
        if (link_attribute_or_target_class == NULL)
        {
	  print_error ("N-ary association for class '" + c.class.name + "' requires an association class.");
	  return "";
        } else
        {
            association_identifier = association_reference_name(
		language_make_identifier
                (class_base_name(link_attribute_or_target_class)));
        } 
    }

    if (is_traversed_backward && !association_class_exists)
    {
      generate_instantiations (ucb, c, c.class, 
 	    link_attribute_or_target_class, source, target);
    }

    if (is_traversed_forward || association_class_exists)
    {
	association_type = generate_association_type_from_pattern 
	    (ucb, c.class, link_attribute_or_target_class, source, target, 
	     is_binary, is_reflexive, is_source_composition,
	     association_class_exists, pattern);

	return association_identifier + " : " + 
	       association_type + ";" + NL;
    }
    else
    {
        return "";
    }
    
}

string
substituted_pattern (string a_pattern, string target_name,
		     string target_access_type, string target_package,
		     string qualifier_type, string inverse_qualifier_type)
{
    string subbed_string;

    // A target_name must always be passed.
    //
    subbed_string = string_search_and_replace (
	a_pattern, "${target_class.name}", target_name);
    subbed_string = string_search_and_replace (
	subbed_string, "${target_access_type}",
	target_access_type);
    
    if (target_package != NULL)
	subbed_string = string_search_and_replace ( 
	    subbed_string, "${target_package}", target_package);
    
    if (qualifier_type != NULL)
	subbed_string = string_search_and_replace ( 
	    subbed_string, "${qualifier.type}", qualifier_type);
    
    if (inverse_qualifier_type != NULL)
	subbed_string = string_search_and_replace ( 
	    subbed_string, "${inverse_qualifier.type}", inverse_qualifier_type);
    
    return subbed_string;
    
}
		      
string
generate_ref_for_nary_association_class (unit_code_block ucb, UmlClass c, 
					 link target_link)
{
    pattern_descriptor pattern;
    string             generated = "";
    string             association_type, association_identifier;
    UmlRole            target_role;
    node               target_class;
    string             target_name, target_package;

    target_role = UmlRole (target_link);

    target_class = find_by_query (
        "node[id=${target_link.from_node_id} & node_refs]");

    target_name    = language_make_base_name(target_class);
    target_package = library_unit_name(target_class);

    pattern = create_association_pattern ("Default");

    association_type = substituted_pattern
      (pattern.unqualified_single_pattern, target_name, 
       classwide_access_type_name(target_name), full_scope_list(target_class),
       NULL, NULL);
    
    set_add (ucb.class_withs, target_package);

    association_identifier = 
      language_make_identifier (target_role.role.name);

    if (association_identifier == "")
        association_identifier =association_reference_name(
	    language_make_identifier (
            class_base_name(target_class)));

    generated = generated + 
      association_identifier + " : " + association_type +  ";" + NL;

    return generated;
}

string
generate_ref_for_binary_association_class (unit_code_block ucb, UmlClass c, 
					   link source_link, link target_link)
{
    pattern_descriptor  pattern;
    string              generated = "";
    string              association_type, association_identifier;
    UmlRole             source_role, target_role;
    node                source_class, target_class;
    string              target_name, target_package;
    boolean             is_traversed_forward, is_traversed_backward;


    source_role = UmlRole (source_link);
    target_role = UmlRole (target_link);

    is_traversed_forward = 
	(UmlRole__GetItemValue(target_role, "UmlRoleNavigability") == "True");

    is_traversed_backward =  
	(UmlRole__GetItemValue(source_role, "UmlRoleNavigability") == "True");

    source_class = 
	find_by_query ("node[id == ${source_link.from_node_id} & node_refs]");
    target_class = 
	find_by_query ("node[id == ${target_link.from_node_id} & node_refs]");

    target_name    = language_make_base_name(target_class);
    target_package = library_unit_name(target_class);

    if (is_traversed_backward)
    {
      generate_instantiations (ucb, c, source_class, 
			       target_class, source_role, target_role); 
    }

    if (is_traversed_forward)
    {
	pattern = create_association_pattern ("Default");

	association_type = substituted_pattern
	  (pattern.unqualified_single_pattern, target_name,
	    classwide_access_type_name(target_name), full_scope_list(target_class),
     	    NULL, NULL);

	set_add (ucb.class_withs, target_package);

	association_identifier = 
	    language_make_identifier (target_role.role.name);

	if (association_identifier == "")
	    association_identifier = association_reference_name(
		language_make_identifier (
		class_base_name(target_class)));

	generated = generated + 
	    association_identifier + " : " + association_type +  ";" + NL;

	return generated;
    }
    else
    {
        return "";
    }

}

string
generate_associations_for_association_class (unit_code_block ucb,
					     UmlClass c)
{
    string          generated = "";
    link            association_class_link;
    link            first_link, second_link;
    set             link_set;
    int             i, num_links;

    //
    // If the class is an association class, we need to implement
    // associations for it since traversal along the association goes through
    // this class.  This needs to be implemented as a simple 1-1 association.
    //

    // for each association to which the association class is attached
    for_each_in_select (
        "link[UmlAssociationClassLink & to_node_id=${c.class.id} & link_refs]",
        association_class_link)
    {

        // get links from each class involved in the association
        link_set = set_select
	  ("link[(UmlRole & to_node_id=${association_class_link.from_node_id}) & link_refs]");

        // num_links == 1 for reflexive with no roles defined,
        //              2 for reflexive with roles,
        //              2 for binary, 
        //              3 for ternary, ...
        num_links = set_count (link_set);

        if (num_links == 1)
        {
            ide_warning ("  Warning: Roles are not defined for reflexive association.");
        }
        else if (num_links == 2)
        {
	    // generate association references in both directions
            first_link = set_get_element (link_set, 0);
            second_link = set_get_element (link_set, 1);

            generated = generated + 
	        generate_ref_for_binary_association_class 
		(ucb, c, first_link, second_link);

            generated = generated + 
	        generate_ref_for_binary_association_class 
		(ucb, c, second_link, first_link);

        }
        else if (num_links > 2)
	  {
	    // need set instantiation for nary associations
	    generate_tagged_set_instantiation (c, ucb);	  

	    // generate association references to all involved classes
	    for (i=0; i < num_links; i=i+1)
	    {
		first_link = set_get_element (link_set, i);

		generated = generated + 
		    generate_ref_for_nary_association_class (ucb, c, first_link);
	    }
        }

        set_clear (link_set);
    }

    return generated;
}

string
generate_association_type_from_pattern (unit_code_block ucb, node source_class,
    node target_class, UmlRole from_role, UmlRole to_role, boolean is_binary, 
    boolean is_reflexive, boolean is_composition, boolean association_class_exists, 
    pattern_descriptor pattern)
{
    string    template = "";
    boolean   is_multiple, is_ordered;
    boolean   is_qualified = False, is_inverse_qualified = False;
    string    qualifier_type = "", inverse_qualifier_type = "";
    string    multiplicity;
    string    target, target_, target_access_type;
    string    target_package;
    string    qualifier_target_;
    string    inverse_qualifier_target_;
    string    double_qualifier_target_;

    multiplicity = UmlRole__GetItemValue(to_role, "UmlMultiplicity");

    is_multiple = decode_multiplicity (multiplicity);

    is_ordered = (UmlRole__GetItemValue(to_role, "UmlRoleIsOrdered") == "True");

    // 
    //  If the qualifer is not present OR does not have a type, it will be
    //  assumed to be unqualified.
    //
    qualifier_type = 
        ada_qualifier_type (from_role, source_class, target_class, True);

    if (qualifier_type != "")
        is_qualified = True;

    inverse_qualifier_type = 
        ada_qualifier_type (to_role, target_class, source_class, True);

    if (inverse_qualifier_type != "")
        is_inverse_qualified = True;

    target         = language_make_base_name(target_class);
    target_        = target + "_";
    target_package = library_unit_name(target_class);

    if (!is_binary)
    {
        template = pattern.nary_pattern;

	set_add (ucb.class_withs, target_ + SET_TYPE_NAME);
    } 
    else if (is_qualified == False && is_inverse_qualified == False)
    {
        if (is_multiple == False)
        {
            template = pattern.unqualified_single_pattern;

	    if (!is_reflexive || association_class_exists)
	      set_add (ucb.class_withs, target_package);
        }
        else if (is_ordered == False)
        {
            template = pattern.unqualified_unordered_pattern;

	    set_add (ucb.class_withs, target_ + SET_TYPE_NAME);
        }
        else
        {
            template = pattern.unqualified_ordered_pattern;

            set_add (ucb.class_withs, target_ + LIST_TYPE_NAME);
        }

    } else if (is_qualified == True && is_inverse_qualified == False)
    {
        qualifier_target_ = qualifier_type + "_" + target_;

        if (is_multiple == False)
        {
            template = pattern.qualified_single_pattern;

            set_add (ucb.class_withs, qualifier_target_ + MAP_TYPE_NAME);
        }
        else if (is_ordered == False)
        {
            template = pattern.qualified_unordered_pattern;

            set_add (ucb.class_withs, qualifier_target_ + 
		SET_TYPE_NAME + "_" + MAP_TYPE_NAME);
        }
        else
        {
            template = pattern.qualified_ordered_pattern;

            set_add (ucb.class_withs, qualifier_target_ + 
		LIST_TYPE_NAME + "_" + MAP_TYPE_NAME);
        }


    } else if (is_qualified == False && is_inverse_qualified == True)
    {
        inverse_qualifier_target_ = inverse_qualifier_type + "_" + target_;

        if (is_multiple == False)
        {
            template = pattern.inverse_qualified_single_pattern;

            set_add (ucb.class_withs, inverse_qualifier_target_ + 
		TUPLE_TYPE_NAME);
        }
        else if (is_ordered == False)
        {
            template = pattern.inverse_qualified_unordered_pattern;

            set_add (ucb.class_withs, inverse_qualifier_target_ + 
		TUPLE_TYPE_NAME + "_" + SET_TYPE_NAME);
        }
        else
        {
            template = pattern.inverse_qualified_ordered_pattern;

            set_add (ucb.class_withs, inverse_qualifier_target_ + 
		TUPLE_TYPE_NAME + "_" + LIST_TYPE_NAME);
        }

    } else if (is_qualified == True && is_inverse_qualified == True)
    {
        double_qualifier_target_ = 
            qualifier_type + "_" + inverse_qualifier_type + "_" + target_;

        if (is_multiple == False)
        {
            template = pattern.double_qualified_single_pattern;

            set_add (ucb.class_withs, double_qualifier_target_ + 
		TUPLE_TYPE_NAME + "_" + MAP_TYPE_NAME);
        }
        else if (is_ordered == False)
        {
            template = pattern.double_qualified_unordered_pattern;

            set_add (ucb.class_withs, double_qualifier_target_ + 
		TUPLE_TYPE_NAME + "_" + SET_TYPE_NAME + "_" + MAP_TYPE_NAME);
        }
        else
        {
            template = pattern.double_qualified_ordered_pattern;

            set_add (ucb.class_withs, double_qualifier_target_ + 
		TUPLE_TYPE_NAME + "_" + LIST_TYPE_NAME + "_" + MAP_TYPE_NAME);
        }
    }

    if (is_composition)
      target_access_type = class_type_name(target);
    else
      target_access_type = classwide_access_type_name(target);

    template = substituted_pattern(template, target, 
				   target_access_type, full_scope_list(target_class),
				   qualifier_type, inverse_qualifier_type);

    return template;
}

boolean
decode_multiplicity (string multiplicity)
{
  return (multiplicity != "" && multiplicity != "0" && 
	  multiplicity != "1" && multiplicity != "0-1" && 
	  multiplicity != "0,1" && multiplicity != "0..1" && 
	  multiplicity != "ExactlyOne" && multiplicity != "exactlyone" && 
	  multiplicity != "exactly_one" && 
	  multiplicity != "One" && multiplicity != "one" && 
	  multiplicity != "Single" && multiplicity != "single" && 
	  multiplicity != "Optional" && multiplicity != "optional");
}

pattern_descriptor
create_association_pattern(string pattern_family_name)
{

    if (pattern_family_name == "")
        pattern_family_name = "Default";

    return get_family_pattern_descriptor(pattern_family_name);
}

//////////////////////////////////////////////////////////////////////////////
string
language_replace_scope_delimiter(string the_string)
{
    return string_search_and_replace(the_string, SD, SD_REPLACEMENT);
}

string
language_file_name (node package)
{
  if (ada_file_name_base == "Full Ada Unit Name")
    return string_search_and_replace(library_unit_name(package),
				     ".", FILE_NAME_DOT_REPLACEMENT_CHARACTER);
  else
    return package.name;
}

void
language_generate_file_header (list code)
{
  list_insert(code, 0, COMMENT_PREFIX);
  list_insert(code, 1, 
	      COMMENT_PREFIX + "  Created on " + time_to_string(time_now(), NULL) + 
	      " for " + user() + " from system " + current_system());
  list_insert(code, 2, COMMENT_PREFIX);
}


void
language_check_options()
{
}

set
language_compile_preprocessing(set package_set)
{
    /*
     * given the input packages, as a set of package nodes, perform any
     * pre-processing
     */
    int             i, n;
    node            package;
    set             packages = set_create("node");
    string          base_name, qualified_name;
    list            scope_list;


    /* filter packages */
    for (i = 0, n = set_count(package_set); i < n; i = i + 1)
    {
      package = set_get_element(package_set, i);

      base_name = language_make_base_name(package);
      scope_list = language_make_scope_list(package);
      qualified_name = language_build_qualified_name(scope_list, base_name);

      if (qualified_name == "")
	ide_warning("  Warning: Ignoring unnamed package with id " + package.id + "...");
      else if (is_object_excluded(package) == True)
	ide_warning("  Warning: Ignoring excluded package '" + qualified_name + "'...");	
      else if (list_count(scope_list) !=0)
	{
	  if (!set_is_member(package_set, 
			     outermost_package(package)))
	    // only warn if root ancestor package isn't in set
	    ide_warning("  Warning: Ignoring non top-level package '" + qualified_name + "'...");
	}
      else
	set_add(packages, package);
    }

    //  create dependency graph
    //  this will be used to register dependencies of subclasses on 
    //  superclasses and association sources on targets
    //
    dependency_graph = graph_create ();

    return packages;
}


list
language_compile_postprocessing(list packages)
{
    //
    //  Given the compiled packages, as a list of package descriptors, 
    //  perform any post-processing

    int             i, j, n, m;
    string          package_name;
    PackageCodeDescriptor p;
    list            sorted_package_names, sorted_packages, package_names;
    node            package;
    graph           dependencies;

    //
    //  Now order the packages based on their dependencies.
    //  This is for when more than one class is output to the same file.
    //

    // all the package names for this execution of code_gen
    //
    package_names = list_create("string", 0);
    for (i = 0; i < list_count(packages); i = i + 1)
    {
        p = list_get(packages, i);
        list_append(package_names, 
		    library_unit_name(p.uml_package.package));
    }

    if (!graph_is_acyclic(dependency_graph))
        ide_warning ( NL + 
	    "  Warning: There are circular compilation dependencies." + NL +
	    "           (Unless one or more involved packages were generated separately" + NL +
	    "            with different options.)" + NL);

    // sort packages in graph topologically 
    //
    sorted_package_names = graph_topological_sort(dependency_graph);
    m = list_count(package_names);
    sorted_packages = list_create("PackageCodeDescriptor", 0);
    for (i = 0, n = list_count(sorted_package_names); i < n; i = i + 1)
    {
        package_name = list_get(sorted_package_names, i);
        /* only return it if it's in the compiled list */
        if ((j = list_find(package_names, 0, package_name)) != m)
        {
            p = list_get(packages, j);
            list_append(sorted_packages, p);
            /* maintain the parallelism in the two collections */
            list_delete(packages, j);
            list_delete(package_names, j);
            m = m - 1;
        }
    }

    //  add the rest of the classes that don't have dependencies
    // 
    for (i = 0, n = list_count(packages); i < n; i = i + 1)
        list_append(sorted_packages, list_get(packages, i));

    return sorted_packages;
}

void
generate_set_instantiation(unit_code_block ucb, 
			   string item_name, string item_pkg, string item_type, 
			   string start_tag_line, string end_tag_line, node class)
{
  instantiation  i;

  i.start_tag = start_tag_line;
  i.end_tag = end_tag_line;
  i.class = class;
  
  i.name = item_name + "_" + SET_TYPE_NAME;
  i.generic = SET_PACKAGE_NAME;
  i.args = item_pkg + "." + item_type;

  i.withs = list_create("string",0);
  list_append(i.withs, SET_PACKAGE_NAME);
  list_append(i.withs, item_pkg);

  list_append(ucb.instantiations, i);
}

void
generate_list_instantiation(unit_code_block ucb, 
			    string item_name, string item_pkg, string item_type,
			    string start_tag_line, string end_tag_line, node class)
{
  instantiation  i;

  i.start_tag = start_tag_line;
  i.end_tag = end_tag_line;
  i.class = class;

  i.name = item_name + "_" + LIST_TYPE_NAME;
  i.generic = LIST_PACKAGE_NAME;
  i.args = item_pkg + "." + item_type;

  i.withs = list_create("string",0);
  list_append(i.withs, LIST_PACKAGE_NAME);
  list_append(i.withs, item_pkg);

  list_append(ucb.instantiations, i);
}

void
generate_map_instantiation(unit_code_block ucb, string key_type,
			   string value_name,string value_pkg,string value_type,
			   string start_tag_line, string end_tag_line, node class)
{
  instantiation  i;
  
  i.start_tag = start_tag_line;
  i.end_tag = end_tag_line;
  i.class = class;

  i.name = ada_concatenated_name (key_type, value_name, MAP_TYPE_NAME);
  i.generic = MAP_PACKAGE_NAME;
  i.args = key_type + ", " + value_pkg + "." + value_type;

  i.withs = list_create("string",0);
  list_append(i.withs, MAP_PACKAGE_NAME);
  list_append(i.withs, value_pkg);

  list_append(ucb.instantiations, i);
}

void
generate_tuple_instantiation (unit_code_block ucb, string first_type,
			      string second_name, string second_pkg,
			      string second_type,
			      string start_tag_line, string end_tag_line, node class)
{
  instantiation  i;

  i.start_tag = start_tag_line;
  i.end_tag = end_tag_line;
  i.class = class;
  
  i.name = ada_concatenated_name(first_type, second_name, TUPLE_TYPE_NAME);
  i.generic = TUPLE_PACKAGE_NAME;
  i.args = first_type + ", " + second_pkg + "." + second_type;

  i.withs = list_create("string",0);
  list_append(i.withs, TUPLE_PACKAGE_NAME);
  list_append(i.withs, second_pkg);

  list_append(ucb.instantiations, i);
}

string
ada_concatenated_name (string first, string second, string third)
{
    string converted_first;

    // 
    //  The first string is assumed to be a fully qualified ada
    //  type name for which we must remove the scope delimiter.
    //
    converted_first = string_search_and_replace (first, ".", "_");

    return converted_first + "_" + second + "_" + third;
}

//
//  !! look at uml_name_type_syntax... for overlap with the other
//     string_search_and_replace, and look at parse_array_... to
//     see if it's necessary
string
ada_qualifier_type (UmlRole role, node source_class, node target_class, 
    boolean replace_scope_delimiter)
{
    string qualifier = "", qualifier_name = "", qualifier_type = "";
    string ada_qualifier_type = "";

    if ((qualifier = UmlRole__GetItemValue(role, "UmlRoleQualifier")) != "")
    {
        qualifier_name =
            uml_name_type_syntax_2_type_space_name_syntax(qualifier, "N", "");
 
        qualifier_type =
            uml_name_type_syntax_2_type_space_name_syntax(qualifier, "T", "");
 
        if (qualifier_type == "")
            qualifier_type = attribute_type
                (get_attribute_by_name(target_class, qualifier_name));
 
        qualifier_type = parse_array_syntax_from_type (qualifier_type);
 
        if (qualifier_type != "")
            if (replace_scope_delimiter)
                ada_qualifier_type = 
                    string_search_and_replace (qualifier_type, ".", "_");
            else
                ada_qualifier_type = qualifier_type;
        else
            ide_warning ("  Warning: Key '" + qualifier_name + "' for '" + class_qualified_name(source_class) + "' missing type.");
    }

    return ada_qualifier_type;
}


void
generate_instantiations (unit_code_block ucb,
			 UmlClass c, 
			 node source_class, node target_class, 
			 UmlRole from_role, UmlRole to_role)
{
    boolean          self_is_multiple, self_is_ordered;
    string           self_multiplicity; 
    boolean          is_qualified = False, is_inverse_qualified = False;
    string           qualifier_type = "", inverse_qualifier_type = "";

    self_multiplicity = UmlRole__GetItemValue(from_role, "UmlMultiplicity");

    self_is_multiple = decode_multiplicity(self_multiplicity);

    self_is_ordered = 
        (UmlRole__GetItemValue (from_role, "UmlRoleIsOrdered") == "True");

    // 
    //  If the qualifer is not present OR does not have a type, it will be
    //  assumed to be unqualified.
    //
    qualifier_type = 
        ada_qualifier_type (from_role, source_class, target_class, False);

    if (qualifier_type != "")
        is_qualified = True;

    inverse_qualifier_type = 
        ada_qualifier_type (to_role, target_class, source_class, False);

    if (inverse_qualifier_type != "")
        is_inverse_qualified = True;

    if (is_qualified)
      {
	generate_tagged_tuple_instantiation (qualifier_type, c, ucb);

        if (self_is_multiple)
	  {
	    if (self_is_ordered)
	      {
		generate_tagged_list_of_tuple_instantiation 
		  (qualifier_type, c, ucb);

                if (is_inverse_qualified)
		  generate_tagged_map_to_list_of_tuple_instantiation 
		    (inverse_qualifier_type, qualifier_type, c, ucb);
	      }
            else
	      {
		generate_tagged_set_of_tuple_instantiation 
		  (qualifier_type, c, ucb);

                if (is_inverse_qualified)
		  generate_tagged_map_to_set_of_tuple_instantiation 
		    (inverse_qualifier_type, qualifier_type, c, ucb);
	      }
	  }
        else
	  {
	    if (is_inverse_qualified)
	      generate_tagged_map_to_tuple_instantiation
		(inverse_qualifier_type, qualifier_type, c, ucb);
	  }
      }
    else
      {
        if (self_is_multiple)
	  {
            if (self_is_ordered)
	      {
		generate_tagged_list_instantiation (c, ucb);
		if (is_inverse_qualified)
		  generate_tagged_map_to_list_instantiation 
		    (inverse_qualifier_type, c, ucb);
	      }
            else
	      {
		generate_tagged_set_instantiation (c, ucb);
		if (is_inverse_qualified)
		  generate_tagged_map_to_set_instantiation 
		    (inverse_qualifier_type, c, ucb);
	      }
	  }
        else
	  {
	    if (is_inverse_qualified)
	        generate_tagged_map_instantiation (inverse_qualifier_type, c, ucb);
	  }
      }
}

const string    BAD_ADA95_IDENTIFERS_TRANSLATE_TABLE = 
    " !@#$%^&*()+-=|\\{}[],./<>?~`;:'\"\t" + NL;

const string    GOOD_ADA95_IDENTIFERS_TRANSLATE_TABLE = 
    string_repeat("_", string_length(BAD_ADA95_IDENTIFERS_TRANSLATE_TABLE));

string
language_make_identifier(string s)
{
    //
    // given a string, translate it into a valid identifier for the language
    //
    s = language_replace_scope_delimiter(s);
    
    return string_translate(s, BAD_ADA95_IDENTIFERS_TRANSLATE_TABLE,
                            GOOD_ADA95_IDENTIFERS_TRANSLATE_TABLE);
}

const string    BAD_ADA95_CLASS_IDENTIFERS_TRANSLATE_TABLE = 
    " !@#$%^&*()+-=|\\{},./<>?~`;'\"\t" + NL;
const string    GOOD_ADA95_CLASS_IDENTIFERS_TRANSLATE_TABLE = string_repeat 
    ("_", string_length(BAD_ADA95_CLASS_IDENTIFERS_TRANSLATE_TABLE));

string
language_make_unit_name(node package)
{
  return library_unit_name(package);
}

string
full_scope_list(node object)
{
  string parent = library_unit_parent_name(outermost_package(object));
  if (parent != "")
    parent = parent + ".";
  return (parent + list_to_string(language_make_scope_list(object), SD));
}

string
full_qualified_name(node object)
{
  string parent = library_unit_parent_name(outermost_package(object));
  if (parent != "")
    parent = parent + ".";
  return (parent + language_make_qualified_name(object));
}

string
language_make_base_name(node class)
{
    //
    // given a UML class, or some UML construct that is supposed to be
    // implemented as a class, translate its name into a valid class 
    // name for the language (ignore anything enclosed in <>'s, e.g.
    // template arguments, and filter out bad characters)
    //
    // also, get the fully qualified name using enclosing packages,
    // but don't worry about enclosing classes yet
    //
    string s;

    if (class.type == "UmlClass")
	s = class_base_name(class);
    else
	s = language_make_identifier(class.name);

    return translated_class_string(s);
}

// source should be a package, class or operation
void
generate_object_dependencies(unit_code_block ucb, node source)
{
  node  target;
  string target_package;
  int   i,n;
  link  dependency;
  list  dependencies;

  dependencies = list_select("link[UmlDependency && link_refs && from_node_id=${source.id}]");

  for (i = 0, n = list_count(dependencies); i < n; i = i + 1)
    {
      dependency = list_get(dependencies, i);
      target = find_by_query ("node[id == ${dependency.to_node_id} & node_refs]");

      target_package = library_unit_name(target);

      // 1. For operations we add withs to the package body
      // 2. For classes we add it the spec or body depending on where the
      // full class definition appears 
      // 3. For packages we add the withs to both spec and body
      
      // Do we want to offer some user control for this?

      if (source.type == "UmlOperation")
	set_add(ucb.body_withs, target_package);
      else if (source.type == "UmlClass")
	set_add(ucb.class_withs, target_package);
      else if (source.type == "UmlPackage")
	{
	  set_add(ucb.specification_withs, target_package);
	  set_add(ucb.body_withs, target_package);
	}
      else
	ide_error("QRL function generate_object_dependencies called with inappropriate arguments.");
    }
}

list
language_make_scope_list(node class)
{
    string scope_string, one_scope;
    const string LIST_SEPARATOR = "?";
    list scope_list;
    int i, n;

    // get string containing the enclosing scopes
    scope_string = uml_class_qualified_name(class);

    // prepare for conversion to list
    scope_string = string_search_and_replace(scope_string, UML_PATH_SEPARATOR,
					     LIST_SEPARATOR); 

    // convert to list
    scope_list = string_to_list(scope_string, LIST_SEPARATOR);

    // delete the last item of the list, which is the class itself,
    // leaving only the scopes
    list_delete(scope_list, (list_count(scope_list)-1));

    // translate the names of the scopes for Ada_95
    for (i = 0, n = list_count(scope_list); i < n; i = i + 1) {
	one_scope = list_get(scope_list, i);
	list_set(scope_list, i, translated_class_string(one_scope));
    }

    return scope_list;
}

string
language_build_qualified_name(list scope_list, string base_name)
{
    if (list_count(scope_list) == 0)
	return base_name;
    else
	return list_to_string(scope_list, SD) + SD + base_name;
}

string
language_make_qualified_name(node class)
{
    node name_class;

    // 'class_surrogate_node' is used here to handle the case of making
    // a qualified name for an anonymous instantiation.  uclassd does
    // not allow the complete qualified name to be used as a label,
    // but we can still come up with the complete qualified name by
    // finding the corresponding parameterized class.
    name_class = class_surrogate_node(class);

    return language_build_qualified_name(
	language_make_scope_list(name_class), 
	language_make_base_name(name_class));
}

string
translated_class_string(string s)
{
    // Note this ignores everything after the first "<", not just what is 
    // between "<" and ">".  In practice, for classes that is the same thing.

    int             f = string_find(s, 0, "<");
    int             l = string_length(s);
    string          t = "";

    if (f != l)
    {
	t = string_extract(s, f, l - f);
	s = string_extract(s, 0, f);
    }

    return string_translate(s, BAD_ADA95_CLASS_IDENTIFERS_TRANSLATE_TABLE,
                            GOOD_ADA95_CLASS_IDENTIFERS_TRANSLATE_TABLE) + t;
}


const string    BAD_ADA95_ATTR_IDENTIFERS_TRANSLATE_TABLE = 
    "!@#$%^&*()+-=|\\{},./<>?~`;:'\"\t" + NL;
const string    GOOD_ADA95_ATTR_IDENTIFERS_TRANSLATE_TABLE = string_repeat 
    ("_", string_length(BAD_ADA95_ATTR_IDENTIFERS_TRANSLATE_TABLE));

string
language_make_attribute_identifier(string s)
{
    //
    // translate string it into a valid class identifier for the language
    //

    return string_translate (s, BAD_ADA95_ATTR_IDENTIFERS_TRANSLATE_TABLE, 
	GOOD_ADA95_ATTR_IDENTIFERS_TRANSLATE_TABLE);
}


const string    BAD_ADA95_OPERATION_IDENTIFERS_TRANSLATE_TABLE = 
    "@#$\\{}.?`;:'\t" + NL;

const string    GOOD_ADA95_OPERATION_IDENTIFERS_TRANSLATE_TABLE = string_repeat
    ("_", string_length(BAD_ADA95_OPERATION_IDENTIFERS_TRANSLATE_TABLE));

string
make_operation_identifier(string s)
{
    return string_translate (s, BAD_ADA95_OPERATION_IDENTIFERS_TRANSLATE_TABLE,
	GOOD_ADA95_OPERATION_IDENTIFERS_TRANSLATE_TABLE);
}

string
make_attribute_name(UmlAttribute uml_attribute)
{
    string          attribute_name, attribute_type;

    attribute_type = 
	UmlAttribute__GetItemValue(uml_attribute, "UmlAttributeType");
    attribute_name = 
	language_make_attribute_identifier(uml_attribute.attribute.name);

    return parse_array_syntax_from_name(attribute_name, attribute_type);
}

string
make_attribute_type(UmlAttribute uml_attribute)
{
    string          attribute_type;

    attribute_type = 
	UmlAttribute__GetItemValue(uml_attribute, "UmlAttributeType");

    return parse_array_syntax_from_type(attribute_type);
}

string
parse_array_syntax_from_name(string attribute_name, string attribute_type)
{
    int             array_open, array_close;

    if (attribute_type != "")
    {
        array_open = string_find(attribute_type, 0, "[");
        if (array_open < string_length(attribute_type))
        {
            array_close = string_find(attribute_type, array_open, "]");
            if (array_close < string_length(attribute_type))
                attribute_name = attribute_name + string_extract (
		    attribute_type, array_open, (array_close - array_open) + 1);
        }
    }

    return attribute_name;
}

string
parse_array_syntax_from_type(string attribute_type)
{
    int             array_open, array_close;

    if (attribute_type != "")
    {
        array_open = string_find(attribute_type, 0, "[");
        if (array_open < string_length(attribute_type))
        {
            array_close = string_find(attribute_type, array_open, "]");
            if (array_close < string_length(attribute_type))
                attribute_type = string_extract(attribute_type, 0, array_open);
        }
    }

    return attribute_type;
}


void
generate_tagged_set_instantiation (UmlClass c,
				   unit_code_block ucb)
{
    string class_name, class_pkg, class_type;

    class_name = c.class.name;
    class_pkg  = library_unit_name(c.class);
    class_type = classwide_access_type_name(class_name);

    generate_set_instantiation (ucb, class_name, class_pkg, class_type,
				START_SET_TAG, END_SET_TAG, c.class);
}

void
generate_tagged_list_instantiation (UmlClass c,
				    unit_code_block ucb)
{
    string class_name, class_pkg, class_type;

    class_name = c.class.name;
    class_pkg  = library_unit_name(c.class);
    class_type = classwide_access_type_name(class_name);

    generate_list_instantiation (ucb, class_name, class_pkg, class_type, 
				 START_LIST_TAG, END_LIST_TAG, c.class);
}

void
generate_tagged_map_instantiation (string key_type, UmlClass c,
				   unit_code_block ucb)
{
    string class_name, class_pkg, class_type;
    string start_tag;
    
    class_name = c.class.name;
    class_pkg  = library_unit_name(c.class);
    class_type = classwide_access_type_name(class_name);

    start_tag = START_MAP_TAG + key_type + "  ";

    generate_map_instantiation (ucb, key_type,
				class_name, class_pkg, class_type, 
				start_tag, END_MAP_TAG, c.class);
}

void
generate_tagged_map_to_set_instantiation (string key_type, 
					  UmlClass c,
					  unit_code_block ucb)
{
    string class_name, set_pkg, set_type;
    string start_tag;

    class_name = c.class.name;
    set_pkg    = class_name + "_" + SET_TYPE_NAME;
    set_type   = SET_TYPE_NAME;

    start_tag = START_MAP_TO_SET_TAG + key_type + "  ";

    generate_map_instantiation (ucb, key_type,
				set_pkg, set_pkg, set_type, 
				start_tag, END_MAP_TO_SET_TAG, c.class);
}

void
generate_tagged_map_to_list_instantiation (string key_type, 
					   UmlClass c,
					   unit_code_block ucb)
{
    string class_name, list_pkg, list_type;
    string start_tag;

    class_name = c.class.name;
    list_pkg   = class_name + "_" + LIST_TYPE_NAME;
    list_type  = LIST_TYPE_NAME;

    start_tag = START_MAP_TO_LIST_TAG + key_type + "  ";

    generate_map_instantiation (ucb, key_type,
				list_pkg, list_pkg, list_type, 
				start_tag, END_MAP_TO_LIST_TAG, c.class);
}

void
generate_tagged_tuple_instantiation (string type, UmlClass c,
				     unit_code_block ucb)
{
    string class_name, class_pkg, class_type;
    string start_tag;

    class_name = c.class.name;
    class_pkg  = library_unit_name(c.class);
    class_type = classwide_access_type_name(class_name);

    start_tag = START_TUPLE_TAG + type + "  ";

    generate_tuple_instantiation (ucb, type,
				  class_name, class_pkg, class_type, 
				  start_tag, END_TUPLE_TAG, c.class);
}

void
generate_tagged_set_of_tuple_instantiation (string type, UmlClass c,
					    unit_code_block ucb)
{
    string class_name, tuple_pkg, tuple_type;
    string start_tag;

    class_name = c.class.name;
    tuple_pkg  = ada_concatenated_name (type, class_name, TUPLE_TYPE_NAME);
    tuple_type = TUPLE_TYPE_NAME;

    start_tag = START_SET_OF_TUPLE_TAG + type + "  ";

    generate_set_instantiation (ucb, tuple_pkg, tuple_pkg, tuple_type, 
				start_tag, END_SET_OF_TUPLE_TAG, c.class);
}

void
generate_tagged_list_of_tuple_instantiation (string type, UmlClass c,
					     unit_code_block ucb)
{
    string class_name, tuple_pkg, tuple_type;
    string start_tag;

    class_name = c.class.name;
    tuple_pkg  = ada_concatenated_name (type, class_name, TUPLE_TYPE_NAME);
    tuple_type = TUPLE_TYPE_NAME;

    start_tag = START_LIST_OF_TUPLE_TAG + type + "  ";

    generate_list_instantiation (ucb, tuple_pkg, tuple_pkg, tuple_type,
				 start_tag, END_LIST_OF_TUPLE_TAG, c.class);
}

void
generate_tagged_map_to_tuple_instantiation (string key_type, string type, 
					    UmlClass c,
					    unit_code_block ucb)
{
    string class_name, tuple_pkg, tuple_type;
    string start_tag;

    class_name = c.class.name;
    tuple_pkg  = ada_concatenated_name (type, class_name, TUPLE_TYPE_NAME);
    tuple_type = TUPLE_TYPE_NAME;

    start_tag = START_MAP_TO_TUPLE_TAG + key_type + "  " + type + "  ";

    generate_map_instantiation (ucb, key_type,
				tuple_pkg, tuple_pkg, tuple_type, 
				start_tag, END_MAP_TO_TUPLE_TAG, c.class);
}

void
generate_tagged_map_to_set_of_tuple_instantiation (string key_type, 
						   string type, UmlClass c,
						   unit_code_block ucb)
{
    string class_name, tuple_pkg, tuple_type, set_pkg, set_type;
    string start_tag;

    class_name = c.class.name;
    tuple_pkg  = ada_concatenated_name (type, class_name, TUPLE_TYPE_NAME);
    set_pkg    = tuple_pkg + "_" + SET_TYPE_NAME;
    set_type   = SET_TYPE_NAME;

    start_tag = START_MAP_TO_SET_OF_TUPLE_TAG + key_type + "  " + type + "  ";

    generate_map_instantiation (ucb, key_type,
				set_pkg, set_pkg, set_type, 
				start_tag, END_MAP_TO_SET_OF_TUPLE_TAG, c.class);
}

void
generate_tagged_map_to_list_of_tuple_instantiation (string key_type, 
						    string type, UmlClass c,
						    unit_code_block ucb)
{
    string class_name, tuple_pkg, tuple_type, list_pkg, list_type;
    string start_tag;

    class_name = c.class.name;
    tuple_pkg  = ada_concatenated_name (type, class_name, TUPLE_TYPE_NAME);
    list_pkg   = tuple_pkg + "_" + LIST_TYPE_NAME;
    list_type  = LIST_TYPE_NAME;

    start_tag = START_MAP_TO_LIST_OF_TUPLE_TAG + key_type + "  " + type + "  ";

    generate_map_instantiation (ucb, key_type,
				list_pkg, list_pkg, list_type, 
				start_tag, END_MAP_TO_LIST_OF_TUPLE_TAG, c.class);
}

string
object_code_gen_id (node object)
{
  item code_gen_id_item;

  if (object == NULL)
    return "";

  code_gen_id_item = 
    find_by_query("item[obj_id=${object.id} & UmlCxxCodeGenId]");
  
  if (code_gen_id_item != NULL)
    return code_gen_id_item.value;
  else
    return to_string(object.id);
}

void
append_begin_tag (list code, string tag, node object)
{
  list_append(code, tag + object_code_gen_id(object));
}

void
append_end_tag (list code, string tag)
{
  list_append(code, tag);
}

void
append_tag_pair (list code, int index, node object,
		 string start_tag, string end_tag)
{
  // no code generated - don't add any tags
  if (index == list_count(code))
    return;

  list_insert(code, index, start_tag + object_code_gen_id(object));
  list_append(code, end_tag);
}
	       
string
spaces(int n)
{
  int i;
  string s = "";

  for (i = 0; i < n; i = i + 1)
    s = s + " ";
  
  return s;
}  
