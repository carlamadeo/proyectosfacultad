//*****************************************************************************
// $RCSfile: ada_genop.tdl,v $
// $Revision: 1.4 $
// $Date: 2002/03/08 16:03:54 $
// Author: Peter Kleiner
//*****************************************************************************

//WDH care for the fact that the signature editor incorrectly generates INOUT for IN OUT parameters. 

/*
Support templates and procedures dealing with operations.
called by genSpec (defined in ada_genspec.tdl) and genBody (defined in ada_genbody.tdl).

templates/procs called in genSpec. The order follows the occurence in genSpec

13a. genClassOperationsSpecs
	Generate a subprogram declaration for each instance of MOperation with a
	visibility as indicated by the second parameter, i.e.
	public: public part of package specification
	private: private part of package specification
	implementation: package body
13b. genClassOperationsSpecsTask
	Generate an entry declaration for each operation
13c. genClassOperationsSpecsPT
	Generate an entry/procedure/function declaration for each operation
13.1. genSubprogramDeclaration
	generate the subprogram declaration for an instance of MOperation
13.1.1. genOpParaList
	generate the parameter list for an instance of MOperation
13.1.1.1. genOperationBindingOpen
13.1.1.2. [MParaItem].genDefault()
13.1.2. genRename

templates/procs called in genBody. The order follows the occurence in genBody

20a. genOperationBody
20b. genOperationBodyCallPT
20c. genOperationBodyCallTask
20d. genOperationBodyCallSM
20e. genOperationBodyTask
20.1. genFunctionDefaultBody
25a. genClassOperationsBodies
25b. genClassOperationsBodiesPT
25c. genClassOperationsBodiesTask

*/

/* 13a. operations with visibility as indicated by [place] */
template genClassOperationsSpecs(MClass,place)
[if(isStoragePool([MClass]) && classPrivacyMatch(getClassPrivacy([MClass]),[place]))]
[insert("include","System.Storage_Elements")]
procedure Allocate	(Pool : in out [MClass.name];
			 Storage_Address : out System.Address;
			 Size_In_Storage_Elements : in System.Storage_Elements.Storage_Count;
			 Alignment : in System.Storage_Elements.Storage_Count);

procedure Deallocate	(Pool : in out [MClass.name];
			 Storage_Address : in System.Address;
			 Size_In_Storage_Elements : in System.Storage_Elements.Storage_Count;
			 Alignment : in System.Storage_Elements.Storage_Count);
			 
function Storage_Size	(Pool : [MClass.name]) return System.Storage_Elements.Storage_Count;
[end if]
[loop(MClass->MOperation where [MOperation].visibility() == [place];setText(genSectionComment("Operations")))]
[getText()]
[genSubprogramDeclaration([MOperation],[MClass])]
[end loop]
end template

/* 13b. class operations in task type declaration */
template genClassOperationsSpecsTask(MClass)
[loop(MClass->MOperation where ![MOperation].isStatic();setText(""genSectionComment("Operations")))]
[getText()]
[   if([MOperation:callEventId] == "")]
entry [MOperation.name][genOpParaList([MOperation],FALSE)][closeList()];
[   else]
[       // avoid duplicate for operations matching an event]
[   end if]
[end loop]
end template

/* 13c. class operations in protected type declaration */
template genClassOperationsSpecsPT(MClass)
[loop(MClass->MOperation where ![MOperation].isStatic();setText(""genSectionComment("Operations")))]
[getText()]
[   if(isEntry([MOperation]))]
[      if([MOperation:callEventId] == "")]
entry [MOperation.name][genOpParaList([MOperation],FALSE)][closeList()];
[      end if]
[   else]
[      if(isFunction([MOperation]))]
function [MOperation.name][genOpParaList([MOperation],FALSE)][closeList()] return [genResultType([MOperation.returnType])];
[      else]
procedure [MOperation.name][genOpParaList([MOperation],FALSE)][closeList()];
[      end if]
[   end if]
[end loop]
end template

/* 13.1 generate declaration for the given instance of MOperation. genResultType
   generates an Ada subtype indication for the result type given in the model
   (defined in ada_std.tdl) */
template genSubprogramDeclaration(MOperation,MClass)
[if(isFunction([MOperation]))]
function [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] return [genResultType([MOperation.returnType])][genRename([MClass],[MOperation.name])][[MOperation].genAbstract()];
[appendMapFile("function "[MOperation.name][genOpParaList([MOperation],TRUE)][closeList()],[MClass.name]"_"[MOperation.name])]
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
function Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()] return [genResultType([MOperation.returnType])][genRename([MClass],[MOperation.name])][[MOperation].genAbstract()];
[appendMapFile("function "[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()],[MClass.name]"_"[MOperation.name])]
[   end if]
[else]
procedure [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()][genRename([MClass],[MOperation.name])][[MOperation].genAbstract()];
[appendMapFile("procedure "[MOperation.name][genOpParaList([MOperation],TRUE)][closeList()],[MClass.name]"_"[MOperation.name])]
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
procedure Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()][genRename([MClass],[MOperation.name])][[MOperation].genAbstract()];
[appendMapFile("procedure "[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()],[MClass.name]"_"[MOperation.name])]
[   end if]
[end if]
[if(isInlined([MOperation]))]
	[genInlinePragma([MOperation.name])]
[end if]
end template

proc genTimeoutDecl(MOperation)

   local oldDelim = delim();
   
   setDelim("; ");
   if(isFunction([MOperation]))
      return [oldDelim] "Timeout : duration; Timed_Out : access Boolean";
   else
      return [oldDelim] "Timeout : duration; Timed_Out : OUT Boolean";
   end if
end proc
/* 13.1.1. genOpParaList. addthis indicates whether an implicit parameter for the
   instance of MClass is added to the parameter list. genParameterType generates
   an Ada subtype indication for the type specification given in the model
   (defined in ada_std.tdl) */
// The original version bases the selection 'this' / 'acc_this' parameter on [MOperation].isStatic() 
proc genOpParaList(MOperation,addthis)

   local result = "";

   if ([addthis] && ![MOperation].isStatic())
      [result] = genOperationBindingOpen([MOperation]);
   else
      openList();
      if(isFunction([MOperation]) && ![MOperation].isStatic())
         // the Task/PT operation is mapped to an entry
         loop(MOperation->MClass)
            if(isTask([MClass]) || (isPT([MClass]) && isEntry([MOperation])))
               setDelim("; ");
               [result] = "(result : out " genResultType([MOperation.returnType]);
            end if
         end loop
      end if
   end if
   loop(MOperation->OpPara)
//WDH care for the fact that the signature editor incorrectly generates INOUT for IN OUT parameters. 
      local mechanism = replace([OpPara.mechanism],"INOUT","IN OUT");
      if ([mechanism] == "")
         [mechanism] = "IN"; // just a matter of style (and compatibility to previous versions)
      end if
      [result] = [result] delim() [OpPara.name] " : " [mechanism] " " genParameterType([OpPara.type]) [OpPara].genDefault();
      setDelim("; ");
   end loop

   return breakLongLines([result],"; ");

end proc

// fixUp will modify a tokenSet such that each line is indented as the call of fixUp.
//
// fixUp must be called from a template with a trailing backslash to avoid empty lines
// Also, no TDL calls on the left of the fixUp call; otherwise the indentation
// will be incorrect due to the implementation of getIndentCount.
proc fixUp(block)
    local res = "";
    local delim = "";
    loop (Instances->TokenSet([block]))
         [res] = [res] [delim] [TokenSet.line]"\n";
         [delim] = createString(" ",getIndentCount());
    end loop
    return [res];
end proc

// We know this will not result in perfect indentation due to TDL call left to the fixUp() call.
// Anyway, this is better than without fixUp and still encapsulates the algorithm locally.
proc breakLongLines(line,separator)
   if (getLength([line]) < 120)
      return [line];
   else
      return fixUp( "\n" replace ([line], [separator], [separator]"\n"));
   end if
end proc

proc MOperation.genAbstract()

   if([MOperation].isAbstract())
      return " is abstract";
   end if
   
end proc

/* 13.1.1.1. put parameter for operation depending on binding of an attribute.
   The delim() is set correctly */
proc genOperationBindingOpen(MOperation)

   loop(MOperation->MClass)
      switch([MOperation.binding])
      case "normal" : // Thus, all non-static operations are considered virtual
      case "virtual" :
         setDelim("; ");
         if(getClassPrivacy([MClass]) != "implementation")
            return "(acc_this : access " [MClass.name];
         else
            return "(acc_this : " [MClass.name] "_ptr";
         end if
      case "static" :
         openList();
         return "";
      default :
         // That's how we would treat non-static, non-virtual operations
         setDelim("; ");
         return "(acc_this : " getClassParamForUpdate([MClass]);
      end switch
   end loop

end proc

/* 13.1.1.2. add default value to parameter declaration, if any */
template MParaItem.genDefault()
[if([MParaItem.defaultValue] != "")]
 := [genExpression([MParaItem.defaultValue])]
[end if]
end template

/* 13.1.2. generated "renames ...", if applicable */
proc genRename(MClass, opName)
if(isInterface([MClass]) )
  loop(MClass->MInterface->Implementation As ImplClass)
     return " renames " importClassOp([ImplClass],[opName]);
  end loop
else
  bodyIsRequired();
end if
end proc

/* 20a. generate the body of an operation belonging to the instance of MClass.
   addthis indicates whether "this" shall be added, if not operation is not static */
template genOperationBody(MOperation,MClass,addthis)

--------------------------------------------------------------------------------
-- Operation :		[MOperation.name]
--
-- Description :	[outText([MOperation.description],"","\t--\t\t\t\t\t")]
--
--------------------------------------------------------------------------------
\
[if(isEntry([MOperation]))]
\
entry [MOperation.name][genOpParaList([MOperation],[addthis])][closeList()] when
[mergeOut("UDEB::"getUniqueId([MOperation]),"barrier condition","true ")]
is
[   if([addThis])]
	[accThis([MClass])]
[   end if]
[   if(getCodeFromRep([MOperation]) == "")]
[mergeOut("UDOI::"getUniqueId([MOperation]),"entry code","begin\n\tnull;")]
[   else]
[getCodeFromRep([MOperation])]
[   end if]
end [MOperation.name];
\
[else if(isFunction([MOperation]))]
\
function [MOperation.name][genOpParaList([MOperation],[addthis])][closeList()] return [genResultType([MOperation.returnType])] is
[   if([addThis])]
	[accThis([MClass])]
[   end if]
[   if(getCodeFromRep([MOperation]) == "")]
[mergeOut("UDOI::"getUniqueId([MOperation]),"function code",genFunctionDefaultBody([MOperation.returnType]))]
[   else]
[getCodeFromRep([MOperation])]
[   end if]
end [MOperation.name];
\
[else]
\
procedure [MOperation.name][genOpParaList([MOperation],[addthis])][closeList()] is
[   if([addThis])]
	[accThis([MClass])]
[   end if]
[   if(getCodeFromRep([MOperation]) == "")]
[mergeOut("UDOI::"getUniqueId([MOperation]),"procedure code","begin\n\tnull;")]
[   else]
[getCodeFromRep([MOperation])]
[   end if]
end [MOperation.name];
\
[end if end if]
end template

/* 20b. generate the body of an operation belonging to the instance of MClass.
   this is called in the package body to produce the body of the wrappers for
   the protected type function and procedures/entries */
template genOperationBodyCallPT(MOperation,MClass)
[if(isFunction([MOperation]))]
function [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] return [genResultType([MOperation.returnType])] is
[   if (isEntry([MOperation]))]
   Result : [genResultObjectType([MOperation.returnType])];
begin
   [accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
   return result;
[   else]
begin
   return [accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
[   end if]
end [MOperation.name];
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
function Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()] return [genResultType([MOperation.returnType])] is
	Result : [genResultObjectType([MOperation.returnType])];
begin
	select
		[accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
		Timed_Out.all := False;
	or delay Timeout;
		Timed_Out.all := True;
	end select;
	return result;
end Timed_[MOperation.name];
[   end if]
[else] 
procedure [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] is
begin
   [accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
end [MOperation.name];
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
procedure Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()] is
begin
	select
		[accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
		Timed_Out := False;
	or delay Timeout;
		Timed_Out := True;
	end select;
end Timed_[MOperation.name];
[   end if]
[end if]
end template

/* 20c. generate the body of an operation belonging to the instance of MClass.
   this is called in the package body to produce the body of the wrappers for
   the task type entries */
template genOperationBodyCallTask(MOperation,MClass)
[if(isFunction([MOperation]))]
function [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] return [genResultType([MOperation.returnType])] is
	Result : [genResultObjectType([MOperation.returnType])];
begin
	[accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
	return Result;
end [MOperation.name];
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
function Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()] return [genResultType([MOperation.returnType])] is
	Result : [genResultObjectType([MOperation.returnType])];
begin
	select
		[accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
		Timed_Out.all := False;
	or delay Timeout;
		Timed_Out.all := True;
	end select;
	return Result;
end Timed_[MOperation.name];
[   end if]
[else] 
procedure [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] is
begin
   [accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
end [MOperation.name];
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
procedure Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()] is
begin
	select
		[accThisToTaskPt([MClass])][MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
		Timed_Out := False;
	or delay Timeout;
		Timed_Out := True;
	end select;
end Timed_[MOperation.name];
[   end if]
[end if]
end template

/* 20d. generate the body of an operation belonging to the instance of MClass.
   this is called in the package body to produce an operation body which is a call event */
// see gensm.tdl

/* 20e */
template genOperationBodyTask(MOperation,MClass)
accept [MOperation.name][genOpParaList([MOperation],FALSE)][closeList()] do
[   if(getCodeFromRep([MOperation]) == "")]
[mergeOut("UDOI::"getUniqueId([MOperation]),"procedure code","null;")]
[   else]
[getCodeFromRep([MOperation])]
[   end if]
end [MOperation.name];
end template

/* 20.1. function default body */
template genFunctionDefaultBody(returnType)
	Result : [genResultObjectType([returnType])];
begin
	return Result;
end template

/* 20.2. useOpParaList. addthis indicates whether an implicit parameter for the
   instance of MClass is added to the association list. */
proc useOpParaList(MOperation,addthis)

   local result = "";

   if ([addthis] && ![MOperation].isStatic())
      [result] = delim() "acc_this";
      setDelim(", ");
   else
      if(isFunction([MOperation]))
         loop(MOperation->MClass)
            if(isTask([MClass]) || (isPT([MClass]) && isEntry([MOperation])))
               [result] = "(result";
               setDelim(", ");
            end if
         end loop
      end if
   end if
   loop(MOperation->OpPara)
      [result] = [result] delim() [OpPara.name];
      setDelim(", ");
   end loop

   return [result] closeList();

end proc

/* 25a. generate the bodies of all operations belonging to the instance of MClass.
   called only in a package body */
template genClassOperationsBodies(MClass)
[loop(MClass->MOperation;setText(""genSectionComment("Operations")))]
[getText()]

[   if([MOperation].isAbstract())]
[   else if([MOperation].isSubunit())]
[      if (isFunction([MOperation]))]
function [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] return [genResultType([MOperation.returnType])] is separate;
[      else]
procedure [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] is separate;
[      end if]
[   else if(isCallEvent([MOperation],[MClass]))]
[genOperationBodyCallSM([MOperation],[MClass])]
[   else if(isPT([MClass]) && ![MOperation].isStatic())]
[genOperationBodyCallPT([MOperation],[MClass])]
[   else if(isTask([MClass]) && ![MOperation].isStatic())]
[genOperationBodyCallTask([MOperation],[MClass])]
[   else]
[genOperationBody([MOperation],[MClass],"TRUE")]
[   end if end if end if end if end if]
[end loop]
[if(isStoragePool([MClass]))]

procedure Allocate	(Pool : in out [MClass.name];
			 Storage_Address : out System.Address;
			 Size_In_Storage_Elements : in System.Storage_Elements.Storage_Count;
			 Alignment : in System.Storage_Elements.Storage_Count) is
[mergeOut("UDSPALL","storage pool allocate","begin\n\traise Program_Error;")]
end Allocate;

procedure Deallocate	(Pool : in out [MClass.name];
			 Storage_Address : in System.Address;
			 Size_In_Storage_Elements : in System.Storage_Elements.Storage_Count;
			 Alignment : in System.Storage_Elements.Storage_Count) is
[mergeOut("UDSPDALL","storage pool deallocate","begin\n\traise Program_Error;")]
end Deallocate;
			 
function Storage_Size	(Pool : [MClass.name]) return System.Storage_Elements.Storage_Count is
[mergeOut("UDSPSZ","storage pool size","begin\n\traise Program_Error;\n\treturn 0;")]
end Storage_Size;
[end if]
[if(doGenStreamOps([MClass]))]
procedure Write(Stream : access Ada.Streams.Root_Stream_Type'Class;
		Item   : in     [MClass.name]_cptr) is
[mergeOut("UDSTWR","stream write","begin\n\traise Program_Error;")]
end Write;

procedure Read (Stream : access Ada.Streams.Root_Stream_Type'Class;
		Item   :    out [MClass.name]_cptr) is
[mergeOut("UDSTRD","stream read","begin\n\traise Program_Error;")]
end Read;
[end if]
end template

/* 25b. generate the bodies of all operations belonging to the instance of MClass.
   called only in a protected type body */
template genClassOperationsBodiesPT(MClass)
[loop(MClass->MOperation where ![MOperation].isStatic();setText(""genSectionComment("Operations")))]
[getText()]
[   if([MOperation].isSubunit() && [place] != "subunit")]
[      if (isFunction([MOperation]))]
function [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] return [genResultType([MOperation.returnType])] is separate;
[      else]
procedure [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] is separate;
[      end if]
[   else]
[genOperationBody([MOperation],[MClass],FALSE)]
[   end if]
[end loop]
end template

/* 25c. generate the bodies of all operations belonging to the instance of MClass.
   called only in a task type body */
template genClassOperationsBodiesTask(MClass)
[loop(MClass->MOperation;setText(""genSectionComment("Operations")))]
[selectAlternative(
	genOperationBodyTask([MOperation],[MClass]))]
[end loop]
end template
