//*****************************************************************************
// Autor : Chafik Aouanet, P.Kleiner
// Date  : 24.6.1999
//*****************************************************************************

//Note: inter state machine transitions occur more than once due to uml2interface.qrl
//      they are suppressed here

//TBD: event parameter: overload Take_Event
//TBD: internal Transitions
//TBD: Case  Implementation bei Task
//TBD: bei Table guards auswerten
//TBD: call genClassOperationsBodiesTask
//TBD: wenn send über relation, index ggf. vorhanden im target !!


//*****************************************************************************
//******************* utilities to represent transition paths *****************
// a path is a list of transition IDs (separated by blanks)
// all transitions except the last in the path have a ToState which is a JunctionPoint.
// the last transition in the path has a ToState which is not a JunctionPoint.
//
// a pathName is the name of a variable holding a path.
//
// a pathSet is a list of path names (separated by "\n").
// In other words, it is a TokenSet with the TokenSet.line being pathNames.
//
//*****************************************************************************

// Generate a new, unique variable name
proc newPathName()
   [newPathName__COUNT__] = add([newPathName__COUNT__],"1");
   return "PATH_" [newPathName__COUNT__];
end proc

proc printPath (pathName)
   local x = "";
   loop (Instances->MTransition([[pathName]]) )
      [x] = [x] " TID:" [MTransition.id];
   end loop
//T info = "printPath(" [pathName] ") = " [x] "\n";
   return [x];
// the loop above is just to demonstrate the concept
// "return [[pathName]];" would essentially do the job
end proc

proc printPathSet (paths)
   local x = "";
   loop (Instances->TokenSet([paths]) As pathName)
      [x] = [x] [pathName.line]":(" printPath([pathName.line]) ") ";
   end loop
   return [x];
end proc

// get the set of outgoing paths for the given state
// as calculated by genStateMachineMapEntry.
// I.e. including paths inherited from superstates
proc getPathSet (MState)
   return [MState:paths];
end proc

// get the set of outgoing paths for the given state
// as given by the model
proc getLocalPaths (MState)
   local x = "getLocalPaths_" [MState.id];
   if ([[x]] != "")
      if ([[x]] != ".")
         return [[x]];
      else 
         return "";
      end if
   end if
   [[x]] = getLocalPaths_with_prefix ([MState],"");
//T info = [x] " -> "[[x]]".\n";
//T info = [x] " -> "printPathSet([[x]])".\n";
   if ([[x]] != "")
      return [[x]];
   else
      [[x]] = ".";
      return "";
   end if
end proc
proc getLocalPaths_with_prefix (MState,prefix)
//T info = "getLocalPaths_with_prefix : State=" [MState.name]", prefix="[prefix]"\n";
   local set = "";
   local del = "";
   local header = "";
   if ([prefix] != "")
      [header] = [prefix] " "; // Thus, we avoid a leading blank in the list
   end if
   loop (MState->ToState->MTransition)
      if (hasLoop(ToState->MPseudoState As ps where [ps.kind] == "JunctionPoint"))
         [set] = [set] [del] getLocalPaths_with_prefix ([ToState],[header][MTransition.id]);
      else
         local name = newPathName();
         [[name]] = [header][MTransition.id];
//T info = [name] " -> " [[name]] "\n";
         [set] = [set] [del] [name];
      end if
      [del] = "\n";
   end loop
   return [set];
end proc

// get the id of the triggering event of a path
// (Note that at most one transition in a path may have a trigger event)
proc getPathTriggerId(pathName)
   local x = "getPathTriggerId_" [pathName];
   if ([[x]] != "")
      if ([[x]] != ".")
         return [[x]];
      else 
         return "";
      end if
   end if

   loop (Instances->MTransition([[pathName]])->TriggerEvent)
      [[x]] = [TriggerEvent.id];
//T info = [x]" -> "[TriggerEvent.id]" = "[TriggerEvent.name]"\n";
      return [[x]];
   end loop
//T info = [x]" -> <null>\n";
   [[x]] = ".";
   return "";
end proc

// the list of ids of non-timeout events handled in this state
// as calculated by genStateMachineMapEntry.
proc getHandledEvents(MState)
      return [MState:handledEvents];
end proc

proc getToStateId(pathName)
   local x = "getToStateId_" [pathName];
   if ([[x]] != "")
      return [[x]];
   end if
   loop (Instances->MTransition(split([[pathName]]," ","T"))->ToState )
//T info = "getToStateId("[pathName]") -> "[ToState.id]" = "[ToState.name]" Tid="[MTransition.id]"\n";
      [[x]] = [ToState.id];
      return [[x]];
   end loop
   info = "ERROR: getToStateId("[pathName]") -> <null>\n";
end proc

proc getPaths(MState As FromState,MEvent As TriggerEvent)

   local x = "getPaths_" [FromState.id]"_"[TriggerEvent.id];
   if ([[x]] != "")
      if ([[x]] != ".")
         return [[x]];
      else 
         return "";
      end if
   end if

   local del = "";
   loop (Instances->TokenSet(getPathSet([FromState])) As pathName where getPathTriggerId([pathName.line]) == [TriggerEvent.id])
      [[x]] = [[x]] [del] [pathName.line];
      [del] = "\n";
   end loop

//T info = [x]" -> "[[x]]".\n";
//T info = [x] " -> " printPathSet([[x]]) "\n";

   if ([[x]] == "")
      [[x]] = ".";
      return "";
   else
      return [[x]];
   end if
end proc

proc getPathGuardCode(MClass,pathName)
   local x = "getPathGuardCode_"[pathName];
   if ([[x]] != "")
      return [[x]];
   end if
   local code  = "";
   local delim = "";
   local lastDelim = "";
   loop (Instances->MTransition([[pathName]]))
      local c2 = genGuard([MTransition],[MClass]);
      if ([c2] != "" && [c2] != "TRUE")
         [code] = [code] [delim] [c2];
         [lastDelim] = [delim];
         [delim] = ") and then (";
      end if
   end loop
   if ([code] == "")
      [code] = "TRUE";
   end if 
   // we only generate the parentheses, id we generated the ") and then (" delimeter
   // This is just to avoid redundant pairs of parentheses
   if ([lastDelim] != "")
      [code] = "("[code]")";
   end if
   [[x]] = [code];
//T info = [x]" -> >"[[x]]"<\n";
   return [[x]];
end proc

// get the complete code for a path
// as calculated by genStateMachineMapEntry.
proc getPathCode(MState As FromState,MEvent As TriggerEvent,pathName)
   local x = "Code_" [FromState.id] "_" [TriggerEvent.id] "_" [pathName];
//T info ="getPathCode "[FromState.name]", "[TriggerEvent.id]", pathName="[pathName]":\n"[x]"\n"[[x]]"\n";
   return [[x]];
end proc

template genPathActions(pathName,MClass)
[   loop (Instances->MTransition([[pathName]]))]
[genTransitionAction([MTransition],[MClass])]
[   end loop]
end template

template reachDynamicChoicePoint(MState As Choice,MClass,byEvent)
-- reachDynamicChoicePoint [Choice.name]
if FALSE then null;
[   loop(Choice->ToState->MTransition)]
elsif [genGuard([MTransition],[MClass])]
then
   [genTransitionAction([MTransition],[MClass])]
   [reachState([ToState],[MClass],[byEvent])]
[   end loop]
end if;
end template

//**********************************************************************************
proc stateMachineImplementation(MClass)

   //None: suppress generation of state machine
   //Case: one operation Take_Event with case over State and nested case over event
   //Table: one operation Take_Event with table access
   //Entry: (Protected Type / Task only) one entry per Event, discard events in wrong state
   //Entry_Wait: (Protected Type / Task only) one entry per Event, wait for state able to
   //            handle an event (violates UML semantic !)

   local defaultSMType;
   local SMType = "";

   if([MClass:SMType] != "")
      return [MClass:SMType];
   end if

   [MClass:hasEventParameters] = FALSE;
   loop(MClass->ReceiveEvent where hasLoop(ReceiveEvent->EvPara) && (genEventName([ReceiveEvent]) != "__delay"))
      [MClass:hasEventParameters] = TRUE;
   end loop

   if([MClass:hasEventParameters])
      // event parameter not compatible with Table
      [defaultSMType] = "Case";
   else
      [defaultSMType] = "Table";
   end if
   
   [SMType] = [MClass].getTaggedValue("State_Machine_Implementation", [defaultSMType]);
//T info = "SMI " [MClass.name] " -> " [SMType] "\n";
   
   switch([SMType])
   case "Table":
      if([MClass:hasEventParameters])
         info = "Class " [MClass.name] ": state machine type " [SMType] " changed to " [defaultSMType] " due to event parameters\n";
         [MClass:SMType] = "Case";
         return [SMType];
      end if
   case "Case":
   case "None":
      [MClass:SMType] = [SMType];
      return [SMType];
   case "Entry":
   case "Entry_Wait":
      if(isTask([MClass]) == FALSE && isPT([MClass]) == FALSE)
         info = "Class " [MClass.name] ": state machine type " [SMType] " changed to " [defaultSMType] " due to class type\n";
         [SMType] = [defaultSMType];
         return [SMType];
      else
         [MClass:SMType] = [SMType];
         return [SMType];
      end if
   default:
      info = "Class " [MClass.name] ": state machine type " [SMType] " unsupported\n";
      [MClass:SMType] = [defaultSMType];
      return [defaultSMType];
   end switch

end proc

proc useSMCode(MClass)

   local use = "";
   local defaultUse = "Comment";

   if([MClass:useSMCode] != "")
      return [MClass:useSMCode];
   end if

   // Ignore means: do nothing with the code in the model, but generate a stub for each
   //    action to be filled by the user (mergeOut)
   // Stub means: generate a stub for the actions with code in the model only, 
   //    which is filled by the user (mergeOut)
   // Comment means: place the code in the model as comment into the action procedure
   //    which is filled by the user (mergeOut)
   // Code means: use the code in the model as Ada code

   [use] = [MClass].getTaggedValue("Use_State_Machine_Code", [defaultUse]);
   switch([use])
   case "Comment" :
   case "Ignore" :
   case "Stub" :
   case "Code" :
      [MClass:useSMCode] = [use];
      return [use];
   default :
      info = "Class " [MClass.name] ": state machine code usage " [use] " unsupported\n";
      [MClass:useSMCode] = [defaultUse];
      return [defaultSMType];
   end switch

end proc

proc StateMachineRequiresTask(MClass)

   // A timeout event requires a task for its implementation
   loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) == "__delay")
      return TRUE;
   end loop
  
   // An activity in a state requires a task for its implementation
   loop(MClass->MStatemachine where hasActivity([MStatemachine]))
      return TRUE;
   end loop
  
   return FALSE;

end proc

proc isActiveClass(MClass)

   if (![MClass.active])
      return FALSE;
   end if
   
   if(stateMachineImplementation([MClass]) == "None")
      return FALSE;
   end if
   
   return TRUE;
   
end proc

proc isActiveClassInstance(MClass)

   if(isActiveClass([MClass]))   
      return TRUE;
   else
      loop(MClass->SuperClass)
         return isActiveClassInstance([SuperClass]);
      end loop
      return FALSE;
   end if
end proc

proc doInitializeStateMachine(MClass)

   if (!isActiveClass([MClass]))
      loop(MClass->SuperClass)
         return doInitializeStateMachine([SuperClass]);
      end loop
      return FALSE;
   end if
   
   loop(MClass->MStatemachine->MState->MCreationState->ToState->MTransition->TriggerEvent where genEventName([TriggerEvent]) != "__delay")
      return TRUE;
   end loop
   
   return FALSE;
   
end proc

proc StateMachineRequiresSignals()

   loop(Instances->MClass where isActiveClass([MClass]))
      return TRUE;
   end loop
   
   return FALSE;

end proc

//*****************************************************************************
// 1. control state machine placement (privacy)
//*****************************************************************************

template genStateMachinePreType(MClass,place)
[if(isActiveClassInstance([MClass]) == TRUE && [place] == "private")]
[genStpCallsPrivateDecls([MClass])]
[end if]
[if(isActiveClass([MClass]))]
[   switch([place])]
[   case "public":]
[genStateMachineEventDecl([MClass])]
[      if(getClassPrivacy([MClass]) == "public")]
[genStateMachinePackageDecl([MClass])]
[      end if]
[      return]
[   case "private":]
[      if(getClassPrivacy([MClass]) != "public" && getClassPrivacy([MClass]) != "implementation")]
[genStateMachinePackageDecl([MClass])]
[      end if]
[      return]
[   case "implementation":]
[      if(getClassPrivacy([MClass]) == "implementation")]
[genStateMachinePackageDecl([MClass])]
[      end if]
[      return]
[   default :]
ERROR genStateMachinePreType: unsupported stateMachineImplementation 
[   end switch]
[end if]
end template

template genStateMachinePostType(MClass,place)
end template

template genStateMachineSpec(MClass,place)
[if([place] == "public")]
[genStateMachineClassWideOpDecl([MClass])]
[genStateMachineClassOperationSpecs([MClass])]
[end if]
end template

template genStateMachineClassWideOpDecl(MClass)
end template

template genStateMachineClassOperationSpecs(MClass)
[if(isActiveClass([MClass]) == TRUE && stateMachineImplementation([MClass]) == "Table")]


[genSectionComment("State Machine Operations")]
procedure Take_Event(acc_This : [getClassParamForUpdate([MClass])]; Event : [MClass.name]_Event_Type);
[end if]
end template

template genStateMachineClassOperationSpecsPT(MClass)
[if(isActiveClass([MClass]))]

[genSectionComment("State Machine Operations")]
[   switch(stateMachineImplementation([MClass]))]
[   case "Case":]\			
[   case "Table":]\			
entry Take_Event(Event : [MClass.name]_Event_Type);
[      return]
[   case "Entry":]\			
[   case "Entry_Wait":]\			
[      loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
entry Take_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],FALSE)][closeList()];
[      end loop]
procedure InitializeSM;
[      return]
[   default:]
ERROR genStateMachineClassOperationSpecsPT: unsupported stateMachineImplementation 
[   end switch]
[end if]
end template

proc genEvParaList(MEvent,MClass,addThis)

   local result = "";

   if(!hasLoop(MEvent->EvPara) && [MEvent:operationId] != "")
      // this is a call event without parameters. Use those of the operation, if any
      loop(Instances->MOperation([MEvent:operationId]))
         return genOpParaList([MOperation],[addThis]);
      end loop
   end if

   openList();
   if ([addThis])
      [result] = delim() "acc_This : " getClassParamForUpdate([MClass]);
      setDelim("; ");
   end if
   loop(MEvent->EvPara)
      [result] = [result] delim() [EvPara.name] " : " genParameterType([EvPara.type]) [EvPara].genDefault();
      setDelim("; ");
   end loop

   return breakLongLines([result],"; ");

end proc

proc useEvParaList(MEvent,addThis)

   local result = "";

   if(!hasLoop(MEvent->EvPara) && [MEvent:operationId] != "")
      // this is a call event without parameters. Use those of the operation, if any
      loop(Instances->MOperation([MEvent:operationId]))
         return useOpParaList([MOperation],[addThis]);
      end loop
   end if

   if ([addthis])
      [result] = delim() "acc_This";
      setDelim(", ");
   end if
   loop(MEvent->EvPara)
      [result] = [result] delim() [EvPara.name];
      setDelim(", ");
   end loop

   return [result] closeList();

end proc

template genStateMachineClassOperationSpecsTask(MClass)
[if(isActiveClass([MClass]))]

[genSectionComment("State Machine Operations")]
[   switch(stateMachineImplementation([MClass]))]
[   case "Case":]\			
[   case "Table":]\			
entry Take_Event(Event : [MClass.name]_Event_Type);
[      return]
[   case "Entry":]\			
[   case "Entry_Wait":]\			
[      loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
entry Take_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],FALSE)][closeList()];
[      end loop]
[      return]
[   default:]
ERROR genStateMachineClassOperationSpecsTask: unsupported stateMachineImplementation
[   end switch]
[end if]
end template

template genStateMachineBodyFixed(MClass)
[if(isActiveClassInstance([MClass]))]
[genStpCallsBodyDecls([MClass])]
[end if]
[if(isActiveClass([MClass]))]
[   switch(stateMachineImplementation([MClass]))]
[   case "None" :]
[      return]
[   case "Case" :]
[      if(isPT([MClass]))]
[// does not work for parameters genTakeEventBodyCallPT([ MClass])]
[      else if(isTask([MClass]))]
[// does not work for parameters genTakeEventBodyCallTask([ MClass])]
[      else]
[// does not work for parameters genTakeEventBodyCase([ MClass])]
[      end if end if]
[      return]
[   case "Table" :]
[      if(isPT([MClass]))]
[genTakeEventBodyCallPT([MClass])]
[      else if(isTask([MClass]))]
[genTakeEventBodyCallTask([MClass])]
[      else]
[genTakeEventBodyTable([MClass])]
[      end if end if]
[      return]
[   case "Entry":]
[   case "Entry_Wait" :]
[      if(isPT([MClass]))]
[// does not work for parameters genTakeEventBodyCallPT([ MClass])]
[      else if(isTask([MClass]))]
[// does not work for parameters genTakeEventBodyCallTask([ MClass])]
[      end if end if]
[      return]
[   default :]
ERROR genStateMachineBodyFixed: unsupported stateMachineImplementation
[   end switch]
[end if]
end template

template genStateMachineBodyFixedPT(MClass)
[if(isActiveClass([MClass]))]
procedure Perform_Activity;
procedure InitializeSM is
begin
	Perform_Activity; -- Just to allow completion transitions from the start state
end InitializeSM;
[   if(stateMachineImplementation([MClass])=="Table")]
[genTableEventTakeBodyPT([MClass])]
[   else]
[genEventEntriesPT([MClass])]
[   end if]
[end if]
end template


template genStateMachineBodyUser(MClass)
[if(isActiveClass([MClass]))]
[   switch(stateMachineImplementation([MClass]))]
[   case "None" :]
[      return]
[   case "Case" :]
[      if(isPT([MClass]) == FALSE && isTask([MClass]) == FALSE)]
[// does not work for event parameters genTakeEventBodyCase([ MClass])]
[      end if]
[genStateMachinePackageBody([MClass])]
[      return]
[   case "Table" :]
[   case "Entry":]
[   case "Entry_Wait" :]
[genStateMachinePackageBody([MClass])]
[      return]
[   default :]
ERROR genStateMachineBodyUser: unsupported stateMachineImplementation
[   end switch]
[end if]
end template

template genStateMachineBodyUserPT(MClass)
[if(isActiveClass([MClass]))]
[   if(stateMachineImplementation([MClass])!="Table")]
[      loop(MClass->MStatemachine)]
\
[setTextBlind(genSectionComment("Entry Action Procedures"))]
[entryActionProcedures([MStatemachine],[MClass],FALSE)]
[setTextBlind(genSectionComment("Exit Action Procedures"))]
[exitActionProcedures([MStatemachine],[MClass],FALSE)]
[setTextBlind(genSectionComment("Activity Procedure"))]
[activityProcedure([MStatemachine],[MClass],FALSE)]
[      end loop]
[   end if]
[end if]
end template

//*****************************************************************************
// 3. namings
//*****************************************************************************

proc genStateName(MState)

   if ([MState:cache_genStateName] != "")
      return [MState:cache_genStateName];
   end if
   [MState:cache_genStateName] = genStateNameInLocalMachine([MState]);

   if ([MState:cache_genStateName] == "")
      return [MState:cache_genStateName];
      // keep the possibility to have no name. See genStateNameInLocalMachine.
   end if
   
   // prepend superstate name, if any.
   loop(MState->MStatemachine->SuperState)
	[MState:cache_genStateName] = genStateName([SuperState]) "_"[MState:cache_genStateName]; 
   end loop

   return [MState:cache_genStateName];
   
end proc

proc genStateNameInLocalMachine(MState)

   // for a state without a name, we try to find a suitable name
   // for a creation or final event we can use the name of the enclosing state machine
   // a creation event without name and an eventless transition to some state gets no
   // name: the target state is used as creation event in this case later on

   if ([MState.name] == "")
      loop(MState->MCreationState)
         // it is a creation state
         loop(MCreationState->ToState->MTransition)
            // we have an outgoing transition
            loop(MTransition->TriggerEvent)
               // the transition has an associated event, create a name for the unnamed state
               loop(MState->MStatemachine As MyMachine)
                  return "CREATION_" getSMName([MyMachine]);
               end loop
            end loop
            // we have an outgoing transition without event
            return "";
         end loop 
         // we have no outgoing transition
         loop(MState->MStatemachine As MyMachine)
            info = "Creation state of state machine " getSMName([MyMachine]) " has no outgoing transition\n";
         end loop
         return "??";
      end loop
     
      loop(MState->MFinalState)
         loop(MState->MStatemachine As MyMachine)
            return "FINAL_" getSMName([MyMachine]) "_" [MState.id];
         end loop
      end loop

      loop(MState->MPseudoState As historyState where [historyState.kind] == "HistoryState")
         loop(MState->MStatemachine As MyMachine)
            return [historyState.name]"_" getSMName([MyMachine]);
         end loop
      end loop

      return "ST_" [MState.id];
   else
      loop(MState->MPseudoState As historyState where [historyState.kind] == "HistoryState")
         loop(MState->MStatemachine As MyMachine)
            return [historyState.name]"_" getSMName([MyMachine]);
         end loop
      end loop
      
      // (genStateName() == "") is used as a criterion for "do nothing for that state, it's not represented in the generated code"
      if (hasLoop(MState->MPseudoState))
         // This is for kind == "JunctionPoint" and "DynamicChoicePoint"
         return "";
      end if

      return "ST_" [MState.name];
   end if
  
end proc

proc genEventName(MEvent)

   if ([MEvent.name] != "after")
      return [MEvent.name] "_Event";
   else
      return "__delay";
   end if
  
end proc

proc genActionProcName(MState,MEvent)

   return genStateName([MState]) "_Action_" genEventName([MEvent]);
   
end proc

proc getDelay(MEvent)

   loop(MEvent->EvPara)
      return [EvPara.name];
   end loop
   
end proc

proc getSMName(MStatemachine)

   loop(MStatemachine->SuperState)
	return [SuperState.name];
   end loop
  
   loop(MStatemachine->MClass)
	return [MClass.name];
   end loop
  
end proc

//*****************************************************************************
// 3. event type
//*****************************************************************************

template genStateMachineEventDecl(MClass)

[genSectionComment("event type")]
type [MClass.name]_Event_Type is (
[setDelim("  ")]
[   loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
	[delim()][genEventName([ReceiveEvent])][setDelim(", ")]
[   end loop]
	);
end template

// recursive looping over Statemachines for check, whether an activity is defined
proc hasActivity(MStatemachine)

   loop(MStatemachine->MState where getActivity([MState]) != "")
      return TRUE;
   end loop

   loop(MStatemachine->MState->Submachine where hasActivity([Submachine]))
      return TRUE;
   end loop
  
   return FALSE;

end proc

//*****************************************************************************
// 4. generate a map of events and state transitions
//*****************************************************************************

//^
// recursively create a table of event,target state for each source state
//
proc genStateMachineMap(MStatemachine,MClass)

   loop(MStatemachine->MState As FromState where genStateName([FromState]) != "")
      if(isSuperState([FromState]))
	 // a super state is never a legal source for an event
	 // but each outgoing event of a super state must be applied to the states in
	 // all submachines
         genStateMachineMapToSuperState([MClass],[FromState],[FromState]);
         //for a super state in the current machine,
         //add the local transitions in the submachine (recursion)
         loop(FromState->Submachine)
            genStateMachineMap([Submachine],[MClass]);
         end loop
      else
         // add the transitions to the map
	 genStateMachineMapEntry([MClass],[FromState],[FromState],[MStatemachine]);
     end if
   end loop   
  
end proc

/** calculates for each non-junction state
MEvent:acceptingStates		the list of states accepting the event
"Code_" [FromStateToUse.id] "_" [TriggerEvent.id] "_" [pathName.line]
				code from the complete path if taken from FromStateToUse
				This is precomputed because otherwise we would need so many parameters from the context
FromStateToUse:timeoutTransition
FromStateToUse:mayTerminate
**/
proc genStateMachineMapEntry(MClass,MState As FromStateForEvents,MState As FromStateToUse, MStatemachine As MachineToUse)
// FromStateForEvents is the state where the transition starts (as given in the model)
// FromStateToUse is the state from which the transition is implemented
//   (this may be different if FromStateToUse inherits a transition from its (transitive) superstate FromStateForEvents


//T   testInfo("SM_Map", "genSMMEntry {"[MClass.name]"::FromStateForEvents: "[FromStateForEvents.name]", FromStateToUse: "[FromStateToUse.name]", MachineToUse: "getSMName([MachineToUse])"\n");

   local s;
   if (hasLoop(FromStateToUse->MPseudoState As ps where [ps.kind] == "JunctionPoint"))
      return;
      // nothing to do here except for junctionPoints which is dealt with in genPathActions
   end if
   
   // add the paths originating at [FromStateForEvents] to the paths of [FromStateToUse].
   local inheritedPaths = getLocalPaths([FromStateForEvents]);
   if ([inheritedPaths] != "")
      if ([FromStateToUse:paths] != "")
         [FromStateToUse:paths] = [FromStateToUse:paths] "\n" [inheritedPaths];
      else
         [FromStateToUse:paths] = [inheritedPaths];
      end if
   end if
   
   loop(Instances->TokenSet([FromStateToUse:paths]) As pathName)
    loop(Instances->MState(getToStateId([pathName.line])) As ToState)
      local triggerId = getPathTriggerId([pathName.line]);
      local triggerName = "";
      loop(Instances->MEvent([triggerId]) As TriggerEvent)
         testInfo("SM_Map", [MClass.name]"::"[FromStateForEvents.name]": path " printPath([pathName.line]) " event " [TriggerEvent.name] " to " [ToState.name] "\n");
         [triggerName] = genEventName([TriggerEvent]);
         
//?         if [MTransition:tag] == "genMap"
//?            info ="genStateMachineMapEntry RECURSION FOR "[pathName.line]"\n";
//?         else
            if ([triggerName]  != "__delay")
               // code here corresponds to
               // loop(FromStateForEvents->ToState->MTransition->TriggerEvent where [MTransition:tag] != "genMap" && genEventName([TriggerEvent]) != "__delay")
               if(regexp([FromStateToUse:handledEvents]" "," "[TriggerEvent.id]" ") == "")
                  [FromStateToUse:handledEvents] = [FromStateToUse:handledEvents] " " [TriggerEvent.id];
               end if
            
               [s] = "Code_" [FromStateToUse.id] "_" [TriggerEvent.id] "_" [pathName.line];
//?               [MTransition:tag] = "genMap"; // prevent recursion
               [[s]] = genStateTransition([MClass],[FromStateToUse],[MachineToUse],[ToState],genPathActions([pathName.line],[MClass]),[triggerName]);
//T info = [s]" -> "[[s]]"\n";

//?               [MTransition:tag] = "--"; // prevent recursion
               if(regexp([TriggerEvent:acceptingStates]" "," "[FromStateToUse.id]" ") == "")
                  [TriggerEvent:acceptingStates] = [TriggerEvent:acceptingStates] " " [FromStateToUse.id];
               else
//T                  info = [s] ": avoid duplicates in TriggerEvent:acceptingStates \n";
               end if
               // guards are not precomputed
               if(hasLoop(ToState->MFinalState))
                  [s] = "Terminates_" [FromStateToUse.id] "_" [TriggerEvent.id];
                  [[s]] = TRUE;
//T                  info = [s] ": " [[s]] "\n";
               end if
            else
            // code here corresponds to
            // loop(FromStateForEvents->ToState->MTransition->TriggerEvent where [MTransition:tag] != "genMap" && genEventName([TriggerEvent]) == "__delay")
            
               if([FromStateToUse:timeout] != "")
                  info = "Class " [MClass.name] " state " [FromStateToUse:name] ": multiple timeout transitions not supported\n";
               else
                  [FromStateToUse:timeout] = evaluateOcl(getDelay([TriggerEvent]),[MClass]);
//T               info = [acceptorState.name] ": delay " [acceptorState:timeout] "\n";
//?                  [MTransition:tag] = "genMap"; // prevent recursion
                  [FromStateToUse:timeoutTransition] = genStateTransition([MClass],[FromStateToUse],[MachineToUse],[ToState],genPathActions([pathName.line],[MClass]),[triggerName]);
//?                  [MTransition:tag] = "--"; // prevent recursion
               end if
            
            end if
//?         end if
      end loop
      
      if ([triggerName] == "")
         // code here corresponds to
         // loop(FromStateForEvents->ToState->MTransition where !hasLoop(MTransition->TriggerEvent))
         testInfo("SM_Map", [MClass.name]"::"[FromStateForEvents.name]": Path " [pathName.line] " no-event to " [ToState.name] "\n");
         if(hasLoop(ToState->MFinalState))
            [FromStateToUse:mayTerminate] = "+";
//T	    info = [acceptorState.name] ": mayTerminate\n";
         else
            //this is a transition without event. The predecessor(s) of FromStateForEvents 
            //already took this transition in genStateTransition 
         end if
      end if
      
    end loop
   end loop

//T   testInfo("SM_Map", "genSMMEntry } ");
end proc

proc genStateMachineMapToSuperState(MClass,MState As FromStateForEvents,MState As SuperState)

   local result = "";

   loop(SuperState->Submachine->MState As FromState where genStateName([FromState]) != "")
      if(isSuperState([FromState]))
         genStateMachineMapToSuperState([MClass],[FromStateForEvents],[FromState]);
      else
         genStateMachineMapEntry([MClass],[FromStateForEvents],[FromState],[Submachine]);     
      end if
   end loop
  
   return [result];

end proc

//^
// perform transition from one state to the other, executing any actions as needed
//
proc genStateTransition(MClass,MState As FromState, MStatemachine As FromMachine, MState As TargetState,TransitionAction,byEvent)

   local result;
   local commonRoot;
  
//T   info = "STR " [FromState.name]"="[FromState.id] " to " [TargetState.name]"="[TargetState.id] "\n";

   loop(TargetState->Submachine)
      // this is a transition to a submachine
      loop(Submachine->MState->MCreationState)
         // we got a creation state
//T         info = "STR submachine with creation state as target\n";
	 return genStateTransition([MClass],[FromState],[FromMachine],[MCreationState],[TransitionAction],[byEvent]);
      end loop
      loop(Submachine->MState->MPseudoState As historyState where [historyState.kind] == "HistoryState")
//T         info = "STR submachine [TargetState.name] with history state as target\n";
         // we got a history state
         // this time we forget the history !
         loop(historyState->ToState)
	    return genStateTransition([MClass],[FromState],[FromMachine],[ToState],[TransitionAction],[byEvent]);
         end loop
         info = "Error in state machine " getSMName([Submachine]) ": history state has no sucessor\n";
	 return "";
      end loop
      info = "Error in state machine " getSMName([Submachine]) ": no starting point but transition to state machine\n";
      return "";
   end loop

   loop(TargetState->MCreationState where genStateName([MCreationState]) == "")
      //skip the creation state without creation event
//T         info = "STR submachine, creation state without event\n";
      loop(MCreationState->ToState)
         return genStateTransition([MClass],[FromState],[FromMachine],[ToState],[TransitionAction],[byEvent]);
      end loop
   end loop
  
   [result] = genExitAction([FromState],[MClass]);
   loop(TargetState->MStatemachine As TargetMachine)
      if(getSMName([FromMachine])==getSMName([TargetMachine]))
         // we have no nesting
//T         info = "STR same machines\n";
         [result] = [result] [TransitionAction];
      else
         loop(MClass->MStatemachine)
            [commonRoot] = getCommonRoot([FromMachine],[TargetMachine]);
         end loop
//T         info = "STR common root" [commonRoot] "\n";
         // we have nesting
         // phase 1: leave all enclosing state machines until commonRoot is reached
         [result] = [result] deIndent(leaveMachines([FromMachine],[commonRoot],[MClass]));
         // phase 2: execute transition action
         [result] = [result] deIndent([TransitionAction]);
         // phase 3: enter all intermediate state machines from commonRoot til TargetMachine
         [result] = [result] deIndent(enterMachines([commonRoot],[TargetMachine],[MClass],[byEvent]));
      end if
   end loop
   [result] = [result] reachState([TargetState],[MClass],[byEvent]);

   return [result];
  
end proc

// This is an auxilliary routine that removes erroneous indentation created by the fact that
// templates are called from procedures.
// In contrast to switching off the indent mechanism totally,
// we still can get indentation from nested templates
proc deIndent(text)
   local pattern = "\n" createString(" ",getIndentCount());
   return replace([text],[pattern],"\n");
end proc

template genEntryAction(MState,MClass,byEvent)
[genTrace([MClass],"Entering state ",genStateName([MState]))]
currentState := [genStateName([MState])];
[if(isTagged([MClass]) == TRUE || getClassPrivacy([MClass]) == "implementation")]
[genHandleStateAssign([MClass],[MState.id],"currentState","acc_This.all'access", [byEvent])]
[else]
[genHandleStateAssign([MClass],[MState.id],"currentState",[MClass.name]"'address", [byEvent])]
[end if]
[switch(useSMCode([MClass]))]
[case "Code" :]
[   if([MState].getTaggedValue("Entry_Action","") != "")]
-- from tagged value "Entry_Action"
[outDesc(breakLongLines(evaluateStatement([MState].getTaggedValue("Entry_Action",""),[MClass]),";"))]
[   end if]
[   if(getEntryAction([MState]) != "")]
[      loop(MState->MAction->MActionType where [MActionType.type] == "entry")]
[outDesc(evaluateAction([MAction],[MClass]))]
[      end loop]
[   end if]
[   break]
[case "Stub" :]
[case "Comment" :]
[   if(getEntryAction([MState]) != "")]
Enter_[genStateName([MState])][genAccThisArgument([MClass])];
[   end if]
[   break]
[case "Ignore" :]
Enter_[genStateName([MState])][genAccThisArgument([MClass])];
[   break]
[default :]
ERROR genEntryAction: unsupported useSMCode [useSMCode([MClass])]
[end switch]
end template

template entryActionProcedures(MStatemachine,MClass,addThis)

[loop(MStatemachine->MState where genStateName([MState]) != "")]
[   switch(useSMCode([MClass]))]
[   case "Code" :]
[      break]
[   case "Stub" :]
[      if(getEntryAction([MState]) != "")]
[getText()]
procedure Enter_[genStateName([MState])][genAccThisParameter([MClass],[addThis])] is
	[genSMrenames([MClass],[addThis])]
--[genTrace([MClass],"Entering state ",genStateName([MState]) )]
[mergeOut("UDAC::"getUniqueId([MState]),"Entry Action Code","begin\n\tnull;")]
end Enter_[genStateName([MState])];

[      end if]
[      break]
[   case "Comment" :]
[      if(getEntryAction([MState]) != "")]
[getText()]
procedure Enter_[genStateName([MState])][genAccThisParameter([MClass],[addThis])] is
	[genSMrenames([MClass],[addThis])]
--[genTrace([MClass],"Entering state ",genStateName([MState]))]
[outDescAsComment("Action: " getEntryAction([MState]))]
[mergeOut("UDAC::"getUniqueId([MState]),"Entry Action Code","begin\n\tnull;")]
end Enter_[genStateName([MState])];

[      end if]
[      break]
[   case "Ignore" :]
[getText()]
procedure Enter_[genStateName([MState])][genAccThisParameter([MClass],[addThis])] is
	[genSMrenames([MClass],[addThis])]
--[genTrace([MClass],"Entering state ",genStateName([MState]))]
[mergeOut("UDAC::"getUniqueId([MState]),"Entry Action Code","begin\n\tnull;")]
end Enter_[genStateName([MState])];

[      break]
[   default :]
ERROR entryActionProcedures: unsupported useSMcode [useSMCode([MClass])]
[   end switch]
[end loop]
[loop(MStatemachine->MState->Submachine)]
[entryActionProcedures([Submachine],[MClass],[addThis])]
[end loop]
end template

template genExitAction(MState,MClass)
[if(!hasLoop(MState->MCreationState))]
[genTrace([MClass],"Leaving state ",genStateName([MState]))]
[   switch(useSMCode([MClass]))]
[   case "Code" :]
[      loop(MState->MAction->MActionType where [MActionType.type] == "exit")]
[outDesc(evaluateAction([MAction],[MClass]))]
[      end loop]
[      return]
[   case "Stub" :]
[   case "Comment" :]
[      if(getExitAction([MState]) != "")]
Exit_[genStateName([MState])][genAccThisArgument([MClass])];
[      end if]
[      return]
[   case "Ignore" :]
Exit_[genStateName([MState])][genAccThisArgument([MClass])];
[      return]
[   default :]
ERROR genExitAction: unsupported useSMcode [useSMCode([MClass])]
[   end switch]
[end if]
end template

template exitActionProcedures(MStatemachine,MClass,addThis)
[loop(MStatemachine->MState where genStateName([MState]) != "" && !hasLoop(MState->MCreationState))]
[   switch(useSMCode([MClass]))]
[   case "Code" :]
[      break]
[   case "Stub" :]
[      if(getExitAction([MState]) != "")]
[getText()]
procedure Exit_[genStateName([MState])][genAccThisParameter([MClass],[addThis])] is
	[genSMrenames([MClass],[addThis])]
--[genTrace([MClass],"Leaving state ",genStateName([MState]))]
[mergeOut("UDXAC::"getUniqueId([MState]),"Exit Action Code","begin\n\tnull;")]
end Exit_[genStateName([MState])];

[      end if]
[      break]
[   case "Comment" :]
[      if(getExitAction([MState]) != "")]
[getText()]
procedure Exit_[genStateName([MState])][genAccThisParameter([MClass],[addThis])] is
	[genSMrenames([MClass],[addThis])]
--[genTrace([MClass],"Leaving state ",genStateName([MState]))]
[outDescAsComment("Action: " getExitAction([MState]))]
[mergeOut("UDXAC::"getUniqueId([MState]),"Exit Action Code","begin\n\tnull;")]
end Exit_[genStateName([MState])];

[      end if]
[      break]
[   case "Ignore" :]
[getText()]
procedure Exit_[genStateName([MState])][genAccThisParameter([MClass],[addThis])] is
	[genSMrenames([MClass],[addThis])]
--[genTrace([MClass],"Leaving state ",genStateName([MState]))]
[mergeOut("UDXAC::"getUniqueId([MState]),"Exit Action Code","begin\n\tnull;")]
end Exit_[genStateName([MState])];

[      break]
[   default :]
ERROR exitActionProcedures: unsupported useSMcode [useSMCode([MClass])]
[   end switch]
[end loop]
[loop(MStatemachine->MState->Submachine)]
[exitActionProcedures([Submachine],[MClass],[addThis])]
[end loop]
end template

template reachState(MState,MClass,byEvent)
[if(hasLoop(MState->MPseudoState As historyState where [historyState.kind] == "HistoryState"))]
[if(isTagged([MClass]) == TRUE || getClassPrivacy([MClass]) == "implementation")]
[genHandleStateAssign([MClass],"","memory_"genStateName([MState]), "acc_This.all'access", [byEvent])]
[else]
[genHandleStateAssign([MClass],"","memory_"genStateName([MState]), [MClass.name]"'address", [byEvent])]
[end if]
case memory_[genStateName([MState])] is
[   loop(MState->MStatemachine)]
[entryActionCases([MStatemachine],[MClass],[byEvent])]
[   end loop]
end case;
[else if(hasLoop(MState->MPseudoState As cp where [cp.kind] == "DynamicChoicePoint" ))]
[reachDynamicChoicePoint([MState],[MClass],[byEvent])]
[else]
[genEntryAction([MState],[MClass],[byEvent])]
[end if end if]
end template

template entryActionCases(MStatemachine,MClass,byEvent)
[loop(MStatemachine->MState where genStateName([MState]) != "")]
when [genStateName([MState])] =>
	[genEntryAction([MState],[MClass],[byEvent])]

[end loop]
[loop(MStatemachine->MState->Submachine)]
[entryActionCases([Submachine],[MClass],[byEvent])]
[end loop]
end template


template genActivity(MState,MClass)
[if(!hasLoop(MState->MCreationState))]
[   switch(useSMCode([MClass]))]
[   case "Code" :]
[outDesc(getActivity([MState]))]
[      return]
[   case "Stub" :]
[   case "Comment" :]
[      if(getActivity([MState]) != "")]
Perform_Activity;
[      end if]
[      return]
[   case "Ignore" :]
Perform_Activity;
[      return]
[   default :]
ERROR genActivity: unsupported useSMcode [useSMCode([MClass])]
[   end switch]
[end if]
end template

proc genGuard(MTransition,MClass)

   if([MTransition:guard] != "")
      return [MTransition:guard];
   end if

   local expr;
   loop(MTransition->MGuard)
      [expr] = [MGuard.expression];
   end loop
   if ([expr] == "")
      // completion transitions have the guard only as annotation, so try that too
      loop(MTransition->Note where [Note.type] == "UmlTransitionDefinition") 
         loop(Note->Item where [Item.type] == "UmlTransitionGuard")
            [expr] = [Item.value];
         end loop
      end loop
   end if

   if ([expr] != "")
      [MTransition:guard] = evaluateOcl([expr],[MClass]);
   else
      [MTransition:guard] = "TRUE";
      testInfo ("OCL", "  evalExpression -> TRUE\n");
   end if

   return [MTransition:guard];

end proc

template genTransitionAction(MTransition,MClass)
[// StP will split SendAction at each ',' instead of ';'. (ECR7156)]
[// As a workaround, we ALWAYS use the UmlTransitionAction which gives us the whole actionlist as one string]
[//]
[//if (hasLoop(MTransition->SendAction))]
[//   loop(MTransition->SendAction)]
[//evaluateAction([SendAction],[MClass])]
[//   end loop]
[//else]
[      // completion transitions have the action only as annotation, so try that too]
[      loop(MTransition->Note where [Note.type] == "UmlTransitionDefinition")]
[         loop(Note->Item where [Item.type] == "UmlTransitionAction")]
[evaluateStatement([Item.value],[MClass])]
[         end loop]
[      end loop]
[//end if]

[loop(MTransition->MTarget->MEvent)]
-- send [MEvent.name] to [MTarget.target]
[   loop(MClass->MAttribute where [MAttribute.name] == [MTarget.target])]
[      if([MAttribute].isStatic())]
[findSend([MAttribute.type],[MEvent],[MAttribute.name])];
[      else]
[findSend([MAttribute.type],[MEvent],"This." [MAttribute.name])];
[      end if]
[      return]
[   end loop]
[   loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="" && [ToRole.name] == [MTarget.target])]
[      if([ToRole:isPointer])]
[callSend([ToClass],[MEvent],"This." [ToRole:adaName]".all")];
[      else]
[callSend([ToClass],[MEvent],"This." [ToRole:adaName])];
[      end if]
[      return]
[   end loop]
send([MTarget.target],[MEvent.name][setDelim(", ")][useEvParaList([MEvent],FALSE)];
[end loop]
end template

template callSend(MClass,MEvent,thisExpr)
[insert("include",[MClass:cuName] "." [MClass.name] "_Signals")]
[MClass:cuName].[MClass.name]_Signals.Send_[genEventName([MEvent])] ([thisExpr]'access[setDelim(", ")][useEvParaList([MEvent],FALSE)]
end template

proc findSend(typeString,MEvent,thisExpr)

   local subString = lastWord([typeString]," "); // get rid of passing mode keywords
	
   // is it already a class name ?
   // This check can be omitted, if not appropriate
	
   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      return callSend([MClass],[MEvent],[thisExpr]);
   end loop

   // strip constraint, if any
	
   [subString] = stripConstraint([subString]);

   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      return callSend([MClass],[MEvent],[thisExpr]);
   end loop
	
   // strip _ptr or _cptr, if any

   [subString] = stripPointer([subString]);

   loop(Instances->MClass(MClass_ids_by_name ([subString])))
      return callSend([MClass],[MEvent],[thisExpr]);
   end loop

   setDelim(", ");
   return "send(" [thisExpr] ", " [MEvent.name] useEvParaList([MEvent],FALSE);

end proc

proc evaluateAction(MAction,MClass)
   
   if([MAction:actionCode] == "")
      [MAction:actionCode] = evaluateStatement([MAction.name],[MClass]);
   end if   
   return [MAction:actionCode];

end proc

proc evaluateStatement(actionString,MClass)

   local act = [actionString];
   
   if([act] == "")
      return "";
   end if
   
   testInfo ("OCL", "evaluateStatement " [act] "\n");

   if(regexp([act],";$") == "")
      [act] = [act] ";";
      testInfo ("OCL", "   evaluateStatement (01) -> " [act] "\n");
   end if
   
   [act] = evaluateOcl([act],[MClass]);
   
   [act] = breakLongLines([act],";");
   
   return [act];
   
end proc

/* This is a common utility used to transform statements as well as expressions
   A trailing semicolon is allowed, but not necessary for this routine
*/
proc evaluateOcl(actionString,MClass)

   local act = [actionString];
   local this = bodyToThis([MClass]);
  
   [act] = replace([act],"==","#=");
   testInfo ("OCL", "   evaluateStatement (10) -> " [act] "\n");
   [act] = replace([act],"([^#:=!<>])=","\1:=");
   testInfo ("OCL", "   evaluateStatement (11) -> " [act] "\n");
   [act] = replace([act],"#=","=");
   testInfo ("OCL", "   evaluateStatement (12) -> " [act] "\n");
   [act] = replace([act],"!=","/=");
   testInfo ("OCL", "   evaluateStatement (13) -> " [act] "\n");
   [act] = replace([act],"&&"," and ");
   testInfo ("OCL", "   evaluateStatement (14) -> " [act] "\n");
   [act] = replace([act],"\|\|"," or ");
   testInfo ("OCL", "   evaluateStatement (15) -> " [act] "\n");
   [act] = replace([act],"!"," not ");
   testInfo ("OCL", "   evaluateStatement (16) -> " [act] "\n");

   // replace "role.op(x)" by "class_pkg.op(role_part,x)"
   // replace "role.op()"  by "class_pkg.op(role_part)"
   //
   loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As ToClass Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="")
      local ToRoleName = genRoleName([ToRole]);  // this is always != ""
      testInfo("OCL", "   check rel " [ToRole.name] ", gen=" [ToRoleName] ", ada=" [ToRole:adaName]" -> " [act] "\n");
      if (regexp([act],[ToRoleName]) != "")
         loop(ToClass->MOperation)
            testInfo("OCL", "   check rel's op " [MOperation.name] "\n");
            if([ToRole:isPointer])

               [act] = replace([act], "(^|[^A-Za-z0-9_.])"[ToRoleName]"."[MOperation.name]" *\(" , 
                                      "\1"importClassOp([ToClass],[MOperation.name])"("[this]"."[ToRole:adaName]",##OCL##");
            else
               [act] = replace([act], "(^|[^A-Za-z0-9_.])"[ToRoleName]"."[MOperation.name]" *\(" , 
                                      "\1"importClassOp([ToClass],[MOperation.name])"("[this]"."[ToRole:adaName]"'access,##OCL##");
            end if
            if (isTimedEntry([MOperation],[MClass]))
            // same as above, but also for timed call
             if([ToRole:isPointer])

               [act] = replace([act], "(^|[^A-Za-z0-9_.])"[ToRoleName]".Timed_"[MOperation.name]" *\(" , 
                                      "\1"importClassOp([ToClass],"Timed_"[MOperation.name])"("[this]"."[ToRole:adaName]",##OCL##");
            else
               [act] = replace([act], "(^|[^A-Za-z0-9_.])"[ToRoleName]".Timed_"[MOperation.name]" *\(" , 
                                      "\1"importClassOp([ToClass],"Timed_"[MOperation.name])"("[this]"."[ToRole:adaName]"'access,##OCL##");
             end if
            end if
            testInfo ("OCL", "   evaluateStatement (21) -> " [act] "\n");
         end loop
    
         // Read only relational operations     
         loop (Instances->TokenSet("get\nGet_\nCount_") )
            local x = [TokenSet.line];
//            info = "OCL try " [x] " on " [ToRoleName] " for "[act]"\n";
            [act] = replace([act], "(^|[^A-Za-z0-9_.])(|"[MClass.name]"[.])"[x][ToRoleName]"\(\)" , "\1"[x][ToRoleName]"_Part("[this]")");
         end loop
         // read/Write relational operations     
         loop (Instances->TokenSet("set\nSet_\nAdd_\nRemove_\nAlloc_") )
            [x] = [TokenSet.line];
//            info = "OCL try " [x] " on " [ToRoleName] " for "[act]"\n";
            [act] = replace([act], "(^|[^A-Za-z0-9_.])(|"[MClass.name]"[.])"[x][ToRoleName]"\(" ,   "\1"[x][ToRoleName]"_Part("[this]"'unchecked_access,");
         end loop
              
         [act] = replace([act], "(^|[^A-Za-z0-9_.])"[ToRoleName]"([^A-Za-z0-9_])" , "\\1"[this]"."[ToRole:adaName]"\\2");
      end if

   end loop
   loop(MClass->MAttribute where ![MAttribute].isStatic())
      testInfo("OCL", "   check attr " [MAttribute.name] "\n");
      [act] = replace([act], "(^|[^A-Za-z0-9_.])(|"[MClass.name]"[.])("[MAttribute.name]")" ,      "\1"[this]"."[MAttribute.name]);
      [act] = replace([act], "(^|[^A-Za-z0-9_.])(|"[MClass.name]"[.])get"[MAttribute.name]"\(\)" , "\1get"[MAttribute.name]"("[this]")");
      [act] = replace([act], "(^|[^A-Za-z0-9_.])(|"[MClass.name]"[.])set"[MAttribute.name]"\(" ,   "\1set"[MAttribute.name]"("[this]"'access,");
      testInfo ("OCL", "   evaluateStatement (31) -> " [act] "\n");
   end loop
   // replace class_name.op(X) with class_name.op("[this]"'access,X)
   // replace op(X)            with            op("[this]"'access,X)
   loop(MClass->MOperation where ![MOperation].isStatic())
      testInfo("OCL", "   check op " [MOperation.name] "\n");
      [act] = replace([act], "(^|[^A-Za-z0-9_.])(|"[MClass.name]"[.])("[MOperation.name]") *\(" , "\\1\\3("[this]"'access,##OCL##");
      testInfo ("OCL", "   evaluateStatement (41) -> " [act] "\n");
   end loop
   [act] = replace([act], ",##OCL## *\)" , ")");
   [act] = replace([act], ",##OCL##" ,     ",");
   testInfo ("OCL", "evaluateStatement (final) -> " [act] "\n");
   return [act];

end proc

proc genAccThisParameter(MClass,doIt)

   if(![doIt]) 
      return "";
   else
      return "(acc_This : " getClassParamForUpdate([MClass]) ")";
   end if

end proc

proc genAccThisArgument(MClass)

   switch(stateMachineImplementation([MClass]))
   case "Table":
      return "(acc_This)"; 
   case "Case":
   case "Entry":
   case "Entry_Wait":
      return ""; 
   default :
      return "ERROR genAccThisArgument: unsupported stateMachineImplementation";
   end switch

end proc

template activityProcedure(MStatemachine,MClass,addThisAndCS)
[getText()]
[if([addThisAndCS])]
procedure Perform_Activity (acc_This : [getClassParamForUpdate([MClass])][genStateParam([MClass])]) is
	[genSMrenames([MClass],TRUE)]
[else]
procedure Perform_Activity is
[end if]
begin
	case currentState is
	[activityCases([MStatemachine],[MClass])]
	end case;
end Perform_Activity;
end template

template activityCases(MStatemachine,MClass)
[// wdh: the second part of the condition seems nonsense: presence of activity has influence on completion trainsitions]
[//   loop(MStatemachine->MState where genStateName([MState]) != "" && (useSMCode([MClass]) != "Code" || getActivity([MState]) == ""))]
[loop(MStatemachine->MState where genStateName([MState]) != "")]
when [genStateName([MState])] =>
	[activityAndCompletionForState([MStatemachine],[MClass],[MState],"")]
[end loop]

[loop(MStatemachine->MState->Submachine)]
[activityCases([Submachine],[MClass])]
[end loop]
end template

template activityAndCompletionForState(MStatemachine,MClass,MState,elsePart)
[genActivityCode([MState],[MClass])]
[setDelim("if")]
[    loop(Instances->TokenSet(getPathSet([MState])) As pathName where getPathTriggerId([pathName.line]) == "")]
[     loop(Instances->MState(getToStateId([pathName.line])) As ToState where hasLoop(ToState->MFinalState) ==FALSE)]
[delim()] [getPathGuardCode([MClass],[pathName.line])] then
	[outDesc(
genStateTransition([MClass],[MState],[MStatemachine],[ToState],
genPathActions([pathName.line],[MClass]), ""))]
[      if(getPathGuardCode([MClass],[pathName.line]) == "TRUE")]
end if; -- other transitions impossible
[         return]
[      end if]
[setDelim("elsif")]
[    end loop]
[   end loop]
[   if ([elsePart] != "")]
[      if(delim() == "if")]
[elsePart]
[      else]
else
	[elsePart]
[      end if]
[   end if]
[   if(delim() != "if")]
end if;
[   end if]
end template

template genActivityCode(MState,MClass)
[genTrace([MClass],"Activity for state ",genStateName([MState]))]
[switch(useSMCode([MClass]))]
[case "Code" :]
[outDesc(evaluateStatement(getActivity([MState]),[MClass]))]
[case "Comment" :]
[outDescAsComment("Activity: "getActivity([MState]))]
[default :]
[mergeOut("UDACT::"getUniqueId([MState]),"Action Code","null;")]
[end switch]
end template

tcl_proc matchLists(L1, L2)

	set result ""
	
	foreach i1 $L1 i2 $L2 {
		if {$i1 != $i2} {
			return $result
		} else {
			set result $i1
		}
	}
	return $result	

end proc

proc getSMPath(MStatemachine)

   loop(MStatemachine->SuperState->MStatemachine As Parent)
      return getSMPath([Parent]) " " getSMName([MStatemachine]);
   end loop
   return getSMName([MStatemachine]);

end proc

proc getCommonRoot(MStatemachine As S1,MStatemachine As S2)

//   local s1List = invIdOrder(getIdListRec(S1->SuperState->MStatemachine));
//   local s2List = invIdOrder(getIdListRec(S2->SuperState->MStatemachine));
   local s1List = getSMPath([S1]);
   local s2List = getSMPath([S2]);

//T   info = "s1List " [s1List] " s2List " [s2List] "\n";

   local id = matchLists([s1List],[s2List]);
  
//   loop(Instances->MStatemachine([id]))
//      return getSMName([MStatemachine]);
//   end loop

   return [id];
  
end proc

template leaveMachines(MStatemachine As Current, Target,MClass)
[loop(Current->SuperState->MStatemachine)]
[   loop(Current->MState->MPseudoState As historyState where [historyState.kind] == "HistoryState")]
memory_[genStateName([historyState])] := currentState;
[   end loop]
[genExitAction([SuperState],[MClass])]
[   if(getSMName([MStatemachine]) != [Target])]
[leaveMachines([MStatemachine],[Target],[MClass])]
[   end if]
[end loop]
end template

template enterMachines(Source, MStatemachine As Destination,MClass,byEvent)
[loop(Destination->SuperState->MStatemachine)]
[   if(getSMName([MStatemachine]) != [Source])]
[enterMachines([Source],[MStatemachine],[MClass],[byEvent])]
[   end if]
[genEntryAction([SuperState],[MClass],[byEvent])]
[genActivity([SuperState],[MClass])]
[end loop]
end template

//^
// access the map
//

proc terminates(MState,MEvent)

   local s;

   [s] = "Terminates_" [MState.id] "_" [MEvent.id];
   testInfo("SM_Map", "Terminates("[MState.name]","[MEvent.name]"):"[[s]]"\n");
   if([[s]] == TRUE)
      return TRUE;
   else
      return FALSE;
   end if

end proc

proc getTransitionCode(MState,MEvent,MTransition)

   local s;

   [s] = "Code_" [MState.id] "_" [MEvent.id] "_" [MTransition.id];
   testInfo("SM_Map", "TC("[MState.name]","[MEvent.name]","[MTransition.id]"):"[[s]]"\n");
   return [[s]];
   
end proc

//*****************************************************************************
// 5. state machine package (defines state type and action procedures)
//*****************************************************************************

template genStateMachinePackageDecl(MClass)			


package [MClass.name]_State_Machine is
[loop(MClass->MStatemachine)]
[genStateMachineMap([MStatemachine],[MClass])]
[end loop]

	[genSectionComment("State Type")]
[loop(MClass->MStatemachine)]
	[setDelim("")]
	type State_Type is (
		[addStatesToEnum([MStatemachine])]
		);
	[genSubtypesForAddStatesToEnum([MStatemachine],"")]
[   if([doCallStp] == TRUE)]
	function stateId (S : State_Type) return Managed_Base_Classes.Stp_State_Id;
[   end if]
[end loop]

[switch(stateMachineImplementation([MClass]))]
[case "Table":]

	-- Action procedures
[   loop(MClass->MStatemachine)]
        [defineActionProcedures([MStatemachine],[MClass])]
[   end loop]
	procedure Perform_Activity (acc_This : [getClassParamForUpdate([MClass])][genStateParam([MClass])]);

	type Action_Procedure is access procedure (acc_This : [getClassParamForUpdate([MClass])][genStateParam([MClass])]);
	StateEventTable : array (State_Type,[MClass.name]_Event_Type) of Action_Procedure;

[   break]
[case "Entry_Wait":]

[   if(isPT([MClass]))]
	-- State related Guards for protected type's entries		
[      loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
	[genEventName([ReceiveEvent])]_Accepted : array (State_Type) of Boolean;
[      end loop]
[   end if]
[   break]
[case "Entry":]
[   break]
[case "Case":]
[      if(isPT([MClass]) == FALSE && isTask([MClass]) == FALSE)]
	[genEventProceduresDeclCase([MClass])]
[      end if]
[   break]
[default :]
ERROR genStateMachinePackageDecl: unsupported stateMachineImplementation
[end switch]				
end [MClass.name]_State_Machine;
end template

//^
// recursively define the state type as set of all states in all submachines
//
template addStatesToEnum(MStatemachine)
[loop(MStatemachine->MState where genStateName([MState]) != "")]
	[delim()][genStateName([MState])][setDelim(", ")]
[   loop(MState->Submachine)]
[addStatesToEnum([Submachine])]
[   end loop]
[end loop]
end template

proc genSubtypesForAddStatesToEnum(MStatemachine,super)
// Same as above, but produce subtype declarations
   local first = "";
   local last  = "<error>";
   local curr  = "<error>";
   local result = "";
   loop(MStatemachine->MState where genStateName([MState]) != "")
      [curr] = genStateName([MState]);
      if ([first] == "")
         [first] = [curr];
      end if
      // [result_t] = [result_t] delim() [curr]; // "\nl";
      // setDelim(", ");
      loop(MState->Submachine)
         [result] = [result] genSubtypesForAddStatesToEnum([Submachine],[curr]);
      end loop
   end loop
   [last] = [curr];
   if ([super] != "")
      [result] = [result] "subtype "[super]"_Substate_Range is State_Type range "[first]" .. "[last]";\n";
   end if
   return [result];
end proc

//^
// recursively define action procedures for all state transitions
//
template defineActionProcedures(MStatemachine,MClass)
[loop(MStatemachine->MState As FromState where genStateName([FromState]) != "")]
[   loop(FromState->Submachine)]
[defineActionProcedures([Submachine],[MClass])]
[   end loop]
[   loop(Instances->MEvent(getHandledEvents([FromState])) As TriggerEvent)]
procedure [genActionProcName([FromState],[TriggerEvent])] (acc_This : [getClassParamForUpdate([MClass])][genStateParam([MClass])]);
	[genInlinePragma(genActionProcName([FromState],[TriggerEvent]))]
[   end loop]
[end loop]

end template

template genStateParam(MClass)
[if(isPT([MClass]) || isTask([MClass]))]
; currentState : in out State_Type
[end if]
end template

template genSMrenames(MClass,doIt)
[if([doIt])] 
[accThis([MClass])]
[   if(isPT([MClass]) == FALSE && isTask([MClass]) == FALSE)]
currentState : State_Type renames [thisToTaskPt([MClass])]currentState;
[   end if]
[end if]
end template

template genStateMachinePackageBody(MClass)			

package body [MClass.name]_State_Machine is

[if([doCallStp] == TRUE)]
	function stateId (S : State_Type) return Managed_Base_Classes.Stp_State_Id is
	begin
		case S is
[   loop(MClass->MStatemachine)]
		[addStatesToStateIdCase([MStatemachine])]
[   end loop]
		end case;
	end stateId;
[end if]

[switch(stateMachineImplementation([MClass]))]
[case "Entry":]
[   break]
[case "Case":]
[      if(isPT([MClass]) == FALSE && isTask([MClass]) == FALSE)]
[// does not work for event parameters genTakeEventBodyCase([ MClass])]
	[genEventProceduresBodyCase([MClass])]
[      end if]
[   break]
[case "Table":]
[   loop(MClass->MStatemachine)]
[setTextBlind(genSectionComment("Entry Action Procedures"))]
	[entryActionProcedures([MStatemachine],[MClass],TRUE)]
[setTextBlind(genSectionComment("Exit Action Procedures"))]
	[exitActionProcedures([MStatemachine],[MClass],TRUE)]
[setTextBlind(genSectionComment("Activity Procedure"))]
	[activityProcedure([MStatemachine],[MClass],TRUE)]
[   end loop]

	-- Action procedure bodies

[   loop(MClass->MStatemachine)]
        [defineActionProcedureBodies([MStatemachine],[MClass])]
[   end loop]

begin
[   loop(MClass->MStatemachine)]
	[initStateEventTable([MStatemachine],[MClass])]
[   end loop]
[   break]
[case "Entry_Wait":]
[   if(isPT([MClass]))]
begin
[      loop(MClass->MStatemachine)]
	[initAccepted([MStatemachine],[MClass])]
[      end loop]
[   end if]
[   break]
[default :]
ERROR genStateMachinePackageBody: unsupported stateMachineImplementation
[end switch]
end [MClass.name]_State_Machine;

end template

template addStatesToStateIdCase(MStatemachine)
[loop(MStatemachine->MState where genStateName([MState]) != "")]
when [genStateName([MState])] => return [MState.id];
[   loop(MState->Submachine)]
[addStatesToStateIdCase([Submachine])]
[   end loop]
[end loop]
end template

//^
// recursively define action procedures for all state transitions
//
template defineActionProcedureBodies(MStatemachine,MClass)
[loop(MStatemachine->MState As FromState where genStateName([FromState]) != "")]
[   loop(FromState->Submachine)]
[defineActionProcedureBodies([Submachine],[MClass])]
[   end loop]
[   loop(Instances->MEvent(getHandledEvents([FromState])) As TriggerEvent)]

procedure [genActionProcName([FromState],[TriggerEvent])] (acc_This : [getClassParamForUpdate([MClass])][genStateParam([MClass])]) is
	[genSMrenames([MClass],TRUE)] 
begin
	[loop(Instances->TokenSet(getPaths([FromState],[TriggerEvent])) As pathName;setDelim("if");setDelim("elsif"))]
	[delim()] [getPathGuardCode([MClass],[pathName.line])] then
		[outDesc(getPathCode([FromState],[TriggerEvent],[pathName.line]))]
	[end loop]
	end if;
end [genActionProcName([FromState],[TriggerEvent])];
[   end loop]
[end loop]
end template


//^
// recursively set action for all possible transitions
//
template initStateEventTable(MStatemachine,MClass)
[loop(MStatemachine->MState As FromState where genStateName([FromState]) != "")]
[   loop(FromState->Submachine)]
[initStateEventTable([Submachine],[MClass])]
[   end loop]
[   loop(Instances->MEvent(getHandledEvents([FromState])) As TriggerEvent)]
StateEventTable([genStateName([FromState])],[genEventName([TriggerEvent])])
   := [genActionProcName([FromState],[TriggerEvent])]'access;
[   end loop]
[end loop]
end template

template initAccepted(MStatemachine,MClass)
[loop(MStatemachine->MState As FromState where genStateName([FromState]) != "")]
[   loop(FromState->Submachine)]
[initAccepted([Submachine],[MClass])]
[   end loop]
[   loop(Instances->MEvent(getHandledEvents([FromState])) As TriggerEvent)]
[genEventName([TriggerEvent])]_Accepted([genStateName([FromState])]) := True;
[   end loop]
[end loop]
end template

//*****************************************************************************
// 6. storage for the state machines
//*****************************************************************************

template genStateMachineComponents(MClass)			
[if(isActiveClass([MClass]))]
[genSectionComment("State Machine")]
[   loop(MClass->MStatemachine)]
currentState : [MClass.name]_State_Machine.State_Type := [MClass.name]_State_Machine.[[MStatemachine].creationState()];
[genMemory([MStatemachine],[MClass])]
[   end loop]
[end if]
end template

template genMemory(MStatemachine,MClass)
[loop(MStatemachine->MState->MPseudoState As historyState where [historyState.kind] == "HistoryState")]
[   loop(MStatemachine->SuperState)]
memory_[genStateName([historyState])] 
	: [MClass.name]_State_Machine.[genStateName([SuperState])]_Substate_Range 
	:= [MClass.name]_State_Machine.[[MStatemachine].creationState()];
[   end loop]
[end loop]
[loop(MStatemachine->MState->Submachine)]
[genMemory([Submachine],[MClass])]
[end loop]
end template

proc MStatemachine.creationState()

	loop(MStatemachine->MState->MCreationState)
	   if(genStateName([MCreationState]) == "")
	      // the creation state is anonymous and has a transition without event
	      // to a "normal" state. This is our creation state
	      loop(MCreationState->ToState)
	         return genStateName([ToState]);
	      end loop
	   else	
	      return genStateName([MCreationState]);
	   end if
	end loop
	
	info = "Error: state machine " getSMName([MStatemachine]) " has no creation state\n";
	
	return "??";

end proc

proc MState.creationState()

	loop(MState->Submachine)
	   return [Submachine].creationState();
	end loop
	
end proc

proc hasSubmachine(MState)

	loop(MState->Submachine)
	   return TRUE;
	end loop
	
	return FALSE;
	
end proc

//*****************************************************************************
// 7a. passive class or protected type using state event table
//*****************************************************************************

template genTakeEventBodyTable(MClass)

[genSectionComment("State Machine Operations")]
procedure Take_Event(acc_This : [getClassParamForUpdate([MClass])]; Event : [MClass.name]_Event_Type) is
	stateAction : [MClass.name]_State_Machine.Action_Procedure;
	use type [MClass.name]_State_Machine.Action_Procedure;
begin
	stateAction := [MClass.name]_State_Machine.StateEventTable(acc_This.currentState,Event);
	if stateAction /= NULL then
		stateAction(acc_This);
		[MClass.name]_State_Machine.Perform_Activity (acc_This);
	else
		[genHandleStateError([MClass],"acc_This.all'access","acc_This.currentState","","Event","")]
	end if;
end Take_Event;
end template

template genTableEventTakeBodyPT(MClass)

[genSectionComment("State Machine Operations")]
entry Take_Event(Event : [MClass.name]_Event_Type) when true is
	stateAction : [MClass.name]_State_Machine.Action_Procedure;
	use type [MClass.name]_State_Machine.Action_Procedure;
begin
	stateAction := [MClass.name]_State_Machine.StateEventTable(currentState,Event);
	if stateAction /= NULL then
[if(isTagged([MClass]))]
		stateAction(acc_This.all'unchecked_access, currentState);
		[MClass.name]_State_Machine.Perform_Activity (acc_This.all'unchecked_access, currentState);
[else]
		stateAction([MClass.name]'access,currentState);
		[MClass.name]_State_Machine.Perform_Activity ([MClass.name]'access,currentState);
[end if]
	else
[if(isTagged([MClass]))]
		[genHandleStateError([MClass],"acc_This.all'access","currentState","","Event","")]
[else]
		[genHandleStateError([MClass],[MClass.name]"'address","currentState","","Event","")]
[end if]
	end if;
end Take_Event;
end template

//*****************************************************************************
// 7b. passive class using nested case
//*****************************************************************************

template genTakeEventBodyCase(MClass)

[genSectionComment("State Machine Operations")]
procedure Take_Event(acc_This : [getClassParamForUpdate([MClass])]; Event : [MClass.name]_Event_Type) is
	[accThis([MClass])]
	use [MClass.name]_State_Machine;
	currentState : State_Type renames this.currentState;
[loop(MClass->MStatemachine)]
\
[setTextBlind(genSectionComment("Entry Action Procedures"))]
	[entryActionProcedures([MStatemachine],[MClass],FALSE)]
[setTextBlind(genSectionComment("Exit Action Procedures"))]
	[exitActionProcedures([MStatemachine],[MClass],FALSE)]
[setTextBlind(genSectionComment("Activity Procedure"))]
	[activityProcedure([MStatemachine],[MClass],FALSE)]
	
[end loop]
begin
	case currentState is
[loop(MClass->MStatemachine)]
	[genTakeEventCases([MStatemachine],[MClass])]
[end loop]
	when others =>
		raise Program_Error;
	end case; -- end state case
end Take_Event;
end template

//^
// recursively add cases to the case of current state
//
template genTakeEventCases(MStatemachine,MClass)
[loop(MStatemachine->MState As FromState where genStateName([FromState]) != "")]
[   if(isSuperState([FromState]))]
[      loop(FromState->Submachine)]
[genTakeEventCases([Submachine],[MClass])]
[      end loop]
[   else]
when [genStateName([FromState])] =>
	case Event is
[      loop(Instances->MEvent(getHandledEvents([FromState])) As TriggerEvent)]
	when [genEventName([TriggerEvent])] =>
		[loop(Instances->TokenSet(getPaths([FromState],[TriggerEvent])) As pathName;setDelim("if");setDelim("elsif"))]
		[delim()] [getPathGuardCode([MClass],[pathName.line])] then
			[outDesc([getPathCode([FromState],[TriggerEvent],[pathName.line])])]
		[end loop]
		end if;
		Perform_Activity;
[      end loop]
	when others =>
		[genHandleStateError([MClass],"acc_This.all'access","currentState",[FromState.id],"Event","")]
	end case;  -- end Event case
[   end if]
[end loop]
end template

template genEventProceduresDeclCase(MClass)

[genSectionComment("State Machine Operations")]
[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
procedure Take_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],TRUE)][closeList()];
	[genInlinePragma("Take_"genEventName([ReceiveEvent]))]
[end loop]
end template

template genEventProceduresBodyCase(MClass)

[genSectionComment("State Machine Operations")]

[loop(MClass->MStatemachine)]
[setTextBlind(genSectionComment("Entry Action Procedures"))]
[entryActionProcedures([MStatemachine],[MClass],TRUE)]
[setTextBlind(genSectionComment("Exit Action Procedures"))]
[exitActionProcedures([MStatemachine],[MClass],TRUE)]
[setTextBlind(genSectionComment("Activity Procedure"))]
[activityProcedure([MStatemachine],[MClass],TRUE)]
[end loop]

[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
procedure Take_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],TRUE)][closeList()] is
	[accThis([MClass])]
	use [MClass.name]_State_Machine;
	currentState : State_Type renames this.currentState;
begin
	case currentState is
[   loop(Instances->MState([ReceiveEvent:acceptingStates]) As FromState)]
	when [MClass.name]_State_Machine.[genStateName([FromState])] =>
		[loop(Instances->TokenSet(getPaths([FromState],[ReceiveEvent])) As pathName;setDelim("if");setDelim("elsif"))]
		[delim()] [getPathGuardCode([MClass],[pathName.line])] then
			[outDesc(getPathCode([FromState],[ReceiveEvent],[pathName.line]))]
		[end loop]
		end if;
		Perform_Activity (acc_This);
[   end loop]
	when others =>
		[genHandleStateError([MClass],"acc_This.all'access","currentState","","",[ReceiveEvent.id])]
	end case;
end Take_[genEventName([ReceiveEvent])];

[end loop]
end template

//*****************************************************************************
// 7c. protected type
//*****************************************************************************

template genTakeEventBodyCallPT(MClass)

[genSectionComment("State Machine Operations")]
procedure Take_Event(acc_This : [getClassParamForUpdate([MClass])]; Event : [MClass.name]_Event_Type) is
begin
[switch(stateMachineImplementation([MClass]))]
[case "Table":]
	[accThisToTaskPt([MClass])]Take_Event (Event);
[   break]
[case "Case":]
[case "Entry" :]
[case "Entry_Wait" :]
	case Event is
[   loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
	when [genEventName([ReceiveEvent])] =>
		[accThisToTaskPt([MClass])]Take_[genEventName([ReceiveEvent])];
[   end loop]
	end case;
[case "None" :]
[default :]
ERROR genTakeEventBodyCallPT: unsupported stateMachineImplementation
[end switch]
end Take_Event;
end template

template genEventEntriesPT(MClass)
[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
[if(stateMachineImplementation([MClass])=="Entry_Wait")]
entry Take_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],FALSE)][closeList()]
   when [MClass.name]_State_Machine.[genEventName([ReceiveEvent])]_Accepted(currentState) is
[else]
entry Take_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],FALSE)][closeList()] when TRUE is
[end if]
begin
	case currentState is
[   loop(Instances->MState([ReceiveEvent:acceptingStates]) As FromState)]
	when [MClass.name]_State_Machine.[genStateName([FromState])] =>
		[loop(Instances->TokenSet(getPaths([FromState],[ReceiveEvent])) As pathName;setDelim("if");setDelim("elsif"))]
		[delim()] [getPathGuardCode([MClass],[pathName.line])] then
			[outDesc(getPathCode([FromState],[ReceiveEvent],[pathName.line]))]
		[end loop]
		end if;
		Perform_Activity; -- for protected entries, it's impossible to have this outside the entry body
[   end loop]
	when others =>
[if(stateMachineImplementation([MClass])=="Entry_Wait")]
		raise Program_Error;
[else]
		[genHandleStateError([MClass],"acc_This.all'access","currentState","","",[ReceiveEvent.id])]
[end if]
	end case;
end Take_[genEventName([ReceiveEvent])];
[end loop]

end template

//*****************************************************************************
// 7d. task type
//*****************************************************************************


template genTakeEventBodyCallTask(MClass)
[genSectionComment("State Machine Operations")]
procedure Take_Event(acc_This : [getClassParamForUpdate([MClass])]; Event : [MClass.name]_Event_Type) is
begin
[switch(stateMachineImplementation([MClass]))]
[case "Table":]
[case "Case":]
	[accThisToTaskPt([MClass])]Take_Event (Event);
[   break]
[case "Entry" :]
[case "Entry_Wait" :]
	case Event is
[   loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
	when [genEventName([ReceiveEvent])] =>
		[accThisToTaskPt([MClass])]Take_[genEventName([ReceiveEvent])];
[   end loop]
	end case;
[   break]
[case "None" :]
[default :]
ERROR genTakeEventBodyCallTask: unsupported stateMachineImplementation
[end switch]
end Take_Event;
end template

template genStateMachineTaskBodyDecls(MClass)
[if(isActiveClass([MClass]))]
[   switch(stateMachineImplementation([MClass]))]
[   case "None" :]
[      return]
[   case "Table":]
[genStateMachineComponents([MClass])]
use [MClass.name]_State_Machine;
[      return]
[   case "Case":]
[genStateMachineComponents([MClass])]
use [MClass.name]_State_Machine;
[      loop(MClass->MStatemachine)]
[setTextBlind(genSectionComment("Entry Action Procedures"))]
[entryActionProcedures([MStatemachine],[MClass],FALSE)]
[setTextBlind(genSectionComment("Exit Action Procedures"))]
[exitActionProcedures([MStatemachine],[MClass],FALSE)]
[setTextBlind(genSectionComment("Activity Procedure"))]
[activityProcedure([MStatemachine],[MClass],FALSE)]
[      end loop]
[      return]
[   case "Entry" :]
[   case "Entry_Wait" :]
[genStateMachineComponents([MClass])]
use [MClass.name]_State_Machine;
[      loop(MClass->MStatemachine)]
[setTextBlind(genSectionComment("Entry Action Procedures"))]
[entryActionProcedures([MStatemachine],[MClass],FALSE)]
[setTextBlind(genSectionComment("Exit Action Procedures"))]
[exitActionProcedures([MStatemachine],[MClass],FALSE)]
[      end loop]
[   end switch]
[end if]
end template

template genStateMachineTaskBodyPart(MClass)
[if(isActiveClass([MClass]))]
loop
   [mergeOut("UDTBSMP" condGetUniqueId([MClass]),"task body state machine prefix","")]
	case currentState is
[loop(MClass->MStatemachine)]
	[genTaskBodyCases([MStatemachine],[MClass])]
[end loop]
	end case; -- end state case
	[mergeOut("UDTBSMS" condGetUniqueId([MClass]),"task body state machine suffix","")]
end loop;
[end if]
end template

template genTaskBodyCases(MStatemachine,MClass)
[loop(MStatemachine->MState As FromState where genStateName([FromState]) != "")]
when [MClass.name]_State_Machine.[genStateName([FromState])] =>
[   if(isSuperState([FromState]) || hasLoop(FromState->MFinalState) || hasLoop(FromState->MPseudoState As historyState where [historyState.kind] == "HistoryState"))]
	raise Program_Error;
[   else]
[openSelect()]
[      switch(stateMachineImplementation([MClass]))]
[      case "Case" :]

\
[         if(!isTagged([MClass]))]
	[genAttributeOperationBodiesTask([MClass])]
	[genRelationOperationBodiesTask([MClass])]
[         end if]
	[//later: must not duplicate mergeOut !! genClassOperationsBodiesTask([//MClass])]
	[setTextBlind("\n"genSectionComment("State Machine"))]
	[selectAlternative(
		genAcceptTakeEventCase([MClass],[FromState]))]
[         break]
[      case "Table" :]

\
[         if(!isTagged([MClass]))]
	[genAttributeOperationBodiesTask([MClass])]
	[genRelationOperationBodiesTask([MClass])]
[         end if]
	[selectAlternative(
		genAcceptTakeEventTable([MClass],[FromState]))]
[         break]
[      case "Entry" :]

\
[         if(!isTagged([MClass]))]
	[genAttributeOperationBodiesTask([MClass])]
	[genRelationOperationBodiesTask([MClass])]
[         end if]
	[genAcceptEntriesAll([MClass],[FromState])]
[         break]
[      case "Entry_Wait" :]

\
	[activityAndCompletionForState([MStatemachine],[MClass],[FromState],
genAcceptEntriesEW([MClass],[FromState]))]
[         break]
[      default :]
ERROR genTaskBodyCases: unsupported stateMachineImplementation
[      end switch]
	[closeSelect()]

[   end if]
[   loop(FromState->Submachine)]
[genTaskBodyCases([Submachine],[MClass])]
[   end loop]
[end loop]
end template

template genAcceptTakeEventCase(MClass,MState As FromState)
accept Take_Event(Event : [MClass.name]_Event_Type) do
--TBD
end Take_Event;
end template

template genAcceptTakeEventTable(MClass,MState As FromState)
accept Take_Event(Event : [MClass.name]_Event_Type) do
	declare
		stateAction : [MClass.name]_State_Machine.Action_Procedure;
		use type [MClass.name]_State_Machine.Action_Procedure;
	begin
		stateAction := [MClass.name]_State_Machine.StateEventTable(currentState,Event);
		if stateAction /= NULL then
[if(isTagged([MClass]))]
			stateAction(acc_This.all'unchecked_access, currentState);
[// wdh: activity should be moved outside rendezvous]
			[MClass.name]_State_Machine.Perform_Activity (acc_This.all'unchecked_access, currentState);
[else]
			stateAction([MClass.name]'unchecked_access,currentState);
			[MClass.name]_State_Machine.Perform_Activity ([MClass.name]'unchecked_access,currentState);
[end if]
		else
[if(isTagged([MClass]))]
			[genHandleStateError([MClass],"acc_This.all'access","currentState","","Event","")]
[else]
			[genHandleStateError([MClass],[MClass.name]"'address","currentState","","Event","")]
[end if]
		end if;
	end;
end Take_Event;
end template

template genAcceptEntriesAll(MClass,MState As FromState)
[if(genActivity([FromState],[MClass]) != "" && ([FromState:timeout] != "" || [FromState:mayTerminate] != ""))]
[genActivityCode([FromState],[MClass])]
[end if]
[loop(MClass->ReceiveEvent)]
[   markEvent([ReceiveEvent],FALSE)]
[end loop]
[loop(Instances->MEvent(getHandledEvents([FromState])) As TriggerEvent)]
[   markEvent([TriggerEvent],TRUE)]
[selectAlternative(
	genAcceptEventEntry([TriggerEvent],[FromState],[MClass]))]
[end loop]
[loop(MClass->ReceiveEvent where ![ReceiveEvent:mark])]
[selectAlternative(
	genAcceptEventEntryDummy([ReceiveEvent],[FromState],[MClass]))]
[end loop]
[if([FromState:timeout] != "")]
[selectAlternative(
	genDelayCode([FromState]))]
[else if([FromState:mayTerminate] != "")]
[selectTerminateAlternative()]
[else if(genActivity([FromState],[MClass]) != "")]
[selectElseAlternative(
	genActivityCode([FromState],[MClass]))]
[end if end if end if]
end template

proc markEvent(MEvent,value)

   [MEvent:mark] = [value];

end proc

template genAcceptEventEntry(MEvent As TriggerEvent,MState As FromState,MClass)

[	if (stateMachineImplementation([MClass]) == "Entry_Wait")]
[		loop(Instances->TokenSet(getPaths([FromState],[TriggerEvent])) As pathName;setDelim("when (");setDelim("  or ("))]
[delim()] [getPathGuardCode([MClass],[pathName.line])] )
[		end loop]
  =>
[	end if]
accept Take_[genEventName([TriggerEvent])][genEvParaList([TriggerEvent],[MClass],FALSE)][closeList()] do
	[loop(Instances->TokenSet(getPaths([FromState],[TriggerEvent])) As pathName;setDelim("if");setDelim("elsif"))]
	[delim()] [getPathGuardCode([MClass],[pathName.line])] then
		[outDesc(getPathCode([FromState],[TriggerEvent],[pathName.line]))]
	[end loop]
	end if;
end Take_[genEventName([TriggerEvent])];
[if(terminates([FromState],[TriggerEvent]))]
[   if(isTagged([MClass]))]
[genHandleSMDestroy([MClass],[FromState.id],"acc_This.all'access",genEventName([TriggerEvent]))]
[   else]
[genHandleSMDestroy([MClass],[FromState.id],[MClass.name]"'address",genEventName([TriggerEvent]))]
[   end if]
exit;
[end if]
end template

template genAcceptEventEntryDummy(MEvent As ReceiveEvent,MState As FromState,MClass)


accept Take_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],FALSE)][closeList()] do
[if(isTagged([MClass]))]
	[genHandleStateError([MClass],"acc_This.all'access","currentState","","",[ReceiveEvent.id])]
[else]
	[genHandleStateError([MClass],[MClass.name]"'address","currentState","","",[ReceiveEvent.id])]
[end if]
end Take_[genEventName([ReceiveEvent])]; 
end template

template genDelayCode(MState As FromState)
delay [FromState:timeout];
begin -- Block introduced as workaround for ECR 6520
[outDesc([FromState:timeoutTransition])]
end;
end template


template genAcceptEntriesEW(MClass,MState As FromState)
[if(!isTagged([MClass]))]
[genAttributeOperationBodiesTask([MClass])]
[genRelationOperationBodiesTask([MClass])]
[end if]
[loop(Instances->MEvent(getHandledEvents([FromState])) As TriggerEvent)]
[selectAlternative(
	genAcceptEventEntry([TriggerEvent],[FromState],[MClass]))]
[end loop]
[if([FromState:timeout] != "")]
[selectDelayAlternative(
	genDelayCode([FromState]))]
[else if([FromState:mayTerminate] != "")]
[selectTerminateAlternative()]
[end if end if]
[closeSelect()]
[openSelect()]
[// just to get the nesting right, assuming nobody wants to add something to the selective wait above]
end template

//*****************************************************************************
// 8. constructor
//*****************************************************************************

template genStateMachineInitialize(MClass,MClass As TypeClass)
[if([MClass.active])]
[   if (doInitializeStateMachine([MClass]))]
case Event is

[   loop(MClass->MStatemachine->MState->MCreationState)]
[    loop(Instances->TokenSet(getPathSet([MCreationState])) as pathName)]
[     loop(Instances->MEvent(getPathTriggerId([pathName.line])) as TriggerEvent where genEventName([TriggerEvent]) != "__delay")]
when [genEventName([TriggerEvent])] =>
	[genHandleSMCreate([MClass],[MCreationState.id],"acc_this.all'access", genEventName([TriggerEvent]))]
[      if(stateMachineImplementation([MClass])=="Table")]
[         if(isTask([MClass]) || isPT([MClass]))]
	[accThisToTaskPt([TypeClass])]Take_Event([genEventName([TriggerEvent])]);
[         else]
	Take_Event(acc_This,[genEventName([TriggerEvent])]);
[         end if]
[      else]
[         if(isTask([MClass]) || isPT([MClass]))]
	[accThisToTaskPt([TypeClass])]Take_[genEventName([TriggerEvent])];
[         else]
	[MClass.name]_State_Machine.Take_[genEventName([TriggerEvent])](acc_This);
[         end if]
[      end if]
	return;
[      end loop]
[    end loop]
[   end loop]
when others =>
   raise constraint_error; -- error handling generated by genHandleStateError does not work
[//	[genHandleStateError([MClass],"acc_This.all'access","acc_This.currentState","","Event","")]]
end case;
[   else]
[      if (stateMachineImplementation([MClass])!="Table" && isPT([MClass]))]
[accThisToTaskPt([TypeClass])]InitializeSM;
[      else]
null;
[      end if]
[   end if]
[else]
[   loop(MClass->SuperClass)]
[genStateMachineInitialize([SuperClass],[TypeClass])]
[   end loop]
[end if]
end template

//*****************************************************************************
// 7. helpers
//*****************************************************************************

proc isSuperState(MState)

   loop(MState->Submachine)
      return TRUE;
   end loop
   return FALSE;
  
end proc

proc getEntryAction(MState)


   loop(MState->MAction->MActionType where [MActionType.type] == "entry")
      return [MAction.name];
   end loop
   
   return "";
  
end proc

proc getExitAction(MState)

   loop(MState->MAction->MActionType where [MActionType.type] == "exit")
      return [MAction.name];
   end loop
  
   return "";
  
end proc

proc getActivity(MState)

   loop(MState->MActivity)
      return [MActivity.name];
   end loop
  
   return "";
  
end proc

proc identifyClassOperations()

   loop(Instances->MClass->MOperation where isActiveClass([MClass]))
      matchEvent([MOperation],[MClass]);
   end loop
  
end proc

proc matchEvent(MOperation,MClass)

//T info = "isCallEvent " [MOperation.name] " -> ";

   [MOperation:callEventId] = "";

   loop(MClass->ReceiveEvent where [MOperation.name] == [ReceiveEvent.name])
      if(genEvParaList([ReceiveEvent],[MClass],FALSE) == "")
         [MOperation:callEventId] = [ReceiveEvent.id];
         [ReceiveEvent:operationId] = [MOperation.id];
//T info = "TRUE\n";
         return;
      else if(genOpParaList([MOperation],FALSE) == genEvParaList([ReceiveEvent],[MClass],FALSE))
         [MOperation:callEventId] = [ReceiveEvent.id];
         [ReceiveEvent:operationId] = [MOperation.id];
//T info = "TRUE\n";
         return;
      end if end if
   end loop

//T info = "FALSE\n";
   return;

end proc

proc isCallEvent(MOperation,MClass)

   if([MOperation:callEventId] == "")
      return FALSE;
   else
      return TRUE;
   end if
  
end proc

proc hasParameters(MEvent)

   if(hasLoop(MEvent->EvPara))
      return TRUE;
   end if
   
   if([MEvent:operationId] == "")
      return FALSE;
   end if
   
   loop(Instances->MOperation([MEvent:operationId]))
      if(hasLoop(MOperation->OpPara))
         return TRUE;
      else
         return FALSE;
      end if
   end loop
   
   return FALSE;
   
end proc

/* genTrace conditionally generates calls to a user defined procedure
   which might be defined as follows:
	procedure trace_state (t : string; name : string) is
	begin
		ada.text_io.put_line (t & name);
	end trace_state;
*/

proc genTrace(MClass,text,stateName)

   if([MClass:traceSMCode] == "")
      [MClass:traceSMCode] = [MClass].getTaggedValueBool("Trace_State_Machine", "FALSE");
   end if

   if ([MClass:traceSMCode])
   	return "Trace_State(\"" [text] "\", \"" [stateName] "\");";
   else
   	return "--TRC " [text] [stateName];
   end if
   
end proc
/***
proc traceSMCode (MClass)
   if([MClass:traceSMCode] == "")
      [MClass:traceSMCode] = [MClass].getTaggedValueBool("Trace_State_Machine", "FALSE");
   end if
   return [MClass:traceSMCode];
end proc
template genTrace(MClass,text,stateName)
[   if (traceSMCode ([MClass]))]
Trace_State("[text]", "[stateName]");
[   else]
--TRC [text] [stateName]
[   end if]
end template
***/

template genSignalSpec(MClass)
with ACD_Runtime.Queued_Signals;
with [MClass:cuName];
with ACD_Runtime.Signals;
package [MClass:cuName].[MClass.name]_Signals is

	package Signals renames ACD_Runtime.Signals;
	package Queued_Signals renames ACD_Runtime.Queued_Signals;

	[mark("renames","rename_proc")]

	type Signal (Event : [MClass.name]_Event_Type) is new Queued_Signals.Queued_Signal with private;
[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
	procedure Send_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],TRUE)][delim()]Priority : Signals.Priority_Type := Signals.Normal);
[end loop] 

	procedure Dispatch (S : Signal);

	function Image (S : Signal) return String;

[if([doRaven])]
	function Allocate (S : Signal) return Signals.Signal_Class_Ref;
	procedure Free (S : access Signal);
[end if]    
 
private

      [mark("marshalltypes","")]
[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay" && hasParameters([ReceiveEvent]))]
	type [genEventName([ReceiveEvent])]_Arg_Type is
		record
[   if(hasLoop(ReceiveEvent->EvPara))]
[      loop(ReceiveEvent->EvPara)]
			[EvPara.name] : [genMarshalledParameterType([EvPara])];
[      end loop]
[   else]
[      loop(Instances->MOperation([ReceiveEvent:operationId]))]
[         loop(MOperation->OpPara)]
			[OpPara.name] : [genMarshalledParameterType([OpPara])];
[         end loop]
[      end loop]
[   end if]
		end record;
[end loop]


	[mark("publicsupptypes_Local","")]
	type Signal (Event : [MClass.name]_Event_Type) is new Queued_Signals.Queued_Signal with
		record
			This : [getClassTypeForAssociation([MClass],"Local")];
			case Event is
[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay" && hasParameters([ReceiveEvent]))]
			when [genEventName([ReceiveEvent])] =>
				[genEventName([ReceiveEvent])]_Arg : [genEventName([ReceiveEvent])]_Arg_Type;
[end loop]
[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay" && !hasParameters([ReceiveEvent]))]
			when [genEventName([ReceiveEvent])] => null;
[end loop]
			end case;
		end record;
      
end [MClass:cuName].[MClass.name]_Signals;
end template

template genSignalBody(MClass)
with ACD_Runtime.Signal_Queue;
[if([doCallStp] != TRUE)]
[   if([doRaven])]
with System.Address_Image_And_Value;
[   else]
with System;
[   end if]
[end if]
package body [MClass:cuName].[MClass.name]_Signals is

	Dots : constant string := "...";
	
	package Signal_Queue renames ACD_Runtime.Signal_Queue;

	use Queued_Signals;
	[//TBD: find solution not to redefine rename mark("renames","rename_proc")]

[loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
	procedure Send_[genEventName([ReceiveEvent])][genEvParaList([ReceiveEvent],[MClass],TRUE)][delim()]Priority : Signals.Priority_Type := Signals.Normal) is
	begin
[   if(hasParameters([ReceiveEvent]))]
		Send (Signal'(	Queued_Signal with
				Event	=> [genEventName([ReceiveEvent])],
				This	=> [getClassTypeForAssociation([MClass],"Local")] (acc_This),
				[genEventName([ReceiveEvent])]_Arg => [genEventName([ReceiveEvent])]_Arg_Type'[openList()][marshallEvParaList([ReceiveEvent])]),
		      Priority);
[   else]
		Send (Signal'(Queued_Signal with Event => [genEventName([ReceiveEvent])], This => [getClassTypeForAssociation([MClass],"Local")] (acc_This)), Priority);
[   end if]				
	end Send_[genEventName([ReceiveEvent])];
	
[end loop] 

	procedure Dispatch (S : Signal) is
[switch(stateMachineImplementation([MClass]))]
[case "Table":]
[   // we have no event parameters yet]
	begin
		--T text_io.put_line ("[MClass.name] Event " & [MClass.name]_Event_Type'image (S.Event)); --T
		[MClass:cuName].Take_Event (	
			acc_This	=> S.This.all'access,
			Event		=> S.Event);
[      break]
[case "Case":]
[case "Entry" :]
[case "Entry_Wait" :]
		acc_This : [getClassTypeForAssociation([MClass],"Local")] renames S.This;
	begin
		--T text_io.put_line ("Class [MClass.name] Event " & [MClass.name]_Event_Type'image (S.Event)); --T
		case S.Event is
[   loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
   		when [genEventName([ReceiveEvent])] =>
[      if(stateMachineImplementation([MClass])=="Case")]
			[MClass.name]_State_Machine.Take_[genEventName([ReceiveEvent])](acc_This
[      setDelim(", ")]
[      else]
			[accThisToTaskPt([MClass])]Take_[genEventName([ReceiveEvent])]
[      openList()]
[      end if]
[      if(hasLoop(ReceiveEvent->EvPara))]
[         loop(ReceiveEvent->EvPara)]
				[delim()][EvPara.name]	=> [deMarshall([EvPara], "S." genEventName([ReceiveEvent]) "_Arg." [EvPara.name])][setDelim(", ")]
[         end loop]
[      else]
[         loop(Instances->MOperation([ReceiveEvent:operationId]))]
[            loop(MOperation->OpPara)]
				[delim()][OpPara.name]	=> [deMarshall([OpPara], "S." genEventName([ReceiveEvent]) "_Arg." [OpPara.name])][setDelim(", ")]
[            end loop]
[         end loop]
[      end if]
				[closeList()];
[   end loop] 
		end case;
[   break]
[case "None" :]
[default :]
ERROR genSignalBody: unsupported stateMachineImplementation
[end switch]
	end Dispatch;

	function Image (S : Signal) return String is
[switch(stateMachineImplementation([MClass]))]
[case "Table":]
[   // we have no event parameters yet]
[   if([doCallStp])]
		StpCalls_St : constant String := Managed_Base_Classes.Stp_State_Id'image (StpCalls_Current_State (S.This.all));
		StpCalls_Inst : constant String := Managed_Base_Classes.Name (S.This.all'access);
		StpCalls_Inst_And_St : constant String := StpCalls_Inst & ":" & StpCalls_St(2 ..StpCalls_St'last);
[   else]
[      if([doRaven])]
		StpCalls_Inst_And_St : constant String := System.Address_Image_And_Value.Image (S.This.all'address);
[      else]
		StpCalls_Inst_And_St : constant String := System.Image (S.This.all'address);
[      end if]
[   end if]
	begin
		return "[MClass.name]::" & [MClass.name]_Event_Type'image (S.Event)
		   & " -> " & StpCalls_Inst_And_St;
[      break]
[case "Case":]
[case "Entry" :]
[case "Entry_Wait" :]
		acc_This : [getClassTypeForAssociation([MClass],"Local")] renames S.This;
[   if([doCallStp])]
		StpCalls_St : constant String := Managed_Base_Classes.Stp_State_Id'image (StpCalls_Current_State (S.This.all));
		StpCalls_Inst : constant String := Managed_Base_Classes.Name (S.This.all'access);
		StpCalls_Inst_And_St : constant String := StpCalls_Inst & ":" & StpCalls_St(2 ..StpCalls_St'last);
[   else]
[      if([doRaven])]
[insert("include","System.Address_Image_And_Value")]
		StpCalls_Inst_And_St : constant String := System.Address_Image_And_Value.Image (S.This.all'address);
[      else]
[insert("include","System")]
		StpCalls_Inst_And_St : constant String := System.Image (S.This.all'address);
[      end if]
[   end if]
	begin
		case S.Event is
[   loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")]
   		when [genEventName([ReceiveEvent])] =>
			return "[MClass.name]::[genEventName([ReceiveEvent])]"
[openList()]
[      if(hasLoop(ReceiveEvent->EvPara))]
[         loop(ReceiveEvent->EvPara)]
				& "[delim()][EvPara.name] => " & [callImage([EvPara.type],[MClass],deMarshall([EvPara], "S." genEventName([ReceiveEvent]) "_Arg." [EvPara.name]))]
				[setDelim(", ")]
[         end loop]
[      else]
[         loop(Instances->MOperation([ReceiveEvent:operationId]))]
[            loop(MOperation->OpPara)]
				& "[delim()][OpPara.name] => " & [callImage([OpPara.type],[MClass],deMarshall([OpPara], "S." genEventName([ReceiveEvent]) "_Arg." [OpPara.name]))]
				[setDelim(", ")]
[            end loop]
[         end loop]
[      end if]
				& "[closeList()] -> " & StpCalls_Inst_And_St;
[   end loop] 
		end case;
[   break]
[case "None" :]
[default :]
ERROR genSignalBody: unsupported stateMachineImplementation
[end switch]
	end Image;

[if([doRaven])]
	type Envelope (Event : [MClass.name]_Event_Type := [getFirstEvent([MClass])]) is
		record
			Used : Boolean := False;
			S : aliased Signal (Event);
		end record;

	My_Heap : array (1 .. 20) of Envelope;

	function Allocate (S : Signal) return Signals.Signal_Class_Ref is
		subtype The_Signal is Signal (S.Event);
	begin
		for I in My_Heap'range loop
			if not My_Heap(I).Used then
				My_Heap (I) := (Event => S.Event, Used => true, S => S);
		                return The_Signal (My_Heap (I).S)'access;
			end if;
		end loop;
		raise Storage_Error;
	end Allocate;
	
	procedure Free (S : access Signal) is
	begin
		for I in My_Heap'range loop
			if My_Heap(I).Used then
				declare
					subtype The_Signal is Signal (S.Event);
				begin
					if The_Signal (My_Heap (I).S)'access = S then
						My_Heap (I).Used := false;
						return;
 					end if;
				end;
			end if;
		end loop;
		raise Constraint_Error;
	end Free;
[end if]    

end [MClass:cuName].[MClass.name]_Signals;
end template

proc getFirstEvent(MClass)

   loop(MClass->ReceiveEvent where genEventName([ReceiveEvent]) != "__delay")
   	return genEventName([ReceiveEvent]);
   end loop
   return "??";
   
end proc

proc genMarshalledParameterType(MPara)

//T info = "genM " [MPara.name] " : " [MPara.type] "\n";

   if([MPara:marshallType] != "")
      return [MPara:marshallType];
   end if

   local typeString = [MPara.type];
   local result;
  
   [result] = replace([typeString]," *\*","");
   if([result] != [typeString])
//T info = "   -> *\n";
      // a pointer is fine for now
      [MPara:marshallType] = genParameterType([typeString]);
      [MPara:marshalling] = [MPara.name];
      return [MPara:marshallType];
   end if

   loop(Instances->MClass(MClass_ids_by_name ([typeString]))->MDataType->TaggedValue
	Where [TaggedValue.tag] == [language])
      // its a MDataType, go on with Ada name of it
//T info = "   -> MDataType\n";
      evaluateMarshallingOfTypeString([MPara],[TaggedValue.value]);
      return [MPara:marshallType];     
   end loop

   local typeSpec = lastWord([typeString]," "); // get rid of passing mode keywords
   local subString = [typeSpec];

   // is it already a class name ?
	
   loop(Instances->MClass(MClass_ids_by_name ([typeSpec])))
//T info = "   -> MClass\n";
      // use pointer for classes
      [MPara:marshallType] = getClassTypeForAssociation([MClass],"Local");
      [MPara:marshalling] = "new " importClass([MClass]) "'(" [MPara.name] ")";
      [MPara:deMarshallingPre] = "";
      [MPara:deMarshallingPost] = ".all";
      return [MPara:marshallType];
   end loop

   // is there a constraint ?
	
   [result] = stripConstraint([subString]);
   if([result] != [subString])
//T info = "   -> constrained of " [result] "\n";
      // constrained type is fine, take it
      [MPara:marshallType] = genParameterType([subString]);
      [MPara:marshalling] = [MPara.name];
      return [MPara:marshallType];
   end if

   // is there a _ptr or _cptr ?

   [result] = stripPointer([subString]);
   if([result] != [subString])
//T info = "   -> MClass pointer of " [result] "\n";
      // pointer type is fine, take it
      [MPara:marshallType] = genParameterType([subString]);
      [MPara:marshalling] = [MPara.name];
      return [MPara:marshallType];
   end if

   // lets see if it is "build in"

//T info = "   -> else:" [typeSpec] "\n";
   evaluateMarshallingOfTypeString([MPara],[typeSpec]);
   return [MPara:marshallType];     

end proc

proc evaluateMarshallingOfTypeString(MPara,typeString)

//T info = "eval " [typeString] "\n";

   if(toLower([typeString]) == "string")
      // we know that to be unconstrained: use a pointer here
      insert("marshalltypes","type M_" [MPara.name] " is access all string;\n");
      [MPara:marshallType] = "M_" [MPara.name];
      [MPara:marshalling] = "new "[typeString]"'("[MPara.name]")";
      [MPara:deMarshallingPre] = "";
      [MPara:deMarshallingPost] = ".all";
//T info = "found string\n";
      return;       
   end if

   // others to be added here

   // unknown, leave it alone
   [MPara:marshallType] = genParameterType([typeString]);
   [MPara:marshalling] = [MPara.name];
   return [MPara:marshallType];

end proc

proc deMarshall(MPara,expr)

   if([MPara:marshalling] == [MPara.name])
      return [expr];
   else
      return [MPara:deMarshallingPre] [expr] [MPara:deMarshallingPost];
   end if
   
end proc

proc marshallEvParaList(MEvent)

   local result = "";

   if(!hasLoop(MEvent->EvPara) && [MEvent:operationId] != "")
      // this is a call event without parameters. Use those of the operation, if any
      loop(Instances->MOperation([MEvent:operationId]))
         loop(MOperation->OpPara)
            [result] = [result] delim() [OpPara.name] " => " [OpPara:marshalling];
            setDelim(", ");
         end loop
      end loop
   end if

   loop(MEvent->EvPara)
      [result] = [result] delim() [EvPara.name] " => " [EvPara:marshalling];
      setDelim(", ");
   end loop

   return [result] closeList();

end proc

template genSignals()
package ACD_Runtime.Signals is
    
    type Priority_Type is (Normal, High, Sdbg);
    type Signal is abstract tagged private;
    
    procedure Send (S : Signal'class; Priority : Priority_Type := Normal) is abstract;
    
    function Image (S : Signal) return String is abstract;

[if([doRaven])]
    type Signal_Class_Ref is access all Signal'class;
    function Allocate (S : Signal) return Signal_Class_Ref is abstract;
    procedure Free (S : access Signal) is abstract;
[end if]    
    
private
    
    type Signal is abstract tagged null record;
   
end ACD_Runtime.Signals;
end template

template genQueuedSignalsSpec()
with ACD_Runtime.Signals;
package ACD_Runtime.Queued_Signals is

    package Signals renames ACD_Runtime.Signals;
    
    type Queued_Signal is abstract new Signals.Signal with private;
    
    procedure Send (S : Queued_Signal'class; Priority : Signals.Priority_Type := Signals.Normal);

    procedure Dispatch (S : Queued_Signal) is abstract;
    
    procedure Dispatch_Signals;

    function Image (S : Queued_Signal) return String is abstract;

[if([doRaven])]
    function Allocate (S : Queued_Signal) return Signals.Signal_Class_Ref is abstract;
    procedure Free (S : access Queued_Signal) is abstract;
[end if]    
    
private
    
    type Queued_Signal is abstract new Signals.Signal with null record;

end ACD_Runtime.Queued_Signals;
end template


template genQueuedSignalsBody()
with ACD_Runtime.Signal_Queue;
package body ACD_Runtime.Queued_Signals is
    
    procedure Send (S : Queued_Signal'class; Priority : Signals.Priority_Type := Signals.Normal) is
    begin
       ACD_Runtime.Signal_Queue.Enqueue (S, Priority);
    end Send;
    
    procedure Dispatch_Signals is
       S : Queued_Signal'class := Queued_Signal'class (Signal_Queue.Dequeue);
    begin
       Dispatch (S);
    end Dispatch_Signals;
        
end ACD_Runtime.Queued_Signals;
end template

template genSignalQueueSpec()
with ACD_Runtime.Signals;
package ACD_Runtime.Signal_Queue is

    package Signals renames ACD_Runtime.Signals;
    
    procedure Enqueue (S : Signals.Signal'class; Priority : Signals.Priority_Type);
    
    function Dequeue return Signals.Signal'class;

    function Image return String;

end ACD_Runtime.Signal_Queue;
end template

template genSignalQueueBody()
with Unchecked_Deallocation;
--T with Ada.Tags;
--T with Text_IO;
package body ACD_Runtime.Signal_Queue is

	Max_Pending_Normal : constant := 10;
	Max_Pending_High : constant := 5;
	Max_Pending_Sdbg : constant := 1;
	
	type Count_Type is range 0 .. Max_Pending_Normal + Max_Pending_High + Max_Pending_Sdbg;
	subtype Index_Type is Count_Type range 1 .. Count_Type'last;
[if([doRaven])]
	subtype Signal_Ptr is Signals.Signal_Class_Ref; use type Signals.Signal_Class_Ref;
[else]
	type Signal_Ptr is access all Signals.Signal'class;
[end if]
	type Signal_Array is array (Index_Type range <>) of Signal_Ptr; 
	subtype queue_image_string is string (1 .. 10_000);
	
	To_Be_Freed : Signal_Ptr;

	protected Queue is
[if([doRaven])]
		procedure Enqueue_Normal (S : Signal_Ptr);
		procedure Enqueue_High (S : Signal_Ptr);
		procedure Enqueue_Sdbg (S : Signal_Ptr);
[else]
		entry Enqueue_Normal (S : Signal_Ptr);
		entry Enqueue_High (S : Signal_Ptr);
		entry Enqueue_Sdbg (S : Signal_Ptr);
[end if]
		entry Dequeue (S : out Signal_Ptr);
		procedure Image (str : out queue_image_string; Last_Char : out positive);
	private
		Normal_Signals : Signal_Array (1 .. Max_Pending_Normal);  
		Normal_Read_Pos, 
		Normal_Write_Pos : Index_Type := Index_Type'first;
		Normal_Count : Count_Type := 0;
		
		High_Signals : Signal_Array (1 .. Max_Pending_High);  
		High_Read_Pos, 
		High_Write_Pos : Index_Type := Index_Type'first;
		High_Count : Count_Type := 0;
		
		Sdbg_Signals : Signal_Array (1 .. Max_Pending_Sdbg);  
		Sdbg_Read_Pos, 
		Sdbg_Write_Pos : Index_Type := Index_Type'first;
		Sdbg_Count : Count_Type := 0;
		
		Total_Count : Count_Type := 0;
	end Queue;
	
	procedure Enqueue (S : Signals.Signal'class; Priority : Signals.Priority_Type) is
[if([doRaven])]
		P : Signal_Ptr := Signals.Allocate (Signals.Signal'class'(S));
[else]
		P : Signal_Ptr := new Signals.Signal'class'(S);
[end if]
	begin
		case Priority is
		when Signals.Normal =>
		   Queue.Enqueue_Normal (P);
		when Signals.High =>
		   Queue.Enqueue_High (P);
		when Signals.Sdbg =>
		   Queue.Enqueue_Sdbg (P);
		end case;
	end Enqueue;
	
	function Dequeue return Signals.Signal'class is
[if([doRaven])]
[else]
	procedure Free is new Unchecked_Deallocation (Signals.Signal'class, Signal_Ptr);
[end if]
		Result_Ptr : Signal_Ptr;
	begin
		if To_Be_Freed /= null then
[if([doRaven])]
			signals.Free (To_Be_Freed); To_Be_Freed := null;
[else]
			Free (To_Be_Freed);
[end if]
		end if;
		Queue.Dequeue (Result_Ptr);
		To_Be_Freed := Result_Ptr;
		return Result_Ptr.all;
	end Dequeue;
	
	function Image return String is
		str : queue_image_string;
		lc : positive;
	begin
		Queue.Image(str, LC);
		return Str(1 .. LC);
	end Image;
	
	procedure Inc (POS : in out Index_Type; Last : Index_Type) is
	begin
		if POS = Last then
		   POS := Index_Type'first;
		else
		   POS := POS + 1;
		end if;
	end Inc;             
	
	protected body Queue is

[if([doRaven])]
		procedure Enqueue_Normal (S : Signal_Ptr) is
		begin
			if Normal_Count >= Max_Pending_Normal then
			   raise Program_Error;
			end if;
			--T text_io.put_line ("Enqueue_Normal " 
			--T       & ada.tags.external_tag (s.all'tag));
			Normal_Signals (Normal_Write_POS) := S;
			Inc (Normal_Write_POS, Max_Pending_Normal);
			Normal_Count := Normal_Count + 1;
			Total_Count := Total_Count + 1;
		end Enqueue_Normal;
		
		procedure Enqueue_High (S : Signal_Ptr) is
		begin
			if High_Count >= Max_Pending_High then
			   raise Program_Error;
			end if;
			--T text_io.put_line ("Enqueue_High " 
			--T       & ada.tags.external_tag (s.all'tag));
			High_Signals (High_Write_POS) := S;
			Inc (High_Write_POS, Max_Pending_High);
			High_Count := High_Count + 1;
			Total_Count := Total_Count + 1;
		end Enqueue_High;
		
		procedure Enqueue_Sdbg (S : Signal_Ptr) is
		begin
			if Sdbg_Count >= Max_Pending_Sdbg then
			   raise Program_Error;
			end if;
			--T text_io.put_line ("Enqueue_Sdbg " 
			--T       & ada.tags.external_tag (s.all'tag));
			Sdbg_Signals (Sdbg_Write_POS) := S;
			Inc (Sdbg_Write_POS, Max_Pending_Sdbg);
			Sdbg_Count := Sdbg_Count + 1;
			Total_Count := Total_Count + 1;
		end Enqueue_Sdbg;
[else]
		entry Enqueue_Normal (S : Signal_Ptr) when Normal_Count < Max_Pending_Normal is
		begin
			--T text_io.put_line ("Enqueue_Normal " 
			--T       & ada.tags.external_tag (s.all'tag));
			Normal_Signals (Normal_Write_POS) := S;
			Inc (Normal_Write_POS, Max_Pending_Normal);
			Normal_Count := Normal_Count + 1;
			Total_Count := Total_Count + 1;
		end Enqueue_Normal;
		
		entry Enqueue_High (S : Signal_Ptr) when High_Count < Max_Pending_High is
		begin
			--T text_io.put_line ("Enqueue_High " 
			--T       & ada.tags.external_tag (s.all'tag));
			High_Signals (High_Write_POS) := S;
			Inc (High_Write_POS, Max_Pending_High);
			High_Count := High_Count + 1;
			Total_Count := Total_Count + 1;
		end Enqueue_High;
		
		entry Enqueue_Sdbg (S : Signal_Ptr) when Sdbg_Count < Max_Pending_Sdbg is
		begin
			--T text_io.put_line ("Enqueue_Sdbg " 
			--T       & ada.tags.external_tag (s.all'tag));
			Sdbg_Signals (Sdbg_Write_POS) := S;
			Inc (Sdbg_Write_POS, Max_Pending_Sdbg);
			Sdbg_Count := Sdbg_Count + 1;
			Total_Count := Total_Count + 1;
		end Enqueue_Sdbg;
[end if]

		entry Dequeue (S : out Signal_Ptr) when Total_Count > 0 is
		begin
			if Sdbg_Count > 0 then
			   S := Sdbg_Signals (Sdbg_Read_POS);
			   --T text_io.put_line ("Dequeue_Sdbg " 
			   --T       & ada.tags.external_tag (s.all'tag));
			   Inc (Sdbg_Read_POS, Max_Pending_Sdbg);
			   Sdbg_Count := Sdbg_Count - 1;
			   Total_Count := Total_Count - 1;
			   return;
			end if;   
			if High_Count > 0 then
			   S := High_Signals (High_Read_POS);
			   --T text_io.put_line ("Dequeue_High " 
			   --T       & ada.tags.external_tag (s.all'tag));
			   Inc (High_Read_POS, Max_Pending_High);
			   High_Count := High_Count - 1;
			   Total_Count := Total_Count - 1;
			   return;
			end if;   
			if Normal_Count > 0 then
			   S := Normal_Signals (Normal_Read_POS);
			   --T text_io.put_line ("Dequeue_Normal " 
			   --T       & ada.tags.external_tag (s.all'tag));
			   Inc (Normal_Read_POS, Max_Pending_Normal);
			   Normal_Count := Normal_Count - 1;
			   Total_Count := Total_Count - 1;
			   return;
			end if;   
			raise Program_Error; 
		end Dequeue;
		
		procedure Image (str : out queue_image_string; Last_char : out positive) is
			Result : queue_image_string; POS : Positive := 1;
			
			procedure Add (Read_Pos : Index_Type; Count : Count_Type;
			               The_Signals : in out Signal_Array) is
			   RPos : Index_Type := Read_POS;
			
			   procedure Add (Item : String) is
			   begin
			      Result (POS .. POS + Item'length-1) := Item;
			      POS := POS + Item'length;
			   end Add;
			        
			begin
			   for I in 1 .. Count loop
			      Add (Signals.Image (The_Signals (RPos).all));
			      Result (POS) := ASCII.lf; POS := POS + 1;
			      Inc (RPos, The_Signals'last);
			   end loop;   
			end Add;
			
		begin
			Add (Sdbg_Read_Pos, Sdbg_Count, Sdbg_Signals);
			Add (High_Read_Pos, High_Count, High_Signals);
			Add (Normal_Read_Pos, Normal_Count, Normal_Signals);
			str := Result;
			Last_char := Pos - 1;
		end Image;
	
	end Queue;

end ACD_Runtime.Signal_Queue;
end template

template genHandleStateError(MClass,instanceExpr,stateExpr,stateId,eventExpr,eventId)
[if([doCallStp] == TRUE)]
[insert("include", "Stp_Calls")]
[   if([stateId] != "")]
[      loop(Instances->MState([stateId]))]
Stp_Calls.State_Debugger.Enter([stateId], [MClass.id], [instanceExpr], 
	Stp_Calls.At_Unhandled_Event, [MClass.name]_Event_Type'image ([eventExpr]), 
	"[MClass.name]: illegal event "
	& [MClass.name]_Event_Type'image ([eventExpr]) 
	& " in state [genStateName([MState])]");
[      end loop]
[   else if([eventId] != "")]
[      loop(Instances->MEvent([eventId]))]
Stp_Calls.State_Debugger.Enter([MClass.name]_State_Machine.stateId([stateExpr]), [MClass.id], [instanceExpr], 
	Stp_Calls.At_Unhandled_Event, "[genEventName([MEvent])]", 
	"[MClass.name]: illegal event [genEventName([MEvent])] in state "
	& [MClass.name]_State_Machine.State_Type'image ([stateExpr]));
[      end loop]
[   else]
Stp_Calls.State_Debugger.Enter([MClass.name]_State_Machine.stateId([stateExpr]), [MClass.id], [instanceExpr], 
	Stp_Calls.At_Unhandled_Event, [MClass.name]_Event_Type'image ([eventExpr]), 
	"[MClass.name]: illegal event "
	& [MClass.name]_Event_Type'image ([eventExpr]) & " in state "
	& [MClass.name]_State_Machine.State_Type'image ([stateExpr]));
[   end if end if]
[else if([doRaven] != TRUE)]
[insert("include", "Text_IO")]
[   if([stateId] != "")]
[      loop(Instances->MState([stateId]))]
Text_IO.Put_Line ("[MClass.name]: illegal event "
	& [MClass.name]_Event_Type'image ([eventExpr]) 
	& " in state [genStateName([MState])]");
[      end loop]
[   else if([eventId] != "")]
[      loop(Instances->MEvent([eventId]))]
Text_IO.Put_Line ("[MClass.name]: illegal event [genEventName([MEvent])] in state "
	& [MClass.name]_State_Machine.State_Type'image ([stateExpr]));
[      end loop]
[   else]
Text_IO.Put_Line ("[MClass.name]: illegal event "
	& [MClass.name]_Event_Type'image ([eventExpr]) & " in state "
	& [MClass.name]_State_Machine.State_Type'image ([stateExpr]));
[   end if end if]
[else]
[insert("include", "System.System_Interface.Simple_Io")]
[   if([stateId] != "")]
[      loop(Instances->MState([stateId]))]
System.System_Interface.Simple_Io.Put_Line ("[MClass.name]: illegal event "
	& [MClass.name]_Event_Type'image ([eventExpr]) 
	& " in state [genStateName([MState])]");
[      end loop]
[   else if([eventId] != "")]
[      loop(Instances->MEvent([eventId]))]
System.System_Interface.Simple_Io.Put_Line ("[MClass.name]: illegal event [genEventName([MEvent])] in state "
	& [MClass.name]_State_Machine.State_Type'image ([stateExpr]));
[      end loop]
[   else]
System.System_Interface.Simple_Io.Put_Line ("[MClass.name]: illegal event "
	& [MClass.name]_Event_Type'image ([eventExpr]) & " in state "
	& [MClass.name]_State_Machine.State_Type'image ([stateExpr]));
[   end if end if]
[end if end if]
end template

template genHandleStateAssign(MClass,stateId,stateExpr,instanceExpr,eventName)
[if([doCallStp] == TRUE)]
[insert("include", "Stp_Calls")]
[   if([stateId] == "")]
Stp_Calls.State_Debugger.Enter([MClass.name]_State_Machine.stateId ([stateExpr]), [MClass.id], [instanceExpr], Stp_Calls.At_Enter_History, "[eventName]", "Entering state from history");
[   else]
[      loop(Instances->MState([stateId]))]
Stp_Calls.State_Debugger.Enter([MState.id], [MClass.id], [instanceExpr], Stp_Calls.At_Enter_State, "[eventName]", "Entering state [genStateName([MState])]");
[      end loop]
[   end if]
[end if]
end template

template genHandleSMCreate(MClass,stateId,instanceExpr,eventName)
[if([doCallStp] == TRUE)]
[insert("include", "Stp_Calls")]
Stp_Calls.State_Debugger.Enter([stateId], [MClass.id], [instanceExpr], Stp_Calls.At_Initialize_SM, "[eventName]", "");
[end if]
end template

template genHandleSMDestroy(MClass,stateId,instanceExpr,eventName)
[if([doCallStp] == TRUE)]
[insert("include", "Stp_Calls")]
Stp_Calls.State_Debugger.Enter([stateId], [MClass.id], [instanceExpr], Stp_Calls.At_Finalize_SM, "[eventName]", "");
[end if]
end template

template genOperationBodyCallSM(MOperation,MClass)
[if(isFunction([MOperation]))]
function [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] return [genResultType([MOperation.returnType])] is
	Result : [genResultType([MOperation.returnType])];
begin
[   switch(stateMachineImplementation([MClass]))]
[   case "Entry" :]
[   case "Entry_Wait" :]
	[accThisToTaskPt([MClass])]Take_[MOperation.name]_Event[openList()][useOpParaList([MOperation],FALSE)];
	return Result;
[      break]
[   case "Case" :]
[      if(isTask([MClass]) || isPT([MClass]))]
	[accThisToTaskPt([MClass])]Take_[MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
[      else]
	[MClass.name]_State_Machine.Take_[MOperation.name][openList()][useOpParaList([MOperation],TRUE)];
[      end if]
	return Result;
[      break]
[   case "Table" :]
[      if(isTask([MClass]) || isPT([MClass]))]
	[accThisToTaskPt([MClass])]Take_Event ([MClass.name]_Event_Type'([MOperation.name]_Event)[setDelim(", ")][useOpParaList([MOperation],FALSE)];
	return Result;
[      else]
	return Take_Event (acc_this, [MClass.name]_Event_Type'([MOperation.name]_Event)[setDelim(", ")][useOpParaList([MOperation],FALSE)];
[      end if]
[      break]
[   default :]
ERROR genOperationBodyCallSM: unsupported stateMachineImplementation(1)
[   end switch]
end [MOperation.name];
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
function Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()] return [genResultType([MOperation.returnType])] is
	Result : [genResultType([MOperation.returnType])];
begin
	select
		[accThisToTaskPt([MClass])]Take_[MOperation.name]_Event[openList()][useOpParaList([MOperation],FALSE)];
		Timed_Out.all := False;
	or delay Timeout;
		Timed_Out.all := True;
	end select;
	return Result;
end Timed_[MOperation.name];
[   end if]
[else] 
procedure [MOperation.name][genOpParaList([MOperation],TRUE)][closeList()] is
begin
[   switch(stateMachineImplementation([MClass]))]
[   case "Entry" :]
[   case "Entry_Wait" :]
	[accThisToTaskPt([MClass])]Take_[MOperation.name]_Event[openList()][useOpParaList([MOperation],FALSE)];
[      break]
[   case "Case" :]
[      if(isTask([MClass]) || isPT([MClass]))]
	[accThisToTaskPt([MClass])]Take_[MOperation.name][openList()][useOpParaList([MOperation],FALSE)];
[      else]
	[MClass.name]_State_Machine.Take_[MOperation.name][openList()][useOpParaList([MOperation],TRUE)];
[      end if]
[      break]
[   case "Table" :]
[   if(isTask([MClass]) || isPT([MClass]))]
	[accThisToTaskPt([MClass])]Take_Event ([MClass.name]_Event_Type'([MOperation.name]_Event)[setDelim(", ")][useOpParaList([MOperation],FALSE)];
[   else]
	Take_Event (acc_this, [MClass.name]_Event_Type'([MOperation.name]_Event)[setDelim(", ")][useOpParaList([MOperation],FALSE)];
[   end if]
[      break]
[   default :]
ERROR genOperationBodyCallSM: unsupported stateMachineImplementation(2)
[   end switch]
end [MOperation.name];
[   if (isTimedEntry([MOperation],[MClass]))]
-- Timed_Call_Supported:
procedure Timed_[MOperation.name][genOpParaList([MOperation],TRUE)][genTimeoutDecl([MOperation])][closeList()] is
begin
	select
		[accThisToTaskPt([MClass])]Take_[MOperation.name]_Event[openList()][useOpParaList([MOperation],FALSE)];
		Timed_Out := False;
	or delay Timeout;
		Timed_Out := True;
[genInitOpParaList("\t\t\t",[MOperation])]
	end select;
end Timed_[MOperation.name];
[   end if]
[end if]
end template

// Assign a default for out parameters in case they are no assigned useful values.
// This is required because of the constraint checking for out parameters.
proc genInitOpParaList(indent,MOperation)
   local result = "";
   loop(MOperation->OpPara)
      if (toLower([OpPara.mechanism]) == "out")
         local def = genOpParaDefault([OpPara.type]);
         if ([def] != "_none")
         [result] = [result] [indent] [OpPara.name] " := " [def] ";\n";
         end if
      end if
   end loop
   return [result];
end proc

// Utility to obtain the default for an out parameter, given its type.
proc genOpParaDefault(type)
   local tcap = genParameterType([type]);
   local t = toLower([tcap]);
   local tcache = "genOpParaDefault_cache_"[t];
   if ([[tcache]] == "")
      if (regexp([t],"_scptr$") != "")
         [[tcache]] = "_none";
      else if (regexp([t],"_ptr$|_cptr$") != "")
         [[tcache]] = "null";
      else
         switch([t])
         case "boolean":
         case "integer":
         case "natural":
         case "positive":
            [[tcache]] = [tcap]"'last";
            break;
         default:
            [[tcache]] = [tcap]"_Default_Value";
         end switch
      end if end if
   end if
   return [[tcache]];
end proc


template elaborateActiveClass(MClass)
[if([doCallStp] == TRUE)]
[   if(isActiveClassInstance([MClass]))]
[insert("include","Managed_Base_Classes")]
Managed_Base_Classes.Class_Manager.Register (StpCalls_[MClass.name]_Rep'access, [MClass.id], StpCalls_[MClass.name]_Name'access, [MClass.name]'tag);
[   end if]
[end if]
end template

template genStpCallsPrivateDecls(MClass)
[if([doCallStp] == TRUE)]
[insert("include","Managed_Base_Classes")]
function StpCalls_Class_Name (AI : access [MClass.name]) return String;
	[genInlinePragma("StpCalls_Class_Name")]
function StpCalls_Class_Id (AI : access [MClass.name]) return Managed_Base_Classes.Class_Manager.Stp_Class_Id; 
	[genInlinePragma("StpCalls_Class_Id")]
function StpCalls_Get_Instances (AI : access [MClass.name]) return Managed_Base_Classes.Class_Manager.Instance_List_Ref;
	[genInlinePragma("StpCalls_Get_Instances")]
[   if(isActiveClass([MClass]))]
function StpCalls_Current_State (AI : [MClass.name]) return Managed_Base_Classes.Stp_State_Id;
	[genInlinePragma("StpCalls_Current_State")]
[   end if]
function StpCalls_Trigger_Event(AI : access [MClass.name]; Event : String) return String;
	[genInlinePragma("StpCalls_Trigger_Event")]
function Image (AI : access [MClass.name]) return String;
[end if]
end template

template genStpCallsBodyDecls(MClass)
[if([doCallStp] == TRUE)]
StpCalls_[MClass.name]_Rep : aliased Managed_Base_Classes.Class_Manager.Managed_Class_Rep (Is_Limited_Class => [isLimited([MClass])]);
StpCalls_[MClass.name]_Name : aliased constant string := "[MClass.name]";

function StpCalls_Class_Name (AI : access [MClass.name]) return String is
begin
   return StpCalls_[MClass.name]_Name;
end StpCalls_Class_Name;

function StpCalls_Class_Id (AI : access [MClass.name]) return Managed_Base_Classes.Class_Manager.Stp_Class_Id is 
begin
   return [MClass.id];
end StpCalls_Class_Id;

function StpCalls_Get_Instances (AI : access [MClass.name]) return Managed_Base_Classes.Class_Manager.Instance_List_Ref is
begin
   Managed_Base_Classes.StpCalls_Connect (AI, StpCalls_[MClass.name]_Rep'access);
   return Managed_Base_Classes.Class_Manager.Get_Instances (StpCalls_[MClass.name]_Rep'access);
end StpCalls_Get_Instances;

[   if(isActiveClass([MClass]))]
function StpCalls_Current_State (AI : [MClass.name]) return Managed_Base_Classes.Stp_State_Id is
begin
   return [MClass.name]_State_Machine.stateId (AI.currentState);
end StpCalls_Current_State;
[   end if]

function StpCalls_Trigger_Event(AI : access [MClass.name]; Event : String) return String is
	acc_This : [getClassParamForUpdate([MClass])] := [getClassParamForUpdate([MClass])] (AI);
	use [MClass.name]_State_Machine;
begin
[insert("include",[MClass:cuName] "." [MClass.name]"_Signals")]
[insert("include","ACD_Runtime.Signals")]
[loop(MClass->ReceiveEvent;setDelim("");setDelim("els"))]
	[delim()]if Event = "[ReceiveEvent.name]" then
		[MClass.name]_Signals.Send_[genEventName([ReceiveEvent])](acc_This, Priority => ACD_Runtime.Signals.Sdbg);
		return "";
[end loop] 
	else
		return "Could not send unknown event " & Event & " to " & Managed_Base_Classes.Name(AI);
	end if;
end StpCalls_Trigger_Event;

function Image (AI : access [MClass.name]) return String is
	Dots : constant string := "...";
	[mark("imagedecls"[MClass.name],"")]
begin
[insert("include","System")]
   return "[MClass.name]'" 
[   if(hasLoop(MClass->SuperClass))]
[   loop(MClass->SuperClass)]
	& "(" & [importClassOp([SuperClass],"Image")]([importClass([SuperClass])](AI)) & " with ("
[   end loop]   
[   else]
[      if([doRaven])]
[insert("include","System.Address_Image_And_Value")]
	& System.Address_Image_And_Value.Image (AI'address) & "("
[      else]
	& System.Image (AI'address) & "("
[      end if]
[   end if]
[setDelim("")]
[   loop(MClass->MAttribute where [MAttribute].isStatic() == FALSE && inherited([MAttribute],[MClass]) == FALSE)]
	& "[delim()][MAttribute.name] => " & [callImage([MAttribute.type],[MClass],"AI."[MAttribute.name])]
[setDelim(", ")]
[   end loop]
[   loop(MClass->Role As FromRole->MAssociation->MAssociationEnd As ToRole->MClass As Partner Where [FromRole.id] != [ToRole.id] && [ToRole:adaName]!="")]
	& "[delim()][ToRole.name] => " & [callImageRole([ToRole],[Partner],[MClass],"AI."[ToRole:adaName])]
[setDelim(", ")]
[   end loop]
	& ")";
end Image;
[end if]
end template

proc callImage(typeName,MClass,valueExpr)

   local ct = genComponentType([typeName]);

   switch(toLower([ct]))
   case "integer":
   case "boolean":
	return [ct] "'image(" [valueExpr] ")";
   case "string":
	return [valueExpr];
   default:
	break;
   end switch

   return "Dots"; //TBD	

end proc

proc callImageRole(MAssociationEnd As ToRole,MClass As Partner,MClass,valueExpr)

   local multiplicity = getMultiplicity([ToRole.multiplicity]);
   
   switch([multiplicity])
   case "Many" :
      insert("imagedecls"[MClass.name],genImageRolePtr([MClass],[Partner],[ToRole]));
      return [ToRole:ptrTypeName] "Image (" [valueExpr] ")";
   case "One"	:
      return callClassImage([valueExpr],[Partner],[MClass.name],[ToRole:isPointer]);
   default 	:
      insert("imagedecls"[MClass.name],genImageRoleArray([MClass],[Partner],[ToRole]));
      return [ToRole:arrayTypeName] "Image (" [valueExpr] ")";
   end switch
   
end proc

template genImageRolePtr(MClass, MClass as Partner, MAssociationEnd As ToRole)
[insert("imagedecls"[MClass.name],genImageRoleArray([MClass],[Partner],[ToRole]))]
function [ToRole:ptrTypeName]Image(Ptr : [ToRole:ptrTypeName]) return String is
begin
	if Ptr = NULL then
		return "{}";
	else
		return [ToRole:arrayTypeName]Image(Ptr.all);
	end if;
end [ToRole:ptrTypeName]Image;
end template

template genImageRoleArray(MClass, MClass as Partner, MAssociationEnd As ToRole)
function [ToRole:arrayTypeName]Image(Arr : [ToRole:arrayTypeName]) return String is
	Result : String (1 .. 10240); Pos : Natural := 1;
	procedure Add (Item : String) is
	begin
		Result (Pos .. Pos + Item'length-1) := Item;
		Pos := Pos + 1;
	end Add;
begin
	if Ptr = NULL then
		return "{}";
	else
		Add ("{");
		for I in Arr'range loop
			if I > Arr'first then
				Add (", ");
			end if;
			if I > Arr'first + 10 then
				Add ("..."); exit;
			end if;
			return [callClassImage("Arr(I)",[Partner],[MClass.name],[ToRole:isPointer])];
		end loop;
		Add ("}");		
	end if;
end [ToRole:arrayTypeName]Image;
end template

template callClassImage(valueExpr,MClass,tag,isPointer)
[if(isActiveClassInstance([MClass]))]
Managed_Base_Classes.Name([valueExpr]
[   if([isPointer] == FALSE)]
'access
[   end if]
)
[else]
"[MClass.name]'(" & 
[   if([doRaven])]
[insert("include","System.Address_Image_And_Value")]
System.Address_Image_And_Value.Image (
[   else]
System.Image (
[   end if]
[   if([isPointer] == FALSE)]
[valueExpr]'address
[   else]
[insert("include","Unchecked_Conversion")]
[insert("imagedecls"[tag],genUcAddress([MClass],[tag]))]
ucAddress([valueExpr])
[   end if]
) & ")"
[end if]
end template

template genUcAddress(MClass,tag)
function ucAddress is new Unchecked_Conversion([getClassTypeForAssociation([MClass],[tag])],System.Address);
end template