//*****************************************************************************
// $RCSfile: ada_genattr.tdl,v $
// $Revision: 1.3 $
// $Date: 2002/03/08 16:03:54 $
// Author: Peter Kleiner
//*****************************************************************************

// wdh 00/11/13 suppress attribute bodies for visibility="implementation"

/*
Support templates and procedures dealing with attributes.
called by genSpec (defined in ada_genspec.tdl) and genBody (defined in ada_genbody.tdl).

templates/procs called in genSpec. The order follows the occurence in genSpec

9.3.4.1. genAttributeComponents
	Generate a single component for an instance of MAttribute
12. genClassWideAttributes
	Generate an object declaration for all attributes which have a static binding
	and a visibility as indicated by the second parameter, i.e.
	public: public part of package specification
	private: private part of package specification
	implementation: package body	
12.1. genAttributeDeclaration
	Generate object or component declaration for an instance of MAttribute
12.1.1. [MAttribute].genDefault
	generate the default value assignment for an attribute, if any
12.1.2. genAliased
	Generate "aliased" if specified by modeller
14a. genAttributeOperationSpecs
	generate a get/set method for each attribute depending on its visibility
	specified in the model and the place of generation indicated by the
	second parameter:
	public:
	   generate get for attributes with vis. public, public-read-only, public-operation
	   generate set for attributes with vis. public, public-operation
	public-child:
	   generate get for attributes with vis. public-child, public-child-read-only, public-child-operation
	   generate set for attributes with vis. public-child, public-child-operation
	private:
	   generate get for attributes with vis. private, private-read-only, private-operation
	   generate set for attributes with vis. private, private-operation
	private-child:
	   generate get for attributes with vis. private-child, private-child-read-only, private-operation-child
	   generate set for attributes with vis. private-child, private-child-operation
14b. genAttributeOperationSpecsPT
		generate get function for attributes with vis. != implementation
		generate set procedure for attributes with vis. != implementation
14c. genAttributeOperationSpecsTask
		generate get entry for attributes with vis. != implementation
		generate set entry for attributes with vis. != implementation

templates/procs called in genBody. The order follows the occurence in genBody
	
21a. genAttributeOperationBodies
	generate a get/set method body for each attribute depending on its visibility
	specified in the model and the place of generation indicated by the
	second parameter:
	implementation:
		generate get/set for attribute vis. other than *-child* or implementation
	public-child
		generate get/set for attribute vis. public-child, public-child-read-only, public-child-operation
	private-child
		generate get/set for attribute vis. private-child, private-child-read-only, private-child-operation
21b. genAttributeOperationBodiesPT
	generate get entry for attributes with vis. != implementation
	generate set entry for attributes with vis. != implementation
21c. genAttributeOperationBodiesTask
	generate get entry for attributes with vis. != implementation
	generate set entry for attributes with vis. != implementation

*/

/* 9.3.4.1. generate a component for each non static attribute.
   See 12.1. for genAttributeDeclaration */
template genAttributeComponents(MClass)
[loop(MClass->MAttribute where [MAttribute].isStatic() == FALSE && isDiscriminant([MAttribute]) == FALSE && inherited([MAttribute],[MClass]) == FALSE;setText(genSectionComment("Attributes")))]
[getText()]
[genAttributeDeclaration([MAttribute])]
[end loop]
end template



/* 12. generate attributes with binding "static" and visibility [place] (public, private, or
   implementation) */
template genClassWideAttributes1(MClass,place)
[loop(MClass->MAttribute where [MAttribute].isStatic() == TRUE && isDiscriminant([MAttribute]) == FALSE && getClass([MAttribute.type]) != [MClass.id] && classPrivacyMatch(getClassPrivacy([MClass]),[place]);setText(""genSectionComment("Attributes")))]
[getText()]
[genAttributeDeclaration([MAttribute])]
[end loop]
end template

template genClassWideAttributes2(MClass,place)
[loop(MClass->MAttribute where [MAttribute].isStatic() == TRUE && isDiscriminant([MAttribute]) == FALSE && getClass([MAttribute.type]) == [MClass.id] && classPrivacyMatch(getClassPrivacy([MClass]),[place]);setText(""genSectionComment("Attributes")))]
[getText()]
[genAttributeDeclaration([MAttribute])]
[end loop]
end template

/* 12.1. generate declaration for the given instance of MAttribute. genComponentType
   generates an Ada subtype indication for the type specification given in the model
   (defined in ada_std.tdl) */
template genAttributeDeclaration(MAttribute)
[MAttribute.name] : [genAliased([MAttribute])][genComponentType([MAttribute.type])][[MAttribute].genDefault()];
end template

/* 12.1.1. add default value to attribute declaration, if any */
template MAttribute.genDefault()
[if([MAttribute.defaultValue] != "")]
 := [genExpression([MAttribute.defaultValue])]
[end if]
end template

/* 12.1.2. generate "aliased", if specified */
proc genAliased(MAttribute)

   if (isAliased([MAttribute]))
      return "aliased";
   else
      return "";
   end if

end proc

/* 14a. generate set/get operations for attributes with [place] visibility. stripConstraint
   (defined in ada_std.tdl) removes a constraint from the attribute type, if any
   this is always called in the package specification or body, even for MClass being
   a task or protected type */
template genAttributeOperationSpecs(MClass,place)
[loop(MClass->MAttribute where visibilityMatch([MAttribute].visibility(), [place]);setText(""genSectionComment("Attribute operations")))]
[getText()]
function get[MAttribute.name](this : [getClassParamForRead([MClass])]) return [genResultType(stripConstraint([MAttribute.type]))][genRename([MClass],"get"[MAttribute.name])];
	[genInlinePragma("get"[MAttribute.name])]
[   if(regexp([MAttribute].visibility(),"read-only") == "" && isDiscriminant([MAttribute]) == FALSE)]
[bodyIsRequired()]
procedure set[MAttribute.name](acc_this : [getClassParamForUpdate([MClass])]; value : [genResultType(stripConstraint([MAttribute.type]))])[genRename([MClass],"set"[MAttribute.name])];
	[genInlinePragma("set"[MAttribute.name])]
[   end if]
[end loop]
end template

/* 14b. generate set/get operations for attributes in the protected type declaration.*/
template genAttributeOperationSpecsPT(MClass)
[loop(MClass->MAttribute where [MAttribute].visibility() != "implementation";setText(""genSectionComment("Attribute operations")))]
[getText()]
function get[MAttribute.name] return [genResultType(stripConstraint([MAttribute.type]))];
[   if(!isDiscriminant([MAttribute]))]
procedure set[MAttribute.name](value : [genResultType(stripConstraint([MAttribute.type]))]);
[   end if]
[end loop]
end template

/* 14c. generate set/get operations for attributes in the task type declaration.*/
template genAttributeOperationSpecsTask(MClass)
[loop(MClass->MAttribute where [MAttribute].visibility() != "implementation";setText(""genSectionComment("Attribute operations")))]
[getText()]
entry get[MAttribute.name](value : out [genParameterType(stripConstraint([MAttribute.type]))]);
[   if(!isDiscriminant([MAttribute]))]
entry set[MAttribute.name](value : [genResultType(stripConstraint([MAttribute.type]))]);
[   end if]
[end loop]
end template

/* 21a. generate body for the set/get operation generated for the attributes of MClass
        this is called in the package body, even for a task or PT */
template genAttributeOperationBodies(MClass,place)
[loop(MClass->MAttribute where visibilityMatchBody([MAttribute].visibility(), [place]);setText(""genSectionComment("Attribute operations")))]
[getText()]
function get[MAttribute.name](this : [getClassParamForRead([MClass])]) return [genResultType(stripConstraint([MAttribute.type]))] is
[   if(isTask([MClass]) && !isTagged([MClass]))]
	Result : [genResultObjectType([MAttribute.type])];
begin
	[thisToTaskPt([MClass])]get[MAttribute.name](Result);
	return Result;
[   else if(isPT([MClass]))]
begin
	return [thisToTaskPt([MClass])]get[MAttribute.name];
[   else]
begin
	return this.[MAttribute.name];
[   end if end if]
end get[MAttribute.name];

[   if(!isDiscriminant([MAttribute]))]
procedure set[MAttribute.name](acc_this : [getClassParamForUpdate([MClass])]; value : [genResultType(stripConstraint([MAttribute.type]))]) is
begin
[      if((isTask([MClass]) && !isTagged([MClass])) || isPT([MClass]))]
	[accThisToTaskPt([MClass])]set[MAttribute.name](value);
[      else]
	acc_this.[MAttribute.name] := value;
[      end if]
end set[MAttribute.name];

[   end if]
[end loop]
end template

/* 21b. generate body for the set/get operation generated for the attributes of MClass
        this is called in the protected type body */
template genAttributeOperationBodiesPT(MClass)
[loop(MClass->MAttribute where [MAttribute].visibility() != "implementation";setText(""genSectionComment("Attribute operations")))]
[getText()]

function get[MAttribute.name] return [genResultType(stripConstraint([MAttribute.type]))] is
begin
   return [accThisToAttr([MClass])].[MAttribute.name];
end get[MAttribute.name];
[   if(!isDiscriminant([MAttribute]))]

procedure set[MAttribute.name](value : [genResultType(stripConstraint([MAttribute.type]))]) is
begin
   [accThisToAttr([MClass])].[MAttribute.name] := value;
end set[MAttribute.name];
[   end if]
[end loop]
end template

/* 21c. generate body for the set/get operation generated for the attributes of MClass
        this is called in the task type body */
template genAttributeOperationBodiesTask(MClass)
[loop(MClass->MAttribute where [MAttribute].visibility() != "implementation";setText(""genSectionComment("Attribute operations")))]
[selectAlternative(
	genAttributeGetBodyTask([MAttribute],[MClass]))]
[   if(!isDiscriminant([MAttribute]))]
[selectAlternative(
	genAttributeSetBodyTask([MAttribute],[MClass]))]
[   end if]
[end loop]
end template

template genAttributeGetBodyTask(MAttribute,MClass)
accept get[MAttribute.name](value : out [genParameterType(stripConstraint([MAttribute.type]))]) do
	value := [accThisToAttr([MClass])].[MAttribute.name];
end get[MAttribute.name];
end template

template genAttributeSetBodyTask(MAttribute,MClass)
accept set[MAttribute.name](value : [genResultType(stripConstraint([MAttribute.type]))]) do
	[accThisToAttr([MClass])].[MAttribute.name] := value;
end set[MAttribute.name];
end template

