external string UseCases;

#include "qrl/tsdl_extract.inc"
#include "qrl/basic_textract_dt.inc"
#include "qrl/include/error.inc"

#include "val/qrl/include/TConfig.inc"
#include "val/qrl/include/TUseCase.inc"
#include "val/qrl/include/val_string_globals.inc"
#include "val/qrl/include/CreateDir.inc"


  string OUTPUTPATH = current_projdir() + current_system() + "/test_files/";
  string OUTPUTDIR;
  string FILETEXT;

  set DataItemsDataTypes;


void 
main ()
{
  list UseCaseList, ScenarioList;
  int count1, i;
  int count2, j;
  string use_case_name, test_unit_id, scenario_name;
  node scenario;
  int scenario_id;
  set DataTypes;

  DataItemsDataTypes = set_create ("string");

  UseCaseList = string_to_list (UseCases, " ");

  count1 = list_count (UseCaseList);

  for (i=0;i<count1;i=i+1)
    {
      set_clear(DataItemsDataTypes);

      use_case_name = list_get(UseCaseList,i);

      ScenarioList = GetScenarioList(use_case_name);
      count2 = list_count (ScenarioList);
      for (j=0;j<count2;j=j+1)
        {
          scenario = list_get(ScenarioList,j);
          scenario_name = scenario.name;
          scenario_id = scenario.id;
          message ("  " + scenario_name );
          test_unit_id = Get_T_test_unit_id(use_case_name, scenario_name);

          OUTPUTDIR = OUTPUTPATH + test_unit_id;
          message (OUTPUTDIR); 

          Build_SPacket_Statement(scenario_name, test_unit_id);
          Build_Include_File_Reference();

          Build_Action_Statements(scenario_name, scenario_id);
          DataTypes = Build_Dataitem_Statements(DataItemsDataTypes);
          Build_Datatype_Statements(DataTypes);
          Build_Footer();
          WriteFileText (OUTPUTDIR, FILETEXT);
//          message ( FILETEXT);
          FILETEXT = "";
        }
    }

}


void
Build_SPacket_Statement(string scenario_name, string TestUnitID)
{
  FILETEXT =  ("S_packet " + TestUnitID + ";\n");
  FILETEXT = FILETEXT + "  has subject \"" +
     Get_T_SPacketSubject (scenario_name, "OMTScenarioName") + "\";\n";
  FILETEXT = FILETEXT + "  has description \"" + 
     Get_T_SPacketDescription (scenario_name, "OMTScenarioName") + "\";\n.\n\n";
}

void
Build_Include_File_Reference()
{
  FILETEXT = FILETEXT +  Get_Include_File_Reference();
}

void
Build_Action_Statements( string scenario_name, 
               int scenario_id)
{
  list EventList;
  int event_id, i,count;
  string eventname, fromclass, toclass, actionname;
  link_ref linkrefvar;

  EventList = GetEventList(scenario_id);

  count = list_count(EventList);

  for (i=0; i<count; i=i+1)
    {
       linkrefvar = list_get(EventList, i);
       eventname = GetEventName(linkrefvar.link_id);
       event_id = GetEventID(linkrefvar.link_id);
       fromclass = GetClassName(linkrefvar.from_node_ref_id);
       toclass = GetClassName(linkrefvar.to_node_ref_id);
       actionname = fromclass + "__" + eventname + "__" + toclass;
       
       print_action_header ( actionname);

       print_acts_only_if(eventname);
       print_satisfies(event_id);
       print_is_selected_by(event_id);
       print_is_concluded_on(event_id);

       print_uses_data (event_id, eventname);
       print_produces_data (event_id);

       print_is_tested_exhaustively (event_id);

       print_end_action();

       set_add (DataItemsDataTypes, eventname + SEPARATOR + "event_type");
       DataItemsDataTypes = Build_Dataitem_Set(DataItemsDataTypes,
                            event_id );
    }
}


list
GetEventList( int scenario_id)
{

  string query = "link_ref [
           link [ OMTEventInstance && scope_node_id == ${scenario_id} ] 
           ] sort by ycoord";

  return ( list_select (query) );

}


int
check_existence( string use_case_name, string scenario_name )
{
  string query;
  node nodevar;

  query = "node[OMTScenarioName && node_refs && name == '${scenario_name}'
            && scope_node [ OMTUseCaseParent && name == '${use_case_name}']]";

  nodevar = find_by_query(query);

  if (nodevar == NULL)
     return (0);
  else
     return (nodevar.id);

}

void
print_action_header(  string scenario_name )
{
  FILETEXT = FILETEXT +  ("Action " +  scenario_name + "\n");

  FILETEXT = FILETEXT +  ("   is actiontype internal;\n\n" );

}

void
print_acts_only_if ( string eventname )
{
  FILETEXT = FILETEXT +  ("   acts only if\n");
  FILETEXT = FILETEXT +  ("     (" + eventname + " == did_occur");
  FILETEXT = FILETEXT + (");\n\n");
    
}

void
print_satisfies ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TSatisfies && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  satisfies\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}

void
print_is_selected_by ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TIsSelectedBy && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  is selected by\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}



void
print_is_concluded_on ( int scenario_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q = "item [TIsConcludedOn && obj_id == ${scenario_id}]";

  itemvar = find_by_query(q);

  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  is concluded on\n");
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (";\n\n");
    }
}




void
print_is_tested_exhaustively ( int scenario_id )
{
  int i,count;
  note notevar;
  list TItem;
  item itemvar;

  string q1 = "note [TestAction && obj_id == ${scenario_id} &&
       items [TExhaustive ]]";
  string q2 = "item [TExhaustive && note_id == ${notevar.id}]";

  notevar = find_by_query(q1);

  if (notevar != NULL)
    {
      TItem = list_select(q2);
      count = list_count(TItem);

      FILETEXT = FILETEXT +  ("   is tested exhaustively on dataitem\n");

      for (i=0; i<count; i=i+1)
        {
          itemvar = list_get(TItem, i);
          FILETEXT = FILETEXT +  ("     " + itemvar.value);
          if (i < count - 1)
            FILETEXT = FILETEXT + (",\n");
          else 
            FILETEXT = FILETEXT + (";\n\n");
        }
    }
}


void
print_uses_data ( int event_id, string eventname)
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q1 = "note [TestDataItem && obj_id == ${event_id} &&
       items [TUsed && value == 'True' ]]";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";

  TNote = list_select(q1);

  count = list_count(TNote);


  FILETEXT = FILETEXT +  ("   uses dataitem\n");

  for (i=0; i<count; i=i+1)
    {
      notevar = list_get(TNote, i);
      itemvar = find_by_query(q2);
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      FILETEXT = FILETEXT + (",\n");
    }

  FILETEXT = FILETEXT + "     " + eventname + (";\n\n");
}

void
print_produces_data ( int event_id )
{
  int i,count;
  note notevar;
  list TNote;
  item itemvar;

  string q1 = "note [TestDataItem && obj_id == ${event_id} &&
       items [TProduced && value == 'True' ]]";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";

  TNote = list_select(q1);

  count = list_count(TNote);

  if (count == 0)
     return;


  FILETEXT = FILETEXT +  ("   produces dataitem\n");

  for (i=0; i<count; i=i+1)
    {
      notevar = list_get(TNote, i);
      itemvar = find_by_query(q2);
      FILETEXT = FILETEXT +  ("     " + itemvar.value);
      if (i < count - 1)
         FILETEXT = FILETEXT + (",\n");
      else 
         FILETEXT = FILETEXT + (";\n\n");
    }

}


void
print_end_action()
{

  FILETEXT = FILETEXT + (".\n\n\n");

}

set
Build_Dataitem_Set(set DataItemsDataTypes, int id)
{
  list dataitems;
  int i,count;
  note notevar;
  item itemvar1, itemvar2;

  string q1 = "note [TestDataItem && obj_id == ${id}] sort by name";
  string q2 = "item [TDataItemName && note_id == ${notevar.id}]";
  string q3 = "item [TDataTypeName && note_id == ${notevar.id}]";

  dataitems = list_select(q1);

  count = list_count(dataitems);

  for (i=0;i<count;i=i+1)
    {
      notevar = list_get(dataitems,i);
      itemvar1 = find_by_query(q2);
      itemvar2 = find_by_query(q3);
      set_add (DataItemsDataTypes, itemvar1.value + SEPARATOR + itemvar2.value);


    }

  return (DataItemsDataTypes);

}


set
Build_Dataitem_Statements(set DataItemsDataTypes)
{
  list listvar;
  string stringvar;
  string dataitem, datatype;
  int i,count;
  set DataTypes;

  DataTypes = set_create ("string");

  count = set_count(DataItemsDataTypes);

  for (i=0;i<count;i=i+1)
    {
      stringvar = set_get_element(DataItemsDataTypes,i);

      listvar = string_to_list(stringvar, SEPARATOR );
      dataitem = list_get(listvar,0);
      datatype = list_get(listvar,1);

      if (datatype != "event_type" )
        set_add (DataTypes, datatype);

      FILETEXT = FILETEXT +  ("Dataitem " + dataitem + ";\n");
      FILETEXT = FILETEXT +  ("   is an instance of datatype " + datatype + ";\n");
      FILETEXT = FILETEXT +  (".\n\n");

    }

  return (DataTypes);

}

void
Build_Datatype_Statements(set datatypes)
{
  int i,count;
  string datatypename;
  node nodevar;
  item itemvar;

  string q1 = "node [TTestType && name == '${datatypename}']";
  string q2 = "item [TDataTypeClass && obj_id == ${nodevar.id}]";

  count = set_count (datatypes);

  for (i=0;i<count;i=i+1)
    {
      datatypename = set_get_element(datatypes,i);
      nodevar = find_by_query(q1);

      if (nodevar != NULL)
        {
          itemvar = find_by_query(q2);

          if (itemvar != NULL)
            {
              if (itemvar.value == "integer" || itemvar.value == "real")
                Build_IntegerReal_TypeDef(datatypename, itemvar.value, 
                  nodevar.id);
              else if (itemvar.value == "string")
                Build_String_TypeDef(datatypename, itemvar.value, 
                  nodevar.id);
              else
                message (datatypename + " is not defined in an StP type table");
            }
          else
            {
              message (datatypename + " is not defined in an StP type table");
            }

        }
      else
        {
           message (datatypename + " is not defined in an StP type table");
        }

      FILETEXT = FILETEXT +  (".\n\n");
    }
}

void
Build_IntegerReal_TypeDef(string datatypename, string name, int id)
{
  item itemvar;
  list itemlist;
  int i,count;

  string q1 = "item [TMinimumValue && obj_id == ${id}]";
  string q2 = "item [TMaximumValue && obj_id == ${id}]";
  string q3 = "item [TResolution && obj_id == ${id}]";
  string q4 = "item [TTestValue && obj_id == ${id}]";
  string q5 = "item [TInvalidSubdomain && obj_id == ${id}]";


  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass " + name  + ";\n");

  itemvar = find_by_query(q1);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range minimum " + itemvar.value  + ";\n");
    }

  itemvar = find_by_query(q2);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range maximum " + itemvar.value  + ";\n");
    }

  itemvar = find_by_query(q3);
  if (itemvar != NULL)
    {
      FILETEXT = FILETEXT +  ("  has value range resolution " + itemvar.value  + ";\n");
    }

  itemlist = list_select(q4);
  count = list_count(itemlist);
  for (i=0;i<count;i=i+1 )
    {
      if (i==0)
         FILETEXT = FILETEXT +  ("  has values ");

      itemvar = list_get(itemlist, i);

      FILETEXT = FILETEXT +  (itemvar.value);

      if (i < count - 1)
         FILETEXT = FILETEXT + (",\n             ");
      else 
         FILETEXT = FILETEXT + (";\n");
    }

  FILETEXT = FILETEXT +  ("\n  has valid subdomain as_specified;\n");

  itemvar = find_by_query(q5);
  if (itemvar != NULL)
    {
      if (itemvar.value != "None")
         {
           FILETEXT = FILETEXT +  ("  has invalid subdomain ");
           FILETEXT = FILETEXT +  (GetInvalidSubdomain(itemvar.value)  + ";\n");
         }
    }

}



void
Build_String_TypeDef(string datatypename, string name, int id)
{
  item itemvar;
  list itemlist;
  int i,count;

  string q4 = "item [TTestValue && obj_id == ${id}]";
  string q5 = "item [TInvalidSubdomain && obj_id == ${id}]";


  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass " + name  + ";\n");

  itemlist = list_select(q4);
  count = list_count(itemlist);
  for (i=0;i<count;i=i+1 )
    {
      if (i==0)
         FILETEXT = FILETEXT +  ("  has values ");

      itemvar = list_get(itemlist, i);

      FILETEXT = FILETEXT +  ("\"" + itemvar.value + "\"");

      if (i < count - 1)
         FILETEXT = FILETEXT + (",\n             ");
      else 
         FILETEXT = FILETEXT + (";\n");
    }

  FILETEXT = FILETEXT +  ("\n  has valid subdomain as_specified;\n");

  itemvar = find_by_query(q5);
  if (itemvar != NULL)
    {
      if (itemvar.value != "None")
         {
           FILETEXT = FILETEXT +  ("  has invalid subdomain ");
           FILETEXT = FILETEXT +  (GetInvalidSubdomain(itemvar.value)  + ";\n");
         }
    }

}


void
Build_Unspecified_TypeDef(string datatypename)
{
  FILETEXT = FILETEXT +  ("DataType " + datatypename + ";\n");
  FILETEXT = FILETEXT +  ("  is datatypeclass unspecified;\n");
  FILETEXT = FILETEXT +  ("  has placeholder value \"UNSPECIFIED\";\n");
  FILETEXT = FILETEXT +  ("  has valid subdomain as_specified;\n");
}

void
Build_Footer()
{
  FILETEXT = FILETEXT + ("\n\npe_mark\n\n");
}

string
GetInvalidSubdomain(string name)
{

  if (name == "NotInList")
    return ("not_in_list");
  else if (name == "OutOfType")
    return ("out_of_type");
  else if (name == "AboveBounds")
    return ("above_bounds");
  else if (name == "BelowBounds")
    return ("below_bounds");
  else if (name == "OutOfBounds")
    return ("out_of_bounds");
  else if (name == "Abnormal")
    return ("abnormal");

}


void
WriteFileText (string OUTPUTDIR, string FILETEXT)
{
  string outputfile = OUTPUTDIR + "/sdf";

  if(write_file_access(outputfile))
     write_file (outputfile, FILETEXT);

  else
    {
      // system ("mkdir " + OUTPUTDIR);
      CreateDirectory(OUTPUTDIR);
      if(write_file_access(outputfile))
         message ("File not available for writing");
      else 
         write_file (outputfile, FILETEXT);

    }
}
