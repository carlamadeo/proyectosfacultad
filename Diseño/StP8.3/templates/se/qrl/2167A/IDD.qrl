//
//      sccsid[] = %W% %Y% %D%
//      StP/Core
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1992-1993
//      All rights reserved
//

//////////////////////////////////////////////////////////////////////
//
//      2167A Interface Design Document
//
//
//      See script_help for general template comments.
//
//////////////////////////////////////////////////////////////////////

#include "qrl/2167A/IDD_externals.inc"
#include "qrl/2167A/2167A_formats.inc"
#include "qrl/2167A/2167A_generic_fns.inc"
#include "qrl/2167A/IDD_table_fns.inc"
#include "qrl/2167A/interfaces.inc"

/*
script_help = "This report satisfies DI-MCCR-80027A, the Interface Design 
Document (IDD).

3.1 The Interface Design Document (IDD) specifies the detailed design for
one or more interfaces between one or more Computer Software Configuration
Items (CSCIs) and other configuration items or critical items.

3.2 The IDD and its companion Interface Requirements Specification (IRS)
serve to communicate and control interface design decisions to the
Government.  Upon completion of Physical Configuration Audit, the IDD
becomes a part of the Product Baseline.

3.3 The IDD is used by the contractor(s) as the basis for software design 
of the interface(s).

7.3 The IDD is used to document the design for those interfaces
specified by an IRS, DI-MCCR-80026A.  The IDD completes the
description of the interface(s).

7.4 The CSCI software components that implement the interface design
information required by this DID are described in a Software Design
Document (SDD), DI-MCCR-80012A, for each CSCI.

7.5 This DID supersedes DI-MCCR-80027 dated 4 June 1985.

The Software through Pictures implementation of the IDD consists of
a Query and Reporting Language (QRL) script that integrates various
graphical diagrams, user-input files, and literal text into a complete
document, embedding in the resulting output file the document preparation
commands for the targetted text formatting system.

This template has implemented two appendices.  Appendix A contains
all figures referenced throughout the document, and Appendix B contains
all the tables.  References are made throughout the template to these
appendices.  If you want to include the diagrams in the text of the
documents, the template must be modified accordingly.

Note that the interfaces may be documented in the IDD or the SDD as 
specified by the doc notes attached to the data flows that constitute the
system interfaces.  DOD-STD-2167 requires that each interface documented
in the IRS be documented in the IDD or the SDD; the SDD documents any
interfaces not documented in an IDD.

Also note that the Software through Pictures implementation of the IDD
assumes only one IDD per CSCI that documents all interfaces (except those
documented in the SDD) in the CSCI.  This structure simplifies production
of the documentation.  If you want to generate separate IDDs for particular
interfaces, you should add special QRL scripts for those IDDs, using this
template as the starting point and specifying the exact interface by name
in the interface select procedure below.";

*/

 
boolean dedt_initialized = False;

boolean debug = False;

//PEC 10/11/95 struct to keep track of msgs & their elements
struct
msg_struct
{
    node msg_node;
    list elements;
};

//PEC 10/11/95 a list of msg_struct's
list MSG_LIST;

void
main()
{
    message("IDD:  START");
    if (legal_target())
    {    
        e_GENERATION_INFO = False;
    	initialize ();
    	title_page ();
    	scope_section ();
    	documents_section ();
    	interface_design_section ();
    	notes_section ();
    	appendices_section ();
    }
    message("IDD:  END");
}

void
initialize ()
{
    message ("IDD:  Initialize");
 
    // set default format
    format(DefaultFormatFile);

    // Diagram printing initialization
    diagram_orientation_scale_set (PortraitFit);
    diagram_caption_alignment_set (Center);
    diagram_caption_orientation_set (Portrait);
    diagram_caption_placement_set (Bottom);
    diagram_caption_paragraph_format_set (FigureFormat);
    diagram_frame_height_set (5.0);
    diagram_frame_width_set (6.0);
    table_caption_alignment_set (Center);
    table_caption_placement_set (Bottom);
    table_width_set (6.5);
    table_caption_paragraph_format_set (TableTitleFormat);
    table_cell_bold_paragraph_format_set (TableHeaderCellFormat);
    table_cell_paragraph_format_set (TableBodyCellFormat);

    message ("        external interface list");
    create_external_interfaces("external_interfaces", select_IDD_components, "IDD");

    //PEC mod 10/5/95 Adding id list to keep track of messages, rts #77
    message ("      . msg node list");
    id_list_create("node[node_refs[file[DseDiagram]]]", "DSE_NODES") ;
    id_list_create("node[DSE_NODES && items[IsMessage && value=='True']]",
                   "MSG_NODES") ;
    //Initialize global msg list
    MSG_LIST=list_create("msg_struct",0);

}


// CLEAN_UP
//
// This function deallocates any memory that might have been allocated
// during the execution of this program.
 
void
clean_up ()
{
    id_list_free ("external_interfaces");
}
 

void
title_page ()
{
    message("IDD:  Title Page");
    paragraph (TitleDocInfoFormat);
    print_line (document_number);
    print (document_date());

    paragraph (TitleMainFormat);
    print_line ("INTERFACE DESIGN DOCUMENT");
    print_line ("FOR THE");
    print (system_name);

    paragraph (TitlePrepInfoFormat);
    print_line ("CONTRACT NO. " + contract_number);
    print_line ("CDRL SEQUENCE NO. " + cdrl_number);
    print_line ("Prepared for: ");
    print_line (contracting_agency_and_dept_code);
    print_line ("Prepared By: ");
    print (contractor_name_and_address);

    paragraph (TitleSignaturesFormat);
    print_line ("Accepted by___________________");
    print ("Date_______________");

    paragraph (TitleSignaturesFormat);
    print_line ("Approved by_____________");
    print ("Date_______________");

    // BUG: Currently, this does not happen in Core 1.0.
    // Steve Schmidt will try to sneak this in after Core 1.1 Beta.

}


// The above procedure uses the standard DOD-STD-2167 title page user
// inputs.



// Sets up the IDD Scope section

// 10.2.3  Scope

// This section shall be numbered 1.  and divided into the following
//  paragraphs.
//
void
scope_section ()
{
    message ("IDD:  1. Scope ...");
    paragraph (HeadingL1Format);
    print ("Scope");

    message ("IDD:    1.1. Identification ...");

    identification ();
    system_overview ();
    document_overview ();
}


//  Sets up the IDD Identification Paragraph (1.1)

//  10.1.3.1  Identification.  This paragraph shall be numbered 1.1 and shall
//  contain the approved identification number, title, and if applicable,
//  abbreviation of the system(s), CSC(s),and interfaces to which this IDD
//  applies. 
void
identification ()
{
    string sys_abbrev = " ";
    string csci_abbrev = " ";

    paragraph (HeadingL2Format);
    print ("Identification");
    paragraph (SubSectionBodyFormat);

    // Add the necessary delimiters around the abbreviations if in fact
    // they exist.
    if (system_abbreviation != "")
	sys_abbrev = " (" + system_abbreviation + ") ";
    else
	display_warning ("No system abbreviation provided");
    
    if (csci_abbreviation != "")
	csci_abbrev = " (" + csci_abbreviation + ") ";
    else
	display_warning ("No CSCI abbreviation provided");


    print ("This Interface Design Document describes the detailed design " +
	"of the interface(s) identified as ");

    print_interface_name_list("InterfaceDesign");

    print (" for the CSCI identified as " + csci_title + csci_abbrev
	+ csci_number + " of the " + system_name + sys_abbrev
	+ system_number + " System.");
}


//
// system_overview()
// The above procedure uses the DOD-STD-2167 standard identification
// variables.
// Sets up the IDD System Overview paragraph
void
system_overview ()
{
    message ("IDD:    1.2. System overview ...");
    paragraph (HeadingL2Format);
    print ("System overview.");
    paragraph (SubSectionBodyFormat);
    print (SECTION_1_2_System_overview);
}


// Sets up the IDD Document Overview paragraph
void
document_overview ()
{
    message ("IDD:    1.3. Document overview ...");
    paragraph (HeadingL2Format);
    print ("Document overview.");
    paragraph (SubSectionBodyFormat);
    print (SECTION_1_3_Document_overview);
}


// sets up the Referenced Documents section of the IDD
void
documents_section ()
{
    message ("IDD:  2. Documents section ...");
    paragraph (HeadingL1Format);
    print ("Referenced Documents");
    paragraph (SubSectionBodyFormat);
    print (SECTION_2_Referenced_documents);
}

// Implements the Interface Design Section of the IDD.

// 10.1.5 Interface Design 


// This section shall be numbered 3 and shall be divided into the following
// paragraphs and subparagraphs to describe the interface design for those
// interfaces to which this IDD applies.
void
interface_design_section ()
{
    string query;
    link one_link;
    int paragraph_count = 2;

    message ("IDD:  3. Interface Design section ...");
    paragraph (HeadingL1Format);
    print ("Interface Design");

    interface_diagrams_paragraph ();

    query = "link[external_interfaces && " +
        "link_refs[file[name == 'top']]] sort by name";
    for_each_in_select(query, one_link)
    {
	paragraph_count = interface_paragraph (one_link, paragraph_count);
    }
}

// Implements the Interface Diagrams paragraph for the IDD.

// 10.1.5.1  Interface Diagrams.  This paragraph shall be numbered 3.1 and shall
// specify for each CSCI to which this IDD applies, its relationship to the other
// HWCIs, CSCIs, or critical items with which it interfaces.  This description 
// may be provided by one or more interface diagrams, as appropriate.

void
interface_diagrams_paragraph ()
{
    message ("IDD:    3.1. Interface Diagrams section ...");
    paragraph (HeadingL2Format);
    print ("Interface Diagrams");
    paragraph (SubSectionBodyFormat);
    if (narrative_document)
    {   
	print ("The interface diagram depicting the relationship of this " +
	    "CSCI to the other CSCIs and HWCIs in the system is depicted " +
	    "below.");
        include_external_interface_diagrams ("Interface Diagram");
    }
    else
    {
	print ("The interface diagram depicting the relationship of this " +
	    "CSCI to the other CSCIs and HWCIs in the system is depicted " +
	    "in Appendix A at the end of this document.");
    }

}


// Implements the Interface Paragraph for the IDD.

// 10.1.5.2 (Interface Name and project-unique identifier).   This paragraph
// shall be numbered 3.X (beginning with 3.2), shall identify an interface by
// name and project-unique identifier, and shall state its purpose.  This
// paragraph shall be divided into the following subparagraphs to describe the
// design of the interface.

int
interface_paragraph (link interface, int X)
{
    string query;
    item one_item;
    note one_note;
    string interface_design_name;
    int paragraph_no = X;

    query = "item[InterfaceName && note[InterfaceDesign && " +
	"obj_id == ${interface.id}]]";
    one_item = find_by_query(query);
    if (one_item != NULL)
    {
	interface_design_name = one_item.value;
    
	message ("IDD:    3." + X + ". Design for '" + interface_design_name + 
	    "' Interface ...");
	paragraph (HeadingL2Format);
	print (interface_design_name + " Interface (" + 
	    find_unique_identifier(interface.id) + ")");
	
	print_note_description(interface.id, SubSectionBodyFormat, "GenericObject");

	data_element_subparagraph (interface.id, interface, paragraph_no,
	    interface_design_name);
	message_description_subparagraph (interface, interface_design_name,
	    paragraph_no);
	interface_priority_subparagraph (interface, interface_design_name,
	    paragraph_no);
	communications_protocol_subparagraph (interface, paragraph_no);
	paragraph_no = paragraph_no + 1;
    }
    return (paragraph_no);
}

// Implements the Data Element subparagraph for a particular interface in
// the IDD.

// 10.1.5.2.1  Data elements.  This subparagraph shall be numbered 3.X.1 (
// beginning with 3.2.1) and shall provide, in a data element definition table,
// the following information, as applicable, for each data element transmitted
// across the interface:
//
// a.  A project-unique identifier for the data element
// b.  A brief description of the data element
// c.  The CSCI, HWCI, or critical item that is the source of the data element
// d.  The CSCI(s), HWCI(s), or critical item(s) that are the users of the
//     data element.
// e.  The units of measure required for the data element, such as seconds,
//     meters, kilohertz, etc.
// f.  The limit/range of values required for the data element (for constants
//     provide the actual value).
// g.  The accuracy required for the data element
// h.  The precision or resolution required for the data element in terms of
//     significant digits.
// i.  The frequency at which the data element is calculated or refreshed, such
//     as 10 KHz or 50 Msec
// j.  Legality checks performed on the data element
// k.  The data type, such as integer, ASCII, fixed, real, enumerated, etc.
// l.  The data representation/format
// m.  The priority of the data element.

// In the Software through Pictures environment, each interface is a data
// flow to or from an external.  Each data flow is a separate interface, so
// each interface consists of a single data structure.  Each interface
// summary paragraph documents the name of the data structure and the purpose
// (as described in the main description annotation for the data flow).  Note
// that StP data flows are always unidirectional.  The initiation criteria
// come from the des_cri note for a data or control flow.

void
data_element_subparagraph (int Object_ID, link ifname, int X, 
    string interface_nm)
{
    string caption;
    string new_ifname;

    message ("IDD:       3." + X + ".1. Data Element Table ...");

    paragraph (HeadingL3Format);
    print ("Data Elements");

    paragraph (TableBodyCellFormat);
    if (dedt_initialized == False)
    {
	new_ifname = string_search_and_replace(ifname.name," ", "_");
	initialize_data_element_def_tab1("IRS_dedt1",Object_ID, new_ifname);
	initialize_data_element_def_tab2("IRS_dedt2",Object_ID, new_ifname);
	initialize_data_element_def_tab3("IRS_dedt3",Object_ID, new_ifname);
        dedt_initialized = True;
    }

    caption = interface_nm + " Data Element Definition Table";

    fill_data_element_def_tabs(Object_ID, ifname.name, caption);
}

// Implements the messages description subparagraph

// 10.1.5.2.2  Message Descriptions. This subparagraph shall be number 3.X.2
// (beginning with 3.2.2), shall identify each message transmitted across the
// interface by name and project-unique identifier, and shall describe the
// assignment of data elements to each message.  A cross-reference of each 
// message to the data elements that embody the message shall be provided.  In
// addition, a cross-reference of each data element to the message(s) of which
// it is a part shall also be provided.  Cross-references may be provided as an
// appendix and referenced in this subparagraph.

void
message_description_subparagraph (link interface, string interface_des_name,
    int X)
{
    string query;
    node one_node = NULL;
    boolean found_msg;

    message ("IDD:       3." + X + ".2. Message Description subparagraph ...");
    paragraph (HeadingL3Format);
    print ("Message Descriptions");
    paragraph (SubSectionBodyFormat);
    print ("The " + interface_des_name + " interface passes messages " +
	"described as follows: ");

    //8/23/95 PEC--Added Selection and Enum types
    //10/5/95 PEC--Added node refs
    query = "node[(Sequence||Enumeration||Selection) && name == '${interface.name}' && node_refs]";
    one_node = find_by_query(query);
    if (one_node != NULL)
    {
	//PEC mod 10/5/95--Changing this entire subparagraph to meet 
	//the DID and rts#77
	found_msg=get_messages(one_node, True);
	if (found_msg)
	{
    	   paragraph (SubSectionBodyFormat);
    	   print("A cross reference between messages and data elements " +
			"is provided in Appendix A.");
	}

    }
    else
        message("IDD ERROR:  Unable to find structure for interface:  " + interface.name);

}

//PEC 10/5/95 function to print message info for an interface.
//Prints the message name, project unique identifier, lists the
//message's data elements, and prints the message description.
//Returns True if any messages are found, False otherwise.
boolean 
get_messages(node interface, boolean First_Time)
{
    node nv ;
    node msg_node ;
    list select_list;
    int i;
    boolean Found=False;
 
    if (First_Time)
    {
      if (debug)
         message("Finding messages for interface:  " + interface.name);

      msg_node = find_by_query("node[MSG_NODES && id=${interface.id}]") ;
      if(msg_node != NULL)
      {  
        if (debug)
           message ("Found message node:  " + msg_node.name);
        paragraph(SubSectionBodyFormat) ;
        print_line("Message (PUI): " +msg_node.name+" ("+msg_node.id+")") ;
        print("  with Data Elements: ") ;
        print_data_elements(msg_node) ;
        print_note_description(msg_node.id, "IndentBody1", "DataDefinition");
	Found=True;
      }  
    }  
 
    select_list=list_select("node[DSE_NODES && in_links[Component && " +
                        "from_node[${interface.id}]]]");
    for(i=0;i<list_count(select_list);i=i+1)
    {
        nv=list_get(select_list,i);
        if (debug)
           message("Checking '"+nv.name+"' to see if it's a message node...");
        msg_node = find_by_query("node[MSG_NODES && id = " + nv.id + "]") ;
        if(msg_node != NULL)
        {
            if (debug)
                message ("Found message node:  " + msg_node.name);

            paragraph(SubSectionBodyFormat) ;
            print_line("Message (PUI): "+msg_node.name+" ("+msg_node.id+")") ;
            print("  with Data Elements: ") ;
            print_data_elements(msg_node) ;
            print_note_description(msg_node.id,"IndentBody1","DataDefinition");
	    Found=True;
        }
        else get_messages(nv, False) ;
    }    

    return(Found);
}

// PEC 10/9/95 prints comma separated list of data elements for a node
// in a data structure.  Also populates global MSG_LIST for use later
//in xref tables.
void print_data_elements(node msg)
{
    list elem_list = list_create("node",0);
    node nv ;
    int i ;
    msg_struct one_msg;
 
    get_leaf_nodes(msg, elem_list) ;
    for(i=0 ; i< list_count(elem_list) ; i = i+1)
    {
        nv = list_get(elem_list, i) ;
        if(i>0) print(", ") ;
        print(nv.name) ;
    }

   //Append to MSG_LIST
   one_msg.msg_node=msg;
   one_msg.elements=elem_list;
   list_append(MSG_LIST,one_msg);
       
}
         
//PEC 10/9/95 returns a list of data elements for a structure
list
get_leaf_nodes(node str, list leaves)
{
   list children;
   string query;
   int num_kids;
   int i;
   node one_child;
     
   query = "node[DSE_NODES && in_links[Component && from_node_id=${str.id}]]";
   children=list_select(query);
   num_kids= list_count(children);
     
   if(num_kids==0)
   {
        list_append(leaves,str);
   }
   else
     for(i=0;i < num_kids;i=i+1)
     { 
        one_child=list_get(children,i);
        get_leaf_nodes(one_child,leaves);
     }

   return(leaves);
}  

// Implements the Interface priority subparagraph

// 10.1.5.2.3 Interface Priority.  This subparagraph shall be numbered 3.X.3
// (beginning with 3.2.3) and shall specify the relative priority of the 
// interface and of each message transmitted across the interface.

void
interface_priority_subparagraph (link interface, string interface_des_name,
    int X)
{
    string query;
    item one_item = NULL;

    message ("IDD:       3." + X + ".3. Interface Priority subparagraph ...");
    paragraph (HeadingL3Format);
    print ("Interface Priority");
    paragraph (SubSectionBodyFormat);
    print_line ("The  " + interface_des_name  + " interface passes " +
	"messages described as above with the following priority: ");
    print_line ();
    print("Interface Name: " +  interface.name);
    
    query = "item[InterfacePriority && note[InterfaceDesign && " +
        "obj_id == ${interface.id}]]";
    one_item = find_by_query(query);
    if (one_item != NULL)
    {
	print_line();
	print ("Priority Level: " + one_item.value);
    }
}

// Implements the Communications Protocol subparagraph

// 10.1.5.2.4  Communications Protocol.  This subparagraph shall be numbered
// 3.X.4 (beginning with 3.2.4) and shall be divided into the following sub-
// paragraphs to describe the commercial, military, or proprietary communi-
// cations protocols associated with the interface.
void
communications_protocol_subparagraph (link interface, int X)
{
    string query;
    note one_note = NULL;

    message ("IDD:       3." + X + ".4. Communications Protocol Subparagraph ...");
    paragraph (HeadingL3Format);
    print ("Communications Protocol");

    query = "note[CommunicationProtocol && obj_id == ${interface.id}]";
    for_each_in_select(query, one_note)
    {
	protocol_name_subsection (one_note, interface.id);
    }
}

// Implements the protocol sections of the IDD.

// 10.1.5.2.4.1  (Protocol Name). This subparagraph shall be numbered 3.X.4.Y
// (beginning with 3.2.4.1), shall identify a protocol by name and shall 
// describe the technical details of the protocol.  This subparagraph shall
// address the following communications specification details, as applicable:

// a.  Fragmentation and reassembly of messages
// b.  Message formatting
// c.  Error control and recovery procedures, including fault tolerant features
// d.  Synchronization, including connection establishment, maintenance, 
//     termination, and timing
// e.  Flow control, including sequence numbering, window size, and buffer
//     allocation.
// f.  Data transfer rate, whether it is periodic or aperiodic, and minimum
//     interval between transfers
// g.  Routing, addressing, and naming conventions
// h.  Transmission services, including priority and grade
// i.  Status, identification, notification, and any other reporting features
// j.  Security, including encryption, user authentication, compartmentalization,
//     and auditing.

void
protocol_name_subsection (note one_note, int interface_id)
{
    string query;
    item one_item = NULL;

    paragraph (HeadingL4Format);
    query = "item[CommunicationProtocol && note_id == ${one_note.id}]";
    one_item = find_by_query(query);
    if (one_item != NULL)
    {
	// print the name of the section
	print (one_item.value);
    
        print_note_description(interface_id, 
	    SubSectionBodyFormat, "CommunicationProtocol");

	paragraph(SubSectionBodyFormat);
	print_item(one_note.id, "Fragmentation", "Fragmentation");	
	print_item(one_note.id, "MessageFormatting", "Message Formatting");
	print_item(one_note.id, "ErrorControl", "Error Control");	
	print_item(one_note.id, "Synchronization", "Synchronization");	
	print_item(one_note.id, "FlowControl", "Flow Control");	
	print_item(one_note.id, "DataTransferRate", "Data Transfer Rate");
	print_item(one_note.id, "RoutingAddressing", "Routing");
	print_item(one_note.id, "TransmissionServices", 
	    "Transmission Services");
	print_item(one_note.id, "StatusIdentification", "Status");
	print_item(one_note.id, "SecurityEncryption", "Security");
    }
}

// Implements the Notes section of the IDD

void
notes_section ()
{
    message ("IDD:  4. Notes ...");
    paragraph (HeadingL1Format);
    print ("Notes");
    paragraph (SubSectionBodyFormat);
    print ( SECTION_4_Notes);
    paragraph ();
    print (SECTION_4_abbreviations);
}


void
appendices_section ()
{
    // Narrative vs Reference flag will determine the appendices to
    // be included
    
    if (!narrative_document)
    {
	message ("IDD:  Appendix A");
	paragraph (AppendixL1StartFormat);
	print ("IDD Figures.");
	appendix_A_subsection ();
    }
    //PEC 10/12/95 Adding msg xref tables to appendix
    message ("IDD:  Message Cross Reference");
    paragraph (AppendixL2Format);
    print("Message Cross Reference Tables");
    paragraph (SubSectionBodyFormat);
    message_cross_reference_tables();
}

void
appendix_A_subsection ()
{
    paragraph (AppendixL2Format);
    message ("IDD:  Appendix A...");
    print ("Interface Diagram");
    paragraph (SubSectionBodyFormat);
    include_external_interface_diagrams ("Interface Diagram");
}

