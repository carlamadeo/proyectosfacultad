
// 	StP/SE
// 	Confidential property of Aonix
// 	Copyright (c) 1992-1999
// 	All rights reserved
//

#include "qrl/check/check_common.inc"
#include "ct/qrl/include/files.inc"
#include "qrl/check/cse.inc"

int	steVerbose = 0;

struct steprop_tp
{
    int         verbose;
    int         check_one;
    int         check_two;
    int         check_three;
    int         check_four;
    int         check_five;
    int         check_six;
    list        diaglist;
};


int 
checkSteSemanticsFromSte(steprop_tp props)
{
    list	nodelist = list_create("node", 0);
    string	message;

    nodelist = gde_all_mapped_oms_nodes();

    if (list_count(nodelist) == 0)
    {
        print_error("Empty diagram. Semantic checks terminated.");
        print_sc_error("Ste", CurFile, "Empty diagram. Semantic checks terminated.");
        return 1;
    }

    if (list_count(props.diaglist) == 0)
    {
        print_error("Null diagram name. Semantic checks terminated.");
        print_sc_error("Ste", CurFile, "Null diagram name. Semantic checks terminated.");
        return 1;
    }
 
    return checkSteSemantics(props);

    return 1;
}


//
// The main routine for this script, which calls all the appropriate checking
// routines.
//
int checkSteSemantics(steprop_tp props)
{
    int		i, errors = 0; 
    file	one_file;

    cseVerbose = steVerbose = props.verbose;

    print_message("Starting STE Semantic Checking...\n");
    print_sc_para("Starting STE Semantic Checking...\n");

    //  run semantic checks for each diagram
    for ( i = 0; i < list_count(props.diaglist); i++)
    {
	one_file = list_get(props.diaglist, i);

	if (file_history(one_file))
        {
	    print_error("File '" + one_file.name + "' must be saved to the repository before checking semantics.");
	    print_sc_error("Ste", CurFile, "File '" + one_file.name + "' must be saved to the repository before checking semantics.");
        }

	else
	{
	    print_message("Checking semantics for STE diagram '" + one_file.name + "'...\n");
	    print_sc_para("Checking semantics for STE diagram '" + one_file.name + "'...\n");

	    if (props.check_one)
		errors = errors + check_ste_starts(one_file);
	    if (props.check_two)
		errors = errors + check_ste_transition_event_action(one_file);

	    if (props.check_three)
		errors = errors + check_ste_duplicate_links(one_file);

	    if (props.check_four)
		errors = errors + check_ste_duplicate_nodes(one_file);

	    if (props.check_five)
	    {
		if (steVerbose)
		    print_message("Checking that each event is defined in an ELT...");
		print_sc_para("Checking that each event is defined in an ELT...");
		errors = errors + check_elt_alt_definitions(one_file, "Event");
	    }

	    if (props.check_six)
	    {
		if (steVerbose)
		    print_message("Checking that each action is defined in an ALT...");
		print_sc_para("Checking that each action is defined in an ALT...");
		errors = errors + check_elt_alt_definitions(one_file, "Action");
	    }

	}

    }

    if (!errors)
    {
        print_message("Check STE semantics completed with no errors.");
        print_sc_para("Check STE semantics completed with no errors.");
    }
    else if (errors == 1)
    {
        print_message("Check STE semantics completed with 1 error.");
        print_sc_para("Check STE semantics completed with 1 error.");
    }
    else
    {
        print_message("Check STE semantics completed with " + errors + " errors.");
        print_sc_para("Check STE semantics completed with " + errors + " errors.");
    }

    return errors;
}


//
// Check that the diagram has one and only one start state.
//  First checks that there is one start state from a StartState 
//  node (i.e. anchor), if none, checks that there is one state
//  with no in links.
//
int check_ste_starts(file fileobj)
{
    string	query;
    list	start_states = list_create("node_ref", 0);
    int 	count, errors = 0;

    if (steVerbose)
        print_message("Checking that there is one and only one start state...");
    print_sc_para("Checking that there is one and only one start state...");

    query = "node_ref[in_link_refs[from_node_ref[node[StartState]] 
	    && file_id == ${fileobj.id}]]";

    start_states = list_select(query);

    count = list_count(start_states);

    if (count == 0)
    {
	query = "node_ref[node[State] && !in_link_refs 
		&& file_id==${fileobj.id}]";
	start_states = list_select(query);
	count = list_count(start_states);

	if (count == 0)
	{
	    print_error("Diagram '" + fileobj.name + 
			"' has no start state. ");
	    print_sc_error("Ste", CurFile, "Diagram '" + fileobj.name + 
			"' has no start state. ");
	    errors++;
	}
    }
 
    if (count > 1 )
    {
        print_error("Diagram '" + fileobj.name + 
		    "' has multiple start states. ");
        print_sc_error("Ste", CurFile, "Diagram '" + fileobj.name + 
		    "' has multiple start states. ");
	errors++;
    }

    return(errors);
}

//
// Check that each transition has an associated Event/Action.
//
int check_ste_transition_event_action(file fileobj)
{
    int errors = 0;
    string query, query2;
    link transition;            // bad transitions
    set from_set, to_set;       // set of endpoints of bad transitions
    node from, to;              // endpoints

    if (steVerbose)
        print_message("Checking that each transition has an associated Event/Action...");
    print_sc_para("Checking that each transition has an associated Event/Action...");
  
    // Want all transitions with no Action Instances except those coming
    // from Start States.
 
    query = "link[link_refs[ file_id == ${fileobj.id} " +
                " && from_node_ref[node[type != StartState ]]]" +
                " && Transition]";

    for_each_in_select(query, transition)
    {
        query2 = "cntx[cntx_refs && link_id == ${transition.id} && ActionInstance]";
        if(selection_count(query2) != 0)
            continue;   // skip rest of this loop if there are actions associated with this transition
        //query2 = "link[link_refs && id == ${transition.id} && link_refs[ from_node_ref[node[type == StartState ]]]]";
        //if(selection_count(query2) != 0) {
        //    print_message("Found a startstate.");
        //    continue;   // skip rest of this loop if this transition is from a start state
        //}
        // Now report each of these
        query = "node[node_refs[out_link_refs[link_id == ${transition.id}]]]";
        from_set = set_select(query);
        query = "node[node_refs[in_link_refs[link_id == ${transition.id}]]]";
        to_set = set_select(query);
 
        // assert: from_set and to_set each have only one member.
        from = set_get_element(from_set, 0);
        to = set_get_element(to_set, 0);
 
        print_error("Transition from '" + from.name + "' to '" + to.name +
                  "' has no associated Event/Action",
                  link_appids(transition, fileobj));
        print_sc_error("Ste", CurFile, "Transition from '" + from.name + "' to '" + to.name +
                  "' has no associated Event/Action");
        errors++;
    }
    return(errors);
}

 
//
// check for duplicate nodes in a diagram
//
int check_ste_duplicate_nodes(file fileobj)
{
    node 	node;       // duplicate Phase node
    string 	query;      
    int 	errors = 0; 
 
    if (steVerbose)
        print_message("Checking that no state node is referenced in another state transition diagram...");
    print_sc_para("Checking that no state node is referenced in another state transition diagram...");
 
    query = "node[State && node_refs[file[SteDiagram && id == "
                + fileobj.id + "]]" +
                " && node_refs[file[SteDiagram && id != "
                + fileobj.id + "]]]";

    for_each_in_select(query, node)
    {
	print_error("State '" + node.name + "' is referenced in two different diagrams", node_appids(node, fileobj));
	print_sc_error("Ste", CurFile, "State '" + node.name + "' is referenced in two different diagrams");
	errors++;
    }

    return(errors);

}





