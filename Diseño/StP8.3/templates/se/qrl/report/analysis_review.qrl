//
// 	sccsid[] = %W% %Y% %D%
// 	StP/SE
// 	Confidential property of Interactive Development Environments, Inc.
// 	Copyright (c) 1995
// 	All rights reserved
//

////////////////////////////////////////////////////////////////////////////
//
//	analysis_review.qrl
//	
//	This script generates an analysis report of the system
//	
////////////////////////////////////////////////////////////////////////////

#include "qrl/include/files.inc"
#include "qrl/include/return_codes.inc"
#include "se/qrl/include/se_report.inc"

external string  analysis_files = "";  
external_help = "Limit report to file(s) named by this variable.";

external boolean include_dfe_diagrams = True;
external_help = "Includes all data flow diagrams";

external boolean include_cspec_tables = True;
external_help = "Includes all control specification tables";

external boolean include_annotations = True;
external_help = "Includes all annotation information";

external boolean include_all_file_history = False;
external_help = "If True, the report includes a complete history of the file. If False, the report includes only the most recent type of action performed on the file, such as Modified, Viewed.";

external int number_history_actions = 3;
external_help = "Number of history actions to print from the stack of file transactions if include_all_file_history is False";

external string output_symbols = "";
external_help = "Specify the symbol set to print with, either DeMarco/Yourdon (dydfe) or Gane/Sarson (gsdfe).";

external boolean verbose = False;
external_help = "Give status messages as report executes.";

script_help = "This script generates an analysis report of the system, including analysis diagrams, annotations, and source listings. If no file names are given all files are included in the report. ";


boolean page_break_just_printed = True;

const string STATE_TRANSITION_TABLE = "StateTransitionTable";
const string STATE_EVENT_MATRIX = "StateEventMatrix";
const string DECISION_TABLE = "DecisionTable";
const string EVENT_LOGIC_TABLE = "EventLogicTable";
const string ACTION_LOGIC_TABLE = "ActionLogicTable";
const string PROCESS_ACTIVATION_TABLE = "ProcessActivationTable";
const string PROCESS_ACTIVATION_MATRIX = "ProcessActivationMatrix";

string	TABLE_TYPES = "(" + DECISION_TABLE + " || " +
                     PROCESS_ACTIVATION_TABLE + " || " +
                     PROCESS_ACTIVATION_MATRIX + " || " +
                     STATE_TRANSITION_TABLE + " || " +
                     STATE_EVENT_MATRIX + " || " +
                     EVENT_LOGIC_TABLE + " || " +
                     ACTION_LOGIC_TABLE + ")";

//
// main()
//
//	retrieve file objects for named files
// 	print report context and file history for each file,
//   	check to see if file is out of sync with repository,
//	print the diagram,
//	call functions to list objects and annotations,
//	report any errors
//

int
main()
{
    list   list_of_files = list_create("file", 0);
    list   filelist = list_create("file", 0);
    file   one_file;
    int    i, count, errors = 0;
    string time;

    // set default format
    format(DefaultFormatFile);
    table_cell_paragraph_format_set(TableBodyCellFormat);
    table_cell_bold_paragraph_format_set(TableHeaderCellFormat);
    table_caption_paragraph_format_set(FigureTitleFormat);
    diagram_caption_paragraph_format_set(FigureTitleFormat);

    if (output_symbols == "")
	output_symbols = toolinfo_variable("dfe_editor");
    if (output_symbols == NULL || output_symbols == "")
	output_symbols = "dydfe";

    print_message("Preparing Analysis Review Report...");

    if (include_dfe_diagrams)
	filelist = file_list("DfeDiagram", analysis_files);

    if (list_count(filelist) == 0) 
    { 
	print_error("No printable files found."); 
	return ++errors;
    }

    paragraph(SectionFormat);
    print("SE Analysis Review Report");

    paragraph(SeparatorFormat); print("");

    paragraph(Object1Format);
    print("Project directory: " + current_projdir());
    paragraph(Object1Format);
    print("System: " + current_system());
    paragraph(Object1Format);
    time = time_to_string(time_now(), NULL);
    print("Time: " + time );
    paragraph(Object1Format);
    print("User: " + user() );

    paragraph(SeparatorFormat); print("");

    filelist = list_sort_all(filelist, "dfe_diag_sort");

    for (i = 0; i < list_count(filelist); i++)
    {
	one_file = list_get(filelist, i);

	print_message("Working on " + one_file.type +
		": " + one_file.name);

	if (file_history(one_file))
	{
	    ++errors;
	    print_message("Skipping " + one_file.type + " '" + one_file.name + "'...");
	}

	else
	{
	    page();
	    paragraph(Section2Format);
	    print(app_type_print_string(one_file) + ": " + one_file.name);

	    errors = errors + file_hist_print(one_file, 2);

	    if (verbose)
		print_message("Reporting on " + one_file.type +
		    ": " + one_file.name);

	    errors = errors + objs_print(one_file, time);

	    errors = errors + oms_file_print(one_file, time); 

	    if (include_cspec_tables)
		errors = errors + cspec_print(one_file, time); 
	}
    }

    error_count("file printing", errors);

    return errors;
}

int 
dfe_diag_sort(list l, int a, int b)
{
    file f1 = list_get(l, a);
    file f2 = list_get(l, b);

    if (f1.name == "top")
	return(-1);
    if (f2.name == "top")
	return(1);
    if (f1.name < f2.name)
	return(-1);
    return(1);
}

int
cspec_print(file dfe_file, string time)
{
    int		errors = 0;
    string	query, caption;
    boolean	objs_found;
    node	cspec_node;
    file	cspec_file;

    if (verbose)
	print_message("Printing Cspec tables for cspec '" + dfe_file.name + "'");
    query = "node[Cspec && node_refs[file_id == ${dfe_file.id}]]";

    for_each_in_select(query, cspec_node)
    {
	query = "file[${TABLE_TYPES} && name == '${cspec_node.name}']";

	for_each_in_select(query, cspec_file)
	{
	    caption = cspec_file.type + ": " + cspec_file.name 
			+ " (" + time + ")" ;

	    errors = errors + file_print(cspec_file, caption); 

	}
    }

    return errors;
}

void
maybe_print_page_break()
{
    if (page_break_just_printed)
	return;
    else
    {
	page();
        page_break_just_printed = True;
    }    
}

void
printed_something_on_page()
{
    page_break_just_printed = False;
}

// file_hist_print()
//
// print either all file history objects or just the most recent for the file
// depending on the external variable include_all_file_history
//

int
file_hist_print(file one_file, int level )
{
    int		i, index = 0;
    int		errors = 0, hist_count;
    file_hist	file_hist;
    list	file_hist_stack = list_create("file_hist", 0);
    string	query;

    query = "file_hist[file_id == ${one_file.id}] sort by time";

    file_hist_stack = list_select(query);

    hist_count = list_count(file_hist_stack);

    if (include_all_file_history) 
	number_history_actions = hist_count;

    if (hist_count > number_history_actions)
	index = hist_count - number_history_actions;

    for (i = index; i < hist_count; i++)
    {
	file_hist = list_get(file_hist_stack, i);
	paragraph(ObjectFormat + level);
	print(file_hist.time + ": " + 
		app_type_print_string(file_hist) );
    }

    paragraph(SeparatorFormat); print("");
    return errors;
}

//
// objs_print()
//
// for all nodes in the file 
//   print the node and its annotations
//
// for all links in the file
//   print the link and its annotations
//
//   find all cntxs connected to this link
//     print the cntx and its annotations
//

int
objs_print(file one_file, string time)
{
    int     errors = 0;
    boolean objs_found = False;
    boolean cntx_found = False;
    node    one_node, one_scope_node;
    link    one_link;
    cntx    one_cntx;
    string  query, link_query;

    query = "node[node_refs[file_id == ${one_file.id}] && type != FormalCaller] sort by type, name";

    for_each_in_select(query, one_node)
    {
	if (objs_found == False)
	{
            maybe_print_page_break();
	    paragraph(Section2Format);
	    print("Nodes for " + app_type_print_string(one_file) + 
		    ": " + one_file.name);
	    paragraph(SeparatorFormat); print("");
	    objs_found = True;
	    printed_something_on_page();
	}

	node_print(one_node, 1, include_annotations, "", "");
    }

    link_query = "&& (cntxs[cntx_refs] || annot_file_id != 0)";

    objs_found = False;
    id_list_create("link[link_refs[file_id == ${one_file.id}]]", "file_links");

    query = "link[file_links ] sort by type, name";

    for_each_in_select(query, one_link)
    {
	if (objs_found == False)
	{
            maybe_print_page_break();
	    paragraph(Section2Format);
	    print("Links for " + one_file.name +
		    ": " + one_file.name);
	    paragraph(SeparatorFormat); print("");
	    objs_found = True;
	    printed_something_on_page();
	}

	link_print(one_link, 1, "", "");
	cntx_found = False;

	query = "cntx[link_id == ${one_link.id} && cntx_refs ] sort by type, name";

	for_each_in_select(query, one_cntx)
	{
	    cntx_found = True;
	    cntx_print(one_cntx, 2, True, "", "");
	    printed_something_on_page();
	}
    }
    id_list_free("file_links");
    return errors;
}

//
// node_print()
//
// print a node's type, name and signature (if not null)
// call function to print annotation (if it is to be included)
// 

int
node_print(node one_node, int level, boolean include_annots, string prefix, string paragraph)
{
    int errors = 0;
    string this_paragraph;

    if (paragraph == NULL || paragraph == "")
	paragraph = ObjectFormat;

    if (level <= 0)
	this_paragraph = paragraph + "1";
    else
	this_paragraph = paragraph + level;

    paragraph(this_paragraph);
    print(prefix + app_type_print_string(one_node) + ": " + one_node.name);

    if (one_node.sig != NULL && one_node.sig != "")
	print(" (" + one_node.sig + ")");

    if (include_annots)
    {
	annot_print(one_node.id, level);
	paragraph(SeparatorFormat); print("");
    }

    scope_print(one_node.scope_node_id, level);
    paragraph(SeparatorFormat); print("");

    printed_something_on_page();
    return errors;
}

//
// link_print()
//
// print a link's type, name and signature (if not null)
// print the link's from and to nodes (with their annotations)
// call function to print annotation (if it is to be included)
// 

int
link_print(link one_link, int level, string prefix, string paragraph)
{
    int errors = 0;
    node one_node;
    string this_paragraph;

    if (paragraph == NULL || paragraph == "")
	paragraph = ObjectFormat;

    if (level <= 0)
	this_paragraph = paragraph + "1";
    else
	this_paragraph = paragraph + level;

    paragraph(this_paragraph);
    print(prefix + app_type_print_string(one_link) + ": " + one_link.name);

    if (one_link.sig != NULL && one_link.sig != "")
	print(" (" + one_link.sig + ")");

    for_each_in_select("node[id == ${one_link.from_node_id} || " +
	    "id == ${one_link.to_node_id}]", one_node)
    {
	if (one_node.id == one_link.from_node_id)
	    node_print(one_node, level + 1, False, "From ", "");
	else
	if (one_node.id == one_link.to_node_id)
	    node_print(one_node, level + 1, False, "To ", "");
    }

    if (include_annotations)
    {
        annot_print(one_link.id, level);
        paragraph(SeparatorFormat); print("");
    }

    printed_something_on_page();
    return errors;
}

//
// cntx_print()
//
// print a cntx's type, name and signature (if not null)
// call function to print annotation (if it is to be included)
// 

int
cntx_print(cntx one_cntx, int level, boolean include_annot, 
	string prefix, string paragraph)
{
    int errors = 0;
    link one_link;
    string this_paragraph;

    if (paragraph == NULL || paragraph == "")
	paragraph = ObjectFormat;

    if (level <= 0)
	this_paragraph = paragraph + "1";
    else
	this_paragraph = paragraph + level;

    paragraph(this_paragraph);
    print(prefix + app_type_print_string(one_cntx) + ": " + one_cntx.name);

    if (one_cntx.sig != NULL && one_cntx.sig != "")
	print(" (" + one_cntx.sig + ")");

    if (include_annotations)
    {
	annot_print(one_cntx.id, level);
	paragraph(SeparatorFormat); print("");
    }
    printed_something_on_page();
    return errors;
}

//
// annot_print()
//
// print an object's notes' type, and name 
//   print note description line by line
//   print a note's item's type, value
// 

int
annot_print(int objid, int level)
{
    note one_note;
    item one_item;
    int errors = 0;
    int line;
    list note_lines;
    string	query;

    query  = "note[obj_id == ${objid} && type != GenericObject ] sort by type, name";

    for_each_in_select(query, one_note)
    {
	paragraph(NoteFormat + level);
	print(app_type_print_string(one_note) + ": " + one_note.name);

	if (one_note.desc != NULL && one_note.desc != "" )
	{
	    note_lines = string_to_list(one_note.desc, "\n");
	    for (line = 0; line < list_count(note_lines); line = line + 1)
	    {
		paragraph(DescriptionFormat + level);
		print(list_get(note_lines, line));
	    }
	}

	for_each_in_select("item[note_id == ${one_note.id}] " 
			    + "sort by type, value", one_item)
	{
	    paragraph(ItemFormat + level);
	    print(app_type_print_string(one_item) + ": " + one_item.value);
	}
    }
    printed_something_on_page();
    return errors;
}

//
// scope_print()
//
// print an object's file and directory scope
//
 
int
scope_print(int scopeid, int level)
{
    int		errors = 0;
    node	file_scope = NULL;
    node	dir_scope = NULL;
    string	query;
 
    query  = "node[id == ${scopeid} && SEFile]";
    file_scope = find_by_query(query);

    if (file_scope != NULL)
    {
        paragraph(NoteFormat + level);
        print(app_type_print_string(file_scope) + ": " + file_scope.name);

	query  = "node[id == ${file_scope.scope_node_id} && SEDirectory]";
	dir_scope = find_by_query(query);
    }

    if (dir_scope != NULL)
    {
        paragraph(NoteFormat + level);
        print(app_type_print_string(dir_scope) + ": " + dir_scope.name);
    }

    printed_something_on_page();
    return errors;
}

