//
// 	sccsid[] = %W% %Y% %D%
// 	StP/SE
// 	Confidential property of Interactive Development Environments, Inc.
// 	Copyright (c) 1995
// 	All rights reserved
//

////////////////////////////////////////////////////////////////////////////
//
//	design_review.qrl
//	
//	This script generates a report of the design of the system
//	
////////////////////////////////////////////////////////////////////////////

#include "qrl/include/files.inc"
#include "qrl/include/return_codes.inc"
#include "se/qrl/include/se_report.inc"

external string  design_files = "";  
external_help = "Limit report to file(s) named by this variable.";

external boolean include_sce_diagrams = True;
external_help = "Includes all structure chart diagrams";

external boolean include_dse_diagrams = True;
external_help = "Includes all data structure diagrams";

external boolean include_annotations = True;
external_help = "Includes all annotation information";

external boolean include_source_listings = True;
external_help = "Includes listings of all source files generated by the SE Code Generator";

external boolean include_all_file_history = False;
external_help = "If True, the report includes a complete history of the file. If False, the report includes only the most recent type of action performed on the file, such as Modified, Viewed.";

external int number_history_actions = 3;
external_help = "Number of history actions to print from the stack of file transactions if include_all_file_history is False";

external boolean verbose = False;
external_help = "Give status messages as report executes.";

script_help = "This script generates a report of the design of the system, including design diagrams, annotations, and source listings. If no file names are given all files are included in the report. ";


boolean page_break_just_printed = True;

//
// main()
//
//	retrieve file objects for named files
// 	print report context and file history for each file,
//   	check to see if file is out of sync with repository,
//	print the diagram,
//	call functions to list objects and annotations,
//	report any errors
//

int
main()
{
    list   list_of_files = list_create("file", 0);
    list   filelist = list_create("file", 0);
    file   one_file;
    int    i, count, errors = 0;
    string time;

    // set default format
    format(DefaultFormatFile);
    table_cell_paragraph_format_set(TableBodyCellFormat);
    table_cell_bold_paragraph_format_set(TableHeaderCellFormat);
    table_caption_paragraph_format_set(FigureTitleFormat);
    diagram_caption_paragraph_format_set(FigureTitleFormat);

    print_message("Preparing design review report...");

    if (include_sce_diagrams)
	filelist = file_list("SceDiagram", design_files);

    if (include_dse_diagrams)
	list_concatenate(filelist, file_list("DseDiagram", design_files));

    if (list_count(filelist) == 0) 
    { 
	print_error("No printable files found."); 
	return ++errors;
    }

    paragraph(SectionFormat);
    print("SE Design Review Report");

    paragraph(SeparatorFormat); print("");

    paragraph(Object1Format);
    print("Project directory: " + current_projdir());
    paragraph(Object1Format);
    print("System: " + current_system());
    paragraph(Object1Format);
    time = time_to_string(time_now(), NULL);
    print("Time: " + time );
    paragraph(Object1Format);
    print("User: " + user() );

    paragraph(SeparatorFormat); print("");

    for (i = 0; i < list_count(filelist); i++)
    {
	one_file = list_get(filelist, i);

        if (file_history(one_file))
        { 
            ++errors;
            print_message("Skipping " + one_file.type + " '" + one_file.name + "'...");    
        }

	else
	{
	    page();
	    paragraph(Section2Format);
	    print(app_type_print_string(one_file) + ": " + one_file.name);

	    errors = errors + file_hist_print(one_file, 2);

	    if (verbose)
		print_message("Reporting on " + one_file.type +
		    ": " + one_file.name);

	    errors = errors + oms_file_print(one_file, time); 

	    errors = errors + objs_print(one_file, time); // object and annot listing
	}
    }

    error_count("file printing", errors);

    return errors;
}

void
maybe_print_page_break()
{
    if (page_break_just_printed)
	return;
    else
    {
	page();
        page_break_just_printed = True;
    }    
}

void
printed_something_on_page()
{
    page_break_just_printed = False;
}

// file_hist_print()
//
// print either all file history objects or just the most recent for the file
// depending on the external variable include_all_file_history
//

int
file_hist_print(file one_file, int level )
{
    int		i, index = 0;
    int		errors = 0, hist_count;
    file_hist	file_hist;
    list	file_hist_stack = list_create("file_hist", 0);
    string	query;

    query = "file_hist[file_id == ${one_file.id}] sort by time";

    file_hist_stack = list_select(query);

    hist_count = list_count(file_hist_stack);

    if (include_all_file_history) 
	number_history_actions = hist_count;

    if (hist_count > number_history_actions)
	index = hist_count - number_history_actions;

    for (i = index; i < hist_count; i++)
    {
	file_hist = list_get(file_hist_stack, i);
	paragraph(ObjectFormat + level);
	print(file_hist.time + ": " + 
		app_type_print_string(file_hist) );
    }

    paragraph(SeparatorFormat); print("");
    return errors;
}

//
// objs_print()
//
// for all nodes in the file 
//   print the node and its annotations
//
// for all links in the file
//   print the link and its annotations
//
//   find all cntxs connected to this link
//     print the cntx and its annotations
//

int
objs_print(file one_file, string time)
{
    int     errors = 0;
    boolean objs_found = False;
    boolean cntx_found = False;
    node    one_node, one_scope_node;
    link    one_link;
    cntx    one_cntx;
    string  query, link_query;

    query = "node[node_refs[file_id == ${one_file.id}] && type != FormalCaller] sort by type, name";

    for_each_in_select(query, one_node)
    {
	if (objs_found == False)
	{
            maybe_print_page_break();
	    paragraph(Section2Format);
	    print("Nodes for " + app_type_print_string(one_file) + 
		    ": " + one_file.name);
	    paragraph(SeparatorFormat); print("");
	    objs_found = True;
	    printed_something_on_page();
	}

	node_print(one_node, 1, include_annotations, "", "");
    }

//	we don't use this anymore as it is too slow and takes up
//	too much space whilst evaluating
//    link_query = "&& (cntxs[cntx_refs] || annot_file_id != 0)";

    objs_found = False;
    id_list_create("link[link_refs[file_id == ${one_file.id}]]", "file_links");

    query = "link[file_links] sort by type, name";

    for_each_in_select(query, one_link)
    {
	    // this implements the complex && || expression
	if ( one_link.annot_file_id == 0 )
	{
	    one_cntx = find_by_query( "cntx[ link_id = " + one_link.id + " && cntx_refs ]" );
	    if ( one_cntx == NULL )
		continue;
	}

	if (objs_found == False)
	{
            maybe_print_page_break();
	    paragraph(Section2Format);
	    print("Links for " + one_file.name +
		    ": " + one_file.name);
	    paragraph(SeparatorFormat); print("");
	    objs_found = True;
	    printed_something_on_page();
	}

	link_print(one_link, 1, "", "");
	cntx_found = False;

	query = "cntx[link_id == ${one_link.id} && cntx_refs ] sort by type, name";

	for_each_in_select(query, one_cntx)
	{
	    cntx_found = True;
	    cntx_print(one_cntx, 2, True, "", "");
	    printed_something_on_page();
	}
    }
    id_list_free("file_links");
    return errors;
}

//
// node_print()
//
// print a node's type, name and signature (if not null)
// call function to print annotation (if it is to be included)
// 

int
node_print(node one_node, int level, boolean include_annots, string prefix, string paragraph)
{
    int errors = 0;
    string this_paragraph;

    if (paragraph == NULL || paragraph == "")
	paragraph = ObjectFormat;

    if (level <= 0)
	this_paragraph = paragraph + "1";
    else
	this_paragraph = paragraph + level;

    paragraph(this_paragraph);
    print(prefix + app_type_print_string(one_node) + ": " + one_node.name);

    if (one_node.sig != NULL && one_node.sig != "")
	print(" (" + one_node.sig + ")");

    if (include_annots)
    {
	annot_print(one_node.id, level);
	paragraph(SeparatorFormat); print("");
    }

    scope_print(one_node.scope_node_id, level);
    paragraph(SeparatorFormat); print("");

    printed_something_on_page();
    return errors;
}

//
// link_print()
//
// print a link's type, name and signature (if not null)
// print the link's from and to nodes (with their annotations)
// call function to print annotation (if it is to be included)
// 

int
link_print(link one_link, int level, string prefix, string paragraph)
{
    int errors = 0;
    node one_node;
    string this_paragraph;

    if (paragraph == NULL || paragraph == "")
	paragraph = ObjectFormat;

    if (level <= 0)
	this_paragraph = paragraph + "1";
    else
	this_paragraph = paragraph + level;

    paragraph(this_paragraph);
    print(prefix + app_type_print_string(one_link) + ": " + one_link.name);

    if (one_link.sig != NULL && one_link.sig != "")
	print(" (" + one_link.sig + ")");

    for_each_in_select("node[id == ${one_link.from_node_id} || " +
	    "id == ${one_link.to_node_id}]", one_node)
    {
	if (one_node.id == one_link.from_node_id)
	    node_print(one_node, level + 1, False, "From ", "");
	else
	if (one_node.id == one_link.to_node_id)
	    node_print(one_node, level + 1, False, "To ", "");
    }

    if (include_annotations)
    {
        annot_print(one_link.id, level);
        paragraph(SeparatorFormat); print("");
    }

    printed_something_on_page();
    return errors;
}

//
// cntx_print()
//
// print a cntx's type, name and signature (if not null)
// call function to print annotation (if it is to be included)
// 

int
cntx_print(cntx one_cntx, int level, boolean include_annot, 
	string prefix, string paragraph)
{
    int errors = 0;
    link one_link;
    string this_paragraph;

    if (paragraph == NULL || paragraph == "")
	paragraph = ObjectFormat;

    if (level <= 0)
	this_paragraph = paragraph + "1";
    else
	this_paragraph = paragraph + level;

    paragraph(this_paragraph);
    print(prefix + app_type_print_string(one_cntx) + ": " + one_cntx.name);

    if (one_cntx.sig != NULL && one_cntx.sig != "")
	print(" (" + one_cntx.sig + ")");

    if (include_annotations)
    {
	annot_print(one_cntx.id, level);
	paragraph(SeparatorFormat); print("");
    }
    printed_something_on_page();
    return errors;
}

//
// annot_print()
//
// print an object's notes' type, and name 
//   print note description line by line
//   print a note's item's type, value
// 

int
annot_print(int objid, int level)
{
    note one_note;
    item one_item;
    int errors = 0;
    int line;
    list note_lines;
    string	query;

    query  = "note[obj_id == ${objid} && type != GenericObject ] sort by type, name";

    for_each_in_select(query, one_note)
    {
	paragraph(NoteFormat + level);
	print(app_type_print_string(one_note) + ": " + one_note.name);

	if (one_note.desc != NULL && one_note.desc != "" )
	{
	    note_lines = string_to_list(one_note.desc, "\n");
	    for (line = 0; line < list_count(note_lines); line = line + 1)
	    {
		paragraph(DescriptionFormat + level);
		print(list_get(note_lines, line));
	    }
	}

	for_each_in_select("item[note_id == ${one_note.id} && type != CodeGenId] " +
		"sort by type, value", one_item)
	{
	    paragraph(ItemFormat + level);
	    print(app_type_print_string(one_item) + ": " + one_item.value);
	}
    }
    printed_something_on_page();
    return errors;
}

//
// scope_print()
//
// print an object's file and directory scope
//
 
int
scope_print(int scopeid, int level)
{
    int		errors = 0;
    node	file_scope = NULL;
    node	dir_scope = NULL;
    string	query;
 
    query  = "node[id == ${scopeid} && SEFile]";
    file_scope = find_by_query(query);

    if (file_scope != NULL)
    {
        paragraph(NoteFormat + level);
        print(app_type_print_string(file_scope) + ": " + file_scope.name);

	query  = "node[id == ${file_scope.scope_node_id} && SEDirectory]";
	dir_scope = find_by_query(query);
    }

    if (dir_scope != NULL)
    {
        paragraph(NoteFormat + level);
        print(app_type_print_string(dir_scope) + ": " + dir_scope.name);
    }

    printed_something_on_page();
    return errors;
}


