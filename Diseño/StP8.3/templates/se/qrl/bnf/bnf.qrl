
// 	StP/SE
// 	Confidential property of Aonix
// 	Copyright (c) 1992-1999
// 	All rights reserved

#include "ct/qrl/include/files.inc"
#include "ct/qrl/include/return_codes.inc"

external string files = "";
external_help = "The name(s) of the diagram(s) for BNF creation.";

external string output_dir = "";
external_help = "The directory location for the generated BNF file.";

script_help = "This template displays the data structure definition in BNF-format";

int main()
{
    int    	i, errors = 0, err1;
    list   	filelist;
    file   	fileobj;
    int    	list_size;
    string	directory, s;	

    if (output_dir == "")
	directory = path_compose(current_projdir(),
				 current_system(), 
				 "dse_files");
    else directory = output_dir;

    filelist = file_list("DseDiagram", files);
    list_size = list_count(filelist);

    if (list_size == 0) 
    { 
	ide_error("No files found."); 
	errors = errors + 1;
    } 
    else
    {
	for (i = 0; i < list_size; i++)
	{
	    fileobj = list_get(filelist, i);
	    err1 = file_history(fileobj);
	    if (err1 == 0) 
	    {
                // SPR 2424
		s = create_bnf(fileobj);
                if (s == "")
                {
		    print_error("No BNF to generate for diagram '" + fileobj.name + "'.");
                    errors++;
                }
                else
                {
		    write_file(path_compose(directory, fileobj.name + ".bnf"), s);
		    print_message("BNF generated for '" + fileobj.name + "' in " + path_compose(directory, fileobj.name + ".bnf"));
                }
	    }
            else 
                errors++; // filehist. error
	}
    }

    if (errors == 0)
        print_message("BNF generation completed successfully.");
    else
	print_message("BNF generation completed with " + errors + " errors.");

    return(errors);
}


int
idehook_dse_generate_bnf_active_func()
 
{
    string filename;
    file f;

    filename = gde_diagram_name();

    if (filename == "")
        return ACTIVE_FUNC_IS_INACTIVE;

    f = find_by_query("file[DseDiagram && name == '${filename}']");
 
    if (gde_is_modified() || f == NULL || file_history(f))
        return ACTIVE_FUNC_IS_INACTIVE;

    return ACTIVE_FUNC_IS_ACTIVE;
}



void
generate_bnf_from_dse()

{
    string path, s, fname;
    file f;
    int count;

    // SPR 2424
    // The active function makes it so very little error checking needed before calling
    // The qrl function

    fname = gde_diagram_name();
    f = find_by_query("file[DseDiagram && name == '${fname}']");

    path = path_compose(current_projdir(),
			current_system(), 
			"dse_files",
			fname + ".bnf");

    s = create_bnf(f);
    if (s == "")
        print_error("No objects in this diagram to generate BNF for.");
    else
    {
        write_file(path, s);
        print_message("BNF generated in " + path + ".");
    }
    return;
}




//
// creates a bnf-format for each structure in the diagram
//
string
create_bnf(file fileobj)
{
    node structure;
    string query, contents = "";

    // We'll repeatedly examine these sets of objects
    query = "node[node_refs[file[DseDiagram]]]";
    id_list_create(query, "dse_defs");

    query = "link[link_refs[file_id == ${fileobj.id}]]";
    id_list_create(query, "file_links");

    query = "node[node_refs[file_id==${fileobj.id} && !in_link_refs] && (Sequence || Selection || Enumeration || Typedef)]";
    for_each_in_select(query, structure)
    {
	contents = contents + do_bnf("dse_defs", "file_links", structure);
    }

    return contents;
    
}


// 
// A recursive function which goes all the way to the roots and
// prints out the type of each leaf node. Then it goes back up
// and prints the parent with all his children.
// If a leaf element doesn't have a DataType annotation, then it 
// defaults to "int" ie:   a ::= int
string
do_bnf(string dse_defs, string file_links, node structure)
{
    int i;
    string query;		    // all the children of 'structure'
    list children;
    int num_children;
    node child;
    string separator;		    // either '|' or '+'
    string contents = "";

    query = "node[${dse_defs} && in_links[${file_links} && " +
	    "from_node_id == ${structure.id}]]";

    // go thru all the children
    children = list_select(query);
    num_children = list_count(children);

    for (i = 0; i < num_children; i++)
    {
	child = list_get(children, i);
	contents = contents + do_bnf(dse_defs, file_links, child);
    }

    if (num_children == 0)
    {
	contents = contents + print_leaf(structure);
    }
    else
    {
	separator = get_separator(structure.type);
	contents = contents + structure.name + " ::= ";

	if (structure.type == "Selection" || structure.type == "Enumeration")
	{
	    contents = contents + "[ " 
			+ print_children(children, num_children, separator)
			+ " ]\n";
	}
	else
	{
	    contents = contents 
			+ print_children(children, num_children, separator)
			+ "\n";
	}
    }

    return contents;
}


// 
// returns the node type
//
string
get_node_type(int id)
{
    string query;
    item item_var;

    query = "item[DataType && obj_id = ${id}]";
    item_var = find_by_query(query);
    if (item_var != NULL)
	return(item_var.value);
    else
	return("int");
}





//
// Prints the structure's immediate children, separated by 'sep'
//
string
print_children(list children, int count, string sep)
{
    int i;
    node one_child;
    string contents = "";

    if (count >= 0 )
    {
        one_child = list_get(children,0);
	contents = one_child.name;
    }

    for (i = 1; i < count; i++)
    {
        one_child = list_get(children,i);
        contents = contents + sep + one_child.name;
    } 

    return contents;
}


//
// Used when printing each child level. The separator is determined
// by the node type.
string
get_separator(string node_tp)
{
    if (node_tp == "Sequence")
	return(" + ");
    else if (node_tp == "Selection" || node_tp == "Enumeration")
	return(" | ");
    else
	return(" ");
}



//
// Prints the name of the leaf node, along with its DataType annotation
//
string
print_leaf(node structure)
{
    string	node_type;
    int		num_values = 0;
    string	contents = "";


    contents = structure.name + " ::= " + get_node_type(structure.id) + "\n";

    contents = contents + print_allowed_values(structure);

    return contents;
}	

// 
// Prints out the allowed values of the data element
//
string
print_allowed_values(node structure)
{
    string	node_type;
    boolean 	first_time = True;
    string 	query;
    int 	query_count;
    item 	one_value;
    string	contents = "";

    query = "item[AllowedValue && obj_id = ${structure.id}]";
    query_count = selection_count(query);

    for_each_in_select(query, one_value)
    {
	if (first_time == True)
	{
	    contents = structure.name + " ::= *";
	    first_time = False;
	    if (query_count > 1)
		contents = contents + "[ ";
	    contents = contents + one_value.value;
	}
	else
	    contents = contents + " | " + one_value.value;
    }
    if (query_count > 1)
	contents = contents + " ]";	

    contents = contents + print_data_item_value(structure, query_count, "Precision");
    contents = contents + print_data_item_value(structure, query_count, "Units");

    if (contents != "")
	contents = contents + "*\n";

    return(contents);
}


string
print_data_item_value(node structure, int num_previous_values, 
    string item_name)
{
    string 	query;
    item 	item_var;
    string	contents = "";

    query = "item[${item_name} && obj_id = ${structure.id}]";
    item_var = find_by_query(query);
    if (item_var != NULL)
    {
	if (num_previous_values == 0)
	{
	    contents = structure.name + " ::= *";
	}
	else
	{
	    contents = ", ";
	}

	contents = contents + item_name + " " + item_var.value;
    }

    return(contents);
}
