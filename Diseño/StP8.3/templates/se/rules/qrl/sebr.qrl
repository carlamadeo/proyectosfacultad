//
//      sccsid[] = %W% %Y% %D%
//      StP/SE
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1994
//      All rights reserved

/*
 * Public Functions:
 */

// general qrl utility functions
#include "rules/qrl/ct.inc"

const int FALSE = 0;
const int TRUE = 1;

// this comes from the core
#include "rules/qrl/qrl_std.inc"
#include "rules/qrl/gte_qrl_std.inc"

// gte utility functions
#include "rules/qrl/gte.inc"

// support for transitive closure of class lattice (adjacency matrices)
#include "rules/qrl/se_graph.inc"  

// navigating to data flows
#include "rules/qrl/dfe_navigate.inc"  

// browser global variables

/* append at end or from current selection? */
int gte_append_from_current_selection = FALSE; 	

/* visibility of semantic groups */
int se_qbe_is_visible = TRUE;
int se_oid_is_visible = FALSE;

int se_model_hsect_group_is_visible = TRUE;
int se_module_hsect_group_is_visible = TRUE;
int se_parameter_hsect_group_is_visible = TRUE;
int se_process_hsect_group_is_visible = TRUE;
int se_flow_hsect_group_is_visible = TRUE;
int se_adt_hsect_group_is_visible = TRUE;

/* semantic sorts */
list se_models = list_create("file", 0);
list se_modules = list_create("node", 0);
list se_parameters = list_create("cntx", 0);
list se_processes = list_create("node", 0);
list se_flows = list_create("link", 0);
list se_adts = list_create("node", 0);

/***************************************************************************************
 * STARTUP FUNCTION
 */

void
EditorStartupFunction()
{
  /* disable standard "fine-grained" hide/show dialog */
  gte_disable_hideshow_dialog();

  /* register a drop handler for files and classes desktop palettes */
  gte_stpem("EditorDragDropDone 2000 DragDropDone();");

  /* when the editor is started, compile generalizations */
  SEBrowserCompileGraph
();
}

/***************************************************************************************
 * DRAG AND DROP SUPPORT
 */

int
DragDropDone()
{
  /* drop handler for otbr */

  string	apptype, label, dmsg, tp;

  dmsg = toolinfo_variable("DropMessage");
  // message("message " + dmsg);

  if (dmsg == NULL)
    return(0);

  if (string_length(dmsg) == 0)
    return(0);

  /* If the message begins with root_part, it must be a file object
   * that was dropped.
   * The type and label are not be defined for files (should they be?),
   * so handle this drop in a distinct way */

  if (root_part(dmsg) != NULL) 
    return DragDropFileDone(dmsg);

  /* some other type of object was dropped -- get apptype and label */
  apptype = toolinfo_variable("DropType");
  if (apptype == NULL)
    return(0);

  label = toolinfo_variable("DropLabel");
  if (label == NULL)
    return(0);

  return DragDropOMSObjectDone(apptype, label);
}

int
DragDropFileDone(string full_file_name)
{
  list          file_name_tokens;
  string        file_type, file_name, query;
  int i;


  full_file_name = file_part(full_file_name);

  /* get the name and type of the diagram file by parsing name.type */
  file_name_tokens = string_to_list(full_file_name, ".");
  if (list_count(file_name_tokens) < 2)
    return (0);
  
  file_type = list_get(file_name_tokens, list_count(file_name_tokens) - 1);
  if (file_type != "ome")
    return (0);

  file_name = "";
  for (i = 0; i < list_count(file_name_tokens) - 1; i = i + 1)
    file_name = file_name + list_get(file_name_tokens, i);

  /* finally, browse the result: the easy part! */
  query = "file[DfeDiagram || SceDiagram && name == \'" + file_name + "\']";
  SEQuery(query, FALSE, FALSE);

  return(1);
}

int
DragDropOMSObjectDone(string apptype, string label)
{
  string query;

  if (apptype != "Module" || apptype != "Process")
    return (0);

  /* browse the object */
  query = "node[" + apptype + " && name = \'" + label + "\']";
  SEQuery(query, FALSE, FALSE);
  
  return(1);
}

/***********************************************************************************
 * QUERY BY EXAMPLE
 */

int
idehook_is_row_with_query()
{
  /* active func for query by example */

  int hs, r;
  r = gte_get_current_cell_row();
  hs = gte_get_hsect(r);
  if (gte_row_has_query(hs, 1, gte_get_first_row(hs) - r + 1))
    return ACTIVE_FUNC_IS_ACTIVE;
  return ACTIVE_FUNC_IS_INACTIVE;
}

void
SEBrowserFill()
{
    // fill the whole browser
    int i;
    string query;
    int SE_MODEL_QBE_HSECT = gte_lookup_symbol("SE_MODEL_QBE_HSECT");
    int MODULE_QBE_HSECT = gte_lookup_symbol("MODULE_QBE_HSECT");
    int PARAMETER_QBE_HSECT = gte_lookup_symbol("PARAMETER_QBE_HSECT");
    int PROCESS_QBE_HSECT = gte_lookup_symbol("PROCESS_QBE_HSECT");
    int FLOW_QBE_HSECT = gte_lookup_symbol("FLOW_QBE_HSECT");
    int ADT_QBE_HSECT = gte_lookup_symbol("ADT_QBE_HSECT");
 
    query = gte_row_build_query(SE_MODEL_QBE_HSECT, 1, gte_get_first_row(SE_MODEL_QBE_HSECT) - gte_get_first_row(SE_MODEL_QBE_HSECT) + 1);
    if (query == NULL || query == "") 
    {
        gte_print_error("Can't build a query for SE Models.");
	return;
    }
    SEQuery(query, FALSE, FALSE);

    query = gte_row_build_query(MODULE_QBE_HSECT, 1, gte_get_first_row(MODULE_QBE_HSECT) - gte_get_first_row(MODULE_QBE_HSECT) + 1);
    if (query == NULL || query == "") 
    {
        gte_print_error("Can't build a query for Modules.");
	return;
    }
    SEQuery(query, FALSE, FALSE);

    query = gte_row_build_query(PARAMETER_QBE_HSECT, 1, gte_get_first_row(PARAMETER_QBE_HSECT) - gte_get_first_row(PARAMETER_QBE_HSECT) + 1);
    if (query == NULL || query == "") 
    {
        gte_print_error("Can't build a query for Parameters.");
	return;
    }
    SEQuery(query, FALSE, FALSE);

    query = gte_row_build_query(PROCESS_QBE_HSECT, 1, gte_get_first_row(PROCESS_QBE_HSECT) - gte_get_first_row(PROCESS_QBE_HSECT) + 1);
    if (query == NULL || query == "") 
    {
        gte_print_error("Can't build a query for Processes.");
	return;
    }
    SEQuery(query, FALSE, FALSE);

    query = gte_row_build_query(FLOW_QBE_HSECT, 1, gte_get_first_row(FLOW_QBE_HSECT) - gte_get_first_row(FLOW_QBE_HSECT) + 1);
    if (query == NULL || query == "") 
    {
        gte_print_error("Can't build a query for Flows.");
	return;
    }
    SEQuery(query, FALSE, FALSE);

    query = gte_row_build_query(ADT_QBE_HSECT, 1, gte_get_first_row(ADT_QBE_HSECT) - gte_get_first_row(ADT_QBE_HSECT) + 1);
    if (query == NULL || query == "") 
    {
        gte_print_error("Can't build a query for Abstract Data Types.");
	return;
    }
    SEQuery(query, FALSE, FALSE);

}

void
SEQueryByExample()
{
  /* Consider the current row as a pattern describing a set of matching SE objects.
   * Express a query from the row using the Query rule for the row type.
   * Solve the query, then browse the results. */

  int hs, r;
  string query;

  /* get current row */
  r = gte_get_current_cell_row();
  hs = gte_get_hsect(r);

  /* build a query from current row */
  query = gte_row_build_query(hs, 1, gte_get_first_row(hs) - r + 1);
  if (query == NULL || query == "") {
    gte_print_error("Can't build a query from the current row");
    return;
  }
  
  /* execute the query */
  SEQuery(query, FALSE, FALSE);
}

void
SEExpressQueryFromExample()
{
  /* Consider the current row as a pattern describing a set of matching SE objects.
   * Express a query from the row using the Query rule for the row type,
   * place the query in the query dialog text buffer,
   * then popup the query dialog. */

  int hs, r;
  string query;

  /* get current row */
  r = gte_get_current_cell_row();
  hs = gte_get_hsect(r);

  /* build a query from current row */
  query = gte_row_build_query(hs, 1, gte_get_first_row(hs) - r + 1);
  if (query == NULL || query == "") {
    gte_print_error("Can't build a query from the current row");
    return;
  }

  /* put the query in the query dialog, and pop it up */

  gte_query_dialog_set(query);	
  gte_stpem("QueryDialogShow");
  
}

/***********************************************************************************************
 * QUERY EXECUTES THE QUERY (FROM THE QUERY DIALOG)
 * (the query dialog expects a qrl function with this name)
 */

void
query(string query, int clear, int autoadjust)
{
  SEQuery(query, clear, autoadjust);
}

void
SEQuery(string query, int clear, int autoadjust)
{
  int count;
  string query_type;
  set results;

  gte_print_message("Executing query '" + query + "'...");

  query_type = GetQueryOMSReturnType(query);
  if (query_type == NULL)
    return;

  /* distinguish a query has a syntax error from a query that returns no objects */
  results = NULL;
  results = set_select(query);
  if (results == NULL) {
    gte_print_error("The query '" + query + "' contains a syntax error.");
    return;
  }

  if (clear)
    SEBrowserClearContents();

  /* browse the results of the query */
  SEBrowse(results, query_type, TRUE, TRUE, autoadjust);
  return;
}

string
GetQueryOMSReturnType(string query)
{
  /* return the return type of an OMS query */

  string query_type;
  list query_list;

  query_list = string_to_list(query, "[");
  if (list_count(query_list) == 0) {
    gte_print_error("The query '" + query + "' is not of the proper form for browsing.");
    return NULL;
  }

  query_type = list_get(query_list, 0);
  if (!(query_type == "node" || query_type == "link" || query_type == "file" || query_type == "cntx")) {
    gte_print_error("The query '" + query + "' must return either nodes, links, or files.");
    return NULL;
  }

  return query_type;
}

/************************************************************************************
 * HYPERBROWSE 
 */

void
SEHyperbrowse(string query)
{
  set results;
  string return_type;
  int first_row, last_row, current_row, count;

  /* measure selection in rows, but stop at section end (need homogenous semantics). */
  first_row = gte_get_first_row_in_selected();
  last_row = min(gte_get_last_row_in_selected(), gte_get_last_row(gte_get_hsect(first_row)));

  /* get query return type */
  return_type = GetQueryOMSReturnType(query);
  if (return_type == NULL)
    return;

  /* evaluate the query for every element in the selection */
  results = SEHyperbrowseEvaluateQuery(query, return_type, first_row, last_row);
  if (results == NULL)
    return;

  SEBrowse(results, return_type, TRUE, TRUE, FALSE);


  return;
}

/*
 * I make 2 strong assumptions in the design of the SE browser:
 * -- each row describes a single object, whose oid is stored in column 1
 * -- queries about objects related to this object make use only of the object id
 */
const int OID_COL = 1; 
const int OBJECT_NAME_COL = 2;  // absolute, not relative value 

set
SEHyperbrowseEvaluateQuery(string query, string return_type, int first_row, int last_row)
{
  /* returns a list of objects resulting from applying the query to every element of the selection */

  set all_query_results, one_query_results;
  string old_id, new_id;
  int current_row;

  /* initialize the set -- check for illegal query within the loop */
  all_query_results = set_create(return_type);

  /* initialize first id */
  old_id = gte_get_cell_label(first_row, OID_COL);

  /* invalid id check */
  if (old_id == NULL || old_id == "" || !string_converts(old_id, "int"))
    return all_query_results;

  /* evaluate the query for each element of the selection */
  for (current_row = first_row; current_row <= last_row; current_row = current_row + 1) {

    /* get new id */
    new_id = gte_get_cell_label(current_row, OID_COL);

    /* invalid id check */
    if (new_id == NULL || new_id == "" || !string_converts(new_id, "int"))
      continue;

    /* substitute ids in query */
    query = string_search_and_replace(query, old_id, new_id);

    /* save id */
    old_id = new_id;
	
    /* issue the query, and check its syntax. if there's an error abort the loop */
    one_query_results = NULL;
    one_query_results = set_select(query);

    if (one_query_results == NULL) {
      gte_print_error("The query '" + query + "' contains a syntax error.");
      return NULL;
    }
		
    /* union the results */
    set_union(all_query_results, one_query_results);
  }
  return all_query_results;
}

/************************************************************************************
 * special versions of hyperbrowse where the simple model of iterative query substitution fails
 */

void
SEHyperbrowseModelContents()
{
  /* browse model's entire contents */

  set node_results, link_results;
  int first_row, last_row, current_row, count;
  string oid, all_nodes_query, all_links_query;

  /* measure selection in rows, but stop at section end (need homogenous semantics). */
  first_row = gte_get_first_row_in_selected();
  last_row = min(gte_get_last_row_in_selected(), gte_get_last_row(gte_get_hsect(first_row)));

  oid = gte_get_cell_label(first_row, OID_COL);
  all_nodes_query = "node[node_refs[file_id==" + oid + "]]";
  all_links_query = "link[link_refs[file_id==" + oid + "]]";

  /* evaluate both queries for every element in the selection */
  node_results = SEHyperbrowseEvaluateQuery(all_nodes_query, "node", first_row, last_row);
  link_results = SEHyperbrowseEvaluateQuery(all_links_query, "link", first_row, last_row);

  /* browse the combined results using the browser transaction feature */
  SEBrowse(link_results, "link", TRUE, TRUE, FALSE);
  /* highlight the nodes first */
  SEBrowse(node_results, "node", TRUE, TRUE, FALSE);

  return;
}

const string PARENT = "parent";
const string CHILD =   "child";

void
SEHyperbrowseAllParents()
{
  SEHyperbrowseClosureModules(PARENT);
  return;
}
  
void
SEHyperbrowseAllChildren()
{
  SEHyperbrowseClosureModules(CHILD);
  return;
}

void
SEHyperbrowseClosureModules(string atomic_relation)
{
  set all_query_results, one_query_results;
  string query, classname;
  int first_row, last_row, current_row, count;

  /* measure selection in rows, but stop at section end (need homogenous semantics). */
  first_row = gte_get_first_row_in_selected();
  last_row = min(gte_get_last_row_in_selected(), gte_get_last_row(gte_get_hsect(first_row)));

  /* initialize the set */
  all_query_results = set_create("node");

  /* evaluate a single-source transitive closure query for each element of the selection */
  for (current_row = first_row; current_row <= last_row; current_row = current_row + 1) {

    /* get next class name */
    classname =  gte_get_cell_label(current_row, OBJECT_NAME_COL);

    if (classname == NULL || classname == "") 
      continue;

    /* form a query */
    query = SEBuildClosureModulesQuery(classname, atomic_relation);
    if (query == NULL)
      continue;

    /* evaluate the query */
    one_query_results = NULL;
    one_query_results = set_select(query);
    if (one_query_results == NULL) {
      gte_print_error("The query '" + query + "' contains a syntax error.");
      return NULL;
    }
		
    /* union the results */
    set_union(all_query_results, one_query_results);
  }

  /* browse the results */
  SEBrowse(all_query_results, "node", TRUE, TRUE, FALSE);
  return;
}

string
SEBuildClosureModulesQuery(string classname, string atomic_relation)
{
  /* Builds an explicit disjunction enumerating all of the class names in the transitive closure.
   * Probably much faster than iterating. */

  /* can generalize to deal with other atomic relations as well
   * e.g aggregation and association */

  string query;
  list closure_classes = NULL;   /* list of class names */
  int i;
  
  if (atomic_relation == PARENT)
    closure_classes = SEBrowserFastModuleAllParents(classname);
  else if (atomic_relation == CHILD)
    closure_classes = SEBrowserFastModuleAllChildren(classname);

  if (closure_classes == NULL || list_count(closure_classes) == 0)
    return NULL;

  /* query has the form: node[OMTClass && (name == 'c1' || name == 'c2' || ... || name = 'ck')]
   * note: the parenthesis are crucial for getting any speed at all out of sybase,
   * probably because of the implementation of the SE->SQL query transducer */

  query = "node[OMTClass && node_refs && (name =='" + list_get(closure_classes, 0) + "'";
  for (i = 1; i < list_count(closure_classes); i = i + 1) 
    query = query + " || name == '" + list_get(closure_classes, i) + "'";
  query = query + ")]";
  
  return query;
}

/*************************************************************************************
 * WORKHORSE: BROWSE FUNCTION -- BROWSES COLLECTIONS OF KNOWN OMS TYPE
 */

void
SEBrowse(set objects, string object_type, int open_transaction, int close_transaction, int autoadjust)
{
    int             count;
    int             found_oid = 0;

    /* When opening browse transaction, clear all the sorts. */
    if (open_transaction)
	SEBrowserClearSorts();

    /* Sort the objects into separate lists according to their SE semantics. */
    SEBrowserSortObjects(objects, object_type);

    /*
     * When ending browse transaction, fill the table and display the new
     * objects.
     */
    if (close_transaction)
    {

	/* Count the number of objects were successfully categorized. */
	count = SEBrowserCountSortedObjects();

	/* turn off refresh while we are filling the table */
	gte_disable_refresh();
	if (count == 0)

	    /* no results were found in the repository */
	    gte_print_message("No SE objects found in the repository.");
	else if (count == 1)

	    /*
	     * try to browse "in-line" if only one object was returned from
	     * the repository
	     */
	    SEBrowseOneObject(SEBrowserGetFirstNewOid(), object_type);
	else
	{

	    /*
	     * append to browser if multiple objects were returned from the
	     * repository
	     */
	    SEBrowseManyObjects(objects, SEBrowserGetFirstNewOid(), object_type, count);
	}

	/* assert that the sections with new objects are visible */
	SEBrowserSetSemanticGroupVisibility(autoadjust);

	/* refresh the table */
	gte_enable_refresh();
	gte_refresh_table();
    }
    return;
}

void
SEBrowserClearSorts()
{
  /* clear all the existing categories */

  list_clear(se_models); 
  list_clear(se_modules); 
  list_clear(se_parameters); 
  list_clear(se_processes); 
  list_clear(se_flows); 
  list_clear(se_adts); 
}

int
SEBrowserCountSortedObjects()
{
  /* return a count of the sorted, waiting to be seen objects */

  return (list_count(se_models)
	  + list_count(se_modules)
	  + list_count(se_parameters)
	  + list_count(se_processes)
	  + list_count(se_flows)
	  + list_count(se_adts)
	  );
}

void
SEBrowserSortObjects(set objects, string object_type)
{
  /* Sort the objects into separate lists according to their SE semantics. */

  if (object_type == "file") 
    SEBrowserSortFiles(objects);
  else if (object_type == "node")
    SEBrowserSortNodes(objects);
  else if (object_type == "link")
    SEBrowserSortLinks(objects);
  else if (object_type == "cntx")
    SEBrowserSortCntxs(objects);
}

void
SEBrowserSortFiles(set files)
{
  /* sort files into object models, etc. */

  file f;
  int i;

  for (i = 0; i < set_count(files); i = i + 1) {
    f = set_get_element(files, i);
    if (f.type == "SceDiagram" || 
        f.type == "DfeDiagram") {
      list_append(se_models, f);
      continue;
    }
  }
  return;
}

void
SEBrowserSortNodes(set nodes)
{
    node node;
    int i;
    link l;
    string query;

    for (i = 0; i < set_count(nodes); i = i + 1) 
    {
	node = set_get_element(nodes, i);
	if (node.type == "Module") 
	{
	    list_append(se_modules, node);
	    continue;
	}
	if (node.type == "Process") 
	{
	    list_append(se_processes, node);
	    continue;
	}
	if (node.type == "Sequence")
	{
	    // This is going to slow things down, but is a flaw with the model of this browser
	    query = "link[from_node_id == ${node.id} || to_node_id == ${node.id}]";
	    l = find_by_query(query);

	    if (l != NULL)
		list_append(se_adts, node);

	    continue;
	}
    }
    return;
}

void
SEBrowserSortLinks(set links)
{
  /* sort links into roles, constraints etc. */

  link link;
  int i;

  for (i = 0; i < set_count(links); i = i + 1) {
    link = set_get_element(links, i);
    if (link.type == "ControlFlow") {
      list_append(se_flows, link);
      continue;
    }
    if (link.type == "DataFlow") {
      list_append(se_flows, link);
      continue;
    }
  }
}

void
SEBrowserSortCntxs(set cntxs)
{
    cntx cntx;
    int i;

    for (i = 0; i < set_count(cntxs); i = i + 1) 
    {
	cntx = set_get_element(cntxs, i);
	if (cntx.type == "DataIn")
	{
	    list_append(se_parameters, cntx);
	    continue;
	}
	if (cntx.type == "DataOut")
	{
	    list_append(se_parameters, cntx);
	    continue;
	}
	if (cntx.type == "DataInOut")
	{
	    list_append(se_parameters, cntx);
	    continue;
	}
	if (cntx.type == "ControlIn")
	{
	    list_append(se_parameters, cntx);
	    continue;
	}
	if (cntx.type == "ControlOut")
	{
	    list_append(se_parameters, cntx);
	    continue;
	}
    }
}

int
SEBrowserGetFirstNewOid()
{
    /* return the oid of the first new browsed object */

    int found_oid = 0;
    file f;
    node n;
    link l;
    cntx c;
 
    if (list_count(se_models) > 0) 
    {
        f = list_get(se_models, 0);
        return f.id;
    }
    if (list_count(se_modules) > 0) 
    {
        n = list_get(se_modules, 0); 
        return n.id;
    }
    if (list_count(se_parameters) > 0) 
    {
        c = list_get(se_parameters, 0); 
        return c.id;
    }
    if (list_count(se_processes) > 0) 
    {
        n = list_get(se_processes, 0);
        return n.id;
    }
    if (list_count(se_flows) > 0) 
    {
        l = list_get(se_flows, 0);
        return l.id;
    }
    if (list_count(se_adts) > 0) 
    {
        n = list_get(se_adts, 0);
        return n.id;
    }
  
    return 0;
}

void
SEBrowseOneObject(int id, string result_type)
{
  /* in the special case there is one object, look for it in the table */

  /* look for it */
  if (SEBrowserFindSelectObject(id)) {

    /* already there, update it in place */
    gte_append_from_current_selection = TRUE;
    SEFillBrowser();
    gte_append_from_current_selection = FALSE;
  }
  else {
    /* if not found, append it, then select it */
    SEFillBrowser();
    SEBrowserFindSelectObject(id);
  }

  gte_print_message("1 SE object was retrieved from the repository.");
  return;
}

void
SEBrowseManyObjects(set results, int first_id, string result_type, int se_count)
{
  int id, r1, r2, i, safety;
  
  /* remove duplicates */
  for (i = 0; i < set_count(results); i = i + 1) {
    id = SEBrowserGetElementOid(results, result_type, i);
    for (safety = 0; safety < 10; safety = safety + 1) { 
      if (!SEBrowserFindDeleteObject(id))
	break;
    } 
  }

  /* append the query results via browse */
  SEFillBrowser();

  /* highlight them
   * find the (first) section we added things to by simply looking for
   * first_id in OID_COL, and then get the last row in that section */
  gte_stpem("BufferFindOpt -c -i +l +m +r");
  gte_find("^" + first_id + "$", gte_get_first_row(), OID_COL, gte_get_last_row(), OID_COL);
  r1 = gte_get_current_cell_row();
  r2 = gte_get_last_row(gte_get_hsect(r1));
  gte_set_selection_quietly(r1, gte_get_first_col(), r2, gte_get_last_col(),
			    r1, OBJECT_NAME_COL); 

  /* scroll the last one into view and the move to the first one
   * to ensure that the first one, which also contains the current cell, is in view */
  gte_goto(r2, OBJECT_NAME_COL);
  gte_goto(r1, OBJECT_NAME_COL);

  gte_print_message(se_count + " SE objects were retrieved from the repository.");

  return;
}

int SEBrowserGetElementOid(set set, string set_type, int index)
{
  file file;
  node node;
  link link;

  if (set_type == "file") { 
    file = set_get_element(set, index); 
    return file.id;
  }
  if (set_type == "node") {
    node = set_get_element(set, index);
    return node.id;
  }
  if (set_type == "link") {
    link = set_get_element(set, index);
    return link.id;
  }
  return 0;
}

int SEBrowserFindSelectObject(int id)
{
  int chs;
  gte_stpem("BufferFindOpt -c -i +l +m +r");
  if (gte_find("^" + id + "$", gte_get_first_row(), OID_COL, gte_get_last_row(), OID_COL)) {
    gte_set_selection_quietly(gte_get_current_cell_row(), gte_get_first_col(), 
			      gte_get_current_cell_row(), gte_get_last_col(),
			      gte_get_current_cell_row(), OBJECT_NAME_COL); 
    chs = gte_get_hsect(gte_get_current_cell_row());
    /* make the section and its header section (chs - 2) visible */
    /* gte_stpem("BufferHideShow +h " + (chs - 2) + " " + chs); */
    gte_filltable_string("FillTable{{Hsect{Index " + (chs - 2) + "}}{Hsect{Index " + chs + "}}}");
    return TRUE;
  }
  return FALSE;
}

int SEBrowserFindDeleteObject(int id)
{
  gte_stpem("BufferFindOpt -c -i +l +m +r");
  if (gte_find("^" + id + "$", gte_get_first_row(), OID_COL, gte_get_last_row(), OID_COL)) {
    gte_delete_row(gte_get_current_cell_row());
    return TRUE;
  }
  return FALSE;
}

/**********************
 * FILL BROWSER
 */

void
SEFillBrowser()
{
  /* 
   * Build hsect expressions from the lists.
   * Assemble these into a filltable and load it into the GTE.
   */

  string tempfile = temp_file("0", "se_fill_browser");

  write_file(tempfile,
	     "FillTable{ " + 
	     SEModelsHsectExpression(se_models) +
	     SEModulesHsectExpression(se_modules) +
	     SEParametersHsectExpression(se_parameters) +
	     SEProcessesHsectExpression(se_processes) +
	     SEFlowsHsectExpression(se_flows) +
	     SEAdtsHsectExpression(se_adts) +
	     "}");
  gte_filltable_file(tempfile);

  delete_file(tempfile); 
}

/*************************************************************************************
 * FUNCTIONS WHICH BUILD FILLTABLE COMPONENT EXPRESSIONS FROM LISTS OF OMS OBJECTS
 */

/* section level builders */

string
SEModelsHsectExpression(list diagrams)
{
  /* maps a list of SE diagrams to a filltable hsect expression */ 

  string id_vsect_expression, desc_vsect_expression, qbe_hsect_expression = ""; 
  file odiag;
  int i;

  /* no diagrams */
  if (list_count(diagrams) == 0) 
    return("");

  /* the object ids go in a separate (hideable) column, hence in a separate vsect */
  odiag = list_get(diagrams, 0);
  id_vsect_expression = SEIdentifierRowExpression(odiag.id, TRUE);
  for (i = 1; i < list_count(diagrams); i = i + 1) {
    odiag = list_get(diagrams, i);
    id_vsect_expression = id_vsect_expression + SEIdentifierRowExpression(odiag.id, FALSE);
  }
  id_vsect_expression = "{Vsect{Index ID_VSECT}" + id_vsect_expression + "}";

  /* append one row per diagram into a filltable vsect expression */
  odiag = list_get(diagrams, 0);
  desc_vsect_expression = SEDiagramRowExpression(odiag, TRUE);
  for (i = 1; i < list_count(diagrams); i = i + 1) {
    odiag = list_get(diagrams, i);
    desc_vsect_expression = desc_vsect_expression + SEDiagramRowExpression(odiag, FALSE);
  }
  desc_vsect_expression = "{Vsect{Index DESCRIPTION_VSECT}" + desc_vsect_expression + "}";

  /* if qbe is visible, make qbe visible for this hsect. */
  if (se_qbe_is_visible)
    qbe_hsect_expression = "{Hsect{Index SE_MODEL_QBE_HSECT}{Hidden False}}";

  return("{Hsect{Index SE_MODEL_HEADER_HSECT}{Hidden False}}"
	 + qbe_hsect_expression
	 + "{Hsect{Index SE_MODEL_HSECT}{Hidden False}" + id_vsect_expression + desc_vsect_expression + "}");
}

string
SEModulesHsectExpression(list modules)
{
  /* maps a list of SE modules to a filltable hsect expression */

  string id_vsect_expression, desc_vsect_expression, qbe_hsect_expression = ""; 
  node module;
  int i;

  /* no modules */
  if (list_count(modules) == 0) 
    return("");

  /* the object ids go in a separate (hideable) column, hence in a separate vsect */
  module = list_get(modules, 0);
  id_vsect_expression = SEIdentifierRowExpression(module.id, TRUE);
  for (i = 1; i < list_count(modules); i = i + 1) {
    module = list_get(modules, i);
    id_vsect_expression = id_vsect_expression + SEIdentifierRowExpression(module.id, FALSE);
  }
  id_vsect_expression = "{Vsect{Index ID_VSECT}" + id_vsect_expression + "}";

  /* append one row per module into a filltable vsect expression */
  module = list_get(modules, 0);
  desc_vsect_expression = SEModuleRowExpression(module, TRUE);
  for (i = 1; i < list_count(modules); i = i + 1) {
    module = list_get(modules, i);
    desc_vsect_expression = desc_vsect_expression + SEModuleRowExpression(module, FALSE);
  }
  desc_vsect_expression = "{Vsect{Index DESCRIPTION_VSECT}" + desc_vsect_expression + "}";

  /* if qbe is visible, make qbe visible for this hsect. */
  if (se_qbe_is_visible)
    qbe_hsect_expression = "{Hsect{Index MODULE_QBE_HSECT}{Hidden False}}";

  return("{Hsect{Index MODULE_HEADER_HSECT}{Hidden False}}"
	 + qbe_hsect_expression 
	 + "{Hsect{Index MODULE_HSECT}{Hidden False}" + id_vsect_expression + desc_vsect_expression + "}");
}

string
SEParametersHsectExpression(list parameters)
{
    /* maps a list of SE parameters to a filltable hsect expression */

    string id_vsect_expression, desc_vsect_expression, qbe_hsect_expression = ""; 
    cntx param;
    int i;

    /* no parameter */
    if (list_count(parameters) == 0) 
        return("");

  /* the object ids go in a separate (hideable) column, hence in a separate vsect */
  param = list_get(parameters, 0);
  id_vsect_expression = SEIdentifierRowExpression(param.id, TRUE);
  for (i = 1; i < list_count(parameters); i = i + 1) {
    param = list_get(parameters, i);
    id_vsect_expression = id_vsect_expression + SEIdentifierRowExpression(param.id, FALSE);
  }
  id_vsect_expression = "{Vsect{Index ID_VSECT}" + id_vsect_expression + "}";

  /* append one row per param into a filltable vsect expression */
  param = list_get(parameters, 0);
  desc_vsect_expression = SEParameterRowExpression(param, TRUE);
  for (i = 1; i < list_count(parameters); i = i + 1) {
    param = list_get(parameters, i);
    desc_vsect_expression = desc_vsect_expression + SEParameterRowExpression(param, FALSE);
  }
  desc_vsect_expression = "{Vsect{Index DESCRIPTION_VSECT}" + desc_vsect_expression + "}";

  /* if qbe is visible, make qbe visible for this hsect. */
  if (se_qbe_is_visible)
    qbe_hsect_expression = "{Hsect{Index PARAMETER_QBE_HSECT}{Hidden False}}";

  return("{Hsect{Index PARAMETER_HEADER_HSECT}{Hidden False}}"
	 + qbe_hsect_expression
	 + "{Hsect{Index PARAMETER_HSECT}{Hidden False}" + id_vsect_expression + desc_vsect_expression + "}");
}

string
SEProcessesHsectExpression(list processes)
{
  /* maps a list of SE processes to a filltable hsect expression */ 

  string id_vsect_expression, desc_vsect_expression, qbe_hsect_expression = ""; 
  node proc;
  int i;

  /* no processes */
  if (list_count(processes) == 0) 
    return("");

  /* the object ids go in a separate (hideable) column, hence in a separate vsect */
  proc = list_get(processes, 0);
  id_vsect_expression = SEIdentifierRowExpression(proc.id, TRUE);
  for (i = 1; i < list_count(processes); i = i + 1)
    {
      proc = list_get(processes, i);
      id_vsect_expression = id_vsect_expression + SEIdentifierRowExpression(proc.id, FALSE);
    }
  id_vsect_expression = "{Vsect{Index ID_VSECT}" + id_vsect_expression + "}";

  /* append one row per proc into a filltable vsect expression */
  proc = list_get(processes, 0);
  desc_vsect_expression = SEProcessRowExpression(proc, TRUE);
  for (i = 1; i < list_count(processes); i = i + 1)
    {
      proc = list_get(processes, i);
      desc_vsect_expression = desc_vsect_expression + SEProcessRowExpression(proc, FALSE);
    }
  desc_vsect_expression = "{Vsect{Index DESCRIPTION_VSECT}" + desc_vsect_expression + "}";

  /* if qbe is visible, make qbe visible for this hsect. */
  if (se_qbe_is_visible)
    qbe_hsect_expression = "{Hsect{Index PROCESS_QBE_HSECT}{Hidden False}}";

  return("{Hsect{Index PROCESS_HEADER_HSECT}{Hidden False}}"
	 + qbe_hsect_expression
	 + "{Hsect{Index PROCESS_HSECT}{Hidden False}" + id_vsect_expression + desc_vsect_expression + "}");
}

string
SEFlowsHsectExpression(list flows)
{
    /* maps a list of SE parameters to a filltable hsect expression */

    string id_vsect_expression, desc_vsect_expression, qbe_hsect_expression = ""; 
    link flow;
    int i;

    /* no flows */
    if (list_count(flows) == 0) 
        return("");

  /* the object ids go in a separate (hideable) column, hence in a separate vsect */
  flow = list_get(flows, 0);
  id_vsect_expression = SEIdentifierRowExpression(flow.id, TRUE);
  for (i = 1; i < list_count(flows); i = i + 1) {
    flow = list_get(flows, i);
    id_vsect_expression = id_vsect_expression + SEIdentifierRowExpression(flow.id, FALSE);
  }
  id_vsect_expression = "{Vsect{Index ID_VSECT}" + id_vsect_expression + "}";

  /* append one row per flow into a filltable vsect expression */
  flow = list_get(flows, 0);
  desc_vsect_expression = SEFlowRowExpression(flow, TRUE);
  for (i = 1; i < list_count(flows); i = i + 1) {
    flow = list_get(flows, i);
    desc_vsect_expression = desc_vsect_expression + SEFlowRowExpression(flow, FALSE);
  }
  desc_vsect_expression = "{Vsect{Index DESCRIPTION_VSECT}" + desc_vsect_expression + "}";

  /* if qbe is visible, make qbe visible for this hsect. */
  if (se_qbe_is_visible)
    qbe_hsect_expression = "{Hsect{Index FLOW_QBE_HSECT}{Hidden False}}";

  return("{Hsect{Index FLOW_HEADER_HSECT}{Hidden False}}"
	 + qbe_hsect_expression
	 + "{Hsect{Index FLOW_HSECT}{Hidden False}" + id_vsect_expression + desc_vsect_expression + "}");
}

string
SEAdtsHsectExpression(list adts)
{
  /* maps a list of SE abstract data types to a filltable hsect expression */ 

  string id_vsect_expression, desc_vsect_expression, qbe_hsect_expression = ""; 
  node adt;
  int i;

  /* no diagrams */
  if (list_count(adts) == 0) 
    return("");

  /* the object ids go in a separate (hideable) column, hence in a separate vsect */
  adt = list_get(adts, 0);
  id_vsect_expression = SEIdentifierRowExpression(adt.id, TRUE);
  for (i = 1; i < list_count(adts); i = i + 1) {
    adt = list_get(adts, i);
    id_vsect_expression = id_vsect_expression + SEIdentifierRowExpression(adt.id, FALSE);
  }
  id_vsect_expression = "{Vsect{Index ID_VSECT}" + id_vsect_expression + "}";

  /* append one row per diagram into a filltable vsect expression */
  adt = list_get(adts, 0);
  desc_vsect_expression = SEAdtRowExpression(adt, TRUE);
  for (i = 1; i < list_count(adts); i = i + 1) {
    adt = list_get(adts, i);
    desc_vsect_expression = desc_vsect_expression + SEAdtRowExpression(adt, FALSE);
  }
  desc_vsect_expression = "{Vsect{Index DESCRIPTION_VSECT}" + desc_vsect_expression + "}";

  /* if qbe is visible, make qbe visible for this hsect. */
  if (se_qbe_is_visible)
    qbe_hsect_expression = "{Hsect{Index ADT_QBE_HSECT}{Hidden False}}";

  return("{Hsect{Index ADT_HEADER_HSECT}{Hidden False}}"
	 + qbe_hsect_expression
	 + "{Hsect{Index ADT_HSECT}{Hidden False}" + id_vsect_expression + desc_vsect_expression + "}");
}

/* row level builders */

string 
SEIdentifierRowExpression(int oid, int first)
{
  /* construct an expression to fill a browser row with an SE object identifier
   * if first == true, then this is the first object in an collection */

  return("{Row" + SEBrowserRowIndexExpression(first) + "{Cell{Label \"" + oid +"\"}}}");
}

string
SEDiagramRowExpression(file odiag, int first)
{
  // construct an expression to fill a browser row with an SE diagram description
  // if first == true, then this is the first object in an collection
    
  string name_cell_exp, type_cell_exp;
  
  name_cell_exp = "{Cell{Index OBJECT_NAME_COL}{Label \"" + odiag.name + "\"}}";  
  type_cell_exp = "{Cell{Index DIAGRAM_TYPE_COL}{Label \"" + odiag.type + "\"}}";  
  
  return("{Row" + SEBrowserRowIndexExpression(first) + name_cell_exp + type_cell_exp + "}"); 
}

string
SEModuleRowExpression(node module, int first)
{
  // construct an expression to fill a browser row with an SE module description
  // if first == true, then this is the first object in an collection 
    
  list parent_names;
  string name_cell_exp, parents_cell_exp, parent_name;
  int i, nparents;
  
  name_cell_exp = "{Cell{Index OBJECT_NAME_COL}{Label \"" + filltable_string_escape(module.name) + "\"}}";  
  parents_cell_exp = "";

  /* use the compiled generalizations to describe the parents */
  if (SEBrowserModuleGraphIsCompiled()) {
    parent_names = SEBrowserFastModuleDirectParents(module.name);
    if (parent_names != NULL) {
      nparents = list_count(parent_names);
      if (nparents > 0) {
	parents_cell_exp
	  = "{Cell{Index MODULE_PARENTS_COL}{Label \"" + filltable_string_escape(list_get(parent_names, 0)) + "\"}}";  
	for (i = 1; i < nparents; i = i + 1) 
	  parents_cell_exp
	    = parents_cell_exp + "{Cell{Label \"" + filltable_string_escape(list_get(parent_names, i)) + "\"}}";  
      }
    }
  }
  
  return("{Row" + SEBrowserRowIndexExpression(first)  + name_cell_exp + parents_cell_exp + "}"); 
}

string
SEParameterRowExpression(cntx parameter, int first)
{
    // construct an expression to fill a browser row with an SE parameter description
    // if first == true, then this is the first object in an collection
    
    item item;
    string name_cell_exp, type_cell_exp = "", kind_cell_exp, query;
  
    name_cell_exp = "{Cell{Index OBJECT_NAME_COL}{Label \"" + filltable_string_escape(parameter.name) + "\"}}";  
    kind_cell_exp = "{Cell{Index PARAMETER_KIND_COL}{Label \"" + filltable_string_escape(parameter.type) + "\"}}";  

    query = "item[DataType && obj_id = ${parameter.id}]";
    item = find_by_query(query);

    if (item != NULL)
        type_cell_exp = "{Cell{Index PARAMETER_TYPE_COL}{Label \"" + 
            filltable_string_escape(item.value) + "\"}}";  

    return("{Row" + 
            SEBrowserRowIndexExpression(first)  + 
            name_cell_exp + 
            type_cell_exp + 
            kind_cell_exp + "}"); 
}

string
SEProcessRowExpression(node proc, int first)
{
    file            file;
    item            item;
    string          name_cell_exp = "", indices_cell_exp = "", parent_cell_exp = "", children_cell_exp = "",
                    query, full_index = "";
    list            names;
    int             i, n;

    name_cell_exp = "{Cell{Index OBJECT_NAME_COL}{Label \"" + filltable_string_escape(proc.name) + "\"}}";

    query = "file[DfeDiagram && node_refs[node_id = ${proc.id}]]";
    file = find_by_query(query);
    if (file != NULL)
    {
	if (file.name == "top")
	{
	    full_index = "0";
	} else
	{
	    if ((item = find_by_query("item[RelativeIndex && obj_id = ${proc.id}]")) != NULL)
		full_index = file.name + "." + item.value;
	}
    }
    if (full_index != "")
	indices_cell_exp = "{Cell{Index PROCESS_INDICES_COL}{Label \"" +
	    filltable_string_escape(full_index) + "\"}}";

    /* use the compiled generalizations to describe the parents/children */
    if (SEBrowserProcessGraphIsCompiled())
    {
	names = NULL;
	names = SEBrowserFastProcessDirectParents(proc.name);
	if (names != NULL)
	{
	    n = list_count(names);
	    if (n > 0)
	    {
		parent_cell_exp
		    = "{Cell{Index PROCESS_PARENT_COL}{Label \"" + filltable_string_escape(list_get(names, 0)) + "\"}}";
		for (i = 1; i < n; i = i + 1)
		    parent_cell_exp
			= parent_cell_exp + "{Cell{Label \"" + filltable_string_escape(list_get(names, i)) + "\"}}";
	    }
	}
	names = NULL;
	names = SEBrowserFastProcessDirectChildren(proc.name);
	if (names != NULL)
	{
	    n = list_count(names);
	    if (n > 0)
	    {
		children_cell_exp
		    = "{Cell{Index PROCESS_CHILDREN_COL}{Label \"" + filltable_string_escape(list_get(names, 0)) + "\"}}";
		for (i = 1; i < n; i = i + 1)
		    children_cell_exp
			= children_cell_exp + "{Cell{Label \"" + filltable_string_escape(list_get(names, i)) + "\"}}";
	    }
	}
    }
    return ("{Row" +
	    SEBrowserRowIndexExpression(first) +
	    name_cell_exp +
	    indices_cell_exp +
	    parent_cell_exp +
	    children_cell_exp + "}");
}

string
SEFlowRowExpression(link flow, int first)
{
    // construct an expression to fill a browser row with an SE parameter description
    // if first == true, then this is the first object in an collection
    
    item item;
    string name_cell_exp, type_cell_exp = "", kind_cell_exp, query;
  
    name_cell_exp = "{Cell{Index OBJECT_NAME_COL}{Label \"" + filltable_string_escape(flow.name) + "\"}}";  
    kind_cell_exp = "{Cell{Index PARAMETER_KIND_COL}{Label \"" + filltable_string_escape(flow.type) + "\"}}";  

    query = "item[DataType && node[Sequence && name = '${flow.name}']]";
    item = find_by_query(query);

    if (item != NULL)
        type_cell_exp = "{Cell{Index FLOW_TYPE_COL}{Label \"" + 
            filltable_string_escape(item.value) + "\"}}";  
    else
        type_cell_exp = "{Cell{Index FLOW_TYPE_COL}{Label \"" + 
            filltable_string_escape("---") + "\"}}";  

    return("{Row" + 
            SEBrowserRowIndexExpression(first)  + 
            name_cell_exp + 
            type_cell_exp + 
            kind_cell_exp + "}"); 
}

string
SEAdtRowExpression(node adt, int first)
{
  // construct an expression to fill a browser row with an SE adt description
  // if first == true, then this is the first object in an collection
    
  string name_cell_exp;
  
  name_cell_exp = "{Cell{Index OBJECT_NAME_COL}{Label \"" + adt.name + "\"}}";  
  
  return("{Row" + SEBrowserRowIndexExpression(first)  + name_cell_exp + "}"); 
}

string
SEBrowserRowIndexExpression(int first)
{
  if (first) {
    if (gte_append_from_current_selection)
      return "{Index Current}";
    else
      return "{Index Append}";
  }
  else
    return "";
}

/************************************************************************************
 * REDUCE, CLEAR
 */

void
SEBrowserReduce()
{
  int first_row, last_row, num_rows, hsect;
  string ft, saveqbe, savevis;

  /* disable refresh */
  gte_disable_refresh();

  /* clip the selection to a single hsect to ensure homogenous semantics */
  first_row = gte_get_first_row_in_selected();
  last_row = min(gte_get_last_row_in_selected(),
		 gte_get_last_row(gte_get_hsect(first_row)));
  gte_set_selection_quietly(first_row, 0, last_row, gte_get_last_col());

  /* remember how big the selection is and what section it belongs to */
  num_rows = last_row - first_row + 1;
  hsect = gte_get_hsect(first_row);

  /* copy the selection to the paste buffer */
  gte_stpem("TableElementCopy");

  /* save the current QBE's and hideshows as ft expressions */
  saveqbe = SEBrowserSaveAllQBEExpression();
  savevis = gte_visibility_filltable_expression();

  /* clear the table */
  gte_inittable_string("FillTable " + gte_get_table_type() + "{}");

  /* restore the queries and visibility */
  gte_filltable_string(saveqbe);
  gte_filltable_string(savevis);

  /* create a destination selection with enough space for paste */
  ft = "FillTable{{Hsect{Index " + hsect + "}{Vsect{Row{Repeat " + num_rows + " }{ Cell}}}}}";
  gte_filltable_string(ft);

  gte_set_selection_quietly(gte_get_first_row(hsect), 1, 
			    gte_get_last_row(hsect), gte_get_last_col(),
			    gte_get_first_row(hsect), OBJECT_NAME_COL);

  /* paste the old saved selection */
  gte_stpem("TableElementPaste");

  gte_reset_history();

  gte_enable_refresh();
  gte_refresh_table();
}

void SEBrowserClear()
{
  /* empty the browser except for the queries */
  int hs, vs, row, col, first_col, last_col;

  /* save position of current selection */
  row = gte_get_current_cell_row();
  col = gte_get_current_cell_col();
  first_col = gte_get_first_col_in_selected();
  last_col = gte_get_last_col_in_selected();
  hs = gte_get_hsect(row);
  vs = gte_get_vsect(col);

  /* clear the contents of the browser */
  SEBrowserClearContents();

  /* try to reset the selection to a useful approximation of the old value -- i.e. preserve qbe selection */
  first_col = min(first_col, gte_get_last_col());
  last_col = min(last_col, gte_get_last_col());
  col = min(col, gte_get_last_col());
  gte_set_selection_quietly(gte_get_first_row(hs), first_col,  
			    gte_get_first_row(hs), last_col, 
			    gte_get_first_row(hs), col);

  gte_refresh_table();
}

void SEBrowserClearContents()
{
  /* empty the browser except for the queries, quietly */

  /* save the current QBE's and hideshows as a ft expression */
  string saveqbe, savevis;

  /* disable refresh to prevent the inittable from forcing a draw */
  gte_disable_refresh();

  saveqbe = SEBrowserSaveAllQBEExpression();
  savevis = gte_visibility_filltable_expression();

  gte_inittable_string("FillTable " + gte_get_table_type() + "{}");

  /* restore the queries */
  gte_filltable_string(saveqbe);
  gte_filltable_string(savevis);

  /* enable refresh */
  gte_enable_refresh();
}

string
SEBrowserSaveAllQBEExpression()
{
  /* Returns a filltable expression encoding all of the query by example rows. */

  /* get the indices of the qbe sections */
  int SE_MODEL_QBE_HSECT = gte_lookup_symbol("SE_MODEL_QBE_HSECT");
  int MODULE_QBE_HSECT = gte_lookup_symbol("MODULE_QBE_HSECT");
  int PARAMETER_QBE_HSECT = gte_lookup_symbol("PARAMETER_QBE_HSECT");
  int PROCESS_QBE_HSECT = gte_lookup_symbol("PROCESS_QBE_HSECT");
  int FLOW_QBE_HSECT = gte_lookup_symbol("FLOW_QBE_HSECT");
  int ADT_QBE_HSECT = gte_lookup_symbol("ADT_QBE_HSECT");

  return ("FillTable " + 
	  gte_get_table_type() + 
	  "{" + 
	  SEBrowserSaveOneQBEExpression(SE_MODEL_QBE_HSECT) + 
	  SEBrowserSaveOneQBEExpression(MODULE_QBE_HSECT) + 
	  SEBrowserSaveOneQBEExpression(PARAMETER_QBE_HSECT) + 
	  SEBrowserSaveOneQBEExpression(PROCESS_QBE_HSECT) + 
	  SEBrowserSaveOneQBEExpression(FLOW_QBE_HSECT) + 
	  SEBrowserSaveOneQBEExpression(ADT_QBE_HSECT) + 
	  "}");
}

string
SEBrowserSaveOneQBEExpression(int qbe_hs)
{
  string cells = "";
  int vs, r, c, cmax;

  r = gte_get_first_row(qbe_hs);
  vs = gte_lookup_symbol("DESCRIPTION_VSECT");

  cmax = gte_get_last_col(vs);

  for (c = gte_get_first_col(vs); c <= cmax; c = c + 1) {
    cells = cells + "{Cell{Label \"" + gte_get_cell_label(r, c) + "\"}}";
  }
  return "{Hsect {Index " + qbe_hs + "}{Vsect{Index DESCRIPTION_VSECT}{Row " + cells + "}}}";
}

/************************************************************************************
 * SPECIAL HIDESHOW FUNCTIONS
 */

/* HIDE SHOW QBE */

string
SEBrowserToggleQBEVisibilityLabelFunc()
{
  if (se_qbe_is_visible)
    return "Hide QBE";
  else
    return "Show QBE";
}

void
SEBrowserToggleQBEVisibility()
{
  if (se_qbe_is_visible)
    SEBrowserHideQBE();
  else
    SEBrowserShowQBE();
}

void
SEBrowserShowQBE()
{

  /* get the indices of the qbe sections */
  int SE_MODEL_QBE_HSECT = gte_lookup_symbol("SE_MODEL_QBE_HSECT");
  int MODULE_QBE_HSECT = gte_lookup_symbol("MODULE_QBE_HSECT");
  int PARAMETER_QBE_HSECT = gte_lookup_symbol("PARAMETER_QBE_HSECT");
  int PROCESS_QBE_HSECT = gte_lookup_symbol("PROCESS_QBE_HSECT");
  int FLOW_QBE_HSECT = gte_lookup_symbol("FLOW_QBE_HSECT");
  int ADT_QBE_HSECT = gte_lookup_symbol("ADT_QBE_HSECT");

  /* only make the QBE section visibile if the corresponding header section,
   * assumed to live one section above, is visible */
  if (gte_get_hsect_visibility(SE_MODEL_QBE_HSECT - 1))
      gte_set_hsect_visibility(SE_MODEL_QBE_HSECT, True); 

  if (gte_get_hsect_visibility(MODULE_QBE_HSECT - 1))
      gte_set_hsect_visibility(MODULE_QBE_HSECT, True); 

  if (gte_get_hsect_visibility(PARAMETER_QBE_HSECT - 1))
      gte_set_hsect_visibility(PARAMETER_QBE_HSECT, True); 

  if (gte_get_hsect_visibility(PROCESS_QBE_HSECT - 1))
      gte_set_hsect_visibility(PROCESS_QBE_HSECT, True); 

  if (gte_get_hsect_visibility(FLOW_QBE_HSECT - 1))
      gte_set_hsect_visibility(FLOW_QBE_HSECT, True); 

  if (gte_get_hsect_visibility(ADT_QBE_HSECT - 1))
      gte_set_hsect_visibility(ADT_QBE_HSECT, True); 

  se_qbe_is_visible = TRUE;

  gte_refresh_table();

}

void
SEBrowserHideQBE()
{
  /* get the indices of the qbe sections */
  int SE_MODEL_QBE_HSECT = gte_lookup_symbol("SE_MODEL_QBE_HSECT");
  int MODULE_QBE_HSECT = gte_lookup_symbol("MODULE_QBE_HSECT");
  int PARAMETER_QBE_HSECT = gte_lookup_symbol("PARAMETER_QBE_HSECT");
  int PROCESS_QBE_HSECT = gte_lookup_symbol("PROCESS_QBE_HSECT");
  int FLOW_QBE_HSECT = gte_lookup_symbol("FLOW_QBE_HSECT");
  int ADT_QBE_HSECT = gte_lookup_symbol("ADT_QBE_HSECT");

  gte_set_hsect_visibility(SE_MODEL_QBE_HSECT, False); 
  gte_set_hsect_visibility(MODULE_QBE_HSECT, False); 
  gte_set_hsect_visibility(PARAMETER_QBE_HSECT, False); 
  gte_set_hsect_visibility(PROCESS_QBE_HSECT, False);
  gte_set_hsect_visibility(FLOW_QBE_HSECT, False);
  gte_set_hsect_visibility(ADT_QBE_HSECT, False);

  se_qbe_is_visible = FALSE;

  gte_refresh_table();
}

/* HIDE SHOW OID */

string
SEBrowserToggleOidVisibilityLabelFunc()
{
  if (se_oid_is_visible)
    return "Hide Object Ids";
  else
    return "Show Object Ids";
}

void
SEBrowserToggleOidVisibility()
{
  int id_vsect = gte_lookup_symbol("ID_VSECT");

  if (se_oid_is_visible) {
    /* currently visible, so hide it */
    gte_set_vsect_visibility(id_vsect, False);
    se_oid_is_visible = FALSE;
  }
  else {
    /* currently invisible, so show it */
    gte_set_vsect_visibility(id_vsect, True);
    se_oid_is_visible = TRUE;
  }

  gte_refresh_table();
}

/* semantic group visibility */

void
SEBrowserSetSemanticGroupVisibility(int autoadjust)
{
    /* Assert that the sections with newly browsed objects are visible. 
     * For backward compatibility, implement tbr-style autoadjust: 
     * if autoadjust on, only show the groups with new browsed objects */

    if (list_count(se_models) > 0)
        se_model_hsect_group_is_visible = TRUE;
    else if (autoadjust) 
    {
        /* no new browsed objects, so hide it */
        SEBrowserHideSemanticGroup("SE_MODEL_HEADER_HSECT", "SE_MODEL_QBE_HSECT","SE_MODEL_HSECT");
        se_model_hsect_group_is_visible = FALSE;
    }

    if (list_count(se_modules) > 0)
        se_module_hsect_group_is_visible = TRUE;
    else if (autoadjust) 
    {
        SEBrowserHideSemanticGroup("MODULE_HEADER_HSECT", "MODULE_QBE_HSECT","MODULE_HSECT");
        se_module_hsect_group_is_visible = FALSE;
    }

    if (list_count(se_parameters) > 0)
        se_parameter_hsect_group_is_visible = TRUE;
    else if (autoadjust) 
    {
        SEBrowserHideSemanticGroup("PARAMETER_HEADER_HSECT", "PARAMETER_QBE_HSECT","PARAMETER_HSECT");
        se_parameter_hsect_group_is_visible = FALSE;
    }

    if (list_count(se_processes) > 0) 
        se_process_hsect_group_is_visible = TRUE;
    else if (autoadjust) 
    {
        SEBrowserHideSemanticGroup("PROCESS_HEADER_HSECT", "PROCESS_QBE_HSECT","PROCESS_HSECT");
        se_process_hsect_group_is_visible = FALSE;
    }

    if (list_count(se_flows) > 0) 
        se_flow_hsect_group_is_visible = TRUE;
    else if (autoadjust) 
    {
        SEBrowserHideSemanticGroup("FLOW_HEADER_HSECT", "FLOW_QBE_HSECT","FLOW_HSECT");
        se_flow_hsect_group_is_visible = FALSE;
    }

    if (list_count(se_adts) > 0) 
        se_adt_hsect_group_is_visible = TRUE;
    else if (autoadjust) 
    {
        SEBrowserHideSemanticGroup("ADT_HEADER_HSECT", "ADT_QBE_HSECT","ADT_HSECT");
        se_adt_hsect_group_is_visible = FALSE;
    }

    return;
}

void
SEBrowserHideEmptySemanticGroups()
{

    /* Hide all the empty semantic groups. */
  
    if (se_model_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("SE_MODEL_HSECT")) 
    {
        SEBrowserHideSemanticGroup("SE_MODEL_HEADER_HSECT", "SE_MODEL_QBE_HSECT","SE_MODEL_HSECT");
        se_model_hsect_group_is_visible = FALSE;
    }

    if (se_module_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("MODULE_HSECT")) 
    {
        SEBrowserHideSemanticGroup("MODULE_HEADER_HSECT", "MODULE_QBE_HSECT","MODULE_HSECT");
        se_module_hsect_group_is_visible = FALSE;
    }

    if (se_parameter_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("PARAMETER_HSECT")) 
    {
        SEBrowserHideSemanticGroup("PARAMETER_HEADER_HSECT", "PARAMETER_QBE_HSECT","PARAMETER_HSECT");
        se_parameter_hsect_group_is_visible = FALSE;
    }

    if (se_process_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("PROCESS_HSECT")) 
    {
        SEBrowserHideSemanticGroup("PROCESS_HEADER_HSECT", "PROCESS_QBE_HSECT","PROCESS_HSECT");
        se_process_hsect_group_is_visible = FALSE;
    }

    if (se_flow_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("FLOW_HSECT")) 
    {
        SEBrowserHideSemanticGroup("FLOW_HEADER_HSECT", "FLOW_QBE_HSECT","FLOW_HSECT");
        se_flow_hsect_group_is_visible = FALSE;
    }

    if (se_adt_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("ADT_HSECT")) 
    {
        SEBrowserHideSemanticGroup("ADT_HEADER_HSECT", "ADT_QBE_HSECT","ADT_HSECT");
        se_adt_hsect_group_is_visible = FALSE;
    }

    /* if they are all empty, leave at least the object model group visible */
    if (!(se_model_hsect_group_is_visible ||
	  se_module_hsect_group_is_visible ||
	  se_parameter_hsect_group_is_visible ||
	  se_flow_hsect_group_is_visible ||
	  se_adt_hsect_group_is_visible ||
	  se_process_hsect_group_is_visible) ) 
    {
        SEBrowserShowSemanticGroup("SE_MODEL_HEADER_HSECT", "SE_MODEL_QBE_HSECT","SE_MODEL_HSECT");
        se_model_hsect_group_is_visible = TRUE;
    }

    /* refresh */
    gte_refresh_table();
}

int
SEBrowserHideEmptySemanticGroupsActiveFunc()
{
  if (
      /* some empty group is now visible */
      ((se_model_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("SE_MODEL_HSECT"))
       || (se_module_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("MODULE_HSECT"))
       || (se_parameter_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("PARAMETER_HSECT"))
       || (se_process_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("PROCESS_HSECT"))
       || (se_flow_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("FLOW_HSECT"))
       || (se_adt_hsect_group_is_visible && SEBrowserSemanticGroupIsEmpty("ADT_HSECT")))
      &&
      (
       /* more than one group is visible */
       (se_model_hsect_group_is_visible 
	+ se_module_hsect_group_is_visible
	+ se_parameter_hsect_group_is_visible
	+ se_process_hsect_group_is_visible
	+ se_flow_hsect_group_is_visible
	+ se_adt_hsect_group_is_visible)
       > 1)
      )
    return ACTIVE_FUNC_IS_ACTIVE;
  return ACTIVE_FUNC_IS_INACTIVE;
}

string
SEBrowserToggleSEModelVisibilityLabelFunc()
{
  if (se_model_hsect_group_is_visible)
    return "Hide SE Diagrams";
  else
    return "Show SE Diagrams";
}

void
SEBrowserToggleSEModelVisibility()
{
  if (se_model_hsect_group_is_visible) {
    SEBrowserHideSemanticGroup("SE_MODEL_HEADER_HSECT", 
				"SE_MODEL_QBE_HSECT",
				"SE_MODEL_HSECT");
    se_model_hsect_group_is_visible = FALSE;
  }
  else {
    SEBrowserShowSemanticGroup("SE_MODEL_HEADER_HSECT", 
				"SE_MODEL_QBE_HSECT",
				"SE_MODEL_HSECT");
    se_model_hsect_group_is_visible = TRUE;
  }
  gte_refresh_table();
  return;
}

string
SEBrowserToggleModuleVisibilityLabelFunc()
{
  if (se_module_hsect_group_is_visible)
    return "Hide Modules";
  else
    return "Show Modules";
}

void
SEBrowserToggleModuleVisibility()
{
  if (se_module_hsect_group_is_visible) {
    SEBrowserHideSemanticGroup("MODULE_HEADER_HSECT", 
				"MODULE_QBE_HSECT",
				"MODULE_HSECT");
    se_module_hsect_group_is_visible = FALSE;
  }
  else {
    SEBrowserShowSemanticGroup("MODULE_HEADER_HSECT", 
				"MODULE_QBE_HSECT",
				"MODULE_HSECT");
    se_module_hsect_group_is_visible = TRUE;
  }
  gte_refresh_table();
  return;
}

string
SEBrowserToggleParameterVisibilityLabelFunc()
{
  if (se_parameter_hsect_group_is_visible)
    return "Hide Parameters";
  else
    return "Show Parameters";
}

void
SEBrowserToggleParameterVisibility()
{
  if (se_parameter_hsect_group_is_visible) {
    SEBrowserHideSemanticGroup("PARAMETER_HEADER_HSECT", 
				"PARAMETER_QBE_HSECT",
				"PARAMETER_HSECT");
    se_parameter_hsect_group_is_visible = FALSE;
  }
  else {
    SEBrowserShowSemanticGroup("PARAMETER_HEADER_HSECT", 
				"PARAMETER_QBE_HSECT",
				"PARAMETER_HSECT");
    se_parameter_hsect_group_is_visible = TRUE;
  }
  gte_refresh_table();
  return;
}

string
SEBrowserToggleProcessVisibilityLabelFunc()
{
  if (se_process_hsect_group_is_visible)
    return "Hide Processes";
  else
    return "Show Processes";
}

void
SEBrowserToggleProcessVisibility()
{
  if (se_process_hsect_group_is_visible) {
    SEBrowserHideSemanticGroup("PROCESS_HEADER_HSECT", 
				"PROCESS_QBE_HSECT",
				"PROCESS_HSECT");
    se_process_hsect_group_is_visible = FALSE;
  }
  else {
    SEBrowserShowSemanticGroup("PROCESS_HEADER_HSECT", 
				"PROCESS_QBE_HSECT",
				"PROCESS_HSECT");
    se_process_hsect_group_is_visible = TRUE;
  }
  gte_refresh_table();
  return;
}

string
SEBrowserToggleFlowVisibilityLabelFunc()
{
  if (se_flow_hsect_group_is_visible)
    return "Hide Flows";
  else
    return "Show Flows";
}

void
SEBrowserToggleFlowVisibility()
{
  if (se_flow_hsect_group_is_visible) {
    SEBrowserHideSemanticGroup("FLOW_HEADER_HSECT", 
				"FLOW_QBE_HSECT",
				"FLOW_HSECT");
    se_flow_hsect_group_is_visible = FALSE;
  }
  else {
    SEBrowserShowSemanticGroup("FLOW_HEADER_HSECT", 
				"FLOW_QBE_HSECT",
				"FLOW_HSECT");
    se_flow_hsect_group_is_visible = TRUE;
  }
  gte_refresh_table();
  return;
}

string
SEBrowserToggleAdtVisibilityLabelFunc()
{
  if (se_adt_hsect_group_is_visible)
    return "Hide Abstract Data Types";
  else
    return "Show Abstract Data Types";
}

void
SEBrowserToggleAdtVisibility()
{
  if (se_adt_hsect_group_is_visible) {
    SEBrowserHideSemanticGroup("ADT_HEADER_HSECT", 
				"ADT_QBE_HSECT",
				"ADT_HSECT");
    se_adt_hsect_group_is_visible = FALSE;
  }
  else {
    SEBrowserShowSemanticGroup("ADT_HEADER_HSECT", 
				"ADT_QBE_HSECT",
				"ADT_HSECT");
    se_adt_hsect_group_is_visible = TRUE;
  }
  gte_refresh_table();
  return;
}

void
SEBrowserHideSemanticGroup(string header, string qbe, string body)
{
  /* Hide a semantic group consisting of a header section, a qbe section, and a body section.
   * (Arguments are section names.) */

  /* get the indices of the sections */
  int header_hs = gte_lookup_symbol(header);
  int qbe_hs = gte_lookup_symbol(qbe);
  int body_hs = gte_lookup_symbol(body);
  
  gte_set_hsect_visibility(header_hs, False); 
  gte_set_hsect_visibility(qbe_hs, False); 
  gte_set_hsect_visibility(body_hs, False); 
}

void
SEBrowserShowSemanticGroup(string header, string qbe, string body)
{
  /* Hide a semantic group consisting of a header section, a qbe section, and a body section.
   * (Arguments are section names.) */

  /* get the indices of the sections */
  int header_hs = gte_lookup_symbol(header);
  int qbe_hs = gte_lookup_symbol(qbe);
  int body_hs = gte_lookup_symbol(body);
  
  gte_set_hsect_visibility(header_hs, True); 
  if (se_qbe_is_visible)
    gte_set_hsect_visibility(qbe_hs, True); 
  gte_set_hsect_visibility(body_hs, True); 
}

int
SEBrowserSemanticGroupIsEmpty(string body)
{
  /* Return true if a semantic group has no contents. Body is name of body section. */

  int body_hs, row;
  string label;

  /* get the index of the section and its first row */
  body_hs = gte_lookup_symbol(body);
  row = gte_get_first_row(body_hs);

  /* if there is more than one row in the section, it is not empty */
  if (row != gte_get_last_row(body_hs))
    return FALSE;

  /* if there one row, without an object id */
  label = gte_get_cell_label(row, OID_COL);
  if (label == NULL || label == "")
    return TRUE;

  return FALSE;
}

/***********************************************************************************
 * FUNCTIONS WHICH BUILD QBE CLAUSES 
 */

string
SEQBENameClause(int hsect, int vsect, int row, int col)
{
  return SEQBEAtomicClause("name", hsect, vsect, row, col);
}

string
SEQBEAtomicClause(string oms_attribute, int hsect, int vsect, int row, int col)
{
  /* builds a clause which can be embedded in an query from an oms attribute name and a QBE cell pattern. */

  string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));

  /* "*" => match anything, hence no restriction, the null clause */
  if (pattern == "*")
    return "";

  /* "" => match objects with no known type or known NULL scope */
  if (pattern == "")
    return " && " + oms_attribute + "== ''";

  /* otherwise, use the usual string matching algorithm */      
  return " && " + oms_attribute + "$'" + pattern + "'";
}

string
SEQBEScopeClause(int hsect, int vsect, int row, int col)
{
  /* builds a scope clause */

  string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));

  /* "*" => match anything, hence no restriction, the null clause */
  if (pattern == "*") 
    return "";

  /* "" => match objects at global scope */
  if (pattern == "")
    return " && scope_node_id == 0";

  /* otherwise, use the usual string matching algorithm */      
  return " && scope_node[node_refs && name$'" + pattern + "']";
}

string
SEDiagramQBETypeClause(int hsect, int vsect, int row, int col)
{
  string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));

  if (pattern == "*"||pattern == "")
    return "(DfeDiagram|SceDiagram)";
  return pattern;
}

struct
ParentPattern
{
    string          pattern;
    int             repeat;
};

string
SEModuleQBEParentsClause(int hsect, int vsect, int row, int col)
{
    ParentPattern sp, sp2;
    list patterns;
    string pattern, clause = "", subclause = "";  
    int c, cmin, cmax, r, i, is_repeat;
  
    /* collect all the patterns, count repetitions */
    cmin = gte_get_col(vsect, col);
    cmax = gte_get_last_col(vsect);
    r = gte_get_row(hsect, row); 
    patterns = list_create("ParentPattern", 0);
  
    for (c = cmin; c <= cmax; c = c + 1) 
    {
	/* get pattern from cell */
	pattern = gte_get_cell_label(r, c);

	/* make a struct containing the pattern and the repetition count */
	sp.pattern = pattern;
	sp.repeat = 1;
	is_repeat = FALSE;

	/* search for repetitions */
	for (i = 0; i < list_count(patterns); i = i + 1) 
        {
	    sp2 = list_get(patterns, i);
	    if (sp2.pattern == pattern) 
            {
		sp2.repeat = sp2.repeat + 1;
		list_set(patterns, i, sp2);
		is_repeat = TRUE;
		break;
	    }
	}
	if (!is_repeat)
	    list_append(patterns, sp);
    }

    /* build the clause from the patterns */
    for (i = 0; i < list_count(patterns); i = i + 1) 
    {
	sp = list_get(patterns, i);

	/* "*" => match anything, hence no restriction */
	if (sp.pattern == "*") 
	    continue;

	/* "" => find module that has no parents */
	if (sp.pattern == "") 
        {
            clause = clause + " && !in_links[SubprogramCall && link_refs && from_node[Module]]";
	    continue;
        }

	/* module has parent matching string */ 
	subclause = "in_links[SubprogramCall && link_refs && from_node[Module && name$'" + sp.pattern + "']]";

	/* if repetition count > 1, wrap a count clause around the basic restrictor clause */
	//if (sp.repeat > 1)
	//    subclause = "count[" + subclause + "] >= " + sp.repeat;
    
	/* add the subclause to the conjunction */
	clause = clause + " && " + subclause;
    }
    return clause;
}

string
SEParameterQBETypeClause(int hsect, int vsect, int row, int col)
{
    string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));

    // "*" => match anything, hence no restriction, the null clause 
    if (pattern == "*" || pattern == "")
        return "";

    // find the type item
    if (string_find(pattern, 0, "*") || string_find(pattern, 0, "?"))
	return " && items[DataType && value $ '" + pattern + "']";
    else
	return " && items[DataType && value = '" + pattern + "']";
}

string
SEParameterQBEKindClause(int hsect, int vsect, int row, int col)
{
    string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));

    // we do not need the && here because this is at the begining of the query

    // "*" => match anything, hence no restriction
    if (pattern == "*")
        return "(DataIn || DataOut || DataInOut || ControlIn || ControlOut) && ";

    // this can be things like DataIn, DataOut, etc.  Just be sure there are no stars

    if (string_find(pattern, 0, "*") || string_find(pattern, 0, "?"))
	return "(DataIn || DataOut || DataInOut || ControlIn || ControlOut) && ";

    return pattern;
}

string
SEFlowQBETypeClause(int hsect, int vsect, int row, int col)
{
    string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));

    // "*" => match anything, hence no restriction, the null clause 
    if (pattern == "*" || pattern == "")
        return "";

    // can't do this because of bogo association by name 
    return "";
}

string
SETPrimClause(int hsect, int vsect, int row, int col)
{
    string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));
 
    // "*" => match anything, hence no restriction, the null clause
    if (pattern == "*" || pattern == "")
        return "";
 
    return " && items[DataType && value == '" + pattern + "']";
}

string
SEFlowQBEKindClause(int hsect, int vsect, int row, int col)
{

    string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));

    // we do not need the && here because this is at the begining of the query

    // "*" => match anything, hence no restriction
    if (pattern == "*")
        return "(ControlFlow || DataFlow) && ";


    if (string_find(pattern, 0, "*") || string_find(pattern, 0, "?"))
	return "(ControlFlow || DataFlow) && ";

    return pattern;
}

// proper_dfe_name: returns True if int.int... pattern exists

string
proper_dfe_name(string pattern)
{
    int start, sep;

    if (string_length(pattern) == 0)
	return "";

    if (!string_converts(string_extract(pattern, string_length(pattern) - 1, 1), "int"))
	return "";

    start = 0;
    sep = string_find(pattern, start, "."); 
    while (sep != string_length(pattern))
    {
	if (!string_converts(string_extract(pattern, start, sep - start), "int"))
	    return "";
	start = sep + 1;
	if (start < string_length(pattern))
	    sep = string_find(pattern, start, ".");
    }

    if (! string_converts(string_extract(pattern, start, string_length(pattern) - start), "int"))
	return "";
    return string_extract(pattern, 0, start - 1);


} // end of proper_dfe_name

string
get_parent_fname(string name)
{
    int             i;

    for (i = string_length(name) - 1; i > 0; i = i - 1)
    {
	if (string_extract(name, i, 1) == ".")
	    return string_extract(name, 0, i + 1);
    }
    return "";
}

string
SEProcessQBEIndicesClause(int hsect, int vsect, int row, int col)
{
    // use the index to find file names
    string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));
    string proper_name;

    // "*" => match anything, hence no restriction, the null clause 
    if (pattern == "*")
        return "&& node_refs";

    if (pattern == "top")
	return " && node_refs[file[name = 'top']]";

    if (string_converts(pattern, "int"))
	return " && node_refs[file[name $ '" + pattern + "*']]"; 

    if ((proper_name = proper_dfe_name(pattern)) != "")
	return " && node_refs[file[name = '" + proper_name + "']]";

    return " && node_refs[file[name$'" + pattern + "']]";
}

string
SEQBEFromNodeClause(string node_type, int hsect, int vsect, int row, int col)
{
  /* builds a link-has-from-node clause. */
  return SEQBELinkNodeClause("from_node", node_type, hsect, vsect, row, col);
}

string
SEQBEToNodeClause(string node_type, int hsect, int vsect, int row, int col)
{
  /* builds a link-has-to-node clause. */
  return SEQBELinkNodeClause("to_node", node_type, hsect, vsect, row, col);
}

string
SEQBELinkNodeClause(string from_or_to_relation, string node_type, int hsect, int vsect, int row, int col)
{
  /* builds a link-has-node clause. */

  string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));
  string node_type_clause = "";
  
  /* "*" => match anything, hence no restriction, the null clause */
  if (pattern == "*")
    return "";

  if (node_type != "")
    node_type_clause = node_type + " && ";

  /* otherwise, use string matching (null string => find blank association name) */
  return " && " + from_or_to_relation + "[" + node_type_clause + "node_refs && name$'" + pattern + "']";
}

string
SEQBEItemClause(string item_type, int hsect, int vsect, int row, int col)
{
  /* builds a item clause. */

  string pattern = gte_get_cell_label(gte_get_row(hsect, row), gte_get_col(vsect, col));
  return SEQBEItemClauseFromPattern(item_type, pattern, "$");
}

string
SEQBEItemClauseFromPattern(string item_type, string pattern, string comparator)
{
  /* "*" => match anything, hence no restriction, the null clause */
  if (pattern == "*")
    return "";

  /* "" => match no known default value or known NULL default value */
  if (pattern == "")
  // return " && (!items[" + item_type + "] || items[" + item_type + " && value == ''])";
  return " && !items[" + item_type + "]";

  /* otherwise, use the usual string matching algorithm */      
  return " && items[" + item_type + " && value" + comparator + "'" + pattern + "']";
}

/**********************************************************************************
 * COMPILED REPOSITORY INTO GRAPH FOR QUICK BROWSING 
 */

graph se_module_graph = NULL;
graph se_process_graph = NULL;

int
SEBrowserModuleGraphIsCompiled()  
{
    if (se_module_graph != NULL)
        return TRUE;
    else
	return FALSE;
}

int
SEBrowserProcessGraphIsCompiled()  
{
    if (se_process_graph != NULL)
        return TRUE;
    else
	return FALSE;
}

void
SEBrowserCompileGraph()
{
    se_module_graph = SEClassGraph(NULL, list_select("node[Module && node_refs]"));
    se_process_graph = SEClassGraph(NULL, list_select("node[Process && node_refs]"));
    graph_topological_sort(se_module_graph);
    graph_topological_sort(se_process_graph);
    gte_print_message((graph_count(se_module_graph) + graph_count(se_process_graph)) + " relationships compiled.");
}

list
SEBrowserFastModuleDirectParents(string name)
{
  if (graph_is_node(se_module_graph, name))
    return graph_node_predecessors(se_module_graph, name);
  else
    return NULL;
}

list
SEBrowserFastModuleDirectChildren(string name)
{
  if (graph_is_node(se_module_graph, name))
    return graph_node_successors(se_module_graph, name);
  else
    return NULL;
}

list
SEBrowserFastModuleAllParents(string name)
{
  if (graph_is_node(se_module_graph, name))
    return graph_node_indirect_predecessors(se_module_graph, name);
  else
    return NULL;
}

list
SEBrowserFastModuleAllChildren(string name)
{
  if (graph_is_node(se_module_graph, name))
    return graph_node_indirect_successors(se_module_graph, name);
  else
    return NULL;
}

list
SEBrowserFastProcessDirectParents(string name)
{
  if (graph_is_node(se_process_graph, name))
    return graph_node_predecessors(se_process_graph, name);
  else
    return NULL;
}

list
SEBrowserFastProcessDirectChildren(string name)
{
  if (graph_is_node(se_process_graph, name))
    return graph_node_successors(se_process_graph, name);
  else
    return NULL;
}

/**************************************************************************
 * FOR TOPOLOGICAL SORTING, ALLOWING SECONDARY KEYS SPECIFIED IN THE OTBR RULES FILE
 */

string
SEBrowserModuleRank(int hs, int vs, int r, int c)
{
  string classname = gte_get_cell_label(gte_get_row(hs, r), gte_get_col(vs, c));

  if (!graph_is_node(se_module_graph, classname))
    return "0";
  
  return to_string(graph_node_rank(se_module_graph, classname));
}

void
SEBrowseProcHier(string whichway, int id)

{
    // build a query, and call SEHyperbrowse()    

    string query, fname, full_index = "";
    item item;
    file file;

    query = "file[DfeDiagram && node_refs[node_id = ${id}]]";
    file = find_by_query(query);
    if (file == NULL)
	return;
 
    if (whichway == "CHILD")
    {
	if (file.name == "top")
	{
	    full_index = "0";
	} else
	{
	    query = "item[RelativeIndex && obj_id = ${id}]";
	    item = find_by_query(query);
	    if (item != NULL)
		full_index = file.name + "." + item.value;
	}
	file = find_by_query("file[DfeDiagram && name == '${full_index}']");
	if (file == NULL)
	    return;
	query = "node[node_refs[file_id = " + file.id + "]]";
	SEHyperbrowse(query);
    }
    else 
    {
	if (file.name == "top")
	    SEHyperbrowse("");
	if (file.name == "0")
	    SEHyperbrowse("node[node_refs[file[name == 'top']]]");
	else
	{
	    fname = get_parent_fname(file.name);
	    query = "node[node_refs[file[name == '" + fname + "']]]";
	    SEHyperbrowse(query);
	}
    }

    return;
} 

