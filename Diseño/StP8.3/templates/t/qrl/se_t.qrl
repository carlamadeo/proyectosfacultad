//
//      sccsid[] = %W% %Y% %D%
//      StP/T
//      Confidential property of Interactive Development Environments, Inc.
//      Copyright (c) 1994
//      All rights reserved
//
//      se_t.qrl -- Script to extract se design and analysis 
//      information into TSDL.
//
/*
 * Public Functions:
 *	check_and_print_name_clash_with_DFE
 *	decomp_file
 *	descend_hierarchy
 *	descend_mod_hierarchy
 *	extract_control_bars
 *	extract_modules
 *	extract_processes
 *	extract_testable_objects
 *	fill_out_ProcessList_from_diagram
 *	find_primitive_processes
 *      form_extra_state_allows
 *	get_list_from_name
 *      get_offpage_and_anchors   
 *	get_process_flows
 *	get_procs_rel_index
 *	get_testunit_info
 *	main
 *	more_allows_actions
 *	on_subp_list
 *	print_ALT
 *	print_ALT_st_clause
 *	print_DET
 *	print_ELT
 *	print_PAT
 *	print_PAT_st_clause
 *	print_a_process
 *	print_allowed_in_state
 *	print_extra_state
 *	print_extra_statetrans
 *	print_module_actions
 *	print_process_actions
 *	print_real_time
 *	print_rt_up_clause
 *	print_sequential_logic
 *	proc_by_file_and_rel_index
 *	procs_in_a_file
 *	split_proc_name
 */

// The basics

#include "qrl/basic_textract_dt.inc"
#include "qrl/tsdl_extract.inc"
#include "qrl/extract_struct.inc"
#include "qrl/include/error.inc"

script_help = "This script generates TSDL (IEEE 1175 based) from SE Analysis and Design Models.";

const string    SCRIPT_DESCRIPTION = "StP/SE -> StP/T Software Description File";
const boolean OmtMode = False;
boolean ExplicitProcesses = False;
list ArraySuffix;

// Command line arguments
 
external string Tversion = "False";
external_help = "Set Tversion to True to see the entire version number";
 
external string TTestUnit = "";
external_help = "The TestUnit is the basis for extraction of information from th
e repository";
 
// These lists hold the input values from the TUT editor for the kinds of
// things to operate on.
list ModuleList;
list DiagramList;
list ProcessList;

// These hold the rest of the properties in the TUT editor.
string TType  = "SA";
string TNameOrPnum = "Name";
string THierarchy = "Yes";

void
check_and_print_name_clash_with_DFE(node mod, list procl)

{
    int i;
    process_tp proc;

    if (procl == NULL)
	return;

    for (i = 0; i < list_count(procl); i++)
    {
	proc = list_get(procl, i);
	if (proc.process.name == mod.name)
	{
	    print_warning("[T-34] Warning: `" + mod.name + "': a process and module\n\tboth exist with this name.");
	    return;
	}
    }
    return;

} // end of check_and_print_name_clash_with_DFE()





// module related extraction //////////////////////////////////////////////////
//

int
on_subp_list(link n, list nlist)

{
    if (list_find(nlist, 0, n) != list_count(nlist))
	return 1;

    return 0;

} // end of on_subp_list()



// This is a list of SubprogramCall links, because that is really what we are 
// interested in
list ModList;


void descend_mod_hierarchy(link subp)

{
    string query;
    list mod_list;
    link kid_subp;
    int i;

    // Find the kids, call descend hierarchy on them. If no kids, add to
    // the ModList list.  If the module is already on the list, skip it.

    if (on_subp_list(subp, ModList))
	return;

    mod_list = NULL;

    query = "link[SubprogramCall && link_refs && from_node[FormalCaller] && to_node[Module && node_refs && in_links[from_node_id == ${subp.to_node_id}]]]";
    mod_list = list_select(query);

    list_append(ModList, subp);

    if (mod_list != NULL && list_count(mod_list) != 0)
    {
	for (i = 0; i < list_count(mod_list); i++)
	{
	    kid_subp = list_get(mod_list, i);
	    descend_mod_hierarchy(kid_subp);
	}
    }
    return;

} // end of descend_mod_hierarchy()




// see the comment near extract_processes() about 4 cases of extraction
//

list 
extract_modules()

{
    list mod_list1, mod_list2, mlist;
    link subp;
    int i, j, n;
    string query, next_name, op;
    module_tp the_mlist;

    ModList = NULL;

    // careful here, because we only want the formal definition.
    if (ModuleList == NULL)
    {
	// hierarchy does not matter, just get them all

	query = "link[SubprogramCall && link_refs && from_node[FormalCaller]]";
	ModList = list_select(query);
    }
    else
    {
	mod_list1 = list_create("link", 0); 
	for (i = 0; i < list_count(ModuleList); i++)
	{
	    next_name = list_get(ModuleList, i);
	    op = which_op(next_name);
	    query = "link[SubprogramCall && from_node[FormalCaller] && to_node[Module && name ${op} '${next_name}']]";
	    mod_list2 = list_select(query);
	    if (mod_list2 == NULL || list_count(mod_list2) == 0)
		print_warning("[T-24] Warning: Module `" + next_name + "' not found.");
	    else
	        list_concatenate(mod_list1, mod_list2);
	}
	if (THierarchy == "Yes")
	{
	    ModList = list_create("link", 0); 

	    for (j = 0; j < list_count(mod_list1); j++)
	    {
		subp = list_get(mod_list1, j);
		descend_mod_hierarchy(subp);
	    }
	}
	else
	    ModList = mod_list1;
    }

    mlist = list_create("module_tp", 0);
    for (i = 0; i < list_count(ModList); i++)
    {
	subp = list_get(ModList, i);
	the_mlist.module = subp;
	the_mlist.globals_used = NULL;
	the_mlist.globals_produced = NULL;

	// formal parameters
        query = "cntx[cntx_refs && link_id == ${subp.id}]";
	the_mlist.params = list_select(query);

	// global data modules
    	query = "node[DataModule && node_refs && in_links[SubprogramCall && from_node_id == ${subp.to_node_id}] && ! items[TUsed && value = 'False']]";
	the_mlist.globals_used = list_select(query);

    	query = "node[DataModule && node_refs && in_links[SubprogramCall && from_node_id == ${subp.to_node_id}] && ! items[TProduced && value = 'False']]";
	the_mlist.globals_produced = list_select(query);

	list_append(mlist, the_mlist);
    }
    return mlist;

} // end of  extract_modules()
	




// control related extraction /////////////////////////////////////////////////
//



void 
get_offpage_and_anchors(file dfefile)

{
    string query;
    node box;
    list flows;
    link flow;
    item item;
    int i, index;
    type_detail_tp td;

    query = "link[ControlFlow && ((to_node[Cspec] && from_node[FlowAnchor || OffPageExternal || OffPageProcess]) || (from_node[Cspec] && to_node[FlowAnchor || OffPageExternal || OffPageProcess])) && link_refs[file_id == ${dfefile.id}]]";

    flows = list_select(query);

    // and add to the dataitem list
    for (i = 0; i < list_count(flows); i++)
    {
	flow = list_get(flows, i);

	// this is condensed from expand_obj_type(), and will not do type
        // expansion, since the thing here is supposed to be a discrete value.
	// It will quietly skip the thing if the type is not found, as this 
        // will get a warning later.

	query = "node[(Sequence || Selection) && node_refs[file[DseDiagram]] && name = '${flow.name}']";
        box = find_by_query(query);
	
	if (box != NULL)
	{
	    item = get_an_item_from_obj_notetype_itemtype(box.id,
                                            "DataDefinition", "DataType");
	    if (item != NULL && (! primitive_type(item.value)))
	    {
                box = t_find_dse_node(item.value, NULL);
                if (box != NULL)
		{
                    td = clear_td();
                    td.name = box.name;
                    td.annot_id = box.id;
		    td.scope = get_dse_object_scope(box);
                    index = add_dataitem(flow.name + " " + td.scope, td, flow.name, flow.name);
		}
		// otherwise a warning will eventually appear 
	    }
	}
    }
}




list 
extract_control_bars()

{
    int i, j;
    string op, diagram, query;
    list file_list, temp_list;
    file the_file;


    if (DiagramList == NULL)
    {
	query = "file[DfeDiagram && node_refs[node[Cspec]]]";
	file_list = list_select(query);	

    }
    else
    {
	file_list = list_create("file", 0);
	for (i = 0; DiagramList != NULL && i < list_count(DiagramList); i++)
	{
	    diagram = list_get(DiagramList, i);
	    op = which_op(diagram);

	    query = "file[DfeDiagram && name ${op} '${diagram}' && node_refs[node[Cspec]]]";
	    temp_list = list_select(query);
	    for (j = 0; temp_list != NULL && j < list_count(temp_list); 
		 j++)
	    {
		the_file = list_get(temp_list, j);
		if (list_find(file_list, 0, the_file) == 
					  list_count(file_list))
		    list_append(file_list, the_file);
	    }
	}
    }

    return file_list;

} // end of extract_control_bars()



// process related extraction /////////////////////////////////////////////////
//

// Find all primitive processes, either given a list of names, a list of 
// numbers, or the entire system

// get a small bit from other decomp routines.
#include "qrl/include/se_utils.inc"
#include "qrl/include/decomp.inc"

// this things adds all the processes in the specified diagrams to the 
// ProcessList.  It seems a bit backward, to do, but if process numbers
// are what are specified, the processes are converted to numbers.  
// This is convenient, but will be extra as the numbers are converted back to
// node names.

void
fill_out_ProcessList_from_diagram()

{
    int i, j;
    string diagram, op, query, name;
    list node_list;
    node the_node;

    for (i = 0; DiagramList != NULL && i < list_count(DiagramList); i++)
    {
	diagram = list_get(DiagramList, i);
	op = which_op(diagram);

	query = "node[type = Process && node_refs[file[type = DfeDiagram && name ${op} '${diagram}']]]";
	node_list = list_select(query);
	for (j = 0; j < list_count(node_list); j++)
	{
	    the_node = list_get(node_list, j);
	    if (TNameOrPnum == "Pnum")
		name = get_procs_fname(the_node) + "." + 
		       get_procs_rel_index(the_node);
	    else
		name = the_node.name;

	    if (ProcessList == NULL)
		ProcessList = list_create("string", 0);
	    
	    if (list_find(ProcessList, 0, name) == list_count(ProcessList))
		list_append(ProcessList, name);
	}
    }
    return;

} // end of fill_out_ProcessList_from_diagram()




string 
get_procs_rel_index(node proc)

{
    string query = "item[type = RelativeIndex && node[id = ${proc.id}]]";
    item the_item;

    the_item = find_by_query(query);
    if (the_item == NULL)
	return -1;
    else
        return the_item.value;

} // end of get_procs_rel_index()




file
decomp_file(string pfile, string index)

{
    string query;
    list fl;

    if (pfile == "top")
        query = "file[type = DfeDiagram && name == '0']";
    else if (pfile == "0")
        query = "file[type = DfeDiagram && name == '${index}' ]";
    else
        query = "file[type = DfeDiagram && name == '${pfile}.${index}' ]";

    return find_by_query(query);

} // end of decomp_file()




list 
procs_in_a_file(file the_file)

{
    string query;

    query = "node[type = Process && node_refs[file[type = DfeDiagram && name == '${the_file.name}' ]]]";
    
    return list_select(query);

} // end of procs_in_a_file()


node 
proc_by_file_and_rel_index(string fname, string pindex)

{
    string query = 
        "node[type = Process && " + 
             "node_refs[file[type = DfeDiagram && name == '${fname}']] && " + 
             "items[type = RelativeIndex && value == '${pindex}' ]]";

    return find_by_query(query);

} // end of proc_by_file_and_rel_index()


list ProcList;

void
descend_hierarchy(node proc)

{
    // if proc has a decomposition, call descend hierarchy on all the 
    // processes in that diagram, otherwise add the current process to the
    // list, and return that list.

    list file_list, plist;
    file the_file;
    node the_proc;
    process_tp the_process_tp;
    string fname, index;
    int i;

    the_process_tp.flows_in = NULL;
    the_process_tp.flows_out = NULL;

    fname = get_procs_fname(proc);
    index = get_procs_rel_index(proc);

    the_file = decomp_file(fname, index);
    if (the_file == NULL) // no decomposition
    {
	the_process_tp.process = proc;
	the_process_tp.fname = fname; 

	if (list_find(ProcList, 0, the_process_tp) == list_count(ProcList))
	    list_append(ProcList, the_process_tp);
    }
    else if (THierarchy == "Yes")
    {
	plist = procs_in_a_file(the_file);
	for (i = 0; i < list_count(plist); i++)
	{
	    the_proc = list_get(plist, i);
	    descend_hierarchy(the_proc);
	}
    }
    else
    {
	// add it to the list we explicitly specified this process.

	if (ExplicitProcesses)
	{
	    the_process_tp.process = proc;
	    the_process_tp.fname = fname; 

	    if (list_find(ProcList, 0, the_process_tp) == list_count(ProcList))
	        list_append(ProcList, the_process_tp);
	}
	else
	    print_warning("[T-25] Warning: process `" + proc.name + 
               "' has a decomposition.  Skipping.");
    }

    return;

} // end of descend_hierarchy()



int 
split_proc_name(string name)

{
    int pindex, index;

    pindex = 0;

    while ((index = string_find(name, pindex, ".")) != string_length(name))
    {
	pindex = index + 1;
    }

    return pindex;

} // end of split_proc_name()




list 
get_list_from_name(string next_name)

{
    string query, op; 

    op = which_op(next_name);

    query = "node[type = Process && node_refs[file[type = DfeDiagram]] && " +
                 "name ${op} '${next_name}']";
    return list_select(query);

} // end of get_list_from_name()




void 
find_primitive_processes()

{
    // first all of them
    list node_list;
    node the_proc;
    process_tp the_process_tp;
    int i, j, last_part_index;
    string next_name, file_name, proc_index;

    fill_out_ProcessList_from_diagram();

    if (ProcessList == NULL)
    {
	the_proc = FindParentNode("0");
	if (the_proc == NULL)
	{
	    print_warning("[T-26] Error: Could not find top level process.");
	    return;
	}

	descend_hierarchy(the_proc);

    }
    else if (TNameOrPnum == "Name")
    {
	for (i = 0; 
             ProcessList != NULL && i < list_count(ProcessList); i++)
	{
	    next_name = list_get(ProcessList, i);
	    node_list = get_list_from_name(next_name);

	    if (node_list == NULL || (list_count(node_list) == 0))
	    {
		print_warning("[T-27] Warning: Process with name `" + next_name + "' not found.");
		continue;
	    }

	    for (j = 0; j < list_count(node_list); j++)
	    {
		the_proc = list_get(node_list, j);
		descend_hierarchy(the_proc);
	    }
	}
    }
    else // Use process numbers
    {
	// processes will live in a diagram named with all but the last 
        // digit, with the last being the relative index item. Careful about
        // top, 0 and 1.
	// Wild cards not supported for numbers, only names.

	for (i = 0; 
             ProcessList != NULL && i < list_count(ProcessList); i++)
	{
	    next_name = list_get(ProcessList, i);
	    last_part_index = split_proc_name(next_name);

	    if (last_part_index == 0)
	    {
		if (next_name == "0")
		    file_name = "top";
		else
		    file_name = "0";
		proc_index = next_name;
	    }
	    else
	    {
		file_name = string_extract(next_name, 0, last_part_index - 1);
		proc_index = string_extract(next_name, last_part_index, 
		    string_length(next_name) - last_part_index);
	    }
	    the_proc = proc_by_file_and_rel_index(file_name, proc_index);

	    if (the_proc == NULL)
	    {
		print_warning(
     "[T-28] Warning: No process with process number `" + next_name + "'.");
		continue;
	    }
	    descend_hierarchy(the_proc);
	}
    }

    return;

} // end of find_primitive_processes() 



// uniqueness of flows is a problem here.  The links are all distinct objects
// where uniqueness is described by tonode fromnode and name.  
// For now, just use the name criteria for uniqueness.  This is perhaps not 
// correct.

list 
get_process_flows(node proc, string to_from)

{
    string query, dup;
    list linkl, new_linkl;
    link the_link, new_link;
    int i, j;

    query = "link[(DataFlow || ControlFlow) && " +
                 "link_refs && (! items[TParticipates && value = 'False']) &&"+
                 to_from + "_node_id = ${proc.id} ]";

    linkl =  list_select(query);

    // and remove duplicates based on name

    new_linkl = list_create("link", 0);
    for (i = 0; i < list_count(linkl); i++)
    {
	the_link = list_get(linkl, i);
	dup = "False";
        for (j = 0; j < list_count(new_linkl); j++)
        {
	    new_link = list_get(new_linkl, j);
	    if (new_link.name == the_link.name)
	    {
		dup = "True";
		break;
	    }
	}
	if (dup == "False")
	    list_append(new_linkl, the_link);
    }
    return new_linkl;	    

} // end of get_process_flows()



// 4 possibilities:
// 1.  No processes listed, no hierarchy: only do processes in "top" diag,
//     only if primitive.
// 2.  No processes listed, yes hierarchy: do all primitives.
// 3.  Processes listed, no hierarchy: only do those processes listed. To 
//     support higher level testing, do them even if they are not primitive.
// 4.  Processes listed, yes hierarchy: do all primitive processes of the ones
//     listed.
//
// Basically the same goes for modules.

list
extract_processes()

{    	
    list pr_list, all;
    int i, n;
    process_tp the_process_tp;

    pr_list = list_create("process_tp", 0);
    find_primitive_processes();
    for (i = 0; i < list_count(ProcList); i++)
    {
	the_process_tp = list_get(ProcList, i);
 
	// flows 

	the_process_tp.flows_in = 
            get_process_flows(the_process_tp.process, "to");
	the_process_tp.flows_out = 
            get_process_flows(the_process_tp.process, "from");

	list_append(pr_list, the_process_tp);

    }

    return pr_list;
}
     



// extract_testable_objects() /////////////////////////////////////////////////
//
// get the basic information about omt models
//
///////////////////////////////////////////////////////////////////////////////

master_tp
extract_testable_objects()

{
    master_tp master;

    master.modules = NULL;
    master.processes = NULL;
    master.control_bar_diags = NULL;

    // modules
    if (TType == "ALL" || TType == "SD")
    {  
	print_warning("Extracting Structured Design ...");
        master.modules = extract_modules();
    }

    // processes

    if (TType == "ALL" || TType == "SA" || TType == "RT")
    {  
	print_warning("Extracting Data Flow Analysis ...");
	master.processes = extract_processes();
    }

    // real time

    if (TType == "ALL" || TType == "RT")
    {  
	print_warning("Extracting Real Time Analysis ...");
	master.control_bar_diags = extract_control_bars();
    }

    return master;

} // end extract_testable_objects()





// Note that much of the code to handle selections here is almost the same as
// it is for procedures elsewhere in this file.  The basic flow is the same, 
// there are small differences in variables.

string
print_module_actions(list modlist, list procl)

{
    int i, j, k, l, m, index, total;
    module_tp mod;
    node glob, real_mod;
    cntx param;
    string out, asentence, aname, dtype, ending, u_p;
    list ob_list, itemlist, notelist, ulist, plist, nsulist, nsplist, 
         sel_mapping_l;
    item di, dt;
    adt_info_tp adt_info;
    type_detail_tp td;
    type_expansion_tp te;
    sel_mapping_tp sm;
    boolean has_use;

    out = "/* SE Structured Design Model sentences */\n\n";

    for(i = 0; i < list_count(modlist); i++) 
    { 
        mod=list_get(modlist, i);
	real_mod = find_by_query("node[id == ${mod.module.to_node_id}]");
	if (real_mod == NULL)  // should probably never happen, but if so ...
	    continue;

	check_and_print_name_clash_with_DFE(real_mod, procl);

	out += "/* Structured Design Module: " + real_mod.name + " */\n\n";

	ending = action_annots_and_end(mod.module.to_node_id);

	start_type_expansion();

        for (j = 0; mod.params != NULL && j < list_count(mod.params); 
             j++) 
	{
	    param = list_get(mod.params, j);

	    // get the parameter's type.  If it is a complex type, we must
            // make a list of dataitems out of it.

	    // all params with 'in' go to the used list 
	    if (param.type == "DataIn" || param.type == "ControlIn")
	        expand_obj_type(param.id, param.name, "Use", param, NULL, NULL, real_mod.name);

	    // all params with 'out' go to produced list
	    if (param.type == "DataOut" || param.type == "ControlOut")
	        expand_obj_type(param.id, param.name, "Produce", 
                                param, NULL, NULL, real_mod.name);

	    if (param.type == "DataInOut")
	    {
	        expand_obj_type(param.id, param.name, "Use", param, NULL, NULL, real_mod.name);
	        expand_obj_type(param.id, param.name, "Produce", 
                                param, NULL, NULL, real_mod.name);
	    }
	}

        for (j = 0; mod.globals_used != NULL && 
             j < list_count(mod.globals_used); j++) 
	{
	    glob = list_get(mod.globals_used, j);
	    expand_obj_type(glob.id, glob.name, "Use", NULL, glob, NULL, 
                            real_mod.name);
	}


        for (j = 0; mod.globals_produced != NULL && 
             j < list_count(mod.globals_produced); 
             j++) 
	{
	    glob = list_get(mod.globals_produced, j);
	    expand_obj_type(glob.id, glob.name, "Produce", NULL, glob, 
                            NULL, real_mod.name);
	}

	if (no_selections_present(CurTypeExpansion_l) == 1)
	{
	    // just create one action sentence, and be done with it.

	    has_use = False;
	    asentence = start_action_sentence(real_mod.name);
	    ulist = list_create("int", 0);
	    plist = list_create("int", 0);
	    for (k = 0; k < list_count(CurTypeExpansion_l); k++)
	    { 
		te = list_get(CurTypeExpansion_l, k);
		for (l = 0; l < list_count(te.adt_info_l); l = l + 1)
		{
		    adt_info = list_get(te.adt_info_l, l);
		    td = clear_td();
		    td.name = adt_info.adt_type;
		    td.scope = "";
		    td.annot_id = adt_info.annot_id;

		    if (TDebug)
		    {
			print_error("adt_info name: " + adt_info.adt_name + " Scope: " + td.scope);
			if (adt_info.is_array)
			    print_error("Doing array expansion for: " + adt_info.adt_name);	 

		    }

		    if (! adt_info.is_array)
		    {
			index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope, td, adt_info.adt_name);

			if (te.u_or_p == "Use")
			{
			    has_use = True;
			    list_append(ulist, index);
			}
			else
			    list_append(plist, index);
		    }
		    else
		    {
			for (m = 0; m < 5; m++)
			{
			    index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope + "_" + list_get(ArraySuffix, m), td, adt_info.adt_name);

			    if (te.u_or_p == "Use")
			    {
				has_use = True;
				list_append(ulist, index);
			    }
			    else
				list_append(plist, index);
			}    
		    }
		}
	    }
	    if (has_use)
	        out += asentence + print_u_p(ulist, 1) +
	                    print_u_p(plist, 2) +
	                    ending;
	    else
		out += "/* action sentence for " + real_mod.name +
                      " suppressed, no uses dataitems. */\n\n";
	}
	else // do the selection thing
	{
	    // first create non selection ulists and plists
	    has_use = False;
	    nsulist = list_create("int", 0);
	    nsplist = list_create("int", 0);
	    for (k = 0; k < list_count(CurTypeExpansion_l); k++)
	    { 
		te = list_get(CurTypeExpansion_l, k);
		if (te.seq_sel_iter != "Selection")
		{
		    for (l = 0; l < list_count(te.adt_info_l); l = l + 1)
		    {
			adt_info = list_get(te.adt_info_l, l);
			td = clear_td();
			td.name = adt_info.adt_type;
			td.scope = "";
			td.annot_id = adt_info.annot_id;

			if (! adt_info.is_array)
			{
			    index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope, td, adt_info.adt_name);

			    if (te.u_or_p == "Use")
			    {
				has_use = True;
				list_append(nsulist, index);
			    }
			    else
				list_append(nsulist, index);
			}
			else
			{
			    for (m = 0; m < 5; m++)
			    {
				index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope + "_" + list_get(ArraySuffix, m), td, adt_info.adt_name);

				if (te.u_or_p == "Use")
				{
				    has_use = True;
				    list_append(nsulist, index);
				}
				else
				    list_append(nsplist, index);
			    }    
			}
		    }
		}
	    }

	    // next build the selection mapping list.  That contains one
            // entry per union.

	    sel_mapping_l = create_selection_mapping();
	    total = selection_mapping_total(sel_mapping_l);
            print_warning("Creating " + total + " actions for selections.");

            for (j = 0; j < total; j++) 
	    {
		aname = real_mod.name + "_SEL_" + j;
		asentence = start_action_sentence(aname);
		ulist = list_copy(nsulist);
		plist = list_copy(nsplist);

		for (k = 0; k < list_count(sel_mapping_l); k++)
		{
		    sm = list_get(sel_mapping_l, k);	
		    te = list_get(CurTypeExpansion_l, sm.index);
		    adt_info = list_get(te.adt_info_l, sm.cur);
		    td = clear_td();
		    td.name = adt_info.adt_type;
		    td.scope = "";
		    td.annot_id = adt_info.annot_id;

		    if (! adt_info.is_array)
		    {
			index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope, td, adt_info.adt_name);

			if (te.u_or_p == "Use")
			{
			    has_use = True;
			    list_append(ulist, index);
			}
			else
			    list_append(plist, index);
		    }
		    else
		    {
			for (m = 0; m < 5; m++)
			{
			    index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope + "_" + list_get(ArraySuffix, m), td, adt_info.adt_name);

			    if (te.u_or_p == "Use")
			    {
				has_use = True;
				list_append(ulist, index);
			    }
			    else
				list_append(plist, index);
			}    
		    }
		}
		sel_mapping_l = incr_sel_mapping(sel_mapping_l);

		if (has_use)
		    out += asentence + print_u_p(ulist, 1) +
		                print_u_p(plist, 2) +
		                ending;
		else
		    out += "/* action sentence for " + aname + 
                          " suppressed, no uses dataitems. */\n\n";

		if (sel_mapping_l == NULL)
		    break;
	    }
	}
    }

    return out;

} // end of print_module_actions()





// Note that much of the code to handle selections here is almost the same as
// it is for modules elsewhere in this file.  The basic flow is the same, 
// there are small differences in variables.

string 
print_a_process(process_tp process)

{
    int i, j, k, l, index, total;
    string out = "", aname, asentence, ending;
    link flow;
    list ulist, plist, nsulist, nsplist, sel_mapping_l;
    adt_info_tp adt_info;
    type_detail_tp td;
    type_expansion_tp te;
    sel_mapping_tp sm;
    boolean has_use;

    ending = action_annots_and_end(process.process.id);
    start_type_expansion();

    for (i = 0; i < list_count(process.flows_in); i++)
    {
	flow = list_get(process.flows_in, i);
	expand_obj_type(flow.id, flow.name, "Use", NULL, NULL, flow, process.process.name);
    }

    for (i = 0; i < list_count(process.flows_out); i++)
    {
	flow = list_get(process.flows_out, i);
	expand_obj_type(flow.id, flow.name, "Produce", NULL, NULL, flow, process.process.name);
    }

    if (no_selections_present(CurTypeExpansion_l) == 1)
    {
	has_use = False;
	asentence = start_action_sentence(process.process.name);
	ulist = list_create("int", 0);
	plist = list_create("int", 0);

	for (k = 0; k < list_count(CurTypeExpansion_l); k++)
	{
	    te = list_get(CurTypeExpansion_l, k);
	    for (l = 0; l < list_count(te.adt_info_l); l = l + 1)
	    {
		adt_info = list_get(te.adt_info_l, l);
		td = clear_td();
		td.name = adt_info.adt_type;
		td.scope = "";
		td.annot_id = adt_info.annot_id;

		if (! adt_info.is_array)
		{
		    index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope, td, adt_info.adt_name);

		    if (te.u_or_p == "Use")
		    {
			has_use = True;
			list_append(ulist, index);
		    }
		    else
			list_append(plist, index);
		}
		else
		{
		    for (m = 0; m < 5; m++)
		    {
			index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope + "_" + list_get(ArraySuffix, m), td, adt_info.adt_name);

			if (te.u_or_p == "Use")
			{
			    has_use = True;
			    list_append(ulist, index);
			}
			else
			    list_append(plist, index);
		    }    
		}
	    }
	}
	if (has_use)
	{
	    out += asentence + print_u_p(ulist, 1) +
	                print_u_p(plist, 2) +
	                ending;
	}
	else
	    out += "/* action sentence for " + process.process.name +
		  " suppressed, no uses dataitems. */\n\n";
    }
    else // do the selection thing
    {
	has_use = False;
	// first create non selection ulists and plists
	nsulist = list_create("int", 0);
	nsplist = list_create("int", 0);
	for (k = 0; k < list_count(CurTypeExpansion_l); k++)
	{
	    te = list_get(CurTypeExpansion_l, k);
	    if (te.seq_sel_iter != "Selection")
	    {
		for (l = 0; l < list_count(te.adt_info_l); l = l + 1)
		{
		    adt_info = list_get(te.adt_info_l, l);
		    td = clear_td();
		    td.name = adt_info.adt_type;
		    td.scope = "";
		    td.annot_id = adt_info.annot_id;

		    if (! adt_info.is_array)
		    {
			index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope, td, adt_info.adt_name);

			if (te.u_or_p == "Use")
			{
			    has_use = True;
			    list_append(nsulist, index);
			}
			else
			    list_append(nsplist, index);
		    }
		    else
		    {
			for (m = 0; m < 5; m++)
			{
			    index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope + "_" + list_get(ArraySuffix, m), td, adt_info.adt_name);

			    if (te.u_or_p == "Use")
			    {
				has_use = True;
				list_append(nsulist, index);
			    }
			    else
				list_append(nsplist, index);
			}    
		    }
		}
	    }
	}

	// next build the selection mapping list.  That contains one
	// entry per union.
 
	sel_mapping_l = create_selection_mapping();
	total = selection_mapping_total(sel_mapping_l);
	print_warning("Creating " + total + " actions for selections.");
 
	for (j = 0; j < total; j++)
	{
	    aname = process.process.name + "_SEL_" + j;
            asentence = start_action_sentence(aname);
	    ulist = list_copy(nsulist);
	    plist = list_copy(nsplist);

	    for (k = 0; k < list_count(sel_mapping_l); k++)
	    {
		sm = list_get(sel_mapping_l, k);
		te = list_get(CurTypeExpansion_l, sm.index);
		adt_info = list_get(te.adt_info_l, sm.cur);
		td = clear_td();
		td.name = adt_info.adt_type;
		td.scope = "";
		td.annot_id = adt_info.annot_id;

		if (! adt_info.is_array)
		{
		    index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope, td, adt_info.adt_name);

		    if (te.u_or_p == "Use")
		    {
			has_use = True;
			list_append(ulist, index);
		    }
		    else
			list_append(plist, index);
		}
		else
		{
		    for (m = 0; m < 5; m++)
		    {
			index = add_dataitem(adt_info.adt_name + "_" + adt_info.scope + "_" + list_get(ArraySuffix, m), td, adt_info.adt_name);

			if (te.u_or_p == "Use")
			{
			    has_use = True;
			    list_append(ulist, index);
			}
			else
			    list_append(plist, index);
		    }    
		}
	    }
	    sel_mapping_l = incr_sel_mapping(sel_mapping_l);

	    if (has_use)
	    {
		out += asentence + print_u_p(ulist, 1) +
		            print_u_p(plist, 2) +
		            ending;
	    }
	    else
		out += "/* action sentence for " + aname +
		    " suppressed, no uses dataitems. */\n\n";

	    if (sel_mapping_l == NULL)
		break;
	}
    }
    return out;

} // end of print_a_process()




// real time processing: done mostly at print time ///////////////////////////

// combo logic: Decision Tables and Process Activation Tables 
//

string
print_DET(file the_diagram)

{
    string out, aname, query;
    list row_l, ci_l, co_l;
    link row;
    int i;

    out = "";
    query = "link[Decision && link_refs[file_id = ${the_diagram.id}]]";

    row_l = list_select(query);
    
    for (i = 0; row_l != NULL && i < list_count(row_l); i++)
    {
	row = list_get(row_l, i);

	aname = "DET_" + the_diagram.name + "_Row_" + (i + 1);

	// control in's 
        query = "node[ControlIn && node_refs[file_id = ${the_diagram.id}]]";
	ci_l = list_select(query);

	if (ci_l == NULL || list_count(ci_l) == 0)
	{
	    out += "/* Action sentence suppressed for " + aname + 
                  ": No control ins.*/\n\n";
	    continue;
	}

        out += start_action_sentence(aname);

	// control out's
        query = "node[ControlOut && node_refs[file_id = ${the_diagram.id}]]";
	co_l = list_select(query);

	// 1 for use, 2 for produce	
	out += print_rt_up_clause(1, ci_l) +
	            print_rt_up_clause(2, co_l) +
	            print_cond_clause(ci_l, "acts only if", 
				row.from_node_id, the_diagram.id) +
	            print_cond_clause(co_l, "satisfies", 
				row.to_node_id, the_diagram.id) +
	            end_sentence();
    }

    return out;

} // end of print_DET()




// use_or_produce: 1: use
//                 2: produce
//                -1: add the dataitems, but do not actually put them on
//                    any lists

string 
print_rt_up_clause(int use_or_prod, list cio_l)

{
    string out;
    list uplist;
    node cio;
    int i, index;
    type_detail_tp td;

    uplist = list_create("int", 0);

    for (i = 0; cio_l != NULL && i < list_count(cio_l); i++)
    {
	cio = list_get(cio_l, i);

	index = find_simple_dataitem(cio.name);

	if (index == -1)
	{
	    print_warning("[T-53] Warning: Real Time Extraction: No datatype for `" + cio.name + "'.");
	    continue;
	}

	if (use_or_prod != -1)
	    list_append(uplist, index);
    }
    if (use_or_prod != -1)
	out = print_u_p(uplist, use_or_prod);

    return out;

} // end of print_rt_up_clause()



// we need to values from the following function
int CurStateLPos;

rt_state_tp 
find_state(list statel, string name)

{
    rt_state_tp state;
    int i;

    for (i = 0; i < list_count(statel); i++)
    {
	state = list_get(statel, i);
	if (state.name == name)
	{
	    CurStateLPos = i;
	    return state;
	}
    }
    return NULL;

} // end of find_state()




void
form_extra_state_allows(string state_name, string allows1, string allows2)

{
    rt_state_tp state, new_state;

    if ((state = find_state(T_state_l, state_name)) == NULL)
    {
	new_state.name = state_name;
	new_state.allows = list_create("string", 0);
	list_append(new_state.allows, allows2);		
	list_append(new_state.allows, allows1);		

	list_append(T_state_l, new_state);
    }
    else
    {
	if (list_find(state.allows, 0, allows2) == list_count(state.allows))
	    list_append(state.allows, allows2);		
	if (list_find(state.allows, 0, allows1) == list_count(state.allows))
	    list_append(state.allows, allows1);		
	list_set(T_state_l, CurStateLPos, state);
    }

    return;

} // end of form_extra_state_allows()




string
print_PAT(file the_diagram)

{
    string out, query, rname;
    list row_l, ci_l;
    link definition;
    node row;
    int i;

    T_strans_l = list_create("string", 0); 
    T_state_l = list_create("rt_state_tp", 0); 
    //ExtraStates = "";

    out = "";
    query = "node[ControlCombination && node_refs[file_id = ${the_diagram.id}]]";
    row_l = list_select(query);
    
    for (i = 0; row_l != NULL && i < list_count(row_l); i++)
    {
	row = list_get(row_l, i);

	rname = "PAT_" + the_diagram.name + "_Row_" + (i + 1);

	// control in's 
        query = "node[ControlIn && node_refs[file_id = ${the_diagram.id}]]";
	ci_l = list_select(query);

	if (ci_l == NULL || list_count(ci_l) == 0)
	{
	    out += "/* Action sentence suppressed for " + rname + 
                  ": No control ins.*/\n\n";
	    continue;
	}

        out += start_action_sentence(rname);

	// uses clause
	out += print_rt_up_clause(1, ci_l);

	// acts only if clause
	out += print_cond_clause(ci_l, "acts only if", 
					    row.id, the_diagram.id);

	// causes statetransitions

	out += print_PAT_st_clause(rname, row, the_diagram.id);

	// exhaustive testing
	out += print_tested_exhaustively(ci_l);

	out += end_sentence();
    }

    // and print the state transitions and states 
    out += print_extra_statetrans() +
                print_extra_states(T_state_l);

    return out;

} // end of print_PAT()




string
print_PAT_st_clause(string rname, node row, int diag_id) 

{
    string out, query, st_name, state_name;
    out = "";
    list proc_act_l;
    link proc_act;
    node proc;
    int i;
    constant_tp c;

    query = "link[ProcessActivation && from_node_id = ${row.id} && link_refs[file_id = ${diag_id}]]";

    proc_act_l = list_select(query);

    for (i = 0; proc_act_l != NULL && i < list_count(proc_act_l); i++)
    {
	proc_act = list_get(proc_act_l, i);

        c = check_and_add_constant(Constants, proc_act.name);
	if (c != NULL && c.value == "*")
	    continue;

	query = "node[Process && id = ${proc_act.to_node_id}]";
	proc = find_by_query(query);

	if ((c != NULL && c.value == "0") || proc_act.name == "0")
	{
	    st_name = proc.name + "_on_off";
	    if (list_find(T_strans_l, 0, st_name) == list_count(T_strans_l))
		list_append(T_strans_l, st_name);
	}
	else
	{
	    st_name = proc.name + "_off_on";
	    if (list_find(T_strans_l, 0, st_name) == list_count(T_strans_l))
		list_append(T_strans_l, st_name);
	}

	state_name = proc.name + "_off";
	form_extra_state_allows(state_name, proc.name, rname);

	state_name = proc.name + "_on";
	form_extra_state_allows(state_name, proc.name, rname);
	
	if (out == "")
	    out += "\tcauses statetransition\n\t\t" + Tid(st_name); 
	else
	    out += ",\n\t\t" + Tid(st_name);
    }
    if (out != "")
	out += ";\n";
	
    return out;

} // end of print_PAT_st_clause()


// sequential logic: STD's , ELT's and ALT's ...
//

string 
print_allowed_in_state(string which_diag, string name, string diag_name)

{
    string out, query;
    list state_cntx_l, state_l;
    cntx state_cntx;
    node state;
    int i;

    out = "";

    if (which_diag == "ALT")
        query = "cntx[ActionInstance && name $ '*/${name}' && cntx_refs[file[SteDiagram && name = '${diag_name}']]]";
    else // and ELT
        query = "cntx[ActionInstance && name $ '${name}/*' && cntx_refs[file[SteDiagram && name = '${diag_name}']]]";

    state_cntx = find_by_query(query);

    if (state_cntx != NULL)
    {
	query = "node[State && out_links[Transition && cntxs[id = ${state_cntx.id}]]]";
	state_l = list_select(query);

	for (i = 0; state_l != NULL && i < list_count(state_l); i++)
	{
	    state = list_get(state_l, i);

	    if (out == "")
		out += "\tis allowed in state\n\t\t" + Tid(state.name);
	    else
		out += ",\n\t\t" + Tid(state.name);
	}
	if (out != "")
	    out += ";\n";
    }

    return out;

} // end of print_allowed_in_state()



list T_strans_l;
list T_state_l;
string ExtraStates;

string
print_extra_statetrans()

{
    int i;
    string out, oname, st;

    out = "";

    for (i = 0; T_strans_l != NULL && i < list_count(T_strans_l); i++)
    {
	st = list_get(T_strans_l, i);

	oname = string_extract(st, 0, string_length(st) - 7);

	out += "Statetransition " + Tid(st) + 
              "\n\tis statetransitiontype action;\n";

	// on_off or off_on??
	if (string_extract(st, string_length(st) - 6, 6)  == "on_off")
	{
	    out += "\tgoes from first state " + Tid(oname) + "_on;\n";
	    out += "\tgoes to second state " + Tid(oname) + "_off;\n";
	}
	else
	{
	    out += "\tgoes from first state " + Tid(oname) + "_off;\n";
	    out += "\tgoes to second state " + Tid(oname) + "_on;\n";
	}
	out += end_sentence();
    }
    return out;

} // end of print_extra_statetrans() 




string
print_extra_states(list statel)

{
    string out = "";
    string allow;
    int i, j;
    rt_state_tp state;

    for (i = 0; i < list_count(statel); i++)
    {
	state = list_get(statel, i);

        out += "State " + Tid(state.name) + "\n\tis statetype action;\n" +
	   "\tallows action";
	for (j = 0; j < list_count(state.allows); j++)
	{
	    allow = list_get(state.allows, j);
	    if (j == 0)
	        out += "\n\t\t" + Tid(allow);
	    else
	        out += ",\n\t\t" + Tid(allow); 
	}
        out += ";\n" + end_sentence();
    }
    return out;
    
} // end of print_extra_states




string
print_extra_state(string state, string act1, string act2)

{
    return "State " + Tid(state) + "\n\tis statetype action;\n" +
	   "\tallows action\n\t\t" + Tid(act1) + ",\n\t\t" + Tid(act2) + 
           ";\n" + end_sentence();
    
} // end of print_extra_state



string
print_ALT_st_clause(string aname, int action_id, int diag_id) 

{
    string out, query, st_name, state_name;
    out = "";
    list proc_act_l;
    link row, proc_act;
    node proc;
    int i;
    constant_tp c;

    query = "link[Definition && from_node_id = ${action_id} && link_refs[file_id = ${diag_id}]]";

    row = find_by_query(query);

    query = "link[ProcessActivation && from_node_id = ${row.to_node_id}]";
    proc_act_l = list_select(query);

    for (i = 0; proc_act_l != NULL && i < list_count(proc_act_l); i++)
    {
	proc_act = list_get(proc_act_l, i);

        c = check_and_add_constant(Constants, proc_act.name);
	if (c != NULL && c.value == "*")
	    continue;

	query = "node[Process && id = ${proc_act.to_node_id}]";
	proc = find_by_query(query);
	
	if ((c != NULL && c.value == "0") || proc_act.name == "0")
	{
	    st_name = proc.name + "_on_off";
	    if (list_find(T_strans_l, 0, st_name) == list_count(T_strans_l))
		list_append(T_strans_l, st_name);
	}
	else
	{
	    st_name = proc.name + "_off_on";
	    if (list_find(T_strans_l, 0, st_name) == list_count(T_strans_l))
		list_append(T_strans_l, st_name);
	}

	state_name = proc.name + "_off";
	form_extra_state_allows(state_name, proc.name, aname);

	state_name = proc.name + "_on";
	form_extra_state_allows(state_name, proc.name, aname);
	
	if (out == "")
	    out += "\tcauses statetransition\n\t\t" + Tid(st_name); 
	else
	    out += ",\n\t\t" + Tid(st_name);
    }
    if (out != "")
	out += ";\n";
	
    return out;

} // end of print_ALT_st_clause()




// ELT's create new specific actions with acts only if conditions attached to
// them.  Since each of these events is for an action that is supposed exist 
// in an STD, we do not create new states and state transitions, rather we
// assume those are already dealt with.

string
print_ELT(file the_diagram)

{
    string out, rname, query;
    list event_l, ci_l, co_l;
    link definition;
    node event;
    int i;

    out = "";
    // control in's, get em first. 
    query = "node[ControlIn && node_refs[file_id = ${the_diagram.id}]]";
    ci_l = list_select(query);

    query = "node[Event && node_refs[file_id = ${the_diagram.id}]]";

    event_l = list_select(query);
    
    for (i = 0; event_l != NULL && i < list_count(event_l); i++)
    {
	event = list_get(event_l, i);

	rname = "ELT_" + Tid(the_diagram.name) + "_" + Tid(event.name);
        query = "link[Definition && from_node_id = ${event.id}]";
	definition = find_by_query(query);

	if (ci_l == NULL || list_count(ci_l) == 0)
	{
	    out += "/* Action sentence suppressed for " + rname + 
                  ": No control ins.*/\n\n";
	    continue;
	}
        out += start_action_sentence(rname);

	out += get_description_from_id(the_diagram.id);

	// these ci_l's need to be added as dataitems 
	out += print_rt_up_clause(1, ci_l);

	if (definition != NULL)
	    out += print_cond_clause(ci_l, "acts only if", 
			    definition.to_node_id, the_diagram.id);

	out += print_allowed_in_state("ELT", event.name, the_diagram.name);

	out += end_sentence();
    }

    return out;

} // end of print_ELT()




string
print_ALT(file the_diagram)

{
    string out, query, aname;
    list action_l, ci_l, co_l;
    link definition;
    node action;
    int i;

    T_strans_l = list_create("string", 0); 
    T_state_l = list_create("rt_state_tp", 0); 

    out = "";
    query = "node[Action && node_refs[file_id = ${the_diagram.id}]]";

    action_l = list_select(query);
    
    for (i = 0; action_l != NULL && i < list_count(action_l); i++)
    {
	action = list_get(action_l, i);

	aname = "ALT_" + the_diagram.name + "_" + action.name;

        query = "node[ControlOut && node_refs[file_id = ${the_diagram.id}]]";
	co_l = list_select(query);

	if (co_l == NULL || list_count(co_l) == 0)
	{
	    out += "/* Action sentence suppressed for " + aname + 
                  ": No control ins.*/\n\n";
	    continue;
	}

	// 1 for use, 2 for produce below
        out += start_action_sentence(aname) +
	      print_rt_up_clause(1, co_l) +
	      print_rt_up_clause(2, co_l) +
	      print_allowed_in_state("ALT", action.name, the_diagram.name) +
	      print_ALT_st_clause(aname, action.id, the_diagram.id) + 
	      end_sentence();
    }

    out += print_extra_statetrans() + 
                print_extra_states(T_state_l);

    return out;

} // end of print_ALT()





string
more_allows_actions(string out, link tlink)

{
    int i, index;
    node action;
    string query, aname;
    cntx the_cntx;

    query = "cntx[ActionInstance && link_id = ${tlink.id}]";

    the_cntx = find_by_query(query);

    if (the_cntx == NULL)
	return out;

    // we need to grab action out of event/action in the name
    // THEN REALLY CHECK TO BE SURE THIS ACTION ALREADY EXISTS.
    index = string_find(the_cntx.name, 0, "/");

    if (index == string_length(the_cntx.name))
	return out;

    aname = string_extract(the_cntx.name, index + 1, 
                             string_length(the_cntx.name) - index - 1);
    if (out == "")
	out += "\tallows action\n\t\t" + Tid(aname);
    else
	out += ",\n\t\t" + Tid(aname);

    return out;

} // end of more_allows_actions()




// this is very similar to state extraction for OMT.  Be sure to reflect 
// changes in omt_t.qrl also.

string
print_sequential_logic(file the_diagram, list proc_list)

{ 
    string out = ""; 
    string statetrans = ""; 
    string statesent = "";
    string query, these_st, actions;
    list state_l, transition_l;
    node state;
    link transition;
    int i, j;

    query = "node[State && node_refs[file[id = ${the_diagram.id}]]]";
    state_l = list_select(query);

    for (i = 0; state_l != NULL && i < list_count(state_l); i++)
    {
	actions = "";
	state = list_get(state_l, i);

	statesent = print_state_sentence(NULL, state.name, state.id);

	query = "link[Transition && link_refs[file[id = ${the_diagram.id}]] && name != '' && from_node_id = ${state.id}]";
	transition_l = list_select(query);

	these_st = "";
	for (j = 0; transition_l != NULL && j < list_count(transition_l); j++)
	{
	    transition = list_get(transition_l, j);
	    // make a state transition_sentence for each
	    these_st = these_st + print_st_sentence(NULL, transition);

	    // and get the list of actions

	    actions = more_allows_actions(actions, transition); 
	}

	// only print this state if there are some actions
	if (actions != "")
	{
	    out += statesent + actions + ";\n" + end_sentence();
	    statetrans = statetrans + these_st;
	}
	else
            print_warning("[T-51] Error: State `" + state.name + "': No actions on event/action bar.");
    }

    // done with this set of states, print the corresponding state transitions

    return out + statetrans; 

} // end of print_sequential_logic()




string 
print_real_time(list control_list, list proc_list)

{
    file the_file, control_file;
    string out, query;
    int i;

    out = "";

    out += "/* SE Real Time Model sentences */\n\n";

    for (i = 0; i < list_count(control_list); i++)
    {
	the_file = list_get(control_list, i);
	out += "/* Control Specifications for DFE Diagram " + 
              the_file.name + " */\n\n";
	
	// first add in all the potential dataitems that are control flows
        // from anchors and offpage externals

	get_offpage_and_anchors(the_file);

	query = "file[SteDiagram && name = '${the_file.name}']";
	control_file = find_by_query(query);

	if (control_file != NULL)
	{
	    out += print_sequential_logic(control_file, proc_list); 

	    // and the corresponding ELT

	    query = "file[EventLogicTable && name = '${the_file.name}']";
	    control_file = find_by_query(query);
	    if (control_file != NULL)
		out += print_ELT(control_file);

	    // and the corresponding ALT

	    query = "file[ActionLogicTable && name = '${the_file.name}']";
	    control_file = find_by_query(query);
	    if (control_file != NULL)
		out += print_ALT(control_file);
	}
	else
	{
            query = "file[DecisionTable && name = '${the_file.name}']";
            control_file = find_by_query(query);

	    if (control_file != NULL)
		out += print_DET(control_file); 

	    // and the corresponding  PAT

            query = "file[ProcessActivationTable && name = '${the_file.name}']";
            control_file = find_by_query(query);

	    if (control_file != NULL)
		out += print_PAT(control_file); 
	} 
    }

    return out;

} // end of print_real_time()





string
print_process_actions(list proc_list)

{
    list ob_list;
    int i;
    process_tp proc;
    string out, o;

    out = "";

    out += "/* SE Structured Analysis Model sentences */\n\n";

    // STL for processes

    for(i = 0; i < list_count(proc_list); i++) 
    { 
        proc = list_get(proc_list, i);
	out += "/* Structured Analysis Process: " + proc.process.name + " (Diagram: " + proc.fname + ") */\n\n";

	out += print_a_process(proc);
    }

    return out;

} // end print_process_actions()



string InitStuf;

// Get all the info about this testunit out of the repository.  Also
// be certain it exists.
// Note that there is a very similar function in omt_t.qrl that needs to be
// updated as this one does.
 
list
get_testunit_info()
 
{
    string query;
    node TUTnode;
    list itemlist;
    item the_item;
 
    print_warning("Using TestUnit: " + TTestUnit);
    InitStuf = "\n/*\n\tUsing TestUnit: " + TTestUnit + "\n";
 
    query = "node[TTestUnit && node_refs && name = '${TTestUnit}']";
 
    TUTnode = find_by_query(query);
 
    if (TUTnode == NULL)
    {
        print_warning("[T-29] Error: TestUnit `" + TTestUnit + "' does not exist in repository.");

        return(NULL);
    }
 
    // Now get all the items
    itemlist = get_items_from_obj(TUTnode.id, "TUTInfo");
    if (itemlist == NULL)
    {
        print_warning("[T-30] Error: TestUnit `" + TTestUnit + 
           "' not completely defined in repository.");
        return(NULL);
    }
 
    // TType
    the_item = get_particular_item(itemlist,  "TSEExtractProps");
    if (the_item != NULL)
    {
        if (the_item.value == "Structured Design Model Only")
            TType = "SD";
        else if (the_item.value == "Structured Analysis Model Only")
            TType = "SA";
        else if (the_item.value == "Structured Analysis Model with Real Time Extensions")
            TType = "RT";
        else
            TType = "ALL";
    }
    else
        TType = "ALL";
    print_warning("Extracting model information from " + the_item.value);
    InitStuf = InitStuf + "\tExtracting model information from " + the_item.value + "\n";

    // THierarchy
    the_item = get_particular_item(itemlist,  "THierarchy");
    if (the_item != NULL)
    {
        if (the_item.value == "Ignore Hierarchy")
            THierarchy = "No";
	else 
            THierarchy = "Yes";
    }
    else
	THierarchy = "Yes";
    print_warning("Hierarchy Usage: " + the_item.value);
    InitStuf = InitStuf + "\tHierarchy Usage: " + the_item.value + "\n";


    // TNameOrPnum
    the_item = get_particular_item(itemlist,  "TNameOrPnum");
    if (the_item != NULL)
    {
        if (the_item.value == "Use Process Numbers")
            TNameOrPnum = "Pnum";
	else 
            TNameOrPnum = "Name";
    }
    else
	TNameOrPnum = "Name";
    print_warning("Process Specification: " + the_item.value);
    InitStuf = InitStuf + "\tProcess Specification: " + the_item.value + "\n*/\n\n";

    return(itemlist); 

} // end of get_testunit_info()



boolean TDebug = False;
 
int
main()
{
    master_tp master;
    string out = "", outfile, outdir, syscmd;
    int i=0;
    datatype_tp dy;
    list itemlist;

    if (toolinfo_variable("TDebug") == "True")
        TDebug = True;

    ArraySuffix = string_to_list("first second mid nexttolast last", " ");
    DataTypes = list_create("datatype_tp", 0);
    DataItems = list_create("dataitem_tp", 0);
    Constants = list_create("constant_tp", 0);
    ProcList = list_create("process_tp", 0);

    ModuleList = NULL;
    DiagramList = NULL;
    ProcessList = NULL;

    name_and_copyright();
    out += print_header("StP/SE");

    dy.name = "int";
    dy.scope = "";
    list_append(DataTypes, dy);

    if ((itemlist = get_testunit_info()) == NULL)
        return(1);
 
    print_warning("");

    out += InitStuf;
 
    if (TType == "ALL")
    {
	ModuleList = build_input_list("TModuleName", itemlist);
	DiagramList = build_input_list("TDiagramName", itemlist);
	ProcessList = build_input_list("TProcessName", itemlist);
    }
    else if (TType == "SD")
    {
	ModuleList = build_input_list("TModuleName", itemlist);
    }
    else if (TType == "RT")
    {
	DiagramList = build_input_list("TDiagramName", itemlist);
    }
    else if (TType == "SA")
    {
	ProcessList = build_input_list("TProcessName", itemlist);
	DiagramList = build_input_list("TDiagramName", itemlist);
    }

    if (ProcessList != NULL)
	ExplicitProcesses = True;

    outdir = current_projdir() + current_system() + "/test_files/" + TTestUnit;
    outfile = outdir + "/sdf";

    if (write_file_access(outfile) == False)
    {
	if (write_file_access(outdir) == False)
	{
//	    syscmd = "mkdir " + outdir;
//	    system(syscmd);
	    mkdir(outdir);
	    if (write_file_access(outdir) == False)
	    {
                print_warning("[T-14] Error: TestUnit directory `" +
                      outdir + "' not writeable.");
		return(1);
	    }
	}
        syscmd = "touch " + outfile;
	system(syscmd);
        if (write_file_access(outfile) == False)
	{
            print_warning("[T-15] Error: `" + outfile + "' not createable.");
	    return(1);
	}
    }

    print_warning("Cleaning testunit ...");
    if (clean_testunit_files(TTestUnit) != 0)
    {
        print_warning(
            "[T-13] Error: Cannot clean testunit.  Check file permissions.");
        return(1);
    }

    out += print_S_Packet(itemlist) +
                print_std_include() +
                print_user_include_files(itemlist);

    if ((master = extract_testable_objects()) != NULL)
    {
	if (TType == "ALL" || TType == "SD")
	{
	    print_warning("Completing Structured Design ...");
	    out += print_module_actions(master.modules, master.processes);
	}

	if (TType == "ALL" || TType == "SA" || TType == "RT" )
	{
	    print_warning("Completing Data Flow Analysis ...");
	    out += print_process_actions(master.processes);
	}

	if (TType == "ALL" || TType == "RT")
	{
	    print_warning("Completing Real Time Analysis ...");
	    out += print_real_time(master.control_bar_diags, 
					master.processes);
	}

        out += "/* SE cross-model sentences */\n\n" +
                    print_remaining_stuff(PrintPlaceholder);

	write_file(outfile, out);
	print_warning("SE-->T Extract: complete.\n\n"); 

	return 0;
    }
    else
    {
	print_warning("SE-->T Extract: fix errors and try again.\n\n"); 
	return 1;
    }
}
